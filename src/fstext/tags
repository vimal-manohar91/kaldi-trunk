!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AcousticLatticeScale	lattice-utils.h	/^inline vector<vector<double> > AcousticLatticeScale(double acwt) {$/;"	f	namespace:fst
AddSelfLoops	pre-determinize-inl.h	/^template<class Arc> void AddSelfLoops(MutableFst<Arc> *fst, vector<typename Arc::Label> &isyms,$/;"	f	namespace:fst
AddSubsequentialLoop	context-fst-inl.h	/^void AddSubsequentialLoop(typename Arc::Label subseq_symbol,$/;"	f	namespace:fst
ApplyProbabilityScale	fstext-utils-inl.h	/^void ApplyProbabilityScale(float scale, MutableFst<Arc> *fst) {$/;"	f	namespace:fst
ApproxEqual	lattice-weight.h	/^inline bool ApproxEqual(const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
ApproxEqual	lattice-weight.h	/^inline bool ApproxEqual(const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
Arc	determinize-lattice-inl.h	/^  typedef ArcTpl<Weight> Arc; \/\/ arc in non-compact version of lattice $/;"	t	class:fst::LatticeDeterminizer
Arc	push-special.cc	/^  typedef StdArc Arc;$/;"	t	class:fst::PushSpecialClass	file:
Arc	table-matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::TableMatcher
Arc	table-matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::TableMatcherImpl
Arc	trivial-factor-weight.h	/^  typedef A Arc;$/;"	t	class:fst::TrivialFactorWeightFst
Arc	trivial-factor-weight.h	/^  typedef A Arc;$/;"	t	class:fst::TrivialFactorWeightFstImpl
ArcId	table-matcher.h	/^  typedef StateId ArcId;  \/\/ Use this type to store arc offsets [it's actually size_t$/;"	t	class:fst::TableMatcher
ArcId	table-matcher.h	/^  typedef StateId ArcId;  \/\/ Use this type to store arc offsets [it's actually size_t$/;"	t	class:fst::TableMatcherImpl
ArcIterator	context-fst.h	/^  ArcIterator(const ContextFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	context-fst.h	/^class ArcIterator< ContextFst<A> >$/;"	c	namespace:fst
ArcIterator	trivial-factor-weight.h	/^  ArcIterator(const TrivialFactorWeightFst<A, F> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	trivial-factor-weight.h	/^class ArcIterator< TrivialFactorWeightFst<A, F> >$/;"	c	namespace:fst
Arg	fstext-utils-inl.h	/^  typedef T Arg;$/;"	t	struct:fst::IdentityFunction
Arg	fstext-utils-test.cc	/^  typedef typename Arc::Label Arg;$/;"	t	struct:fst::TestFunctor	file:
BackArc	factor.h	/^  bool BackArc(StateId, const Arc&) { return true; }$/;"	f	class:fst::DfsOrderVisitor
BackoffDeterministicOnDemandFst	deterministic-fst-inl.h	/^BackoffDeterministicOnDemandFst<Arc>::BackoffDeterministicOnDemandFst($/;"	f	class:fst::BackoffDeterministicOnDemandFst
BackoffDeterministicOnDemandFst	deterministic-fst.h	/^class BackoffDeterministicOnDemandFst: public DeterministicOnDemandFst<Arc> {$/;"	c	namespace:fst
BaseFloat	lattice-weight-test.cc	/^typedef float BaseFloat;$/;"	t	namespace:fst	file:
CacheDeterministicOnDemandFst	deterministic-fst-inl.h	/^CacheDeterministicOnDemandFst<Arc>::CacheDeterministicOnDemandFst($/;"	f	class:fst::CacheDeterministicOnDemandFst
CacheDeterministicOnDemandFst	deterministic-fst.h	/^class CacheDeterministicOnDemandFst: public DeterministicOnDemandFst<Arc> {$/;"	c	namespace:fst
CanCombineArcs	remove-eps-local-inl.h	/^  bool CanCombineArcs(const Arc &a, const Arc &b, Arc *c) {$/;"	f	class:fst::RemoveEpsLocalClass
CanCombineFinal	remove-eps-local-inl.h	/^  static bool CanCombineFinal(const Arc &a, Weight final_prob, Weight *final_prob_out) {$/;"	f	class:fst::RemoveEpsLocalClass
CheckMemoryUsage	determinize-lattice-inl.h	/^  bool CheckMemoryUsage() {$/;"	f	class:fst::LatticeDeterminizer
CheckNumArcs	remove-eps-local-inl.h	/^  bool CheckNumArcs() {  \/\/ check num arcs in\/out of each state, at end.  Debug.$/;"	f	class:fst::RemoveEpsLocalClass
CheckPhones	context-fst-test.cc	/^static float CheckPhones(const VectorFst<Arc> &linear_fst,$/;"	f	namespace:fst
Clear	fstext-utils.h	/^  void Clear() {$/;"	f	class:fst::VectorFstTplHolder
ClearSymbols	fstext-utils-inl.h	/^void ClearSymbols(bool clear_input,$/;"	f	namespace:fst
Closure	pre-determinize-inl.h	/^template<class Arc> void Closure(MutableFst<Arc> *fst, std::set<typename Arc::StateId> *S,$/;"	f	namespace:fst::pre_determinize_helpers
CommonPrefix	determinize-lattice-inl.h	/^  const Entry *CommonPrefix (const Entry *a, const Entry *b) {$/;"	f	class:fst::LatticeStringRepository
CompactArc	determinize-lattice-inl.h	/^  typedef ArcTpl<CompactWeight> CompactArc; \/\/ arc in compact, acceptor form of lattice$/;"	t	class:fst::LatticeDeterminizer
CompactLatticeHasAlignment	lattice-utils-inl.h	/^bool CompactLatticeHasAlignment($/;"	f	namespace:fst
CompactLatticeWeight	lattice-weight-test.cc	/^typedef CompactLatticeWeightTpl<LatticeWeight, int32> CompactLatticeWeight;$/;"	t	namespace:fst	file:
CompactLatticeWeightCommonDivisor	lattice-weight-test.cc	/^  CompactLatticeWeightCommonDivisor;$/;"	t	namespace:fst	file:
CompactLatticeWeightCommonDivisorTpl	lattice-weight.h	/^class CompactLatticeWeightCommonDivisorTpl {$/;"	c	namespace:fst
CompactLatticeWeightTest	lattice-weight-test.cc	/^void CompactLatticeWeightTest() {$/;"	f	namespace:fst
CompactLatticeWeightTpl	lattice-weight.h	/^  CompactLatticeWeightTpl() { }$/;"	f	class:fst::CompactLatticeWeightTpl
CompactLatticeWeightTpl	lattice-weight.h	/^  CompactLatticeWeightTpl(const WeightType &w, const vector<IntType> &s):$/;"	f	class:fst::CompactLatticeWeightTpl
CompactLatticeWeightTpl	lattice-weight.h	/^class CompactLatticeWeightTpl {$/;"	c	namespace:fst
CompactWeight	determinize-lattice-inl.h	/^  typedef CompactLatticeWeightTpl<Weight, IntType> CompactWeight;$/;"	t	class:fst::LatticeDeterminizer
Compare	determinize-lattice-inl.h	/^  inline int Compare(const Weight &a_w, StringId a_str,$/;"	f	class:fst::LatticeDeterminizer
Compare	lattice-weight.h	/^inline int Compare (const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
Compare	lattice-weight.h	/^inline int Compare (const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
Compare	lattice-weight.h	/^inline int Compare(const TropicalWeight &w1,$/;"	f	namespace:fst
ComposeContext	context-fst-inl.h	/^inline void ComposeContext(vector<int32> &disambig_syms_in,$/;"	f	namespace:fst
ComposeContextFst	context-fst.h	/^void ComposeContextFst(const ContextFst<Arc, LabelT> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
ComposeDeterministicOnDemandFst	deterministic-fst-inl.h	/^ComposeDeterministicOnDemandFst<Arc>::ComposeDeterministicOnDemandFst($/;"	f	class:fst::ComposeDeterministicOnDemandFst
ComposeDeterministicOnDemandFst	deterministic-fst.h	/^class ComposeDeterministicOnDemandFst: public DeterministicOnDemandFst<Arc> {$/;"	c	namespace:fst
ComputeStateInfo	epsilon-property-inl.h	/^void ComputeStateInfo(const VectorFst<Arc> &fst,$/;"	f	namespace:fst
ComputeTotalWeight	rescale-inl.h	/^ComputeTotalWeight(ExpandedFst<Arc> &fst, typename Arc::Weight max_weight, float delta) {$/;"	f	namespace:fst
Concatenate	determinize-lattice-inl.h	/^  const Entry *Concatenate (const Entry *a, const Entry *b) {$/;"	f	class:fst::LatticeStringRepository
ContextF	context-fst.h	/^  typedef ContextFst<Arc, LabelT> ContextF;$/;"	t	class:fst::ContextMatcher
ContextFst	context-fst-inl.h	/^ContextFst<Arc, LabelT>::ContextFst(const ContextFst<Arc, LabelT> &fst, bool reset) {$/;"	f	class:fst::ContextFst
ContextFst	context-fst.h	/^  ContextFst(Label subsequential_symbol,  \/\/ epsilon not allowed.$/;"	f	class:fst::ContextFst
ContextFst	context-fst.h	/^class ContextFst : public Fst<Arc> {$/;"	c	namespace:fst
ContextFstImpl	context-fst-inl.h	/^ContextFstImpl<Arc, LabelT>::ContextFstImpl(Label subsequential_symbol,  \/\/ epsilon not allowed.$/;"	f	class:fst::ContextFstImpl
ContextFstImpl	context-fst-inl.h	/^ContextFstImpl<Arc, LabelT>::ContextFstImpl(const ContextFstImpl &other):$/;"	f	class:fst::ContextFstImpl
ContextFstImpl	context-fst.h	/^class ContextFstImpl : public CacheImpl<Arc> {$/;"	c	namespace:fst
ContextMatcher	context-fst.h	/^  ContextMatcher(const ContextMatcher<Arc, LabelT> &matcher, bool safe)$/;"	f	class:fst::ContextMatcher
ContextMatcher	context-fst.h	/^  ContextMatcher(const FST &fst, MatchType match_type)$/;"	f	class:fst::ContextMatcher
ContextMatcher	context-fst.h	/^class ContextMatcher : public MatcherBase<Arc> {  \/\/ CAREFUL: templated on arc, not on FST like normal Matcher.$/;"	c	namespace:fst
ConvertFromVector	determinize-lattice-inl.h	/^  const Entry *ConvertFromVector(const vector<IntType> &vec) {$/;"	f	class:fst::LatticeStringRepository
ConvertLattice	lattice-utils-inl.h	/^void ConvertLattice($/;"	f	namespace:fst
ConvertLattice	lattice-utils.h	/^void ConvertLattice(const ExpandedFst<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<double>, Int> > > &ifst,$/;"	f	namespace:fst
ConvertLattice	lattice-utils.h	/^void ConvertLattice(const ExpandedFst<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, Int> > > &ifst,$/;"	f	namespace:fst
ConvertLattice	lattice-utils.h	/^void ConvertLattice(const ExpandedFst<ArcTpl<LatticeWeightTpl<double> > > &ifst,$/;"	f	namespace:fst
ConvertLattice	lattice-utils.h	/^void ConvertLattice(const ExpandedFst<ArcTpl<LatticeWeightTpl<float> > > &ifst,$/;"	f	namespace:fst
ConvertLatticeWeight	lattice-weight.h	/^inline void ConvertLatticeWeight($/;"	f	namespace:fst
ConvertNbestToVector	fstext-utils-inl.h	/^void ConvertNbestToVector(const Fst<Arc> &fst,$/;"	f	namespace:fst
ConvertToCost	lattice-weight.h	/^inline double ConvertToCost(const CompactLatticeWeightTpl<LatticeWeightTpl<Float>, Int> &w) {$/;"	f	namespace:fst
ConvertToCost	lattice-weight.h	/^inline double ConvertToCost(const LatticeWeightTpl<Float> &w) {$/;"	f	namespace:fst
ConvertToCost	lattice-weight.h	/^inline double ConvertToCost(const TropicalWeightTpl<Float> &w) {$/;"	f	namespace:fst
ConvertToMinimal	determinize-lattice-inl.h	/^  void ConvertToMinimal(vector<Element> *subset) {$/;"	f	class:fst::LatticeDeterminizer
ConvertToVector	determinize-lattice-inl.h	/^  void ConvertToVector(const Entry *entry, vector<IntType> *out) const {$/;"	f	class:fst::LatticeStringRepository
Copy	context-fst.h	/^  virtual ContextFst<Arc>  *Copy(bool reset = false) const {$/;"	f	class:fst::ContextFst
Copy	context-fst.h	/^  virtual ContextMatcher<Arc, LabelT> *Copy(bool safe = false) const {$/;"	f	class:fst::ContextMatcher
Copy	fstext-utils.h	/^  void Copy(const T &t) {  \/\/ copies it into the holder.$/;"	f	class:fst::VectorFstTplHolder
Copy	table-matcher.h	/^  virtual TableMatcher<FST, BackoffMatcher> *Copy(bool safe = false) const {$/;"	f	class:fst::TableMatcher
Copy	table-matcher.h	/^  virtual TableMatcherImpl<FST> *Copy(bool safe = false) const {$/;"	f	class:fst::TableMatcherImpl
Copy	trivial-factor-weight.h	/^  virtual TrivialFactorWeightFst<A, F> *Copy(bool copy = false) const {$/;"	f	class:fst::TrivialFactorWeightFst
CopySetToVector	pre-determinize-inl.h	/^template<class T> void CopySetToVector(const std::set<T> s, vector<T> *v) {$/;"	f	namespace:fst::pre_determinize_helpers
CreateArc	context-fst-inl.h	/^bool ContextFstImpl<Arc, LabelT>::CreateArc(StateId s,$/;"	f	class:fst::ContextFstImpl
CreateArc	context-fst.h	/^  bool CreateArc(StateId s, Label olabel, Arc *oarc) const {$/;"	f	class:fst::ContextFst
CreateBackoffFst	deterministic-fst-test.cc	/^StdVectorFst* CreateBackoffFst() {$/;"	f	namespace:fst
CreateDisambigArc	context-fst-inl.h	/^void ContextFstImpl<Arc, LabelT>::CreateDisambigArc(StateId s,$/;"	f	class:fst::ContextFstImpl
CreateFactorFst	factor-inl.h	/^void CreateFactorFst(const vector<vector<I> > &sequences,$/;"	f	namespace:fst
CreateILabelInfoSymbolTable	context-fst-inl.h	/^SymbolTable *CreateILabelInfoSymbolTable(const vector<vector<I> > &info,$/;"	f	namespace:fst
CreateMapFst	factor-inl.h	/^void CreateMapFst(const vector<I> &symbol_map,$/;"	f	namespace:fst
CreateNewSymbols	pre-determinize-inl.h	/^template<class Label> void CreateNewSymbols(SymbolTable *input_sym_table, int nSym,$/;"	f	namespace:fst
CreatePhoneOrEpsArc	context-fst-inl.h	/^bool ContextFstImpl<Arc, LabelT>::CreatePhoneOrEpsArc(StateId src,$/;"	f	class:fst::ContextFstImpl
CreateResultFst	deterministic-fst-test.cc	/^StdVectorFst* CreateResultFst() {$/;"	f	namespace:fst
CreateSuperFinal	pre-determinize-inl.h	/^typename Arc::StateId CreateSuperFinal(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
Debug	determinize-lattice-inl.h	/^  void Debug() {  \/\/ this function called if you send a signal$/;"	f	class:fst::LatticeDeterminizer
Debug	determinize-star-inl.h	/^  void Debug() {  \/\/ this function called if you send a signal$/;"	f	class:fst::DeterminizerStar
DecrRefCount	table-matcher.h	/^  int DecrRefCount() {$/;"	f	class:fst::TableMatcherImpl
DefaultLatticeScale	lattice-utils.h	/^inline vector<vector<double> > DefaultLatticeScale() {$/;"	f	namespace:fst
DeleteISymbols	pre-determinize-inl.h	/^int64 DeleteISymbols(MutableFst<Arc> *fst, vector<typename Arc::Label> isyms) {$/;"	f	namespace:fst
DeleteTestFst	deterministic-fst-test.cc	/^void DeleteTestFst(StdVectorFst *fst) {$/;"	f	namespace:fst
Destroy	determinize-lattice-inl.h	/^  void Destroy() {$/;"	f	class:fst::LatticeStringRepository
Destroy	determinize-star-inl.h	/^  void Destroy() {$/;"	f	class:fst::StringRepository
DeterministicOnDemandFst	deterministic-fst.h	/^class DeterministicOnDemandFst {$/;"	c	namespace:fst
Determinize	determinize-lattice-inl.h	/^  bool Determinize(bool *debug_ptr) {$/;"	f	class:fst::LatticeDeterminizer
Determinize	determinize-star-inl.h	/^  void Determinize(bool *debug_ptr) {$/;"	f	class:fst::DeterminizerStar
DeterminizeInLog	fstext-utils-inl.h	/^void DeterminizeInLog(VectorFst<StdArc> *fst) {$/;"	f	namespace:fst
DeterminizeLattice	determinize-lattice-inl.h	/^bool DeterminizeLattice(const Fst<ArcTpl<Weight> > &ifst,$/;"	f	namespace:fst
DeterminizeLattice	determinize-lattice-inl.h	/^bool DeterminizeLattice(const Fst<ArcTpl<Weight> >&ifst,$/;"	f	namespace:fst
DeterminizeLatticeOptions	determinize-lattice.h	/^  DeterminizeLatticeOptions(): delta(kDelta),$/;"	f	struct:fst::DeterminizeLatticeOptions
DeterminizeLatticeOptions	determinize-lattice.h	/^struct DeterminizeLatticeOptions {$/;"	s	namespace:fst
DeterminizeStar	determinize-star-inl.h	/^void DeterminizeStar(Fst<Arc> &ifst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
DeterminizeStar	determinize-star-inl.h	/^void DeterminizeStar(Fst<Arc> &ifst, MutableFst<GallicArc<Arc> > *ofst, float delta,$/;"	f	namespace:fst
DeterminizeStarInLog	fstext-utils-inl.h	/^void DeterminizeStarInLog(VectorFst<StdArc> *fst, float delta, bool *debug_ptr, int max_states) {$/;"	f	namespace:fst
DeterminizerStar	determinize-star-inl.h	/^  DeterminizerStar(const Fst<Arc> &ifst, float delta = kDelta, int max_states = -1):$/;"	f	class:fst::DeterminizerStar
DeterminizerStar	determinize-star-inl.h	/^template<class Arc> class DeterminizerStar {$/;"	c	namespace:fst
DfsOrderVisitor	factor.h	/^  DfsOrderVisitor(vector<StateId> *order): order_(order) { order->clear(); }$/;"	f	class:fst::DfsOrderVisitor
DfsOrderVisitor	factor.h	/^class DfsOrderVisitor {$/;"	c	namespace:fst
Divide	lattice-weight.h	/^inline CompactLatticeWeightTpl<WeightType, IntType> Divide(const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
Divide	lattice-weight.h	/^inline LatticeWeightTpl<FloatType> Divide(const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
Done	context-fst.h	/^  bool Done() const {$/;"	f	class:fst::ContextMatcher
Done	table-matcher.h	/^  bool Done() const { return impl_->Done(); }$/;"	f	class:fst::TableMatcher
Done	table-matcher.h	/^  bool Done() const {$/;"	f	class:fst::TableMatcherImpl
Done_	context-fst.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::ContextMatcher
Done_	table-matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::TableMatcherImpl
Done_	table-matcher.h	/^  virtual bool Done_() const { return impl_->Done(); }$/;"	f	class:fst::TableMatcher
Element	determinize-lattice-inl.h	/^  struct Element {$/;"	s	class:fst::LatticeDeterminizer
Element	determinize-star-inl.h	/^  struct Element {$/;"	s	class:fst::DeterminizerStar
Element	trivial-factor-weight.h	/^    Element() {}$/;"	f	struct:fst::TrivialFactorWeightFstImpl::Element
Element	trivial-factor-weight.h	/^    Element(StateId s, Weight w) : state(s), weight(w) {}$/;"	f	struct:fst::TrivialFactorWeightFstImpl::Element
Element	trivial-factor-weight.h	/^  struct Element {$/;"	s	class:fst::TrivialFactorWeightFstImpl
ElementEqual	trivial-factor-weight.h	/^  class ElementEqual {$/;"	c	class:fst::TrivialFactorWeightFstImpl
ElementKey	trivial-factor-weight.h	/^  class ElementKey {$/;"	c	class:fst::TrivialFactorWeightFstImpl
ElementMap	trivial-factor-weight.h	/^  typedef unordered_map<Element, StateId, ElementKey, ElementEqual> ElementMap;$/;"	t	class:fst::TrivialFactorWeightFstImpl
EmptyString	determinize-lattice-inl.h	/^  inline const Entry *EmptyString() { return NULL; }  $/;"	f	class:fst::LatticeStringRepository
EnsureEpsilonProperty	epsilon-property-inl.h	/^void EnsureEpsilonProperty(VectorFst<Arc> *fst) {$/;"	f	namespace:fst
Entry	determinize-lattice-inl.h	/^    Entry() { }$/;"	f	struct:fst::LatticeStringRepository::Entry
Entry	determinize-lattice-inl.h	/^    Entry(const Entry &e): parent(e.parent), i(e.i) {}$/;"	f	struct:fst::LatticeStringRepository::Entry
Entry	determinize-lattice-inl.h	/^  struct Entry {$/;"	s	class:fst::LatticeStringRepository
EntryEqual	determinize-lattice-inl.h	/^  class EntryEqual {$/;"	c	class:fst::LatticeStringRepository
EntryKey	determinize-lattice-inl.h	/^  class EntryKey { \/\/ Hash function object.$/;"	c	class:fst::LatticeStringRepository
EpsilonClosure	determinize-lattice-inl.h	/^  void EpsilonClosure(vector<Element> *subset) {$/;"	f	class:fst::LatticeDeterminizer
EpsilonClosure	determinize-star-inl.h	/^  void EpsilonClosure(const vector<Element> & input_subset,$/;"	f	class:fst::DeterminizerStar
EqualAlign	fstext-utils-inl.h	/^bool EqualAlign(const Fst<Arc> &ifst,$/;"	f	namespace:fst
Expand	context-fst-inl.h	/^void ContextFstImpl<Arc, LabelT>::Expand(StateId s) {  \/\/ expands arcs only [not final state weight].$/;"	f	class:fst::ContextFstImpl
Expand	trivial-factor-weight.h	/^  void Expand(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
ExpandInputSequences	factor-inl.h	/^void ExpandInputSequences(const vector<vector<I> > &sequences,$/;"	f	namespace:fst
FST	context-fst.h	/^  typedef Fst<Arc> FST;  \/\/ basic FST type that we get passed$/;"	t	class:fst::ContextMatcher
FST	table-matcher.h	/^  typedef F FST;$/;"	t	class:fst::TableMatcher
FST	table-matcher.h	/^  typedef F FST;$/;"	t	class:fst::TableMatcherImpl
Factor	factor-inl.h	/^void Factor(const Fst<Arc> &fst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
Factor	factor-inl.h	/^void Factor(const Fst<Arc> &fst, MutableFst<Arc> *ofst1,$/;"	f	namespace:fst
FactorIterator	trivial-factor-weight.h	/^  typedef F FactorIterator;$/;"	t	class:fst::TrivialFactorWeightFstImpl
FileExists	deterministic-fst-test.cc	/^bool FileExists(string strFilename) { $/;"	f	namespace:fst
Final	context-fst-inl.h	/^typename ContextFstImpl<Arc, LabelT>::Weight ContextFstImpl<Arc, LabelT>::Final(StateId s) {$/;"	f	class:fst::ContextFstImpl
Final	context-fst.h	/^  virtual Weight Final(StateId s) const { return impl_->Final(s); }$/;"	f	class:fst::ContextFst
Final	deterministic-fst-inl.h	/^typename Arc::Weight BackoffDeterministicOnDemandFst<Arc>::Final(StateId state) {$/;"	f	class:fst::BackoffDeterministicOnDemandFst
Final	deterministic-fst-inl.h	/^typename Arc::Weight ComposeDeterministicOnDemandFst<Arc>::Final(StateId s) {$/;"	f	class:fst::ComposeDeterministicOnDemandFst
Final	deterministic-fst-inl.h	/^typename Arc::Weight LmExampleDeterministicOnDemandFst<Arc>::Final(StateId s) {$/;"	f	class:fst::LmExampleDeterministicOnDemandFst
Final	deterministic-fst.h	/^  virtual Weight Final(StateId s) { return fst_->Final(s); }$/;"	f	class:fst::CacheDeterministicOnDemandFst
Final	trivial-factor-weight.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
FinalAction	factor-inl.h	/^  MapFinalAction FinalAction() { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
FinalAction	fstext-utils-inl.h	/^  MapFinalAction FinalAction() { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::MapInputSymbolsMapper
FinalAction	lattice-utils.h	/^  MapFinalAction FinalAction() { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::LatticeToStdMapper
FinalAction	lattice-utils.h	/^  MapFinalAction FinalAction() { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::StdToLatticeMapper
Find	context-fst-inl.h	/^bool ContextMatcher<Arc, LabelT>::Find(typename Arc::Label match_label) {$/;"	f	class:fst::ContextMatcher
Find	table-matcher.h	/^  bool Find(Label match_label) { return impl_->Find(match_label); }$/;"	f	class:fst::TableMatcher
Find	table-matcher.h	/^  bool Find(Label match_label) {$/;"	f	class:fst::TableMatcherImpl
FindLabel	context-fst-inl.h	/^ContextFstImpl<Arc, LabelT>::FindLabel(const vector<LabelT> &label_vec) {$/;"	f	class:fst::ContextFstImpl
FindSelfLoopWithILabel	fstext-utils-inl.h	/^ssize_t FindSelfLoopWithILabel(const Fst<Arc> &fst, typename Arc::StateId s) {$/;"	f	namespace:fst
FindState	context-fst-inl.h	/^   ContextFstImpl<Arc, LabelT>::FindState(const vector<LabelT> &seq) {$/;"	f	class:fst::ContextFstImpl
FindState	trivial-factor-weight.h	/^  StateId FindState(const Element &e) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
Find_	context-fst.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::ContextMatcher
Find_	table-matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::TableMatcherImpl
Find_	table-matcher.h	/^  virtual bool Find_(Label label) { return impl_->Find(label); }$/;"	f	class:fst::TableMatcher
FinishState	factor.h	/^  void FinishState(StateId, StateId, const Arc *) { }$/;"	f	class:fst::DfsOrderVisitor
FinishVisit	factor.h	/^  void FinishVisit() { }$/;"	f	class:fst::DfsOrderVisitor
FollowingInputSymbolsAreSame	fstext-utils-inl.h	/^bool FollowingInputSymbolsAreSame(bool end_is_epsilon, const Fst<Arc> &fst) {$/;"	f	namespace:fst
FollowingInputSymbolsAreSameClass	fstext-utils-inl.h	/^bool FollowingInputSymbolsAreSameClass(bool end_is_epsilon, const Fst<Arc> &fst, const F &f) {$/;"	f	namespace:fst
ForwardOrCrossArc	factor.h	/^  bool ForwardOrCrossArc(StateId, const Arc&) { return true; }$/;"	f	class:fst::DfsOrderVisitor
FreeMostMemory	determinize-lattice-inl.h	/^  void FreeMostMemory() {$/;"	f	class:fst::LatticeDeterminizer
FreeMostMemory	determinize-star-inl.h	/^  void FreeMostMemory() {$/;"	f	class:fst::DeterminizerStar
GenAcceptorFromSequence	context-fst-test.cc	/^static VectorFst<Arc> *GenAcceptorFromSequence(const vector<typename Arc::Label> &symbols, float cost) {$/;"	f	namespace:fst
GenRandPhoneSeq	context-fst-test.cc	/^static VectorFst<Arc> *GenRandPhoneSeq(vector<typename Arc::Label> &phone_syms,$/;"	f	namespace:fst
GetArc	deterministic-fst-inl.h	/^bool BackoffDeterministicOnDemandFst<Arc>::GetArc($/;"	f	class:fst::BackoffDeterministicOnDemandFst
GetArc	deterministic-fst-inl.h	/^bool CacheDeterministicOnDemandFst<Arc>::GetArc(StateId s, Label ilabel,$/;"	f	class:fst::CacheDeterministicOnDemandFst
GetArc	deterministic-fst-inl.h	/^bool ComposeDeterministicOnDemandFst<Arc>::GetArc(StateId s, Label ilabel,$/;"	f	class:fst::ComposeDeterministicOnDemandFst
GetArc	deterministic-fst-inl.h	/^bool LmExampleDeterministicOnDemandFst<Arc>::GetArc($/;"	f	class:fst::LmExampleDeterministicOnDemandFst
GetArc	remove-eps-local-inl.h	/^  inline void GetArc(StateId s, size_t pos, Arc *arc) const {$/;"	f	class:fst::RemoveEpsLocalClass
GetBackoffState	deterministic-fst-inl.h	/^BackoffDeterministicOnDemandFst<Arc>::GetBackoffState(StateId s,$/;"	f	class:fst::BackoffDeterministicOnDemandFst
GetFst	context-fst.h	/^  virtual const FST &GetFst() const { return *fst_; }$/;"	f	class:fst::ContextMatcher
GetFst	table-matcher.h	/^  virtual const FST &GetFst() const { return *fst_; }$/;"	f	class:fst::TableMatcherImpl
GetFst	table-matcher.h	/^  virtual const FST &GetFst() const { return impl_->GetFst(); }$/;"	f	class:fst::TableMatcher
GetImpl	context-fst.h	/^  ContextFstImpl<Arc, LabelT> *GetImpl() const { return impl_; }$/;"	f	class:fst::ContextFst
GetImpl	trivial-factor-weight.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::TrivialFactorWeightFst
GetIndex	deterministic-fst-inl.h	/^inline size_t CacheDeterministicOnDemandFst<Arc>::GetIndex($/;"	f	class:fst::CacheDeterministicOnDemandFst
GetInputSymbols	fstext-utils-inl.h	/^void GetInputSymbols(const Fst<Arc> &fst,$/;"	f	namespace:fst
GetIntSizeString	lattice-weight.h	/^  inline static string GetIntSizeString() {$/;"	f	class:fst::CompactLatticeWeightTpl
GetLinearSymbolSequence	fstext-utils-inl.h	/^bool GetLinearSymbolSequence(const Fst<Arc> &fst,$/;"	f	namespace:fst
GetLinearSymbolSequences	fstext-utils-inl.h	/^bool GetLinearSymbolSequences(const Fst<Arc> &fst,$/;"	f	namespace:fst
GetOutputSymbols	fstext-utils-inl.h	/^void GetOutputSymbols(const Fst<Arc> &fst,$/;"	f	namespace:fst
GetStateProperties	factor-inl.h	/^void GetStateProperties(const Fst<Arc> &fst,$/;"	f	namespace:fst
GetSymbols	fstext-utils-inl.h	/^void GetSymbols(const SymbolTable &symtab,$/;"	f	namespace:fst
GraphLatticeScale	lattice-utils.h	/^inline vector<vector<double> > GraphLatticeScale(double lmwt) {$/;"	f	namespace:fst
HasBannedPrefixPlusDigits	pre-determinize-inl.h	/^inline bool HasBannedPrefixPlusDigits(SymbolTable *symTable, std::string prefix, std::string *bad_sym) {$/;"	f	namespace:fst::pre_determinize_helpers
Hash	lattice-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::CompactLatticeWeightTpl
Hash	lattice-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::LatticeWeightTpl
HighestNumberedInputSymbol	fstext-utils-inl.h	/^typename Arc::Label HighestNumberedInputSymbol(const Fst<Arc> &fst) {$/;"	f	namespace:fst
HighestNumberedOutputSymbol	fstext-utils-inl.h	/^typename Arc::Label HighestNumberedOutputSymbol(const Fst<Arc> &fst) {$/;"	f	namespace:fst
ILabelInfo	context-fst.h	/^  const vector<vector<LabelT> > &ILabelInfo() { return ilabel_info_; }$/;"	f	class:fst::ContextFstImpl
ILabelInfo	context-fst.h	/^  const vector<vector<LabelT> > &ILabelInfo() { return impl_->ILabelInfo(); }$/;"	f	class:fst::ContextFst
IdOfEmpty	determinize-star-inl.h	/^  StringId IdOfEmpty() { return no_symbol; }$/;"	f	class:fst::StringRepository
IdOfLabel	determinize-star-inl.h	/^  StringId IdOfLabel(Label l) {$/;"	f	class:fst::StringRepository
IdOfSeq	determinize-star-inl.h	/^  StringId IdOfSeq(const vector<Label> &v) {  \/\/ also works for sizes 0 and 1.$/;"	f	class:fst::StringRepository
IdOfSeqInternal	determinize-star-inl.h	/^  StringId IdOfSeqInternal(const vector<Label> &v) {$/;"	f	class:fst::StringRepository
IdentityFunction	fstext-utils-inl.h	/^template<class T> struct IdentityFunction {$/;"	s	namespace:fst
Impl	trivial-factor-weight.h	/^  typedef TrivialFactorWeightFstImpl<A, F> Impl;$/;"	t	class:fst::TrivialFactorWeightFst
IncrRefCount	table-matcher.h	/^  int IncrRefCount() {$/;"	f	class:fst::TableMatcherImpl
InitArcIterator	context-fst-inl.h	/^void ContextFstImpl<Arc, LabelT>::InitArcIterator(StateId s, ArcIteratorData<Arc> *data) {$/;"	f	class:fst::ContextFstImpl
InitArcIterator	context-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::ContextFst
InitArcIterator	trivial-factor-weight.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::TrivialFactorWeightFst
InitArcIterator	trivial-factor-weight.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
InitNumArcs	remove-eps-local-inl.h	/^  void InitNumArcs() {  \/\/ init num transitions in\/out of each state.$/;"	f	class:fst::RemoveEpsLocalClass
InitState	factor.h	/^  bool InitState(StateId s, StateId) { order_->push_back(s); return true; }$/;"	f	class:fst::DfsOrderVisitor
InitStateIterator	context-fst.h	/^void ContextFst<A, I>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ContextFst
InitStateIterator	trivial-factor-weight.h	/^void TrivialFactorWeightFst<A, F>::InitStateIterator(StateIteratorData<A> *data) const$/;"	f	class:fst::TrivialFactorWeightFst
InitVisit	factor.h	/^  void InitVisit(const Fst<Arc> &fst) {}$/;"	f	class:fst::DfsOrderVisitor
InitialSubsetHash	determinize-lattice-inl.h	/^                        SubsetKey, SubsetEqual> InitialSubsetHash;$/;"	t	class:fst::LatticeDeterminizer
InitialToStateId	determinize-lattice-inl.h	/^  OutputStateId InitialToStateId(const vector<Element> &subset_in,$/;"	f	class:fst::LatticeDeterminizer
InitializeDeterminization	determinize-lattice-inl.h	/^  void InitializeDeterminization() {    $/;"	f	class:fst::LatticeDeterminizer
InputStateId	determinize-lattice-inl.h	/^  typedef typename Arc::StateId InputStateId;  \/\/ state in the input FST.$/;"	t	class:fst::LatticeDeterminizer
InputStateId	determinize-star-inl.h	/^  typedef typename Arc::StateId InputStateId;$/;"	t	class:fst::DeterminizerStar
InputSymbols	context-fst.h	/^  virtual const SymbolTable* InputSymbols() const {$/;"	f	class:fst::ContextFst
InputSymbolsAction	factor-inl.h	/^  MapSymbolsAction InputSymbolsAction() { return MAP_CLEAR_SYMBOLS; }$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
InputSymbolsAction	fstext-utils-inl.h	/^  MapSymbolsAction InputSymbolsAction() { return MAP_CLEAR_SYMBOLS; }$/;"	f	class:fst::MapInputSymbolsMapper
InputSymbolsAction	lattice-utils.h	/^  MapSymbolsAction InputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::LatticeToStdMapper
InputSymbolsAction	lattice-utils.h	/^  MapSymbolsAction InputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::StdToLatticeMapper
InsertMember	pre-determinize-inl.h	/^vector<T>* InsertMember(const vector<T> m, vector<vector<T>*> *S) {$/;"	f	namespace:fst::pre_determinize_helpers
IsDisambigSymbol	context-fst.h	/^  bool IsDisambigSymbol(Label lab) {  return (disambig_syms_.count(lab) != 0); }$/;"	f	class:fst::ContextFstImpl
IsEmptyString	determinize-star-inl.h	/^  inline bool IsEmptyString(StringId id) {$/;"	f	class:fst::StringRepository
IsIsymbolOrFinal	determinize-lattice-inl.h	/^  bool IsIsymbolOrFinal(InputStateId state) { \/\/ returns true if this state$/;"	f	class:fst::LatticeDeterminizer
IsPhoneSymbol	context-fst.h	/^  bool IsPhoneSymbol(Label lab) {  return (phone_syms_.count(lab) != 0); }$/;"	f	class:fst::ContextFstImpl
IsPrefixOf	determinize-lattice-inl.h	/^  bool IsPrefixOf(const Entry *a, const Entry *b) const {$/;"	f	class:fst::LatticeStringRepository
IsReadInBinary	fstext-utils.h	/^  static bool IsReadInBinary() { return true; }$/;"	f	class:fst::VectorFstTplHolder
IsStochasticFst	fstext-utils-inl.h	/^bool IsStochasticFst(const Fst<Arc> &fst,$/;"	f	namespace:fst
IsStochasticFst	fstext-utils-inl.h	/^bool IsStochasticFst(const Fst<LogArc> &fst,$/;"	f	namespace:fst
IsStochasticFstInLog	fstext-utils-inl.h	/^bool IsStochasticFstInLog(const VectorFst<StdArc> &fst,$/;"	f	namespace:fst
IsymbolOrFinal	determinize-lattice-inl.h	/^  enum IsymbolOrFinal { OSF_UNKNOWN = 0, OSF_NO = 1, OSF_YES = 2 };$/;"	g	class:fst::LatticeDeterminizer
Iterate	push-special.cc	/^  void Iterate(float delta) {$/;"	f	class:fst::PushSpecialClass	file:
KALDI_FSTEXT_CONTEXT_FST_H_	context-fst.h	43;"	d
KALDI_FSTEXT_CONTEXT_FST_INL_H_	context-fst-inl.h	21;"	d
KALDI_FSTEXT_DETERMINISTIC_FST_H_	deterministic-fst.h	41;"	d
KALDI_FSTEXT_DETERMINISTIC_FST_INL_H_	deterministic-fst-inl.h	21;"	d
KALDI_FSTEXT_DETERMINIZE_LATTICE_H_	determinize-lattice.h	21;"	d
KALDI_FSTEXT_DETERMINIZE_LATTICE_INL_H_	determinize-lattice-inl.h	22;"	d
KALDI_FSTEXT_DETERMINIZE_STAR_H_	determinize-star.h	21;"	d
KALDI_FSTEXT_DETERMINIZE_STAR_INL_H_	determinize-star-inl.h	21;"	d
KALDI_FSTEXT_EPSILON_PROPERTY_H_	epsilon-property.h	21;"	d
KALDI_FSTEXT_EPSILON_PROPERTY_INL_H_	epsilon-property-inl.h	21;"	d
KALDI_FSTEXT_FACTOR_H_	factor.h	21;"	d
KALDI_FSTEXT_FACTOR_INL_H_	factor-inl.h	21;"	d
KALDI_FSTEXT_FSTEXT_LIB_H_	fstext-lib.h	21;"	d
KALDI_FSTEXT_FSTEXT_UTILS_H_	fstext-utils.h	22;"	d
KALDI_FSTEXT_FSTEXT_UTILS_INL_H_	fstext-utils-inl.h	21;"	d
KALDI_FSTEXT_FST_TEST_UTILS_H_	fst-test-utils.h	21;"	d
KALDI_FSTEXT_LATTICE_UTILS_H_	lattice-utils.h	22;"	d
KALDI_FSTEXT_LATTICE_UTILS_INL_H_	lattice-utils-inl.h	21;"	d
KALDI_FSTEXT_LATTICE_WEIGHT_H_	lattice-weight.h	22;"	d
KALDI_FSTEXT_PRE_DETERMINIZE_H_	pre-determinize.h	21;"	d
KALDI_FSTEXT_PRE_DETERMINIZE_INL_H_	pre-determinize-inl.h	21;"	d
KALDI_FSTEXT_PUSH_SPECIAL_H_	push-special.h	21;"	d
KALDI_FSTEXT_RAND_FST_H_	rand-fst.h	21;"	d
KALDI_FSTEXT_REMAP_LEAVES_H_	remap-leaves.h	21;"	d
KALDI_FSTEXT_REMOVE_EPS_LOCAL_H_	remove-eps-local.h	21;"	d
KALDI_FSTEXT_REMOVE_EPS_LOCAL_INL_H_	remove-eps-local-inl.h	21;"	d
KALDI_FSTEXT_RESCALE_H_	rescale.h	21;"	d
KALDI_FSTEXT_RESCALE_INL_H_	rescale-inl.h	21;"	d
KALDI_FSTEXT_TABLE_MATCHER_H_	table-matcher.h	21;"	d
KALDI_FSTEXT_TRIVIAL_FACTOR_WEIGHT_H_	trivial-factor-weight.h	44;"	d
Label	context-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ContextFst
Label	context-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ContextFstImpl
Label	context-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ContextMatcher
Label	deterministic-fst-test.cc	/^typedef fst::StdArc::Label   Label;$/;"	t	namespace:fst	file:
Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::BackoffDeterministicOnDemandFst
Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::CacheDeterministicOnDemandFst
Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ComposeDeterministicOnDemandFst
Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::DeterministicOnDemandFst
Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LmExampleDeterministicOnDemandFst
Label	determinize-lattice-inl.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LatticeDeterminizer
Label	determinize-star-inl.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::DeterminizerStar
Label	remove-eps-local-inl.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::RemoveEpsLocalClass
Label	table-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::TableMatcher
Label	table-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::TableMatcherImpl
Label	trivial-factor-weight.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::TrivialFactorWeightFstImpl
Label	trivial-factor-weight.h	/^  typedef typename Arc::Label Label;$/;"	t	struct:fst::TrivialFactorWeightOptions
LatticeArc	lattice-utils.h	/^  typedef ArcTpl<LatticeWeight> LatticeArc;$/;"	t	class:fst::LatticeToStdMapper
LatticeArc	lattice-utils.h	/^  typedef ArcTpl<LatticeWeight> LatticeArc;$/;"	t	class:fst::StdToLatticeMapper
LatticeDeterminizer	determinize-lattice-inl.h	/^  LatticeDeterminizer(const Fst<Arc> &ifst,$/;"	f	class:fst::LatticeDeterminizer
LatticeDeterminizer	determinize-lattice-inl.h	/^template<class Weight, class IntType> class LatticeDeterminizer {$/;"	c	namespace:fst
LatticeScale	lattice-utils.h	/^inline vector<vector<double> > LatticeScale(double lmwt, double acwt) {$/;"	f	namespace:fst
LatticeStringRepository	determinize-lattice-inl.h	/^  LatticeStringRepository() { new_entry_ = new Entry; }$/;"	f	class:fst::LatticeStringRepository
LatticeStringRepository	determinize-lattice-inl.h	/^template<class IntType> class LatticeStringRepository {$/;"	c	namespace:fst
LatticeToStdMapper	lattice-utils.h	/^class LatticeToStdMapper {$/;"	c	namespace:fst
LatticeWeight	lattice-utils.h	/^  typedef LatticeWeightTpl<Int> LatticeWeight;$/;"	t	class:fst::LatticeToStdMapper
LatticeWeight	lattice-utils.h	/^  typedef LatticeWeightTpl<Int> LatticeWeight;$/;"	t	class:fst::StdToLatticeMapper
LatticeWeight	lattice-weight-test.cc	/^typedef LatticeWeightTpl<BaseFloat> LatticeWeight;$/;"	t	namespace:fst	file:
LatticeWeightTest	lattice-weight-test.cc	/^void LatticeWeightTest() {$/;"	f	namespace:fst
LatticeWeightTpl	lattice-weight.h	/^  LatticeWeightTpl() { }$/;"	f	class:fst::LatticeWeightTpl
LatticeWeightTpl	lattice-weight.h	/^  LatticeWeightTpl(T a, T b): value1_(a), value2_(b) {}$/;"	f	class:fst::LatticeWeightTpl
LatticeWeightTpl	lattice-weight.h	/^  LatticeWeightTpl(const LatticeWeightTpl &other): value1_(other.value1_), value2_(other.value2_) { }$/;"	f	class:fst::LatticeWeightTpl
LatticeWeightTpl	lattice-weight.h	/^class LatticeWeightTpl {$/;"	c	namespace:fst
LmExampleDeterministicOnDemandFst	deterministic-fst-inl.h	/^LmExampleDeterministicOnDemandFst<Arc>::LmExampleDeterministicOnDemandFst($/;"	f	class:fst::LmExampleDeterministicOnDemandFst
LmExampleDeterministicOnDemandFst	deterministic-fst.h	/^class LmExampleDeterministicOnDemandFst: public DeterministicOnDemandFst<Arc> {$/;"	c	namespace:fst
MakeFollowingInputSymbolsSame	fstext-utils-inl.h	/^void MakeFollowingInputSymbolsSame(bool end_is_epsilon, MutableFst<Arc> *fst) {$/;"	f	namespace:fst
MakeFollowingInputSymbolsSameClass	fstext-utils-inl.h	/^void MakeFollowingInputSymbolsSameClass(bool end_is_epsilon, MutableFst<Arc> *fst, const F &f) {$/;"	f	namespace:fst
MakeLinearAcceptor	fstext-utils-inl.h	/^void MakeLinearAcceptor(const vector<I> &labels, MutableFst<Arc> *ofst) {$/;"	f	namespace:fst
MakeLinearAcceptorWithAlternatives	fstext-utils-inl.h	/^void MakeLinearAcceptorWithAlternatives(const vector<vector<I> > &labels,$/;"	f	namespace:fst
MakeLoopFst	fstext-utils-inl.h	/^VectorFst<Arc>* MakeLoopFst(const vector<const ExpandedFst<Arc> *> &fsts) {$/;"	f	namespace:fst
MakeLoopFstCompare	fstext-utils-test.cc	/^VectorFst<Arc>* MakeLoopFstCompare(const vector<const ExpandedFst<Arc> *> &fsts) {$/;"	f	namespace:fst
MakePrecedingInputSymbolsSame	fstext-utils-inl.h	/^void MakePrecedingInputSymbolsSame(bool start_is_epsilon, MutableFst<Arc> *fst) {$/;"	f	namespace:fst
MakePrecedingInputSymbolsSameClass	fstext-utils-inl.h	/^void MakePrecedingInputSymbolsSameClass(bool start_is_epsilon, MutableFst<Arc> *fst, const F &f) {$/;"	f	namespace:fst
MakeSubsetUnique	determinize-lattice-inl.h	/^  void MakeSubsetUnique(vector<Element> *subset) {$/;"	f	class:fst::LatticeDeterminizer
MapInputSymbols	fstext-utils-inl.h	/^void MapInputSymbols(const vector<I> &symbol_mapping,$/;"	f	namespace:fst
MapInputSymbolsMapper	fstext-utils-inl.h	/^  MapInputSymbolsMapper(const vector<I> &to_remove, bool copy) {$/;"	f	class:fst::MapInputSymbolsMapper
MapInputSymbolsMapper	fstext-utils-inl.h	/^class MapInputSymbolsMapper {$/;"	c	namespace:fst
MapType	deterministic-fst.h	/^  typedef unordered_map<std::pair<StateId, StateId>, StateId, kaldi::PairHasher<StateId> > MapType;$/;"	t	class:fst::ComposeDeterministicOnDemandFst
MapType	deterministic-fst.h	/^  typedef unordered_map<std::vector<Label>, StateId, kaldi::VectorHasher<Label> > MapType;$/;"	t	class:fst::LmExampleDeterministicOnDemandFst
MapType	determinize-star-inl.h	/^  typedef unordered_map<const vector<Label>*, StringId, VectorKey, VectorEqual> MapType;$/;"	t	class:fst::StringRepository
MemSize	determinize-lattice-inl.h	/^  int32 MemSize() const {$/;"	f	class:fst::LatticeStringRepository
Member	lattice-weight.h	/^  bool Member() const {$/;"	f	class:fst::CompactLatticeWeightTpl
Member	lattice-weight.h	/^  bool Member() const {$/;"	f	class:fst::LatticeWeightTpl
MinimalSubsetHash	determinize-lattice-inl.h	/^                        SubsetKey, SubsetEqual> MinimalSubsetHash;$/;"	t	class:fst::LatticeDeterminizer
MinimalToStateId	determinize-lattice-inl.h	/^  OutputStateId MinimalToStateId(const vector<Element> &subset) {$/;"	f	class:fst::LatticeDeterminizer
MinimizeEncoded	fstext-utils.h	/^void MinimizeEncoded(VectorFst<Arc> *fst, float delta = kDelta) {$/;"	f	namespace:fst
ModifyFst	push-special.cc	/^  void ModifyFst() {$/;"	f	class:fst::PushSpecialClass	file:
N_	context-fst.h	/^  int N_;$/;"	m	class:fst::ContextFstImpl
NaturalLess	lattice-weight.h	/^class NaturalLess<CompactLatticeWeightTpl<LatticeWeightTpl<FloatType>, IntType> > {$/;"	c	namespace:fst
NaturalLess	lattice-weight.h	/^class NaturalLess<LatticeWeightTpl<FloatType> > {$/;"	c	namespace:fst
NbestAsFsts	fstext-utils-inl.h	/^void NbestAsFsts(const Fst<Arc> &fst,$/;"	f	namespace:fst
Next	context-fst.h	/^  void Next() {  \/\/ we only ever get one arc so just set ready_ to false.$/;"	f	class:fst::ContextMatcher
Next	table-matcher.h	/^  void Next() { return impl_->Next(); }$/;"	f	class:fst::TableMatcher
Next	table-matcher.h	/^  void Next() {$/;"	f	class:fst::TableMatcherImpl
Next_	context-fst.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::ContextMatcher
Next_	table-matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::TableMatcherImpl
Next_	table-matcher.h	/^  virtual void Next_() { impl_->Next(); }$/;"	f	class:fst::TableMatcher
NoWeight	lattice-weight.h	/^  static const CompactLatticeWeightTpl<WeightType, IntType> NoWeight() {$/;"	f	class:fst::CompactLatticeWeightTpl
NoWeight	lattice-weight.h	/^  static const LatticeWeightTpl NoWeight() {$/;"	f	class:fst::LatticeWeightTpl
NormalizeSubset	determinize-lattice-inl.h	/^  void NormalizeSubset(vector<Element> *elems,$/;"	f	class:fst::LatticeDeterminizer
NumArcs	context-fst-inl.h	/^size_t ContextFstImpl<Arc, LabelT>::NumArcs(StateId s) {$/;"	f	class:fst::ContextFstImpl
NumArcs	context-fst.h	/^  size_t NumArcs(StateId s) const { return impl_->NumArcs(s); }$/;"	f	class:fst::ContextFst
NumArcs	fstext-utils-inl.h	/^typename Arc::StateId NumArcs(const ExpandedFst<Arc> &fst) {$/;"	f	namespace:fst
NumArcs	trivial-factor-weight.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
NumInputEpsilons	context-fst-inl.h	/^size_t ContextFstImpl<Arc, LabelT>::NumInputEpsilons(StateId s) {$/;"	f	class:fst::ContextFstImpl
NumInputEpsilons	context-fst.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::ContextFst
NumInputEpsilons	trivial-factor-weight.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
NumOutputEpsilons	context-fst.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::ContextFst
NumOutputEpsilons	context-fst.h	/^  size_t NumOutputEpsilons(StateId s) { return 0; }$/;"	f	class:fst::ContextFstImpl
NumOutputEpsilons	trivial-factor-weight.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
NumStates	context-fst.h	/^  StateId NumStates() const { return impl_->NumStates(); }$/;"	f	class:fst::ContextFst
OSF_NO	determinize-lattice-inl.h	/^  enum IsymbolOrFinal { OSF_UNKNOWN = 0, OSF_NO = 1, OSF_YES = 2 };$/;"	e	enum:fst::LatticeDeterminizer::IsymbolOrFinal
OSF_UNKNOWN	determinize-lattice-inl.h	/^  enum IsymbolOrFinal { OSF_UNKNOWN = 0, OSF_NO = 1, OSF_YES = 2 };$/;"	e	enum:fst::LatticeDeterminizer::IsymbolOrFinal
OSF_YES	determinize-lattice-inl.h	/^  enum IsymbolOrFinal { OSF_UNKNOWN = 0, OSF_NO = 1, OSF_YES = 2 };$/;"	e	enum:fst::LatticeDeterminizer::IsymbolOrFinal
One	lattice-weight.h	/^  static const CompactLatticeWeightTpl<WeightType, IntType> One() {$/;"	f	class:fst::CompactLatticeWeightTpl
One	lattice-weight.h	/^  static const LatticeWeightTpl One() {$/;"	f	class:fst::LatticeWeightTpl
Output	determinize-lattice-inl.h	/^  void  Output(MutableFst<Arc> *ofst, bool destroy = true) {$/;"	f	class:fst::LatticeDeterminizer
Output	determinize-lattice-inl.h	/^  void Output(MutableFst<CompactArc>  *ofst, bool destroy = true) {$/;"	f	class:fst::LatticeDeterminizer
Output	determinize-star-inl.h	/^  void  Output(MutableFst<Arc> *ofst, bool destroy = true) {$/;"	f	class:fst::DeterminizerStar
Output	determinize-star-inl.h	/^  void Output(MutableFst<GallicArc<Arc> >  *ofst, bool destroy = true) {$/;"	f	class:fst::DeterminizerStar
OutputStateId	determinize-lattice-inl.h	/^  typedef typename Arc::StateId OutputStateId;  \/\/ same as above but distinguish$/;"	t	class:fst::LatticeDeterminizer
OutputStateId	determinize-star-inl.h	/^  typedef typename Arc::StateId OutputStateId;  \/\/ same as above but distinguish states in output Fst.$/;"	t	class:fst::DeterminizerStar
OutputSymbols	context-fst.h	/^  virtual const SymbolTable* OutputSymbols() const {$/;"	f	class:fst::ContextFst
OutputSymbolsAction	factor-inl.h	/^  MapSymbolsAction OutputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
OutputSymbolsAction	fstext-utils-inl.h	/^  MapSymbolsAction OutputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::MapInputSymbolsMapper
OutputSymbolsAction	lattice-utils.h	/^  MapSymbolsAction OutputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::LatticeToStdMapper
OutputSymbolsAction	lattice-utils.h	/^  MapSymbolsAction OutputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::StdToLatticeMapper
P_	context-fst.h	/^  int P_;$/;"	m	class:fst::ContextFstImpl
PairComparator	determinize-lattice-inl.h	/^  class PairComparator {$/;"	c	class:fst::LatticeDeterminizer
PairComparator	determinize-star-inl.h	/^  class PairComparator {$/;"	c	class:fst::DeterminizerStar
PhiCompose	fstext-utils-inl.h	/^void PhiCompose(const Fst<Arc> &fst1,$/;"	f	namespace:fst
Plus	lattice-weight.h	/^inline CompactLatticeWeightTpl<WeightType, IntType> Plus($/;"	f	namespace:fst
Plus	lattice-weight.h	/^inline LatticeWeightTpl<FloatType> Plus(const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
PreDeterminize	pre-determinize-inl.h	/^void PreDeterminize(MutableFst<Arc> *fst,$/;"	f	namespace:fst
PrecedingInputSymbolsAreSame	fstext-utils-inl.h	/^bool PrecedingInputSymbolsAreSame(bool start_is_epsilon, const Fst<Arc> &fst) {$/;"	f	namespace:fst
PrecedingInputSymbolsAreSameClass	fstext-utils-inl.h	/^bool PrecedingInputSymbolsAreSameClass(bool start_is_epsilon, const Fst<Arc> &fst, const F &f) {$/;"	f	namespace:fst
Print	fstext-utils-test.cc	/^template<class Arc> void Print(const Fst<Arc> &fst, std::string message) {$/;"	f	namespace:fst
ProcessFinal	determinize-lattice-inl.h	/^  void ProcessFinal(OutputStateId output_state) {$/;"	f	class:fst::LatticeDeterminizer
ProcessFinal	determinize-star-inl.h	/^  void ProcessFinal(const vector<Element> &closed_subset, OutputStateId state) {$/;"	f	class:fst::DeterminizerStar
ProcessState	determinize-lattice-inl.h	/^  void ProcessState(OutputStateId output_state) {$/;"	f	class:fst::LatticeDeterminizer
ProcessSubset	determinize-star-inl.h	/^  void ProcessSubset(const pair<vector<Element>*, OutputStateId> & pair) {$/;"	f	class:fst::DeterminizerStar
ProcessTransition	determinize-lattice-inl.h	/^  void ProcessTransition(OutputStateId state, Label ilabel, vector<Element> *subset) {$/;"	f	class:fst::LatticeDeterminizer
ProcessTransition	determinize-star-inl.h	/^  void ProcessTransition(OutputStateId state, Label ilabel, vector<Element> *subset) {$/;"	f	class:fst::DeterminizerStar
ProcessTransitions	determinize-lattice-inl.h	/^  void ProcessTransitions(OutputStateId output_state) {$/;"	f	class:fst::LatticeDeterminizer
ProcessTransitions	determinize-star-inl.h	/^  void ProcessTransitions(const vector<Element> &closed_subset, OutputStateId state) {$/;"	f	class:fst::DeterminizerStar
PropagateFinal	fstext-utils-inl.h	/^void PropagateFinal(typename Arc::Label phi_label,$/;"	f	namespace:fst
PropagateFinalInternal	fstext-utils-inl.h	/^void PropagateFinalInternal($/;"	f	namespace:fst
Properties	context-fst.h	/^  virtual uint64 Properties(uint64 mask, bool test) const {$/;"	f	class:fst::ContextFst
Properties	context-fst.h	/^  virtual uint64 Properties(uint64 props) const { return props; } \/\/ simple matcher that does$/;"	f	class:fst::ContextMatcher
Properties	factor-inl.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
Properties	fstext-utils-inl.h	/^  uint64 Properties(uint64 props) const {  \/\/ Not tested.$/;"	f	class:fst::MapInputSymbolsMapper
Properties	lattice-utils.h	/^  uint64 Properties(uint64 props) { return props; }$/;"	f	class:fst::LatticeToStdMapper
Properties	lattice-utils.h	/^  uint64 Properties(uint64 props) { return props; }$/;"	f	class:fst::StdToLatticeMapper
Properties	lattice-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::CompactLatticeWeightTpl
Properties	lattice-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::LatticeWeightTpl
Properties	table-matcher.h	/^  virtual uint64 Properties(uint64 props) const { return impl_->Properties(props); } \/\/ simple matcher that does$/;"	f	class:fst::TableMatcher
Properties	table-matcher.h	/^  virtual uint64 Properties(uint64 props) const { return props; } \/\/ simple matcher that does$/;"	f	class:fst::TableMatcherImpl
PushInLog	fstext-utils.h	/^void PushInLog(VectorFst<StdArc> *fst, uint32 ptype, float delta = kDelta) {$/;"	f	namespace:fst
PushSpecial	push-special.cc	/^void PushSpecial(VectorFst<StdArc> *fst, float delta) {$/;"	f	namespace:fst
PushSpecialClass	push-special.cc	/^  PushSpecialClass(VectorFst<StdArc> *fst,$/;"	f	class:fst::PushSpecialClass
PushSpecialClass	push-special.cc	/^class PushSpecialClass {$/;"	c	namespace:fst	file:
Q_	determinize-star-inl.h	/^  vector<pair<vector<Element>*, OutputStateId> > Q_;  \/\/ queue of subsets to be processed.$/;"	m	class:fst::DeterminizerStar
Quantize	lattice-weight.h	/^  CompactLatticeWeightTpl Quantize(float delta = kDelta) const {$/;"	f	class:fst::CompactLatticeWeightTpl
Quantize	lattice-weight.h	/^  LatticeWeightTpl Quantize(float delta = kDelta) const {$/;"	f	class:fst::LatticeWeightTpl
RandFst	rand-fst.h	/^template<class Arc> VectorFst<Arc>* RandFst(RandFstOptions opts = RandFstOptions() ) {$/;"	f	namespace:fst
RandFstOptions	rand-fst.h	/^  RandFstOptions() {  \/\/ Initializes the options randomly.$/;"	f	struct:fst::RandFstOptions
RandFstOptions	rand-fst.h	/^struct RandFstOptions {$/;"	s	namespace:fst
RandPairFst	rand-fst.h	/^template<class Arc> VectorFst<Arc>* RandPairFst(RandFstOptions opts = RandFstOptions() ) {$/;"	f	namespace:fst
RandomCompactLatticeWeight	lattice-weight-test.cc	/^CompactLatticeWeight RandomCompactLatticeWeight() {$/;"	f	namespace:fst
RandomLatticeWeight	lattice-weight-test.cc	/^LatticeWeight RandomLatticeWeight() {$/;"	f	namespace:fst
Read	fstext-utils.h	/^  bool Read(std::istream &is) {$/;"	f	class:fst::VectorFstTplHolder
Read	lattice-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::CompactLatticeWeightTpl
Read	lattice-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::LatticeWeightTpl
ReadFloatType	lattice-weight.h	/^  inline static void ReadFloatType(istream &strm, T &f) {$/;"	f	class:fst::LatticeWeightTpl
ReadFstKaldi	fstext-utils-inl.h	/^inline VectorFst<StdArc> *ReadFstKaldi(std::string rxfilename) {$/;"	f	namespace:fst
ReadILabelInfo	context-fst-inl.h	/^void ReadILabelInfo(std::istream &is, bool binary,$/;"	f	namespace:fst
ReadNoParen	lattice-weight.h	/^  inline istream &ReadNoParen($/;"	f	class:fst::LatticeWeightTpl
Rebuild	determinize-lattice-inl.h	/^  void Rebuild(const std::vector<const Entry*> &to_keep) {$/;"	f	class:fst::LatticeStringRepository
RebuildHelper	determinize-lattice-inl.h	/^  void RebuildHelper(const Entry *to_add, SetType *tmp_set) {$/;"	f	class:fst::LatticeStringRepository
RebuildRepository	determinize-lattice-inl.h	/^  void RebuildRepository() { \/\/ rebuild the string repository,    $/;"	f	class:fst::LatticeDeterminizer
ReduceToCommonPrefix	determinize-lattice-inl.h	/^  void ReduceToCommonPrefix(const Entry *a,$/;"	f	class:fst::LatticeStringRepository
RefCount	table-matcher.h	/^  int RefCount() const {$/;"	f	class:fst::TableMatcherImpl
RemoveAlignmentsFromCompactLattice	lattice-utils-inl.h	/^void RemoveAlignmentsFromCompactLattice($/;"	f	namespace:fst
RemoveEps	remove-eps-local-inl.h	/^  void RemoveEps(StateId s, size_t pos) {$/;"	f	class:fst::RemoveEpsLocalClass
RemoveEpsLocal	remove-eps-local-inl.h	/^void RemoveEpsLocal(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
RemoveEpsLocalClass	remove-eps-local-inl.h	/^  RemoveEpsLocalClass(MutableFst<Arc> *fst):$/;"	f	class:fst::RemoveEpsLocalClass
RemoveEpsLocalClass	remove-eps-local-inl.h	/^class RemoveEpsLocalClass {$/;"	c	namespace:fst
RemoveEpsLocalSpecial	remove-eps-local-inl.h	/^void RemoveEpsLocalSpecial(MutableFst<StdArc> *fst) {$/;"	f	namespace:fst
RemoveEpsPattern1	remove-eps-local-inl.h	/^  void RemoveEpsPattern1(StateId s, size_t pos, Arc arc) {$/;"	f	class:fst::RemoveEpsLocalClass
RemoveEpsPattern2	remove-eps-local-inl.h	/^  void RemoveEpsPattern2(StateId s, size_t pos, Arc arc) {$/;"	f	class:fst::RemoveEpsLocalClass
RemovePrefix	determinize-lattice-inl.h	/^  const Entry *RemovePrefix(const Entry *a, size_t n) {$/;"	f	class:fst::LatticeStringRepository
RemovePrefix	determinize-star-inl.h	/^  StringId RemovePrefix(StringId id, size_t prefix_len) {$/;"	f	class:fst::StringRepository
RemoveSomeInputSymbols	fstext-utils-inl.h	/^void RemoveSomeInputSymbols(const vector<I> &to_remove,$/;"	f	namespace:fst
RemoveSomeInputSymbolsMapper	factor-inl.h	/^  RemoveSomeInputSymbolsMapper(const vector<I> &to_remove):$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
RemoveSomeInputSymbolsMapper	factor-inl.h	/^class RemoveSomeInputSymbolsMapper {$/;"	c	namespace:fst
RemoveUselessArcs	fstext-utils-inl.h	/^void RemoveUselessArcs(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
RemoveWeights	fstext-utils-inl.h	/^void RemoveWeights(MutableFst<Arc> *ifst) {$/;"	f	namespace:fst
Rescale	rescale-inl.h	/^inline void Rescale(MutableFst<Arc> *fst, typename Arc::Weight rescale) {$/;"	f	namespace:fst
RescaleToStochastic	rescale-inl.h	/^inline LogWeight RescaleToStochastic(MutableFst<LogArc> *fst,$/;"	f	namespace:fst
Result	fstext-utils-inl.h	/^  typedef T Result;$/;"	t	struct:fst::IdentityFunction
Result	fstext-utils-test.cc	/^  typedef int32 Result;$/;"	t	struct:fst::TestFunctor	file:
Reverse	lattice-weight.h	/^  CompactLatticeWeightTpl<WeightType, IntType> Reverse() const {$/;"	f	class:fst::CompactLatticeWeightTpl
Reverse	lattice-weight.h	/^  LatticeWeightTpl<FloatType> Reverse() const {$/;"	f	class:fst::LatticeWeightTpl
ReverseWeight	lattice-weight.h	/^  typedef CompactLatticeWeightTpl<WeightType, IntType> ReverseWeight;$/;"	t	class:fst::CompactLatticeWeightTpl
ReverseWeight	lattice-weight.h	/^  typedef LatticeWeightTpl ReverseWeight;$/;"	t	class:fst::LatticeWeightTpl
Reweight	remove-eps-local-inl.h	/^  void Reweight(StateId s, size_t pos, Weight reweight) {$/;"	f	class:fst::RemoveEpsLocalClass
ReweightPlusDefault	remove-eps-local-inl.h	/^struct ReweightPlusDefault {$/;"	s	namespace:fst
ReweightPlusLogArc	remove-eps-local-inl.h	/^struct ReweightPlusLogArc {$/;"	s	namespace:fst
RhoCompose	fstext-utils-inl.h	/^void RhoCompose(const Fst<Arc> &fst1,$/;"	f	namespace:fst
SafeDeterminizeMinimizeWrapper	fstext-utils-inl.h	/^void SafeDeterminizeMinimizeWrapper(MutableFst<Arc> *ifst, VectorFst<Arc> *ofst, float delta) {$/;"	f	namespace:fst
SafeDeterminizeMinimizeWrapperInLog	fstext-utils-inl.h	/^void SafeDeterminizeMinimizeWrapperInLog(VectorFst<StdArc> *ifst, VectorFst<StdArc> *ofst, float delta) {$/;"	f	namespace:fst
SafeDeterminizeWrapper	fstext-utils-inl.h	/^void SafeDeterminizeWrapper(MutableFst<Arc> *ifst, MutableFst<Arc> *ofst, float delta) {$/;"	f	namespace:fst
SafeDeterminizeWrapperInLog	fstext-utils-inl.h	/^void SafeDeterminizeWrapperInLog(VectorFst<StdArc> *ifst, VectorFst<StdArc> *ofst, float delta) {$/;"	f	namespace:fst
ScaleLattice	lattice-utils-inl.h	/^void ScaleLattice($/;"	f	namespace:fst
ScaleTupleWeight	lattice-weight.h	/^                  TropicalWeightTpl<FloatType> > ScaleTupleWeight($/;"	f	namespace:fst
ScaleTupleWeight	lattice-weight.h	/^inline CompactLatticeWeightTpl<Weight, IntType> ScaleTupleWeight($/;"	f	namespace:fst
ScaleTupleWeight	lattice-weight.h	/^inline LatticeWeightTpl<FloatType> ScaleTupleWeight($/;"	f	namespace:fst
SeqOfId	determinize-star-inl.h	/^  void SeqOfId(StringId id, vector<Label> *v) {$/;"	f	class:fst::StringRepository
SetArc	remove-eps-local-inl.h	/^  inline void SetArc(StateId s, size_t pos, const Arc &arc) {$/;"	f	class:fst::RemoveEpsLocalClass
SetState	context-fst.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ContextMatcher
SetState	table-matcher.h	/^  void SetState(StateId s) { return impl_->SetState(s); }$/;"	f	class:fst::TableMatcher
SetState	table-matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::TableMatcherImpl
SetState_	context-fst.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::ContextMatcher
SetState_	table-matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::TableMatcherImpl
SetState_	table-matcher.h	/^  virtual void SetState_(StateId s) { impl_->SetState(s); }$/;"	f	class:fst::TableMatcher
SetString	lattice-weight.h	/^  void SetString(const vector<IntType> &s) { string_ = s; }$/;"	f	class:fst::CompactLatticeWeightTpl
SetType	determinize-lattice-inl.h	/^  typedef unordered_set<const Entry*, EntryKey, EntryEqual> SetType;$/;"	t	class:fst::LatticeStringRepository
SetValue1	lattice-weight.h	/^  inline void SetValue1(T f) { value1_ = f; }$/;"	f	class:fst::LatticeWeightTpl
SetValue2	lattice-weight.h	/^  inline void SetValue2(T f) { value2_ = f; }$/;"	f	class:fst::LatticeWeightTpl
SetWeight	lattice-weight.h	/^  void SetWeight(const W &w) { weight_ = w; }$/;"	f	class:fst::CompactLatticeWeightTpl
Size	determinize-lattice-inl.h	/^  inline size_t Size(const Entry *entry) const {$/;"	f	class:fst::LatticeStringRepository
Start	context-fst-inl.h	/^typename ContextFstImpl<Arc, LabelT>::StateId ContextFstImpl<Arc, LabelT>::Start() {$/;"	f	class:fst::ContextFstImpl
Start	context-fst.h	/^  virtual StateId Start() const { return impl_->Start(); }$/;"	f	class:fst::ContextFst
Start	deterministic-fst.h	/^  StateId Start() { return fst_.Start(); }$/;"	f	class:fst::BackoffDeterministicOnDemandFst
Start	deterministic-fst.h	/^  virtual StateId Start() { return fst_->Start(); }$/;"	f	class:fst::CacheDeterministicOnDemandFst
Start	deterministic-fst.h	/^  virtual StateId Start() { return start_state_; }$/;"	f	class:fst::ComposeDeterministicOnDemandFst
Start	deterministic-fst.h	/^  virtual StateId Start() { return start_state_; }$/;"	f	class:fst::LmExampleDeterministicOnDemandFst
Start	trivial-factor-weight.h	/^  StateId Start() {$/;"	f	class:fst::TrivialFactorWeightFstImpl
State	context-fst.h	/^  typedef CacheState<Arc> State;$/;"	t	class:fst::ContextFst
State	trivial-factor-weight.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::TrivialFactorWeightFst
StateId	context-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	context-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ContextFst
StateId	context-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ContextFstImpl
StateId	context-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ContextMatcher
StateId	deterministic-fst-test.cc	/^typedef fst::StdArc::StateId StateId;$/;"	t	namespace:fst	file:
StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::BackoffDeterministicOnDemandFst
StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheDeterministicOnDemandFst
StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ComposeDeterministicOnDemandFst
StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::DeterministicOnDemandFst
StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LmExampleDeterministicOnDemandFst
StateId	determinize-lattice-inl.h	/^  typedef typename Arc::StateId StateId;  \/\/ use this when we don't know if it's input or output.$/;"	t	class:fst::LatticeDeterminizer
StateId	factor.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::DfsOrderVisitor
StateId	fstext-utils.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::VectorFstTplHolder
StateId	push-special.cc	/^  typedef Arc::StateId StateId;$/;"	t	class:fst::PushSpecialClass	file:
StateId	remove-eps-local-inl.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::RemoveEpsLocalClass
StateId	table-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::TableMatcher
StateId	table-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::TableMatcherImpl
StateId	trivial-factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	trivial-factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::TrivialFactorWeightFst
StateId	trivial-factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::TrivialFactorWeightFstImpl
StateIterator	context-fst.h	/^  explicit StateIterator(const ContextFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	context-fst.h	/^class StateIterator< ContextFst<A> >$/;"	c	namespace:fst
StateIterator	trivial-factor-weight.h	/^  explicit StateIterator(const TrivialFactorWeightFst<A, F> &fst)$/;"	f	class:fst::StateIterator
StateIterator	trivial-factor-weight.h	/^class StateIterator< TrivialFactorWeightFst<A, F> >$/;"	c	namespace:fst
StatePropertiesEnum	factor.h	/^enum  StatePropertiesEnum$/;"	g	namespace:fst
StatePropertiesType	factor.h	/^typedef unsigned char StatePropertiesType;$/;"	t	namespace:fst
StdArc	deterministic-fst-test.cc	/^typedef fst::StdArc          StdArc;$/;"	t	namespace:fst	file:
StdToLatticeMapper	lattice-utils.h	/^class StdToLatticeMapper {$/;"	c	namespace:fst
StdVectorFst	deterministic-fst-test.cc	/^typedef fst::StdVectorFst    StdVectorFst;$/;"	t	namespace:fst	file:
StrToWeight	fstext-utils.h	/^  static bool StrToWeight(const std::string &s, bool allow_zero, Weight *w) {$/;"	f	class:fst::VectorFstTplHolder
String	lattice-weight.h	/^  const vector<IntType> &String() const { return string_; }$/;"	f	class:fst::CompactLatticeWeightTpl
StringId	determinize-lattice-inl.h	/^  typedef const typename StringRepositoryType::Entry* StringId;$/;"	t	class:fst::LatticeDeterminizer
StringId	determinize-star-inl.h	/^  typedef typename Arc::Label StringId;  \/\/ Id type used in the StringRepository$/;"	t	class:fst::DeterminizerStar
StringRepository	determinize-star-inl.h	/^  StringRepository() {$/;"	f	class:fst::StringRepository
StringRepository	determinize-star-inl.h	/^template<class Label, class StringId> class StringRepository {$/;"	c	namespace:fst
StringRepositoryType	determinize-lattice-inl.h	/^  typedef LatticeStringRepository<IntType> StringRepositoryType;$/;"	t	class:fst::LatticeDeterminizer
StringRepositoryType	determinize-star-inl.h	/^  typedef StringRepository<Label, StringId> StringRepositoryType;$/;"	t	class:fst::DeterminizerStar
SubsetEqual	determinize-lattice-inl.h	/^    SubsetEqual(): delta_(kDelta) {}$/;"	f	class:fst::LatticeDeterminizer::SubsetEqual
SubsetEqual	determinize-lattice-inl.h	/^    SubsetEqual(float delta): delta_(delta) {}$/;"	f	class:fst::LatticeDeterminizer::SubsetEqual
SubsetEqual	determinize-lattice-inl.h	/^  class SubsetEqual {$/;"	c	class:fst::LatticeDeterminizer
SubsetEqual	determinize-star-inl.h	/^    SubsetEqual(): delta_(kDelta) {}$/;"	f	class:fst::DeterminizerStar::SubsetEqual
SubsetEqual	determinize-star-inl.h	/^    SubsetEqual(float delta): delta_(delta) {}$/;"	f	class:fst::DeterminizerStar::SubsetEqual
SubsetEqual	determinize-star-inl.h	/^  class SubsetEqual {$/;"	c	class:fst::DeterminizerStar
SubsetEqualStates	determinize-lattice-inl.h	/^  class SubsetEqualStates {$/;"	c	class:fst::LatticeDeterminizer
SubsetEqualStates	determinize-star-inl.h	/^  class SubsetEqualStates {$/;"	c	class:fst::DeterminizerStar
SubsetHash	determinize-star-inl.h	/^  typedef unordered_map<const vector<Element>*, OutputStateId, SubsetKey, SubsetEqual> SubsetHash;$/;"	t	class:fst::DeterminizerStar
SubsetKey	determinize-lattice-inl.h	/^  class SubsetKey {$/;"	c	class:fst::LatticeDeterminizer
SubsetKey	determinize-star-inl.h	/^  class SubsetKey {$/;"	c	class:fst::DeterminizerStar
SubsetToStateId	determinize-star-inl.h	/^  OutputStateId SubsetToStateId(const vector<Element> &subset) {  \/\/ may add the subset to the queue.$/;"	f	class:fst::DeterminizerStar
Successor	determinize-lattice-inl.h	/^  const Entry *Successor(const Entry *parent, IntType i) {$/;"	f	class:fst::LatticeStringRepository
T	fstext-utils.h	/^  typedef VectorFst<Arc> T;$/;"	t	class:fst::VectorFstTplHolder
T	lattice-weight.h	/^  typedef FloatType T; \/\/ normally float.$/;"	t	class:fst::LatticeWeightTpl
TableCompose	table-matcher.h	/^void TableCompose(const Fst<Arc> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
TableComposeCache	table-matcher.h	/^  TableComposeCache(const TableComposeOptions &opts = TableComposeOptions()): matcher (NULL), opts(opts) {}$/;"	f	struct:fst::TableComposeCache
TableComposeCache	table-matcher.h	/^struct TableComposeCache {$/;"	s	namespace:fst
TableComposeOptions	table-matcher.h	/^  TableComposeOptions() : connect(true), filter_type(SEQUENCE_FILTER),$/;"	f	struct:fst::TableComposeOptions
TableComposeOptions	table-matcher.h	/^  explicit TableComposeOptions(const TableMatcherOptions &mo,$/;"	f	struct:fst::TableComposeOptions
TableComposeOptions	table-matcher.h	/^struct TableComposeOptions: public TableMatcherOptions {$/;"	s	namespace:fst
TableMatcher	table-matcher.h	/^  TableMatcher(const FST &fst, MatchType match_type,$/;"	f	class:fst::TableMatcher
TableMatcher	table-matcher.h	/^  TableMatcher(const TableMatcher<FST, BackoffMatcher> &matcher, bool safe):$/;"	f	class:fst::TableMatcher
TableMatcher	table-matcher.h	/^class TableMatcher : public MatcherBase<typename F::Arc> {$/;"	c	namespace:fst
TableMatcherImpl	table-matcher.h	/^  TableMatcherImpl(const FST &fst, MatchType match_type,$/;"	f	class:fst::TableMatcherImpl
TableMatcherImpl	table-matcher.h	/^class TableMatcherImpl : public MatcherBase<typename F::Arc> {$/;"	c	namespace:fst
TableMatcherOptions	table-matcher.h	/^  TableMatcherOptions(): table_ratio(0.25), min_table_size(4) { }$/;"	f	struct:fst::TableMatcherOptions
TableMatcherOptions	table-matcher.h	/^struct TableMatcherOptions {$/;"	s	namespace:fst
TempArc	determinize-lattice-inl.h	/^  struct TempArc {$/;"	s	class:fst::LatticeDeterminizer
TempArc	determinize-star-inl.h	/^  struct TempArc {$/;"	s	class:fst::DeterminizerStar
TestAcceptorMinimize	fstext-utils-test.cc	/^template<class Arc>  void TestAcceptorMinimize() {$/;"	f	namespace:fst
TestAccuracy	push-special.cc	/^  double TestAccuracy() { \/\/ returns the error (the difference$/;"	f	class:fst::PushSpecialClass	file:
TestAddSelfLoops	pre-determinize-test.cc	/^template<class Arc>  void TestAddSelfLoops() {$/;"	f	namespace:fst
TestBackoffAndCache	deterministic-fst-test.cc	/^void TestBackoffAndCache() {$/;"	f	namespace:fst
TestCompose	deterministic-fst-test.cc	/^void TestCompose() {$/;"	f	namespace:fst
TestComputeTotalWeight	rescale-test.cc	/^template<class Arc> void TestComputeTotalWeight() {$/;"	f	namespace:fst
TestContextFst	context-fst-test.cc	/^template<class Arc> static void TestContextFst(bool verbose, bool use_matcher) {$/;"	f	namespace:fst
TestConvert	lattice-utils-test.cc	/^template<class Weight, class Int> void TestConvert(bool invert) {$/;"	f	namespace:fst
TestConvert2	lattice-utils-test.cc	/^template<class Int> void TestConvert2() {$/;"	f	namespace:fst
TestConvertPair	lattice-utils-test.cc	/^template<class Weight, class Int> void TestConvertPair(bool invert) {$/;"	f	namespace:fst
TestDeterminize	determinize-star-test.cc	/^template<class Arc>  void TestDeterminize() {$/;"	f	namespace:fst
TestDeterminize2	determinize-star-test.cc	/^template<class Arc>  void TestDeterminize2() {$/;"	f	namespace:fst
TestDeterminizeGeneral	determinize-star-test.cc	/^template<class Arc> void TestDeterminizeGeneral() {$/;"	f	namespace:fst
TestDeterminizeLattice	determinize-lattice-test.cc	/^template<class Arc> void TestDeterminizeLattice() {$/;"	f	namespace:fst
TestDeterminizeLattice2	determinize-lattice-test.cc	/^template<class Arc> void TestDeterminizeLattice2() {$/;"	f	namespace:fst
TestDeterminizeStarInLog	fstext-utils-test.cc	/^template<class Arc>  void TestDeterminizeStarInLog() {$/;"	f	namespace:fst
TestEnsureEpsilonProperty	epsilon-property-test.cc	/^void TestEnsureEpsilonProperty() {$/;"	f	namespace:fst
TestEqualAlign	fstext-utils-test.cc	/^void TestEqualAlign() {$/;"	f	namespace:fst
TestFactor	factor-test.cc	/^template<class Arc> static void TestFactor() {$/;"	f	namespace:fst
TestFactor	trivial-factor-weight-test.cc	/^template<class Arc>  void TestFactor() {$/;"	f	namespace:fst
TestFunctor	fstext-utils-test.cc	/^struct TestFunctor {$/;"	s	namespace:fst	file:
TestLatticeStringRepository	determinize-lattice-test.cc	/^void TestLatticeStringRepository() {$/;"	f	namespace:fst
TestMakeLinearAcceptor	fstext-utils-test.cc	/^void TestMakeLinearAcceptor() {$/;"	f	namespace:fst
TestMakeLoopFst	fstext-utils-test.cc	/^template<class Arc>  void TestMakeLoopFst() {$/;"	f	namespace:fst
TestMakeSymbolsSame	fstext-utils-test.cc	/^template<class Arc>  void TestMakeSymbolsSame() {$/;"	f	namespace:fst
TestMakeSymbolsSameClass	fstext-utils-test.cc	/^template<class Arc>  void TestMakeSymbolsSameClass() {$/;"	f	namespace:fst
TestMinimize	determinize-star-test.cc	/^template<class Arc>  void TestMinimize() {$/;"	f	namespace:fst
TestPreDeterminize	pre-determinize-test.cc	/^template<class Arc>  void TestPreDeterminize() {$/;"	f	namespace:fst
TestPush	determinize-star-test.cc	/^template<class Arc>  void TestPush() {$/;"	f	namespace:fst
TestPushInLog	fstext-utils-test.cc	/^void TestPushInLog() {  \/\/ also tests SafeDeterminizeMinimizeWrapper().$/;"	f	namespace:fst
TestPushSpecial	push-special-test.cc	/^static void TestPushSpecial() {$/;"	f	namespace:fst
TestRemoveEpsLocal	remove-eps-local-test.cc	/^template<class Arc> static void TestRemoveEpsLocal() {$/;"	f	namespace:fst
TestRemoveEpsLocalSpecial	remove-eps-local-test.cc	/^static void TestRemoveEpsLocalSpecial() {$/;"	f	namespace:fst
TestRemoveUselessArcs	fstext-utils-test.cc	/^void TestRemoveUselessArcs() {$/;"	f	namespace:fst
TestRescaleToStochastic	rescale-test.cc	/^void TestRescaleToStochastic() {$/;"	f	namespace:fst
TestSafeDeterminizeWrapper	fstext-utils-test.cc	/^template<class Arc>  void TestSafeDeterminizeWrapper() {  \/\/ also tests SafeDeterminizeMinimizeWrapper().$/;"	f	namespace:fst
TestScalePair	lattice-utils-test.cc	/^template<class Weight, class Int> void TestScalePair(bool invert) {$/;"	f	namespace:fst
TestShortestPath	lattice-utils-test.cc	/^template<class Weight, class Int> void TestShortestPath() {$/;"	f	namespace:fst
TestStringRepository	determinize-star-test.cc	/^template<class Arc, class inttype> void TestStringRepository() {$/;"	f	namespace:fst
TestStringRepository	trivial-factor-weight-test.cc	/^template<class Arc, class inttype> void TestStringRepository() {$/;"	f	namespace:fst
TestTableMatcher	table-matcher-test.cc	/^template<class Arc>  void TestTableMatcher(bool connect, bool left) {$/;"	f	namespace:fst
TestTableMatcherCacheLeft	table-matcher-test.cc	/^template<class Arc>  void TestTableMatcherCacheLeft(bool connect) {$/;"	f	namespace:fst
TestTableMatcherCacheRight	table-matcher-test.cc	/^template<class Arc>  void TestTableMatcherCacheRight(bool connect) {$/;"	f	namespace:fst
Times	lattice-weight.h	/^inline CompactLatticeWeightTpl<WeightType, IntType> Times($/;"	f	namespace:fst
Times	lattice-weight.h	/^inline LatticeWeightTpl<FloatType> Times(const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
TreeArc	factor.h	/^  bool TreeArc(StateId, const Arc&) { return true; }$/;"	f	class:fst::DfsOrderVisitor
TrivialFactorWeightFst	trivial-factor-weight.h	/^  TrivialFactorWeightFst(const Fst<A> &fst)$/;"	f	class:fst::TrivialFactorWeightFst
TrivialFactorWeightFst	trivial-factor-weight.h	/^  TrivialFactorWeightFst(const Fst<A> &fst,  const TrivialFactorWeightOptions<A> &opts)$/;"	f	class:fst::TrivialFactorWeightFst
TrivialFactorWeightFst	trivial-factor-weight.h	/^  TrivialFactorWeightFst(const TrivialFactorWeightFst<A, F> &fst, bool copy)$/;"	f	class:fst::TrivialFactorWeightFst
TrivialFactorWeightFst	trivial-factor-weight.h	/^class TrivialFactorWeightFst : public ImplToFst< TrivialFactorWeightFstImpl<A, F> > {$/;"	c	namespace:fst
TrivialFactorWeightFstImpl	trivial-factor-weight.h	/^  TrivialFactorWeightFstImpl(const Fst<A> &fst, const TrivialFactorWeightOptions<A> &opts)$/;"	f	class:fst::TrivialFactorWeightFstImpl
TrivialFactorWeightFstImpl	trivial-factor-weight.h	/^  TrivialFactorWeightFstImpl(const TrivialFactorWeightFstImpl<A, F> &impl)$/;"	f	class:fst::TrivialFactorWeightFstImpl
TrivialFactorWeightFstImpl	trivial-factor-weight.h	/^class TrivialFactorWeightFstImpl$/;"	c	namespace:fst
TrivialFactorWeightOptions	trivial-factor-weight.h	/^  TrivialFactorWeightOptions(): delta(kDelta), extra_ilabel(0), extra_olabel(0) {}$/;"	f	struct:fst::TrivialFactorWeightOptions
TrivialFactorWeightOptions	trivial-factor-weight.h	/^  TrivialFactorWeightOptions(const CacheOptions &opts, float d,$/;"	f	struct:fst::TrivialFactorWeightOptions
TrivialFactorWeightOptions	trivial-factor-weight.h	/^  explicit TrivialFactorWeightOptions($/;"	f	struct:fst::TrivialFactorWeightOptions
TrivialFactorWeightOptions	trivial-factor-weight.h	/^struct TrivialFactorWeightOptions : CacheOptions {$/;"	s	namespace:fst
Type	context-fst.h	/^  virtual MatchType Type(bool test) const {$/;"	f	class:fst::ContextMatcher
Type	context-fst.h	/^  virtual const string& Type() const { return impl_->Type(); }$/;"	f	class:fst::ContextFst
Type	lattice-weight.h	/^  static const string &Type() {$/;"	f	class:fst::CompactLatticeWeightTpl
Type	lattice-weight.h	/^  static const string &Type() {$/;"	f	class:fst::LatticeWeightTpl
Type	table-matcher.h	/^  virtual MatchType Type(bool test) const { return impl_->Type(test);  }$/;"	f	class:fst::TableMatcher
Type	table-matcher.h	/^  virtual MatchType Type(bool test) const {$/;"	f	class:fst::TableMatcherImpl
Value	context-fst.h	/^  const Arc& Value() const {$/;"	f	class:fst::ContextMatcher
Value	fstext-utils.h	/^  const T &Value() {$/;"	f	class:fst::VectorFstTplHolder
Value	table-matcher.h	/^  const Arc &Value() {  return impl_->Value(); }$/;"	f	class:fst::TableMatcher
Value	table-matcher.h	/^  const Arc &Value() {$/;"	f	class:fst::TableMatcherImpl
Value	table-matcher.h	/^  const Arc& Value() const { return impl_->Value(); }$/;"	f	class:fst::TableMatcher
Value	table-matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::TableMatcherImpl
Value1	lattice-weight.h	/^  inline T Value1() const { return value1_; }$/;"	f	class:fst::LatticeWeightTpl
Value2	lattice-weight.h	/^  inline T Value2() const { return value2_; }$/;"	f	class:fst::LatticeWeightTpl
Value_	context-fst.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::ContextMatcher
Value_	table-matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::TableMatcherImpl
Value_	table-matcher.h	/^  virtual const Arc& Value_() const { return impl_->Value(); }$/;"	f	class:fst::TableMatcher
VectorEqual	determinize-star-inl.h	/^  class VectorEqual {  \/\/ Equality-operator function object.$/;"	c	class:fst::StringRepository
VectorFstHolder	fstext-utils.h	/^typedef VectorFstTplHolder<StdArc> VectorFstHolder;$/;"	t	namespace:fst
VectorFstTplHolder	fstext-utils.h	/^  VectorFstTplHolder(): t_(NULL) { }$/;"	f	class:fst::VectorFstTplHolder
VectorFstTplHolder	fstext-utils.h	/^class VectorFstTplHolder {$/;"	c	namespace:fst
VectorKey	determinize-star-inl.h	/^  class VectorKey { \/\/ Hash function object.$/;"	c	class:fst::StringRepository
VectorToLabelIter	context-fst.h	/^  typedef typename VectorToLabelType::const_iterator VectorToLabelIter;$/;"	t	class:fst::ContextFstImpl
VectorToLabelType	context-fst.h	/^                        Label, kaldi::VectorHasher<LabelT> > VectorToLabelType;$/;"	t	class:fst::ContextFstImpl
VectorToStateIter	context-fst.h	/^  typedef typename VectorToStateType::const_iterator VectorToStateIter;$/;"	t	class:fst::ContextFstImpl
VectorToStateType	context-fst.h	/^                        StateId, kaldi::VectorHasher<LabelT> > VectorToStateType;$/;"	t	class:fst::ContextFstImpl
W	lattice-weight.h	/^  typedef WeightType W;$/;"	t	class:fst::CompactLatticeWeightTpl
WalkSinglePath	deterministic-fst-test.cc	/^Weight WalkSinglePath(StdVectorFst *ifst, DeterministicOnDemandFst<StdArc> *dfst) {$/;"	f	namespace:fst
Weight	context-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ContextFst
Weight	context-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ContextFstImpl
Weight	context-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ContextMatcher
Weight	deterministic-fst-test.cc	/^typedef fst::StdArc::Weight  Weight;$/;"	t	namespace:fst	file:
Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::BackoffDeterministicOnDemandFst
Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::CacheDeterministicOnDemandFst
Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ComposeDeterministicOnDemandFst
Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::DeterministicOnDemandFst
Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LmExampleDeterministicOnDemandFst
Weight	determinize-star-inl.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::DeterminizerStar
Weight	fstext-utils.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::VectorFstTplHolder
Weight	lattice-weight.h	/^  const W &Weight() const { return weight_; }$/;"	f	class:fst::CompactLatticeWeightTpl
Weight	lattice-weight.h	/^  typedef CompactLatticeWeightTpl<BaseWeightType, IntType> Weight;$/;"	t	class:fst::CompactLatticeWeightCommonDivisorTpl
Weight	lattice-weight.h	/^  typedef CompactLatticeWeightTpl<LatticeWeightTpl<FloatType>, IntType> Weight;$/;"	t	class:fst::NaturalLess
Weight	lattice-weight.h	/^  typedef LatticeWeightTpl<FloatType> Weight;$/;"	t	class:fst::NaturalLess
Weight	push-special.cc	/^  typedef Arc::Weight Weight;$/;"	t	class:fst::PushSpecialClass	file:
Weight	remove-eps-local-inl.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::RemoveEpsLocalClass
Weight	table-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::TableMatcher
Weight	table-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::TableMatcherImpl
Weight	trivial-factor-weight.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::TrivialFactorWeightFst
Weight	trivial-factor-weight.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::TrivialFactorWeightFstImpl
Write	fstext-utils.h	/^  static bool Write(std::ostream &os, bool binary, const T &t) {$/;"	f	class:fst::VectorFstTplHolder
Write	lattice-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::CompactLatticeWeightTpl
Write	lattice-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::LatticeWeightTpl
WriteFloatType	lattice-weight.h	/^  inline static void WriteFloatType(ostream &strm, const T &f) {$/;"	f	class:fst::LatticeWeightTpl
WriteFstKaldi	fstext-utils-inl.h	/^inline void WriteFstKaldi(const VectorFst<StdArc> &fst,$/;"	f	namespace:fst
WriteILabelInfo	context-fst-inl.h	/^void WriteILabelInfo(std::ostream &os, bool binary,$/;"	f	namespace:fst
Zero	lattice-weight.h	/^  static const CompactLatticeWeightTpl<WeightType, IntType> Zero() {$/;"	f	class:fst::CompactLatticeWeightTpl
Zero	lattice-weight.h	/^  static const LatticeWeightTpl Zero() {$/;"	f	class:fst::LatticeWeightTpl
acyclic	rand-fst.h	/^  bool acyclic;$/;"	m	struct:fst::RandFstOptions
aiter_	table-matcher.h	/^  ArcIterator<FST> *aiter_;$/;"	m	class:fst::TableMatcherImpl
all_elems_tmp_	determinize-lattice-inl.h	/^  vector<pair<Label, Element> > all_elems_tmp_; \/\/ temporary vector used in ProcessTransitions.$/;"	m	class:fst::LatticeDeterminizer
allow_empty	rand-fst.h	/^  bool allow_empty;$/;"	m	struct:fst::RandFstOptions
arc_	context-fst.h	/^  Arc arc_;                       \/\/ Current arc.$/;"	m	class:fst::ContextMatcher
backoff_matcher_	table-matcher.h	/^  BackoffMatcher backoff_matcher_;$/;"	m	class:fst::TableMatcherImpl
bos_symbol_	deterministic-fst.h	/^  Label bos_symbol_; \/\/ beginning of sentence symbol$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
cached_arcs_	deterministic-fst.h	/^  std::vector<std::pair<StateId, Arc> > cached_arcs_;$/;"	m	class:fst::CacheDeterministicOnDemandFst
connect	table-matcher.h	/^  bool connect;  \/\/ Connect output$/;"	m	struct:fst::TableComposeOptions
current_loop_	context-fst.h	/^  bool current_loop_;             \/\/ Current arc is the implicit loop$/;"	m	class:fst::ContextMatcher
current_loop_	table-matcher.h	/^  bool current_loop_;$/;"	m	class:fst::TableMatcherImpl
delta	determinize-lattice.h	/^  float delta; \/\/ A small offset used to measure equality of weights.$/;"	m	struct:fst::DeterminizeLatticeOptions
delta	trivial-factor-weight.h	/^  float delta;$/;"	m	struct:fst::TrivialFactorWeightOptions
delta_	determinize-lattice-inl.h	/^    float delta_;$/;"	m	class:fst::LatticeDeterminizer::SubsetEqual
delta_	determinize-star-inl.h	/^    float delta_;$/;"	m	class:fst::DeterminizerStar::SubsetEqual
delta_	determinize-star-inl.h	/^  float delta_;$/;"	m	class:fst::DeterminizerStar
delta_	trivial-factor-weight.h	/^  float delta_;$/;"	m	class:fst::TrivialFactorWeightFstImpl
determinized_	determinize-lattice-inl.h	/^  bool determinized_; \/\/ set to true when user called Determinize(); used to make$/;"	m	class:fst::LatticeDeterminizer
determinized_	determinize-star-inl.h	/^  bool determinized_; \/\/ used to check usage.$/;"	m	class:fst::DeterminizerStar
disambig_syms_	context-fst.h	/^  kaldi::ConstIntegerSet<Label> disambig_syms_;$/;"	m	class:fst::ContextFstImpl
element_map_	trivial-factor-weight.h	/^  ElementMap element_map_;    \/\/ mapping Elements to Fst state$/;"	m	class:fst::TrivialFactorWeightFstImpl
elements_	trivial-factor-weight.h	/^  vector<Element> elements_;  \/\/ mapping Fst state to Elements$/;"	m	class:fst::TrivialFactorWeightFstImpl
eos_symbol_	deterministic-fst.h	/^  Label eos_symbol_; \/\/ end of sentence symbol.$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
equal_	determinize-lattice-inl.h	/^  SubsetEqual equal_;  \/\/ object that compares subsets-- only data member is delta_.$/;"	m	class:fst::LatticeDeterminizer
equal_	determinize-star-inl.h	/^  SubsetEqual equal_;  \/\/ object that compares subsets-- only data member is delta_.$/;"	m	class:fst::DeterminizerStar
extra_ilabel	trivial-factor-weight.h	/^  Label extra_ilabel;  \/\/ input label of extra arcs$/;"	m	struct:fst::TrivialFactorWeightOptions
extra_ilabel_	trivial-factor-weight.h	/^  Label extra_ilabel_;        \/\/ ilabel of arc created when factoring final w's$/;"	m	class:fst::TrivialFactorWeightFstImpl
extra_olabel	trivial-factor-weight.h	/^  Label extra_olabel;  \/\/ output label of extra arcs$/;"	m	struct:fst::TrivialFactorWeightOptions
extra_olabel_	trivial-factor-weight.h	/^  Label extra_olabel_;        \/\/ olabel of arc created when factoring final w's$/;"	m	class:fst::TrivialFactorWeightFstImpl
filter_type	table-matcher.h	/^  ComposeFilter filter_type;  \/\/ Which pre-defined filter to use$/;"	m	struct:fst::TableComposeOptions
fst	context-fst-inl.h	/^namespace fst {$/;"	n
fst	context-fst-test.cc	/^namespace fst$/;"	n	file:
fst	context-fst.h	/^namespace fst {$/;"	n
fst	deterministic-fst-inl.h	/^namespace fst {$/;"	n
fst	deterministic-fst-test.cc	/^namespace fst {$/;"	n	file:
fst	deterministic-fst.h	/^namespace fst {$/;"	n
fst	determinize-lattice-inl.h	/^namespace fst {$/;"	n
fst	determinize-lattice-test.cc	/^namespace fst {$/;"	n	file:
fst	determinize-lattice.h	/^namespace fst {$/;"	n
fst	determinize-star-inl.h	/^namespace fst {$/;"	n
fst	determinize-star-test.cc	/^namespace fst$/;"	n	file:
fst	determinize-star.h	/^namespace fst {$/;"	n
fst	epsilon-property-inl.h	/^namespace fst {$/;"	n
fst	epsilon-property-test.cc	/^namespace fst {$/;"	n	file:
fst	epsilon-property.h	/^namespace fst {$/;"	n
fst	factor-inl.h	/^namespace fst {$/;"	n
fst	factor-test.cc	/^namespace fst$/;"	n	file:
fst	factor.h	/^namespace fst {$/;"	n
fst	fstext-utils-inl.h	/^namespace fst {$/;"	n
fst	fstext-utils-test.cc	/^namespace fst$/;"	n	file:
fst	fstext-utils.h	/^namespace fst {$/;"	n
fst	lattice-utils-inl.h	/^namespace fst {$/;"	n
fst	lattice-utils-test.cc	/^namespace fst {$/;"	n	file:
fst	lattice-utils.h	/^namespace fst {$/;"	n
fst	lattice-weight-test.cc	/^namespace fst {$/;"	n	file:
fst	lattice-weight.h	/^namespace fst {$/;"	n
fst	pre-determinize-inl.h	/^namespace fst {$/;"	n
fst	pre-determinize-test.cc	/^namespace fst$/;"	n	file:
fst	pre-determinize.h	/^namespace fst {$/;"	n
fst	push-special-test.cc	/^namespace fst$/;"	n	file:
fst	push-special.cc	/^namespace fst {$/;"	n	file:
fst	push-special.h	/^namespace fst {$/;"	n
fst	rand-fst.h	/^namespace fst {$/;"	n
fst	remap-leaves.h	/^namespace fst {$/;"	n
fst	remove-eps-local-inl.h	/^namespace fst {$/;"	n
fst	remove-eps-local-test.cc	/^namespace fst$/;"	n	file:
fst	remove-eps-local.h	/^namespace fst {$/;"	n
fst	rescale-inl.h	/^namespace fst {$/;"	n
fst	rescale-test.cc	/^namespace fst$/;"	n	file:
fst	rescale.h	/^namespace fst {$/;"	n
fst	table-matcher-test.cc	/^namespace fst{$/;"	n	file:
fst	table-matcher.h	/^namespace fst {$/;"	n
fst	trivial-factor-weight-test.cc	/^namespace fst$/;"	n	file:
fst	trivial-factor-weight.h	/^namespace fst {$/;"	n
fst1_	deterministic-fst.h	/^  DeterministicOnDemandFst<Arc> *fst1_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
fst2_	deterministic-fst.h	/^  DeterministicOnDemandFst<Arc> *fst2_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
fst::AcousticLatticeScale	lattice-utils.h	/^inline vector<vector<double> > AcousticLatticeScale(double acwt) {$/;"	f	namespace:fst
fst::AddSelfLoops	pre-determinize-inl.h	/^template<class Arc> void AddSelfLoops(MutableFst<Arc> *fst, vector<typename Arc::Label> &isyms,$/;"	f	namespace:fst
fst::AddSubsequentialLoop	context-fst-inl.h	/^void AddSubsequentialLoop(typename Arc::Label subseq_symbol,$/;"	f	namespace:fst
fst::ApplyProbabilityScale	fstext-utils-inl.h	/^void ApplyProbabilityScale(float scale, MutableFst<Arc> *fst) {$/;"	f	namespace:fst
fst::ApproxEqual	lattice-weight.h	/^inline bool ApproxEqual(const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
fst::ApproxEqual	lattice-weight.h	/^inline bool ApproxEqual(const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
fst::ArcIterator	context-fst.h	/^class ArcIterator< ContextFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	trivial-factor-weight.h	/^class ArcIterator< TrivialFactorWeightFst<A, F> >$/;"	c	namespace:fst
fst::ArcIterator::ArcIterator	context-fst.h	/^  ArcIterator(const ContextFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	trivial-factor-weight.h	/^  ArcIterator(const TrivialFactorWeightFst<A, F> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::StateId	context-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	trivial-factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::BackoffDeterministicOnDemandFst	deterministic-fst.h	/^class BackoffDeterministicOnDemandFst: public DeterministicOnDemandFst<Arc> {$/;"	c	namespace:fst
fst::BackoffDeterministicOnDemandFst::BackoffDeterministicOnDemandFst	deterministic-fst-inl.h	/^BackoffDeterministicOnDemandFst<Arc>::BackoffDeterministicOnDemandFst($/;"	f	class:fst::BackoffDeterministicOnDemandFst
fst::BackoffDeterministicOnDemandFst::Final	deterministic-fst-inl.h	/^typename Arc::Weight BackoffDeterministicOnDemandFst<Arc>::Final(StateId state) {$/;"	f	class:fst::BackoffDeterministicOnDemandFst
fst::BackoffDeterministicOnDemandFst::GetArc	deterministic-fst-inl.h	/^bool BackoffDeterministicOnDemandFst<Arc>::GetArc($/;"	f	class:fst::BackoffDeterministicOnDemandFst
fst::BackoffDeterministicOnDemandFst::GetBackoffState	deterministic-fst-inl.h	/^BackoffDeterministicOnDemandFst<Arc>::GetBackoffState(StateId s,$/;"	f	class:fst::BackoffDeterministicOnDemandFst
fst::BackoffDeterministicOnDemandFst::Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::BackoffDeterministicOnDemandFst
fst::BackoffDeterministicOnDemandFst::Start	deterministic-fst.h	/^  StateId Start() { return fst_.Start(); }$/;"	f	class:fst::BackoffDeterministicOnDemandFst
fst::BackoffDeterministicOnDemandFst::StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::BackoffDeterministicOnDemandFst
fst::BackoffDeterministicOnDemandFst::Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::BackoffDeterministicOnDemandFst
fst::BackoffDeterministicOnDemandFst::fst_	deterministic-fst.h	/^  const Fst<Arc> &fst_;$/;"	m	class:fst::BackoffDeterministicOnDemandFst
fst::BaseFloat	lattice-weight-test.cc	/^typedef float BaseFloat;$/;"	t	namespace:fst	file:
fst::CacheDeterministicOnDemandFst	deterministic-fst.h	/^class CacheDeterministicOnDemandFst: public DeterministicOnDemandFst<Arc> {$/;"	c	namespace:fst
fst::CacheDeterministicOnDemandFst::CacheDeterministicOnDemandFst	deterministic-fst-inl.h	/^CacheDeterministicOnDemandFst<Arc>::CacheDeterministicOnDemandFst($/;"	f	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::Final	deterministic-fst.h	/^  virtual Weight Final(StateId s) { return fst_->Final(s); }$/;"	f	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::GetArc	deterministic-fst-inl.h	/^bool CacheDeterministicOnDemandFst<Arc>::GetArc(StateId s, Label ilabel,$/;"	f	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::GetIndex	deterministic-fst-inl.h	/^inline size_t CacheDeterministicOnDemandFst<Arc>::GetIndex($/;"	f	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::Start	deterministic-fst.h	/^  virtual StateId Start() { return fst_->Start(); }$/;"	f	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::cached_arcs_	deterministic-fst.h	/^  std::vector<std::pair<StateId, Arc> > cached_arcs_;$/;"	m	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::fst_	deterministic-fst.h	/^  DeterministicOnDemandFst<Arc> *fst_;$/;"	m	class:fst::CacheDeterministicOnDemandFst
fst::CacheDeterministicOnDemandFst::num_cached_arcs_	deterministic-fst.h	/^  StateId num_cached_arcs_;  $/;"	m	class:fst::CacheDeterministicOnDemandFst
fst::CheckPhones	context-fst-test.cc	/^static float CheckPhones(const VectorFst<Arc> &linear_fst,$/;"	f	namespace:fst
fst::ClearSymbols	fstext-utils-inl.h	/^void ClearSymbols(bool clear_input,$/;"	f	namespace:fst
fst::CompactLatticeHasAlignment	lattice-utils-inl.h	/^bool CompactLatticeHasAlignment($/;"	f	namespace:fst
fst::CompactLatticeWeight	lattice-weight-test.cc	/^typedef CompactLatticeWeightTpl<LatticeWeight, int32> CompactLatticeWeight;$/;"	t	namespace:fst	file:
fst::CompactLatticeWeightCommonDivisor	lattice-weight-test.cc	/^  CompactLatticeWeightCommonDivisor;$/;"	t	namespace:fst	file:
fst::CompactLatticeWeightCommonDivisorTpl	lattice-weight.h	/^class CompactLatticeWeightCommonDivisorTpl {$/;"	c	namespace:fst
fst::CompactLatticeWeightCommonDivisorTpl::Weight	lattice-weight.h	/^  typedef CompactLatticeWeightTpl<BaseWeightType, IntType> Weight;$/;"	t	class:fst::CompactLatticeWeightCommonDivisorTpl
fst::CompactLatticeWeightCommonDivisorTpl::operator ()	lattice-weight.h	/^  Weight operator()(const Weight &w1, const Weight &w2) const {$/;"	f	class:fst::CompactLatticeWeightCommonDivisorTpl
fst::CompactLatticeWeightTest	lattice-weight-test.cc	/^void CompactLatticeWeightTest() {$/;"	f	namespace:fst
fst::CompactLatticeWeightTpl	lattice-weight.h	/^class CompactLatticeWeightTpl {$/;"	c	namespace:fst
fst::CompactLatticeWeightTpl::CompactLatticeWeightTpl	lattice-weight.h	/^  CompactLatticeWeightTpl() { }$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::CompactLatticeWeightTpl	lattice-weight.h	/^  CompactLatticeWeightTpl(const WeightType &w, const vector<IntType> &s):$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::GetIntSizeString	lattice-weight.h	/^  inline static string GetIntSizeString() {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Hash	lattice-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Member	lattice-weight.h	/^  bool Member() const {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::NoWeight	lattice-weight.h	/^  static const CompactLatticeWeightTpl<WeightType, IntType> NoWeight() {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::One	lattice-weight.h	/^  static const CompactLatticeWeightTpl<WeightType, IntType> One() {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Properties	lattice-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Quantize	lattice-weight.h	/^  CompactLatticeWeightTpl Quantize(float delta = kDelta) const {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Read	lattice-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Reverse	lattice-weight.h	/^  CompactLatticeWeightTpl<WeightType, IntType> Reverse() const {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::ReverseWeight	lattice-weight.h	/^  typedef CompactLatticeWeightTpl<WeightType, IntType> ReverseWeight;$/;"	t	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::SetString	lattice-weight.h	/^  void SetString(const vector<IntType> &s) { string_ = s; }$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::SetWeight	lattice-weight.h	/^  void SetWeight(const W &w) { weight_ = w; }$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::String	lattice-weight.h	/^  const vector<IntType> &String() const { return string_; }$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Type	lattice-weight.h	/^  static const string &Type() {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::W	lattice-weight.h	/^  typedef WeightType W;$/;"	t	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Weight	lattice-weight.h	/^  const W &Weight() const { return weight_; }$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Write	lattice-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::Zero	lattice-weight.h	/^  static const CompactLatticeWeightTpl<WeightType, IntType> Zero() {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::operator =	lattice-weight.h	/^  CompactLatticeWeightTpl &operator=(const CompactLatticeWeightTpl<WeightType, IntType> &w) {$/;"	f	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::string_	lattice-weight.h	/^  vector<IntType> string_; $/;"	m	class:fst::CompactLatticeWeightTpl
fst::CompactLatticeWeightTpl::weight_	lattice-weight.h	/^  W weight_;$/;"	m	class:fst::CompactLatticeWeightTpl
fst::Compare	lattice-weight.h	/^inline int Compare (const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
fst::Compare	lattice-weight.h	/^inline int Compare (const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
fst::Compare	lattice-weight.h	/^inline int Compare(const TropicalWeight &w1,$/;"	f	namespace:fst
fst::ComposeContext	context-fst-inl.h	/^inline void ComposeContext(vector<int32> &disambig_syms_in,$/;"	f	namespace:fst
fst::ComposeContextFst	context-fst.h	/^void ComposeContextFst(const ContextFst<Arc, LabelT> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
fst::ComposeDeterministicOnDemandFst	deterministic-fst.h	/^class ComposeDeterministicOnDemandFst: public DeterministicOnDemandFst<Arc> {$/;"	c	namespace:fst
fst::ComposeDeterministicOnDemandFst::ComposeDeterministicOnDemandFst	deterministic-fst-inl.h	/^ComposeDeterministicOnDemandFst<Arc>::ComposeDeterministicOnDemandFst($/;"	f	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::Final	deterministic-fst-inl.h	/^typename Arc::Weight ComposeDeterministicOnDemandFst<Arc>::Final(StateId s) {$/;"	f	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::GetArc	deterministic-fst-inl.h	/^bool ComposeDeterministicOnDemandFst<Arc>::GetArc(StateId s, Label ilabel,$/;"	f	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::MapType	deterministic-fst.h	/^  typedef unordered_map<std::pair<StateId, StateId>, StateId, kaldi::PairHasher<StateId> > MapType;$/;"	t	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::Start	deterministic-fst.h	/^  virtual StateId Start() { return start_state_; }$/;"	f	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::fst1_	deterministic-fst.h	/^  DeterministicOnDemandFst<Arc> *fst1_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::fst2_	deterministic-fst.h	/^  DeterministicOnDemandFst<Arc> *fst2_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::next_state_	deterministic-fst.h	/^  StateId next_state_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::start_state_	deterministic-fst.h	/^  StateId start_state_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::state_map_	deterministic-fst.h	/^  MapType state_map_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
fst::ComposeDeterministicOnDemandFst::state_vec_	deterministic-fst.h	/^  std::vector<std::pair<StateId, StateId> > state_vec_; \/\/ maps from$/;"	m	class:fst::ComposeDeterministicOnDemandFst
fst::ComputeStateInfo	epsilon-property-inl.h	/^void ComputeStateInfo(const VectorFst<Arc> &fst,$/;"	f	namespace:fst
fst::ComputeTotalWeight	rescale-inl.h	/^ComputeTotalWeight(ExpandedFst<Arc> &fst, typename Arc::Weight max_weight, float delta) {$/;"	f	namespace:fst
fst::ContextFst	context-fst.h	/^class ContextFst : public Fst<Arc> {$/;"	c	namespace:fst
fst::ContextFst::ContextFst	context-fst-inl.h	/^ContextFst<Arc, LabelT>::ContextFst(const ContextFst<Arc, LabelT> &fst, bool reset) {$/;"	f	class:fst::ContextFst
fst::ContextFst::ContextFst	context-fst.h	/^  ContextFst(Label subsequential_symbol,  \/\/ epsilon not allowed.$/;"	f	class:fst::ContextFst
fst::ContextFst::Copy	context-fst.h	/^  virtual ContextFst<Arc>  *Copy(bool reset = false) const {$/;"	f	class:fst::ContextFst
fst::ContextFst::CreateArc	context-fst.h	/^  bool CreateArc(StateId s, Label olabel, Arc *oarc) const {$/;"	f	class:fst::ContextFst
fst::ContextFst::Final	context-fst.h	/^  virtual Weight Final(StateId s) const { return impl_->Final(s); }$/;"	f	class:fst::ContextFst
fst::ContextFst::GetImpl	context-fst.h	/^  ContextFstImpl<Arc, LabelT> *GetImpl() const { return impl_; }$/;"	f	class:fst::ContextFst
fst::ContextFst::ILabelInfo	context-fst.h	/^  const vector<vector<LabelT> > &ILabelInfo() { return impl_->ILabelInfo(); }$/;"	f	class:fst::ContextFst
fst::ContextFst::InitArcIterator	context-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::ContextFst
fst::ContextFst::InitStateIterator	context-fst.h	/^void ContextFst<A, I>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ContextFst
fst::ContextFst::InputSymbols	context-fst.h	/^  virtual const SymbolTable* InputSymbols() const {$/;"	f	class:fst::ContextFst
fst::ContextFst::Label	context-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ContextFst
fst::ContextFst::NumArcs	context-fst.h	/^  size_t NumArcs(StateId s) const { return impl_->NumArcs(s); }$/;"	f	class:fst::ContextFst
fst::ContextFst::NumInputEpsilons	context-fst.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::ContextFst
fst::ContextFst::NumOutputEpsilons	context-fst.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::ContextFst
fst::ContextFst::NumStates	context-fst.h	/^  StateId NumStates() const { return impl_->NumStates(); }$/;"	f	class:fst::ContextFst
fst::ContextFst::OutputSymbols	context-fst.h	/^  virtual const SymbolTable* OutputSymbols() const {$/;"	f	class:fst::ContextFst
fst::ContextFst::Properties	context-fst.h	/^  virtual uint64 Properties(uint64 mask, bool test) const {$/;"	f	class:fst::ContextFst
fst::ContextFst::Start	context-fst.h	/^  virtual StateId Start() const { return impl_->Start(); }$/;"	f	class:fst::ContextFst
fst::ContextFst::State	context-fst.h	/^  typedef CacheState<Arc> State;$/;"	t	class:fst::ContextFst
fst::ContextFst::StateId	context-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ContextFst
fst::ContextFst::Type	context-fst.h	/^  virtual const string& Type() const { return impl_->Type(); }$/;"	f	class:fst::ContextFst
fst::ContextFst::Weight	context-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ContextFst
fst::ContextFst::impl_	context-fst.h	/^  ContextFstImpl<Arc, LabelT> *impl_;  \/\/ protected so CacheStateIterator$/;"	m	class:fst::ContextFst
fst::ContextFst::~ContextFst	context-fst.h	/^  virtual ~ContextFst() { if (!impl_->DecrRefCount()) delete impl_;  }$/;"	f	class:fst::ContextFst
fst::ContextFstImpl	context-fst.h	/^class ContextFstImpl : public CacheImpl<Arc> {$/;"	c	namespace:fst
fst::ContextFstImpl::ContextFstImpl	context-fst-inl.h	/^ContextFstImpl<Arc, LabelT>::ContextFstImpl(Label subsequential_symbol,  \/\/ epsilon not allowed.$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::ContextFstImpl	context-fst-inl.h	/^ContextFstImpl<Arc, LabelT>::ContextFstImpl(const ContextFstImpl &other):$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::CreateArc	context-fst-inl.h	/^bool ContextFstImpl<Arc, LabelT>::CreateArc(StateId s,$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::CreateDisambigArc	context-fst-inl.h	/^void ContextFstImpl<Arc, LabelT>::CreateDisambigArc(StateId s,$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::CreatePhoneOrEpsArc	context-fst-inl.h	/^bool ContextFstImpl<Arc, LabelT>::CreatePhoneOrEpsArc(StateId src,$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::Expand	context-fst-inl.h	/^void ContextFstImpl<Arc, LabelT>::Expand(StateId s) {  \/\/ expands arcs only [not final state weight].$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::Final	context-fst-inl.h	/^typename ContextFstImpl<Arc, LabelT>::Weight ContextFstImpl<Arc, LabelT>::Final(StateId s) {$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::FindLabel	context-fst-inl.h	/^ContextFstImpl<Arc, LabelT>::FindLabel(const vector<LabelT> &label_vec) {$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::FindState	context-fst-inl.h	/^   ContextFstImpl<Arc, LabelT>::FindState(const vector<LabelT> &seq) {$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::ILabelInfo	context-fst.h	/^  const vector<vector<LabelT> > &ILabelInfo() { return ilabel_info_; }$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::InitArcIterator	context-fst-inl.h	/^void ContextFstImpl<Arc, LabelT>::InitArcIterator(StateId s, ArcIteratorData<Arc> *data) {$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::IsDisambigSymbol	context-fst.h	/^  bool IsDisambigSymbol(Label lab) {  return (disambig_syms_.count(lab) != 0); }$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::IsPhoneSymbol	context-fst.h	/^  bool IsPhoneSymbol(Label lab) {  return (phone_syms_.count(lab) != 0); }$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::Label	context-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ContextFstImpl
fst::ContextFstImpl::N_	context-fst.h	/^  int N_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::NumArcs	context-fst-inl.h	/^size_t ContextFstImpl<Arc, LabelT>::NumArcs(StateId s) {$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::NumInputEpsilons	context-fst-inl.h	/^size_t ContextFstImpl<Arc, LabelT>::NumInputEpsilons(StateId s) {$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::NumOutputEpsilons	context-fst.h	/^  size_t NumOutputEpsilons(StateId s) { return 0; }$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::P_	context-fst.h	/^  int P_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::Start	context-fst-inl.h	/^typename ContextFstImpl<Arc, LabelT>::StateId ContextFstImpl<Arc, LabelT>::Start() {$/;"	f	class:fst::ContextFstImpl
fst::ContextFstImpl::StateId	context-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ContextFstImpl
fst::ContextFstImpl::VectorToLabelIter	context-fst.h	/^  typedef typename VectorToLabelType::const_iterator VectorToLabelIter;$/;"	t	class:fst::ContextFstImpl
fst::ContextFstImpl::VectorToLabelType	context-fst.h	/^                        Label, kaldi::VectorHasher<LabelT> > VectorToLabelType;$/;"	t	class:fst::ContextFstImpl
fst::ContextFstImpl::VectorToStateIter	context-fst.h	/^  typedef typename VectorToStateType::const_iterator VectorToStateIter;$/;"	t	class:fst::ContextFstImpl
fst::ContextFstImpl::VectorToStateType	context-fst.h	/^                        StateId, kaldi::VectorHasher<LabelT> > VectorToStateType;$/;"	t	class:fst::ContextFstImpl
fst::ContextFstImpl::Weight	context-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ContextFstImpl
fst::ContextFstImpl::disambig_syms_	context-fst.h	/^  kaldi::ConstIntegerSet<Label> disambig_syms_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::ilabel_info_	context-fst.h	/^  vector<vector<LabelT> > ilabel_info_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::ilabel_map_	context-fst.h	/^  VectorToLabelType ilabel_map_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::phone_syms_	context-fst.h	/^  kaldi::ConstIntegerSet<Label> phone_syms_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::pseudo_eps_symbol_	context-fst.h	/^  int pseudo_eps_symbol_;  \/\/ This is the symbol we put on epsilon arcs at the start$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::separator_	context-fst.h	/^  std::string separator_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::state_map_	context-fst.h	/^  VectorToStateType state_map_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::state_seqs_	context-fst.h	/^  vector<vector<LabelT> > state_seqs_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::subsequential_symbol_	context-fst.h	/^  Label subsequential_symbol_;$/;"	m	class:fst::ContextFstImpl
fst::ContextFstImpl::~ContextFstImpl	context-fst.h	/^  ~ContextFstImpl() { }$/;"	f	class:fst::ContextFstImpl
fst::ContextMatcher	context-fst.h	/^class ContextMatcher : public MatcherBase<Arc> {  \/\/ CAREFUL: templated on arc, not on FST like normal Matcher.$/;"	c	namespace:fst
fst::ContextMatcher::ContextF	context-fst.h	/^  typedef ContextFst<Arc, LabelT> ContextF;$/;"	t	class:fst::ContextMatcher
fst::ContextMatcher::ContextMatcher	context-fst.h	/^  ContextMatcher(const ContextMatcher<Arc, LabelT> &matcher, bool safe)$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::ContextMatcher	context-fst.h	/^  ContextMatcher(const FST &fst, MatchType match_type)$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Copy	context-fst.h	/^  virtual ContextMatcher<Arc, LabelT> *Copy(bool safe = false) const {$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Done	context-fst.h	/^  bool Done() const {$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Done_	context-fst.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::FST	context-fst.h	/^  typedef Fst<Arc> FST;  \/\/ basic FST type that we get passed$/;"	t	class:fst::ContextMatcher
fst::ContextMatcher::Find	context-fst-inl.h	/^bool ContextMatcher<Arc, LabelT>::Find(typename Arc::Label match_label) {$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Find_	context-fst.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::GetFst	context-fst.h	/^  virtual const FST &GetFst() const { return *fst_; }$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Label	context-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ContextMatcher
fst::ContextMatcher::Next	context-fst.h	/^  void Next() {  \/\/ we only ever get one arc so just set ready_ to false.$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Next_	context-fst.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Properties	context-fst.h	/^  virtual uint64 Properties(uint64 props) const { return props; } \/\/ simple matcher that does$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::SetState	context-fst.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::SetState_	context-fst.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::StateId	context-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ContextMatcher
fst::ContextMatcher::Type	context-fst.h	/^  virtual MatchType Type(bool test) const {$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Value	context-fst.h	/^  const Arc& Value() const {$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Value_	context-fst.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::ContextMatcher
fst::ContextMatcher::Weight	context-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ContextMatcher
fst::ContextMatcher::arc_	context-fst.h	/^  Arc arc_;                       \/\/ Current arc.$/;"	m	class:fst::ContextMatcher
fst::ContextMatcher::current_loop_	context-fst.h	/^  bool current_loop_;             \/\/ Current arc is the implicit loop$/;"	m	class:fst::ContextMatcher
fst::ContextMatcher::fst_	context-fst.h	/^  const FST *fst_;$/;"	m	class:fst::ContextMatcher
fst::ContextMatcher::match_label_	context-fst.h	/^  Label match_label_;             \/\/ Current label to be matched$/;"	m	class:fst::ContextMatcher
fst::ContextMatcher::match_type_	context-fst.h	/^  MatchType match_type_;          \/\/ Type of match to perform$/;"	m	class:fst::ContextMatcher
fst::ContextMatcher::ready_	context-fst.h	/^  bool ready_;                     \/\/ True if arc is waiting to be output.$/;"	m	class:fst::ContextMatcher
fst::ContextMatcher::s_	context-fst.h	/^  StateId s_;                     \/\/ Current state.$/;"	m	class:fst::ContextMatcher
fst::ContextMatcher::~ContextMatcher	context-fst.h	/^  virtual ~ContextMatcher() {$/;"	f	class:fst::ContextMatcher
fst::ConvertLattice	lattice-utils-inl.h	/^void ConvertLattice($/;"	f	namespace:fst
fst::ConvertLattice	lattice-utils.h	/^void ConvertLattice(const ExpandedFst<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<double>, Int> > > &ifst,$/;"	f	namespace:fst
fst::ConvertLattice	lattice-utils.h	/^void ConvertLattice(const ExpandedFst<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, Int> > > &ifst,$/;"	f	namespace:fst
fst::ConvertLattice	lattice-utils.h	/^void ConvertLattice(const ExpandedFst<ArcTpl<LatticeWeightTpl<double> > > &ifst,$/;"	f	namespace:fst
fst::ConvertLattice	lattice-utils.h	/^void ConvertLattice(const ExpandedFst<ArcTpl<LatticeWeightTpl<float> > > &ifst,$/;"	f	namespace:fst
fst::ConvertLatticeWeight	lattice-weight.h	/^inline void ConvertLatticeWeight($/;"	f	namespace:fst
fst::ConvertNbestToVector	fstext-utils-inl.h	/^void ConvertNbestToVector(const Fst<Arc> &fst,$/;"	f	namespace:fst
fst::ConvertToCost	lattice-weight.h	/^inline double ConvertToCost(const CompactLatticeWeightTpl<LatticeWeightTpl<Float>, Int> &w) {$/;"	f	namespace:fst
fst::ConvertToCost	lattice-weight.h	/^inline double ConvertToCost(const LatticeWeightTpl<Float> &w) {$/;"	f	namespace:fst
fst::ConvertToCost	lattice-weight.h	/^inline double ConvertToCost(const TropicalWeightTpl<Float> &w) {$/;"	f	namespace:fst
fst::CreateBackoffFst	deterministic-fst-test.cc	/^StdVectorFst* CreateBackoffFst() {$/;"	f	namespace:fst
fst::CreateFactorFst	factor-inl.h	/^void CreateFactorFst(const vector<vector<I> > &sequences,$/;"	f	namespace:fst
fst::CreateILabelInfoSymbolTable	context-fst-inl.h	/^SymbolTable *CreateILabelInfoSymbolTable(const vector<vector<I> > &info,$/;"	f	namespace:fst
fst::CreateMapFst	factor-inl.h	/^void CreateMapFst(const vector<I> &symbol_map,$/;"	f	namespace:fst
fst::CreateNewSymbols	pre-determinize-inl.h	/^template<class Label> void CreateNewSymbols(SymbolTable *input_sym_table, int nSym,$/;"	f	namespace:fst
fst::CreateResultFst	deterministic-fst-test.cc	/^StdVectorFst* CreateResultFst() {$/;"	f	namespace:fst
fst::CreateSuperFinal	pre-determinize-inl.h	/^typename Arc::StateId CreateSuperFinal(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
fst::DefaultLatticeScale	lattice-utils.h	/^inline vector<vector<double> > DefaultLatticeScale() {$/;"	f	namespace:fst
fst::DeleteISymbols	pre-determinize-inl.h	/^int64 DeleteISymbols(MutableFst<Arc> *fst, vector<typename Arc::Label> isyms) {$/;"	f	namespace:fst
fst::DeleteTestFst	deterministic-fst-test.cc	/^void DeleteTestFst(StdVectorFst *fst) {$/;"	f	namespace:fst
fst::DeterministicOnDemandFst	deterministic-fst.h	/^class DeterministicOnDemandFst {$/;"	c	namespace:fst
fst::DeterministicOnDemandFst::Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::DeterministicOnDemandFst
fst::DeterministicOnDemandFst::StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::DeterministicOnDemandFst
fst::DeterministicOnDemandFst::Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::DeterministicOnDemandFst
fst::DeterministicOnDemandFst::~DeterministicOnDemandFst	deterministic-fst.h	/^  virtual ~DeterministicOnDemandFst() { }$/;"	f	class:fst::DeterministicOnDemandFst
fst::DeterminizeInLog	fstext-utils-inl.h	/^void DeterminizeInLog(VectorFst<StdArc> *fst) {$/;"	f	namespace:fst
fst::DeterminizeLattice	determinize-lattice-inl.h	/^bool DeterminizeLattice(const Fst<ArcTpl<Weight> > &ifst,$/;"	f	namespace:fst
fst::DeterminizeLattice	determinize-lattice-inl.h	/^bool DeterminizeLattice(const Fst<ArcTpl<Weight> >&ifst,$/;"	f	namespace:fst
fst::DeterminizeLatticeOptions	determinize-lattice.h	/^struct DeterminizeLatticeOptions {$/;"	s	namespace:fst
fst::DeterminizeLatticeOptions::DeterminizeLatticeOptions	determinize-lattice.h	/^  DeterminizeLatticeOptions(): delta(kDelta),$/;"	f	struct:fst::DeterminizeLatticeOptions
fst::DeterminizeLatticeOptions::delta	determinize-lattice.h	/^  float delta; \/\/ A small offset used to measure equality of weights.$/;"	m	struct:fst::DeterminizeLatticeOptions
fst::DeterminizeLatticeOptions::max_loop	determinize-lattice.h	/^  int max_loop; \/\/ If >0, can be used to detect non-determinizable input$/;"	m	struct:fst::DeterminizeLatticeOptions
fst::DeterminizeLatticeOptions::max_mem	determinize-lattice.h	/^  int max_mem; \/\/ If >0, determinization will fail and return false$/;"	m	struct:fst::DeterminizeLatticeOptions
fst::DeterminizeStar	determinize-star-inl.h	/^void DeterminizeStar(Fst<Arc> &ifst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
fst::DeterminizeStar	determinize-star-inl.h	/^void DeterminizeStar(Fst<Arc> &ifst, MutableFst<GallicArc<Arc> > *ofst, float delta,$/;"	f	namespace:fst
fst::DeterminizeStarInLog	fstext-utils-inl.h	/^void DeterminizeStarInLog(VectorFst<StdArc> *fst, float delta, bool *debug_ptr, int max_states) {$/;"	f	namespace:fst
fst::DeterminizerStar	determinize-star-inl.h	/^template<class Arc> class DeterminizerStar {$/;"	c	namespace:fst
fst::DeterminizerStar::Debug	determinize-star-inl.h	/^  void Debug() {  \/\/ this function called if you send a signal$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::Determinize	determinize-star-inl.h	/^  void Determinize(bool *debug_ptr) {$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::DeterminizerStar	determinize-star-inl.h	/^  DeterminizerStar(const Fst<Arc> &ifst, float delta = kDelta, int max_states = -1):$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::Element	determinize-star-inl.h	/^  struct Element {$/;"	s	class:fst::DeterminizerStar
fst::DeterminizerStar::Element::operator !=	determinize-star-inl.h	/^    bool operator != (const Element &other) const  {$/;"	f	struct:fst::DeterminizerStar::Element
fst::DeterminizerStar::Element::state	determinize-star-inl.h	/^    InputStateId state;$/;"	m	struct:fst::DeterminizerStar::Element
fst::DeterminizerStar::Element::string	determinize-star-inl.h	/^    StringId string;$/;"	m	struct:fst::DeterminizerStar::Element
fst::DeterminizerStar::Element::weight	determinize-star-inl.h	/^    Weight weight;$/;"	m	struct:fst::DeterminizerStar::Element
fst::DeterminizerStar::EpsilonClosure	determinize-star-inl.h	/^  void EpsilonClosure(const vector<Element> & input_subset,$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::FreeMostMemory	determinize-star-inl.h	/^  void FreeMostMemory() {$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::InputStateId	determinize-star-inl.h	/^  typedef typename Arc::StateId InputStateId;$/;"	t	class:fst::DeterminizerStar
fst::DeterminizerStar::Label	determinize-star-inl.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::DeterminizerStar
fst::DeterminizerStar::Output	determinize-star-inl.h	/^  void  Output(MutableFst<Arc> *ofst, bool destroy = true) {$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::Output	determinize-star-inl.h	/^  void Output(MutableFst<GallicArc<Arc> >  *ofst, bool destroy = true) {$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::OutputStateId	determinize-star-inl.h	/^  typedef typename Arc::StateId OutputStateId;  \/\/ same as above but distinguish states in output Fst.$/;"	t	class:fst::DeterminizerStar
fst::DeterminizerStar::PairComparator	determinize-star-inl.h	/^  class PairComparator {$/;"	c	class:fst::DeterminizerStar
fst::DeterminizerStar::PairComparator::operator ()	determinize-star-inl.h	/^    inline bool operator () (const pair<Label, Element> &p1, const pair<Label, Element> &p2) {$/;"	f	class:fst::DeterminizerStar::PairComparator
fst::DeterminizerStar::ProcessFinal	determinize-star-inl.h	/^  void ProcessFinal(const vector<Element> &closed_subset, OutputStateId state) {$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::ProcessSubset	determinize-star-inl.h	/^  void ProcessSubset(const pair<vector<Element>*, OutputStateId> & pair) {$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::ProcessTransition	determinize-star-inl.h	/^  void ProcessTransition(OutputStateId state, Label ilabel, vector<Element> *subset) {$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::ProcessTransitions	determinize-star-inl.h	/^  void ProcessTransitions(const vector<Element> &closed_subset, OutputStateId state) {$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::Q_	determinize-star-inl.h	/^  vector<pair<vector<Element>*, OutputStateId> > Q_;  \/\/ queue of subsets to be processed.$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::StringId	determinize-star-inl.h	/^  typedef typename Arc::Label StringId;  \/\/ Id type used in the StringRepository$/;"	t	class:fst::DeterminizerStar
fst::DeterminizerStar::StringRepositoryType	determinize-star-inl.h	/^  typedef StringRepository<Label, StringId> StringRepositoryType;$/;"	t	class:fst::DeterminizerStar
fst::DeterminizerStar::SubsetEqual	determinize-star-inl.h	/^  class SubsetEqual {$/;"	c	class:fst::DeterminizerStar
fst::DeterminizerStar::SubsetEqual::SubsetEqual	determinize-star-inl.h	/^    SubsetEqual(): delta_(kDelta) {}$/;"	f	class:fst::DeterminizerStar::SubsetEqual
fst::DeterminizerStar::SubsetEqual::SubsetEqual	determinize-star-inl.h	/^    SubsetEqual(float delta): delta_(delta) {}$/;"	f	class:fst::DeterminizerStar::SubsetEqual
fst::DeterminizerStar::SubsetEqual::delta_	determinize-star-inl.h	/^    float delta_;$/;"	m	class:fst::DeterminizerStar::SubsetEqual
fst::DeterminizerStar::SubsetEqual::operator ()	determinize-star-inl.h	/^    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {$/;"	f	class:fst::DeterminizerStar::SubsetEqual
fst::DeterminizerStar::SubsetEqualStates	determinize-star-inl.h	/^  class SubsetEqualStates {$/;"	c	class:fst::DeterminizerStar
fst::DeterminizerStar::SubsetEqualStates::operator ()	determinize-star-inl.h	/^    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {$/;"	f	class:fst::DeterminizerStar::SubsetEqualStates
fst::DeterminizerStar::SubsetHash	determinize-star-inl.h	/^  typedef unordered_map<const vector<Element>*, OutputStateId, SubsetKey, SubsetEqual> SubsetHash;$/;"	t	class:fst::DeterminizerStar
fst::DeterminizerStar::SubsetKey	determinize-star-inl.h	/^  class SubsetKey {$/;"	c	class:fst::DeterminizerStar
fst::DeterminizerStar::SubsetKey::operator ()	determinize-star-inl.h	/^    size_t operator ()(const vector<Element> * subset) const {  \/\/ hashes only the state and string.$/;"	f	class:fst::DeterminizerStar::SubsetKey
fst::DeterminizerStar::SubsetToStateId	determinize-star-inl.h	/^  OutputStateId SubsetToStateId(const vector<Element> &subset) {  \/\/ may add the subset to the queue.$/;"	f	class:fst::DeterminizerStar
fst::DeterminizerStar::TempArc	determinize-star-inl.h	/^  struct TempArc {$/;"	s	class:fst::DeterminizerStar
fst::DeterminizerStar::TempArc::ilabel	determinize-star-inl.h	/^    Label ilabel;$/;"	m	struct:fst::DeterminizerStar::TempArc
fst::DeterminizerStar::TempArc::nextstate	determinize-star-inl.h	/^    OutputStateId nextstate;  \/\/ or kNoState for final weights.$/;"	m	struct:fst::DeterminizerStar::TempArc
fst::DeterminizerStar::TempArc::ostring	determinize-star-inl.h	/^    StringId ostring;  \/\/ Look it up in the StringRepository, it's a sequence of Labels.$/;"	m	struct:fst::DeterminizerStar::TempArc
fst::DeterminizerStar::TempArc::weight	determinize-star-inl.h	/^    Weight weight;$/;"	m	struct:fst::DeterminizerStar::TempArc
fst::DeterminizerStar::Weight	determinize-star-inl.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::DeterminizerStar
fst::DeterminizerStar::delta_	determinize-star-inl.h	/^  float delta_;$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::determinized_	determinize-star-inl.h	/^  bool determinized_; \/\/ used to check usage.$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::equal_	determinize-star-inl.h	/^  SubsetEqual equal_;  \/\/ object that compares subsets-- only data member is delta_.$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::hash_	determinize-star-inl.h	/^  SubsetHash hash_;  \/\/ hash from Subset to StateId in final Fst.$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::hasher_	determinize-star-inl.h	/^  SubsetKey hasher_;  \/\/ object that computes keys-- has no data members.$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::ifst_	determinize-star-inl.h	/^  const Fst<Arc> *ifst_;$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::max_states_	determinize-star-inl.h	/^  int max_states_;$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::output_arcs_	determinize-star-inl.h	/^  vector<vector<TempArc> > output_arcs_;  \/\/ essentially an FST in our format.$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::repository_	determinize-star-inl.h	/^  StringRepository<Label, StringId> repository_;  \/\/ associate integer id's with sequences of labels.$/;"	m	class:fst::DeterminizerStar
fst::DeterminizerStar::~DeterminizerStar	determinize-star-inl.h	/^  ~DeterminizerStar() {$/;"	f	class:fst::DeterminizerStar
fst::DfsOrderVisitor	factor.h	/^class DfsOrderVisitor {$/;"	c	namespace:fst
fst::DfsOrderVisitor::BackArc	factor.h	/^  bool BackArc(StateId, const Arc&) { return true; }$/;"	f	class:fst::DfsOrderVisitor
fst::DfsOrderVisitor::DfsOrderVisitor	factor.h	/^  DfsOrderVisitor(vector<StateId> *order): order_(order) { order->clear(); }$/;"	f	class:fst::DfsOrderVisitor
fst::DfsOrderVisitor::FinishState	factor.h	/^  void FinishState(StateId, StateId, const Arc *) { }$/;"	f	class:fst::DfsOrderVisitor
fst::DfsOrderVisitor::FinishVisit	factor.h	/^  void FinishVisit() { }$/;"	f	class:fst::DfsOrderVisitor
fst::DfsOrderVisitor::ForwardOrCrossArc	factor.h	/^  bool ForwardOrCrossArc(StateId, const Arc&) { return true; }$/;"	f	class:fst::DfsOrderVisitor
fst::DfsOrderVisitor::InitState	factor.h	/^  bool InitState(StateId s, StateId) { order_->push_back(s); return true; }$/;"	f	class:fst::DfsOrderVisitor
fst::DfsOrderVisitor::InitVisit	factor.h	/^  void InitVisit(const Fst<Arc> &fst) {}$/;"	f	class:fst::DfsOrderVisitor
fst::DfsOrderVisitor::StateId	factor.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::DfsOrderVisitor
fst::DfsOrderVisitor::TreeArc	factor.h	/^  bool TreeArc(StateId, const Arc&) { return true; }$/;"	f	class:fst::DfsOrderVisitor
fst::DfsOrderVisitor::order_	factor.h	/^  vector<StateId> *order_;$/;"	m	class:fst::DfsOrderVisitor
fst::Divide	lattice-weight.h	/^inline CompactLatticeWeightTpl<WeightType, IntType> Divide(const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
fst::Divide	lattice-weight.h	/^inline LatticeWeightTpl<FloatType> Divide(const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
fst::EnsureEpsilonProperty	epsilon-property-inl.h	/^void EnsureEpsilonProperty(VectorFst<Arc> *fst) {$/;"	f	namespace:fst
fst::EqualAlign	fstext-utils-inl.h	/^bool EqualAlign(const Fst<Arc> &ifst,$/;"	f	namespace:fst
fst::ExpandInputSequences	factor-inl.h	/^void ExpandInputSequences(const vector<vector<I> > &sequences,$/;"	f	namespace:fst
fst::Factor	factor-inl.h	/^void Factor(const Fst<Arc> &fst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
fst::Factor	factor-inl.h	/^void Factor(const Fst<Arc> &fst, MutableFst<Arc> *ofst1,$/;"	f	namespace:fst
fst::FileExists	deterministic-fst-test.cc	/^bool FileExists(string strFilename) { $/;"	f	namespace:fst
fst::FindSelfLoopWithILabel	fstext-utils-inl.h	/^ssize_t FindSelfLoopWithILabel(const Fst<Arc> &fst, typename Arc::StateId s) {$/;"	f	namespace:fst
fst::FollowingInputSymbolsAreSame	fstext-utils-inl.h	/^bool FollowingInputSymbolsAreSame(bool end_is_epsilon, const Fst<Arc> &fst) {$/;"	f	namespace:fst
fst::FollowingInputSymbolsAreSameClass	fstext-utils-inl.h	/^bool FollowingInputSymbolsAreSameClass(bool end_is_epsilon, const Fst<Arc> &fst, const F &f) {$/;"	f	namespace:fst
fst::GenAcceptorFromSequence	context-fst-test.cc	/^static VectorFst<Arc> *GenAcceptorFromSequence(const vector<typename Arc::Label> &symbols, float cost) {$/;"	f	namespace:fst
fst::GenRandPhoneSeq	context-fst-test.cc	/^static VectorFst<Arc> *GenRandPhoneSeq(vector<typename Arc::Label> &phone_syms,$/;"	f	namespace:fst
fst::GetInputSymbols	fstext-utils-inl.h	/^void GetInputSymbols(const Fst<Arc> &fst,$/;"	f	namespace:fst
fst::GetLinearSymbolSequence	fstext-utils-inl.h	/^bool GetLinearSymbolSequence(const Fst<Arc> &fst,$/;"	f	namespace:fst
fst::GetLinearSymbolSequences	fstext-utils-inl.h	/^bool GetLinearSymbolSequences(const Fst<Arc> &fst,$/;"	f	namespace:fst
fst::GetOutputSymbols	fstext-utils-inl.h	/^void GetOutputSymbols(const Fst<Arc> &fst,$/;"	f	namespace:fst
fst::GetStateProperties	factor-inl.h	/^void GetStateProperties(const Fst<Arc> &fst,$/;"	f	namespace:fst
fst::GetSymbols	fstext-utils-inl.h	/^void GetSymbols(const SymbolTable &symtab,$/;"	f	namespace:fst
fst::GraphLatticeScale	lattice-utils.h	/^inline vector<vector<double> > GraphLatticeScale(double lmwt) {$/;"	f	namespace:fst
fst::HighestNumberedInputSymbol	fstext-utils-inl.h	/^typename Arc::Label HighestNumberedInputSymbol(const Fst<Arc> &fst) {$/;"	f	namespace:fst
fst::HighestNumberedOutputSymbol	fstext-utils-inl.h	/^typename Arc::Label HighestNumberedOutputSymbol(const Fst<Arc> &fst) {$/;"	f	namespace:fst
fst::IdentityFunction	fstext-utils-inl.h	/^template<class T> struct IdentityFunction {$/;"	s	namespace:fst
fst::IdentityFunction::Arg	fstext-utils-inl.h	/^  typedef T Arg;$/;"	t	struct:fst::IdentityFunction
fst::IdentityFunction::Result	fstext-utils-inl.h	/^  typedef T Result;$/;"	t	struct:fst::IdentityFunction
fst::IdentityFunction::operator ()	fstext-utils-inl.h	/^  T operator () (const T &t) const { return t; }$/;"	f	struct:fst::IdentityFunction
fst::IsStochasticFst	fstext-utils-inl.h	/^bool IsStochasticFst(const Fst<Arc> &fst,$/;"	f	namespace:fst
fst::IsStochasticFst	fstext-utils-inl.h	/^bool IsStochasticFst(const Fst<LogArc> &fst,$/;"	f	namespace:fst
fst::IsStochasticFstInLog	fstext-utils-inl.h	/^bool IsStochasticFstInLog(const VectorFst<StdArc> &fst,$/;"	f	namespace:fst
fst::Label	deterministic-fst-test.cc	/^typedef fst::StdArc::Label   Label;$/;"	t	namespace:fst	file:
fst::LatticeDeterminizer	determinize-lattice-inl.h	/^template<class Weight, class IntType> class LatticeDeterminizer {$/;"	c	namespace:fst
fst::LatticeDeterminizer::Arc	determinize-lattice-inl.h	/^  typedef ArcTpl<Weight> Arc; \/\/ arc in non-compact version of lattice $/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::CheckMemoryUsage	determinize-lattice-inl.h	/^  bool CheckMemoryUsage() {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::CompactArc	determinize-lattice-inl.h	/^  typedef ArcTpl<CompactWeight> CompactArc; \/\/ arc in compact, acceptor form of lattice$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::CompactWeight	determinize-lattice-inl.h	/^  typedef CompactLatticeWeightTpl<Weight, IntType> CompactWeight;$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::Compare	determinize-lattice-inl.h	/^  inline int Compare(const Weight &a_w, StringId a_str,$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::ConvertToMinimal	determinize-lattice-inl.h	/^  void ConvertToMinimal(vector<Element> *subset) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::Debug	determinize-lattice-inl.h	/^  void Debug() {  \/\/ this function called if you send a signal$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::Determinize	determinize-lattice-inl.h	/^  bool Determinize(bool *debug_ptr) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::Element	determinize-lattice-inl.h	/^  struct Element {$/;"	s	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::Element::operator !=	determinize-lattice-inl.h	/^    bool operator != (const Element &other) const {$/;"	f	struct:fst::LatticeDeterminizer::Element
fst::LatticeDeterminizer::Element::state	determinize-lattice-inl.h	/^    StateId state; \/\/ use StateId as this is usually InputStateId but in one case$/;"	m	struct:fst::LatticeDeterminizer::Element
fst::LatticeDeterminizer::Element::string	determinize-lattice-inl.h	/^    StringId string;$/;"	m	struct:fst::LatticeDeterminizer::Element
fst::LatticeDeterminizer::Element::weight	determinize-lattice-inl.h	/^    Weight weight;$/;"	m	struct:fst::LatticeDeterminizer::Element
fst::LatticeDeterminizer::EpsilonClosure	determinize-lattice-inl.h	/^  void EpsilonClosure(vector<Element> *subset) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::FreeMostMemory	determinize-lattice-inl.h	/^  void FreeMostMemory() {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::InitialSubsetHash	determinize-lattice-inl.h	/^                        SubsetKey, SubsetEqual> InitialSubsetHash;$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::InitialToStateId	determinize-lattice-inl.h	/^  OutputStateId InitialToStateId(const vector<Element> &subset_in,$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::InitializeDeterminization	determinize-lattice-inl.h	/^  void InitializeDeterminization() {    $/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::InputStateId	determinize-lattice-inl.h	/^  typedef typename Arc::StateId InputStateId;  \/\/ state in the input FST.$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::IsIsymbolOrFinal	determinize-lattice-inl.h	/^  bool IsIsymbolOrFinal(InputStateId state) { \/\/ returns true if this state$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::IsymbolOrFinal	determinize-lattice-inl.h	/^  enum IsymbolOrFinal { OSF_UNKNOWN = 0, OSF_NO = 1, OSF_YES = 2 };$/;"	g	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::Label	determinize-lattice-inl.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::LatticeDeterminizer	determinize-lattice-inl.h	/^  LatticeDeterminizer(const Fst<Arc> &ifst,$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::MakeSubsetUnique	determinize-lattice-inl.h	/^  void MakeSubsetUnique(vector<Element> *subset) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::MinimalSubsetHash	determinize-lattice-inl.h	/^                        SubsetKey, SubsetEqual> MinimalSubsetHash;$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::MinimalToStateId	determinize-lattice-inl.h	/^  OutputStateId MinimalToStateId(const vector<Element> &subset) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::NormalizeSubset	determinize-lattice-inl.h	/^  void NormalizeSubset(vector<Element> *elems,$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::OSF_NO	determinize-lattice-inl.h	/^  enum IsymbolOrFinal { OSF_UNKNOWN = 0, OSF_NO = 1, OSF_YES = 2 };$/;"	e	enum:fst::LatticeDeterminizer::IsymbolOrFinal
fst::LatticeDeterminizer::OSF_UNKNOWN	determinize-lattice-inl.h	/^  enum IsymbolOrFinal { OSF_UNKNOWN = 0, OSF_NO = 1, OSF_YES = 2 };$/;"	e	enum:fst::LatticeDeterminizer::IsymbolOrFinal
fst::LatticeDeterminizer::OSF_YES	determinize-lattice-inl.h	/^  enum IsymbolOrFinal { OSF_UNKNOWN = 0, OSF_NO = 1, OSF_YES = 2 };$/;"	e	enum:fst::LatticeDeterminizer::IsymbolOrFinal
fst::LatticeDeterminizer::Output	determinize-lattice-inl.h	/^  void  Output(MutableFst<Arc> *ofst, bool destroy = true) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::Output	determinize-lattice-inl.h	/^  void Output(MutableFst<CompactArc>  *ofst, bool destroy = true) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::OutputStateId	determinize-lattice-inl.h	/^  typedef typename Arc::StateId OutputStateId;  \/\/ same as above but distinguish$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::PairComparator	determinize-lattice-inl.h	/^  class PairComparator {$/;"	c	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::PairComparator::operator ()	determinize-lattice-inl.h	/^    inline bool operator () (const pair<Label, Element> &p1, const pair<Label, Element> &p2) {$/;"	f	class:fst::LatticeDeterminizer::PairComparator
fst::LatticeDeterminizer::ProcessFinal	determinize-lattice-inl.h	/^  void ProcessFinal(OutputStateId output_state) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::ProcessState	determinize-lattice-inl.h	/^  void ProcessState(OutputStateId output_state) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::ProcessTransition	determinize-lattice-inl.h	/^  void ProcessTransition(OutputStateId state, Label ilabel, vector<Element> *subset) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::ProcessTransitions	determinize-lattice-inl.h	/^  void ProcessTransitions(OutputStateId output_state) {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::RebuildRepository	determinize-lattice-inl.h	/^  void RebuildRepository() { \/\/ rebuild the string repository,    $/;"	f	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::StateId	determinize-lattice-inl.h	/^  typedef typename Arc::StateId StateId;  \/\/ use this when we don't know if it's input or output.$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::StringId	determinize-lattice-inl.h	/^  typedef const typename StringRepositoryType::Entry* StringId;$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::StringRepositoryType	determinize-lattice-inl.h	/^  typedef LatticeStringRepository<IntType> StringRepositoryType;$/;"	t	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::SubsetEqual	determinize-lattice-inl.h	/^  class SubsetEqual {$/;"	c	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::SubsetEqual::SubsetEqual	determinize-lattice-inl.h	/^    SubsetEqual(): delta_(kDelta) {}$/;"	f	class:fst::LatticeDeterminizer::SubsetEqual
fst::LatticeDeterminizer::SubsetEqual::SubsetEqual	determinize-lattice-inl.h	/^    SubsetEqual(float delta): delta_(delta) {}$/;"	f	class:fst::LatticeDeterminizer::SubsetEqual
fst::LatticeDeterminizer::SubsetEqual::delta_	determinize-lattice-inl.h	/^    float delta_;$/;"	m	class:fst::LatticeDeterminizer::SubsetEqual
fst::LatticeDeterminizer::SubsetEqual::operator ()	determinize-lattice-inl.h	/^    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {$/;"	f	class:fst::LatticeDeterminizer::SubsetEqual
fst::LatticeDeterminizer::SubsetEqualStates	determinize-lattice-inl.h	/^  class SubsetEqualStates {$/;"	c	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::SubsetEqualStates::operator ()	determinize-lattice-inl.h	/^    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {$/;"	f	class:fst::LatticeDeterminizer::SubsetEqualStates
fst::LatticeDeterminizer::SubsetKey	determinize-lattice-inl.h	/^  class SubsetKey {$/;"	c	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::SubsetKey::operator ()	determinize-lattice-inl.h	/^    size_t operator ()(const vector<Element> * subset) const {  \/\/ hashes only the state and string.$/;"	f	class:fst::LatticeDeterminizer::SubsetKey
fst::LatticeDeterminizer::TempArc	determinize-lattice-inl.h	/^  struct TempArc {$/;"	s	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::TempArc::ilabel	determinize-lattice-inl.h	/^    Label ilabel;$/;"	m	struct:fst::LatticeDeterminizer::TempArc
fst::LatticeDeterminizer::TempArc::nextstate	determinize-lattice-inl.h	/^    OutputStateId nextstate;  \/\/ or kNoState for final weights.$/;"	m	struct:fst::LatticeDeterminizer::TempArc
fst::LatticeDeterminizer::TempArc::string	determinize-lattice-inl.h	/^    StringId string;  \/\/ Look it up in the StringRepository, it's a sequence of Labels.$/;"	m	struct:fst::LatticeDeterminizer::TempArc
fst::LatticeDeterminizer::TempArc::weight	determinize-lattice-inl.h	/^    Weight weight;$/;"	m	struct:fst::LatticeDeterminizer::TempArc
fst::LatticeDeterminizer::all_elems_tmp_	determinize-lattice-inl.h	/^  vector<pair<Label, Element> > all_elems_tmp_; \/\/ temporary vector used in ProcessTransitions.$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::determinized_	determinize-lattice-inl.h	/^  bool determinized_; \/\/ set to true when user called Determinize(); used to make$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::equal_	determinize-lattice-inl.h	/^  SubsetEqual equal_;  \/\/ object that compares subsets-- only data member is delta_.$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::hasher_	determinize-lattice-inl.h	/^  SubsetKey hasher_;  \/\/ object that computes keys-- has no data members.$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::ifst_	determinize-lattice-inl.h	/^  const Fst<Arc> *ifst_;$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::initial_hash_	determinize-lattice-inl.h	/^  InitialSubsetHash initial_hash_;   \/\/ hash from Subset to Element, which$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::isymbol_or_final_	determinize-lattice-inl.h	/^  vector<char> isymbol_or_final_; \/\/ A kind of cache; it says whether$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::minimal_hash_	determinize-lattice-inl.h	/^  MinimalSubsetHash minimal_hash_;  \/\/ hash from Subset to OutputStateId.  Subset is "minimal$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::num_arcs_	determinize-lattice-inl.h	/^  int num_arcs_; \/\/ keep track of memory usage: number of arcs in output_arcs_$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::num_elems_	determinize-lattice-inl.h	/^  int num_elems_; \/\/ keep track of memory usage: number of elems in output_states_$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::opts_	determinize-lattice-inl.h	/^  DeterminizeLatticeOptions opts_;$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::output_arcs_	determinize-lattice-inl.h	/^  vector<vector<TempArc> > output_arcs_;  \/\/ essentially an FST in our format.$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::output_states_	determinize-lattice-inl.h	/^  vector<vector<Element>* > output_states_; \/\/ maps from output state to$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::queue_	determinize-lattice-inl.h	/^  vector<OutputStateId> queue_; \/\/ Queue of output-states to process.  Starts with$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::repository_	determinize-lattice-inl.h	/^  LatticeStringRepository<IntType> repository_;  \/\/ defines a compact and fast way of$/;"	m	class:fst::LatticeDeterminizer
fst::LatticeDeterminizer::~LatticeDeterminizer	determinize-lattice-inl.h	/^  ~LatticeDeterminizer() {$/;"	f	class:fst::LatticeDeterminizer
fst::LatticeScale	lattice-utils.h	/^inline vector<vector<double> > LatticeScale(double lmwt, double acwt) {$/;"	f	namespace:fst
fst::LatticeStringRepository	determinize-lattice-inl.h	/^template<class IntType> class LatticeStringRepository {$/;"	c	namespace:fst
fst::LatticeStringRepository::CommonPrefix	determinize-lattice-inl.h	/^  const Entry *CommonPrefix (const Entry *a, const Entry *b) {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::Concatenate	determinize-lattice-inl.h	/^  const Entry *Concatenate (const Entry *a, const Entry *b) {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::ConvertFromVector	determinize-lattice-inl.h	/^  const Entry *ConvertFromVector(const vector<IntType> &vec) {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::ConvertToVector	determinize-lattice-inl.h	/^  void ConvertToVector(const Entry *entry, vector<IntType> *out) const {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::Destroy	determinize-lattice-inl.h	/^  void Destroy() {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::EmptyString	determinize-lattice-inl.h	/^  inline const Entry *EmptyString() { return NULL; }  $/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::Entry	determinize-lattice-inl.h	/^  struct Entry {$/;"	s	class:fst::LatticeStringRepository
fst::LatticeStringRepository::Entry::Entry	determinize-lattice-inl.h	/^    Entry() { }$/;"	f	struct:fst::LatticeStringRepository::Entry
fst::LatticeStringRepository::Entry::Entry	determinize-lattice-inl.h	/^    Entry(const Entry &e): parent(e.parent), i(e.i) {}$/;"	f	struct:fst::LatticeStringRepository::Entry
fst::LatticeStringRepository::Entry::i	determinize-lattice-inl.h	/^    IntType i;$/;"	m	struct:fst::LatticeStringRepository::Entry
fst::LatticeStringRepository::Entry::operator ==	determinize-lattice-inl.h	/^    inline bool operator == (const Entry &other) const {$/;"	f	struct:fst::LatticeStringRepository::Entry
fst::LatticeStringRepository::Entry::parent	determinize-lattice-inl.h	/^    const Entry *parent; \/\/ NULL for empty string.$/;"	m	struct:fst::LatticeStringRepository::Entry
fst::LatticeStringRepository::EntryEqual	determinize-lattice-inl.h	/^  class EntryEqual {$/;"	c	class:fst::LatticeStringRepository
fst::LatticeStringRepository::EntryEqual::operator ()	determinize-lattice-inl.h	/^    inline bool operator()(const Entry *e1, const Entry *e2) const {$/;"	f	class:fst::LatticeStringRepository::EntryEqual
fst::LatticeStringRepository::EntryKey	determinize-lattice-inl.h	/^  class EntryKey { \/\/ Hash function object.$/;"	c	class:fst::LatticeStringRepository
fst::LatticeStringRepository::EntryKey::operator ()	determinize-lattice-inl.h	/^    inline size_t operator()(const Entry *entry) const {$/;"	f	class:fst::LatticeStringRepository::EntryKey
fst::LatticeStringRepository::IsPrefixOf	determinize-lattice-inl.h	/^  bool IsPrefixOf(const Entry *a, const Entry *b) const {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::LatticeStringRepository	determinize-lattice-inl.h	/^  LatticeStringRepository() { new_entry_ = new Entry; }$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::MemSize	determinize-lattice-inl.h	/^  int32 MemSize() const {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::Rebuild	determinize-lattice-inl.h	/^  void Rebuild(const std::vector<const Entry*> &to_keep) {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::RebuildHelper	determinize-lattice-inl.h	/^  void RebuildHelper(const Entry *to_add, SetType *tmp_set) {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::ReduceToCommonPrefix	determinize-lattice-inl.h	/^  void ReduceToCommonPrefix(const Entry *a,$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::RemovePrefix	determinize-lattice-inl.h	/^  const Entry *RemovePrefix(const Entry *a, size_t n) {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::SetType	determinize-lattice-inl.h	/^  typedef unordered_set<const Entry*, EntryKey, EntryEqual> SetType;$/;"	t	class:fst::LatticeStringRepository
fst::LatticeStringRepository::Size	determinize-lattice-inl.h	/^  inline size_t Size(const Entry *entry) const {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::Successor	determinize-lattice-inl.h	/^  const Entry *Successor(const Entry *parent, IntType i) {$/;"	f	class:fst::LatticeStringRepository
fst::LatticeStringRepository::new_entry_	determinize-lattice-inl.h	/^  Entry *new_entry_; \/\/ We always have a pre-allocated Entry ready to use,$/;"	m	class:fst::LatticeStringRepository
fst::LatticeStringRepository::set_	determinize-lattice-inl.h	/^  SetType set_;$/;"	m	class:fst::LatticeStringRepository
fst::LatticeStringRepository::~LatticeStringRepository	determinize-lattice-inl.h	/^  ~LatticeStringRepository() { Destroy(); }$/;"	f	class:fst::LatticeStringRepository
fst::LatticeToStdMapper	lattice-utils.h	/^class LatticeToStdMapper {$/;"	c	namespace:fst
fst::LatticeToStdMapper::FinalAction	lattice-utils.h	/^  MapFinalAction FinalAction() { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::LatticeToStdMapper
fst::LatticeToStdMapper::InputSymbolsAction	lattice-utils.h	/^  MapSymbolsAction InputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::LatticeToStdMapper
fst::LatticeToStdMapper::LatticeArc	lattice-utils.h	/^  typedef ArcTpl<LatticeWeight> LatticeArc;$/;"	t	class:fst::LatticeToStdMapper
fst::LatticeToStdMapper::LatticeWeight	lattice-utils.h	/^  typedef LatticeWeightTpl<Int> LatticeWeight;$/;"	t	class:fst::LatticeToStdMapper
fst::LatticeToStdMapper::OutputSymbolsAction	lattice-utils.h	/^  MapSymbolsAction OutputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::LatticeToStdMapper
fst::LatticeToStdMapper::Properties	lattice-utils.h	/^  uint64 Properties(uint64 props) { return props; }$/;"	f	class:fst::LatticeToStdMapper
fst::LatticeToStdMapper::operator ()	lattice-utils.h	/^  StdArc operator()(const LatticeArc &arc) {$/;"	f	class:fst::LatticeToStdMapper
fst::LatticeWeight	lattice-weight-test.cc	/^typedef LatticeWeightTpl<BaseFloat> LatticeWeight;$/;"	t	namespace:fst	file:
fst::LatticeWeightTest	lattice-weight-test.cc	/^void LatticeWeightTest() {$/;"	f	namespace:fst
fst::LatticeWeightTpl	lattice-weight.h	/^class LatticeWeightTpl {$/;"	c	namespace:fst
fst::LatticeWeightTpl::Hash	lattice-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::LatticeWeightTpl	lattice-weight.h	/^  LatticeWeightTpl() { }$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::LatticeWeightTpl	lattice-weight.h	/^  LatticeWeightTpl(T a, T b): value1_(a), value2_(b) {}$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::LatticeWeightTpl	lattice-weight.h	/^  LatticeWeightTpl(const LatticeWeightTpl &other): value1_(other.value1_), value2_(other.value2_) { }$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Member	lattice-weight.h	/^  bool Member() const {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::NoWeight	lattice-weight.h	/^  static const LatticeWeightTpl NoWeight() {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::One	lattice-weight.h	/^  static const LatticeWeightTpl One() {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Properties	lattice-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Quantize	lattice-weight.h	/^  LatticeWeightTpl Quantize(float delta = kDelta) const {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Read	lattice-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::ReadFloatType	lattice-weight.h	/^  inline static void ReadFloatType(istream &strm, T &f) {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::ReadNoParen	lattice-weight.h	/^  inline istream &ReadNoParen($/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Reverse	lattice-weight.h	/^  LatticeWeightTpl<FloatType> Reverse() const {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::ReverseWeight	lattice-weight.h	/^  typedef LatticeWeightTpl ReverseWeight;$/;"	t	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::SetValue1	lattice-weight.h	/^  inline void SetValue1(T f) { value1_ = f; }$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::SetValue2	lattice-weight.h	/^  inline void SetValue2(T f) { value2_ = f; }$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::T	lattice-weight.h	/^  typedef FloatType T; \/\/ normally float.$/;"	t	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Type	lattice-weight.h	/^  static const string &Type() {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Value1	lattice-weight.h	/^  inline T Value1() const { return value1_; }$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Value2	lattice-weight.h	/^  inline T Value2() const { return value2_; }$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Write	lattice-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::WriteFloatType	lattice-weight.h	/^  inline static void WriteFloatType(ostream &strm, const T &f) {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::Zero	lattice-weight.h	/^  static const LatticeWeightTpl Zero() {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::operator =	lattice-weight.h	/^  LatticeWeightTpl &operator=(const LatticeWeightTpl &w) {$/;"	f	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::value1_	lattice-weight.h	/^  T value1_;$/;"	m	class:fst::LatticeWeightTpl
fst::LatticeWeightTpl::value2_	lattice-weight.h	/^  T value2_;$/;"	m	class:fst::LatticeWeightTpl
fst::LmExampleDeterministicOnDemandFst	deterministic-fst.h	/^class LmExampleDeterministicOnDemandFst: public DeterministicOnDemandFst<Arc> {$/;"	c	namespace:fst
fst::LmExampleDeterministicOnDemandFst::Final	deterministic-fst-inl.h	/^typename Arc::Weight LmExampleDeterministicOnDemandFst<Arc>::Final(StateId s) {$/;"	f	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::GetArc	deterministic-fst-inl.h	/^bool LmExampleDeterministicOnDemandFst<Arc>::GetArc($/;"	f	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::Label	deterministic-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::LmExampleDeterministicOnDemandFst	deterministic-fst-inl.h	/^LmExampleDeterministicOnDemandFst<Arc>::LmExampleDeterministicOnDemandFst($/;"	f	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::MapType	deterministic-fst.h	/^  typedef unordered_map<std::vector<Label>, StateId, kaldi::VectorHasher<Label> > MapType;$/;"	t	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::Start	deterministic-fst.h	/^  virtual StateId Start() { return start_state_; }$/;"	f	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::StateId	deterministic-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::Weight	deterministic-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::bos_symbol_	deterministic-fst.h	/^  Label bos_symbol_; \/\/ beginning of sentence symbol$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::eos_symbol_	deterministic-fst.h	/^  Label eos_symbol_; \/\/ end of sentence symbol.$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::lm	deterministic-fst.h	/^  void *lm; \/\/ wouldn't really be void.$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::lm_	deterministic-fst.h	/^  void *lm_;$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::start_state_	deterministic-fst.h	/^  StateId start_state_;$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::state_map_	deterministic-fst.h	/^  MapType state_map_;$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
fst::LmExampleDeterministicOnDemandFst::state_vec_	deterministic-fst.h	/^  std::vector<std::vector<Label> > state_vec_; \/\/ maps from history-state to pair.$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
fst::MakeFollowingInputSymbolsSame	fstext-utils-inl.h	/^void MakeFollowingInputSymbolsSame(bool end_is_epsilon, MutableFst<Arc> *fst) {$/;"	f	namespace:fst
fst::MakeFollowingInputSymbolsSameClass	fstext-utils-inl.h	/^void MakeFollowingInputSymbolsSameClass(bool end_is_epsilon, MutableFst<Arc> *fst, const F &f) {$/;"	f	namespace:fst
fst::MakeLinearAcceptor	fstext-utils-inl.h	/^void MakeLinearAcceptor(const vector<I> &labels, MutableFst<Arc> *ofst) {$/;"	f	namespace:fst
fst::MakeLinearAcceptorWithAlternatives	fstext-utils-inl.h	/^void MakeLinearAcceptorWithAlternatives(const vector<vector<I> > &labels,$/;"	f	namespace:fst
fst::MakeLoopFst	fstext-utils-inl.h	/^VectorFst<Arc>* MakeLoopFst(const vector<const ExpandedFst<Arc> *> &fsts) {$/;"	f	namespace:fst
fst::MakeLoopFstCompare	fstext-utils-test.cc	/^VectorFst<Arc>* MakeLoopFstCompare(const vector<const ExpandedFst<Arc> *> &fsts) {$/;"	f	namespace:fst
fst::MakePrecedingInputSymbolsSame	fstext-utils-inl.h	/^void MakePrecedingInputSymbolsSame(bool start_is_epsilon, MutableFst<Arc> *fst) {$/;"	f	namespace:fst
fst::MakePrecedingInputSymbolsSameClass	fstext-utils-inl.h	/^void MakePrecedingInputSymbolsSameClass(bool start_is_epsilon, MutableFst<Arc> *fst, const F &f) {$/;"	f	namespace:fst
fst::MapInputSymbols	fstext-utils-inl.h	/^void MapInputSymbols(const vector<I> &symbol_mapping,$/;"	f	namespace:fst
fst::MapInputSymbolsMapper	fstext-utils-inl.h	/^class MapInputSymbolsMapper {$/;"	c	namespace:fst
fst::MapInputSymbolsMapper::FinalAction	fstext-utils-inl.h	/^  MapFinalAction FinalAction() { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::MapInputSymbolsMapper
fst::MapInputSymbolsMapper::InputSymbolsAction	fstext-utils-inl.h	/^  MapSymbolsAction InputSymbolsAction() { return MAP_CLEAR_SYMBOLS; }$/;"	f	class:fst::MapInputSymbolsMapper
fst::MapInputSymbolsMapper::MapInputSymbolsMapper	fstext-utils-inl.h	/^  MapInputSymbolsMapper(const vector<I> &to_remove, bool copy) {$/;"	f	class:fst::MapInputSymbolsMapper
fst::MapInputSymbolsMapper::OutputSymbolsAction	fstext-utils-inl.h	/^  MapSymbolsAction OutputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::MapInputSymbolsMapper
fst::MapInputSymbolsMapper::Properties	fstext-utils-inl.h	/^  uint64 Properties(uint64 props) const {  \/\/ Not tested.$/;"	f	class:fst::MapInputSymbolsMapper
fst::MapInputSymbolsMapper::operator ()	fstext-utils-inl.h	/^  Arc operator ()(const Arc &arc_in) {$/;"	f	class:fst::MapInputSymbolsMapper
fst::MapInputSymbolsMapper::owned	fstext-utils-inl.h	/^  bool owned;$/;"	m	class:fst::MapInputSymbolsMapper
fst::MapInputSymbolsMapper::symbol_mapping_	fstext-utils-inl.h	/^  const vector<I> *symbol_mapping_;$/;"	m	class:fst::MapInputSymbolsMapper
fst::MapInputSymbolsMapper::~MapInputSymbolsMapper	fstext-utils-inl.h	/^  ~MapInputSymbolsMapper() { if (owned && symbol_mapping_ != NULL) delete symbol_mapping_; }$/;"	f	class:fst::MapInputSymbolsMapper
fst::MinimizeEncoded	fstext-utils.h	/^void MinimizeEncoded(VectorFst<Arc> *fst, float delta = kDelta) {$/;"	f	namespace:fst
fst::NaturalLess	lattice-weight.h	/^class NaturalLess<CompactLatticeWeightTpl<LatticeWeightTpl<FloatType>, IntType> > {$/;"	c	namespace:fst
fst::NaturalLess	lattice-weight.h	/^class NaturalLess<LatticeWeightTpl<FloatType> > {$/;"	c	namespace:fst
fst::NaturalLess::Weight	lattice-weight.h	/^  typedef CompactLatticeWeightTpl<LatticeWeightTpl<FloatType>, IntType> Weight;$/;"	t	class:fst::NaturalLess
fst::NaturalLess::Weight	lattice-weight.h	/^  typedef LatticeWeightTpl<FloatType> Weight;$/;"	t	class:fst::NaturalLess
fst::NaturalLess::operator ()	lattice-weight.h	/^  bool operator()(const Weight &w1, const Weight &w2) const {$/;"	f	class:fst::NaturalLess
fst::NbestAsFsts	fstext-utils-inl.h	/^void NbestAsFsts(const Fst<Arc> &fst,$/;"	f	namespace:fst
fst::NumArcs	fstext-utils-inl.h	/^typename Arc::StateId NumArcs(const ExpandedFst<Arc> &fst) {$/;"	f	namespace:fst
fst::PhiCompose	fstext-utils-inl.h	/^void PhiCompose(const Fst<Arc> &fst1,$/;"	f	namespace:fst
fst::Plus	lattice-weight.h	/^inline CompactLatticeWeightTpl<WeightType, IntType> Plus($/;"	f	namespace:fst
fst::Plus	lattice-weight.h	/^inline LatticeWeightTpl<FloatType> Plus(const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
fst::PreDeterminize	pre-determinize-inl.h	/^void PreDeterminize(MutableFst<Arc> *fst,$/;"	f	namespace:fst
fst::PrecedingInputSymbolsAreSame	fstext-utils-inl.h	/^bool PrecedingInputSymbolsAreSame(bool start_is_epsilon, const Fst<Arc> &fst) {$/;"	f	namespace:fst
fst::PrecedingInputSymbolsAreSameClass	fstext-utils-inl.h	/^bool PrecedingInputSymbolsAreSameClass(bool start_is_epsilon, const Fst<Arc> &fst, const F &f) {$/;"	f	namespace:fst
fst::Print	fstext-utils-test.cc	/^template<class Arc> void Print(const Fst<Arc> &fst, std::string message) {$/;"	f	namespace:fst
fst::PropagateFinal	fstext-utils-inl.h	/^void PropagateFinal(typename Arc::Label phi_label,$/;"	f	namespace:fst
fst::PropagateFinalInternal	fstext-utils-inl.h	/^void PropagateFinalInternal($/;"	f	namespace:fst
fst::PushInLog	fstext-utils.h	/^void PushInLog(VectorFst<StdArc> *fst, uint32 ptype, float delta = kDelta) {$/;"	f	namespace:fst
fst::PushSpecial	push-special.cc	/^void PushSpecial(VectorFst<StdArc> *fst, float delta) {$/;"	f	namespace:fst
fst::PushSpecialClass	push-special.cc	/^class PushSpecialClass {$/;"	c	namespace:fst	file:
fst::PushSpecialClass::Arc	push-special.cc	/^  typedef StdArc Arc;$/;"	t	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::Iterate	push-special.cc	/^  void Iterate(float delta) {$/;"	f	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::ModifyFst	push-special.cc	/^  void ModifyFst() {$/;"	f	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::PushSpecialClass	push-special.cc	/^  PushSpecialClass(VectorFst<StdArc> *fst,$/;"	f	class:fst::PushSpecialClass
fst::PushSpecialClass::StateId	push-special.cc	/^  typedef Arc::StateId StateId;$/;"	t	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::TestAccuracy	push-special.cc	/^  double TestAccuracy() { \/\/ returns the error (the difference$/;"	f	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::Weight	push-special.cc	/^  typedef Arc::Weight Weight;$/;"	t	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::fst_	push-special.cc	/^  VectorFst<StdArc> *fst_;$/;"	m	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::initial_state_	push-special.cc	/^  StateId initial_state_;$/;"	m	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::lambda_	push-special.cc	/^  double lambda_; \/\/ our current estimate of the top eigenvalue.$/;"	m	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::num_states_	push-special.cc	/^  StateId num_states_;$/;"	m	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::occ_	push-special.cc	/^  std::vector<double> occ_; \/\/ the top eigenvector of (matrix of weights) transposed.$/;"	m	class:fst::PushSpecialClass	file:
fst::PushSpecialClass::pred_	push-special.cc	/^  std::vector<std::vector<std::pair<StateId, double> > > pred_; \/\/ List of transitions$/;"	m	class:fst::PushSpecialClass	file:
fst::RandFst	rand-fst.h	/^template<class Arc> VectorFst<Arc>* RandFst(RandFstOptions opts = RandFstOptions() ) {$/;"	f	namespace:fst
fst::RandFstOptions	rand-fst.h	/^struct RandFstOptions {$/;"	s	namespace:fst
fst::RandFstOptions::RandFstOptions	rand-fst.h	/^  RandFstOptions() {  \/\/ Initializes the options randomly.$/;"	f	struct:fst::RandFstOptions
fst::RandFstOptions::acyclic	rand-fst.h	/^  bool acyclic;$/;"	m	struct:fst::RandFstOptions
fst::RandFstOptions::allow_empty	rand-fst.h	/^  bool allow_empty;$/;"	m	struct:fst::RandFstOptions
fst::RandFstOptions::n_arcs	rand-fst.h	/^  size_t n_arcs;$/;"	m	struct:fst::RandFstOptions
fst::RandFstOptions::n_final	rand-fst.h	/^  size_t n_final;$/;"	m	struct:fst::RandFstOptions
fst::RandFstOptions::n_states	rand-fst.h	/^  size_t n_states;$/;"	m	struct:fst::RandFstOptions
fst::RandFstOptions::n_syms	rand-fst.h	/^  size_t n_syms;$/;"	m	struct:fst::RandFstOptions
fst::RandFstOptions::weight_multiplier	rand-fst.h	/^  float weight_multiplier;$/;"	m	struct:fst::RandFstOptions
fst::RandPairFst	rand-fst.h	/^template<class Arc> VectorFst<Arc>* RandPairFst(RandFstOptions opts = RandFstOptions() ) {$/;"	f	namespace:fst
fst::RandomCompactLatticeWeight	lattice-weight-test.cc	/^CompactLatticeWeight RandomCompactLatticeWeight() {$/;"	f	namespace:fst
fst::RandomLatticeWeight	lattice-weight-test.cc	/^LatticeWeight RandomLatticeWeight() {$/;"	f	namespace:fst
fst::ReadFstKaldi	fstext-utils-inl.h	/^inline VectorFst<StdArc> *ReadFstKaldi(std::string rxfilename) {$/;"	f	namespace:fst
fst::ReadILabelInfo	context-fst-inl.h	/^void ReadILabelInfo(std::istream &is, bool binary,$/;"	f	namespace:fst
fst::RemoveAlignmentsFromCompactLattice	lattice-utils-inl.h	/^void RemoveAlignmentsFromCompactLattice($/;"	f	namespace:fst
fst::RemoveEpsLocal	remove-eps-local-inl.h	/^void RemoveEpsLocal(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
fst::RemoveEpsLocalClass	remove-eps-local-inl.h	/^class RemoveEpsLocalClass {$/;"	c	namespace:fst
fst::RemoveEpsLocalClass::CanCombineArcs	remove-eps-local-inl.h	/^  bool CanCombineArcs(const Arc &a, const Arc &b, Arc *c) {$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::CanCombineFinal	remove-eps-local-inl.h	/^  static bool CanCombineFinal(const Arc &a, Weight final_prob, Weight *final_prob_out) {$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::CheckNumArcs	remove-eps-local-inl.h	/^  bool CheckNumArcs() {  \/\/ check num arcs in\/out of each state, at end.  Debug.$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::GetArc	remove-eps-local-inl.h	/^  inline void GetArc(StateId s, size_t pos, Arc *arc) const {$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::InitNumArcs	remove-eps-local-inl.h	/^  void InitNumArcs() {  \/\/ init num transitions in\/out of each state.$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::Label	remove-eps-local-inl.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::RemoveEps	remove-eps-local-inl.h	/^  void RemoveEps(StateId s, size_t pos) {$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::RemoveEpsLocalClass	remove-eps-local-inl.h	/^  RemoveEpsLocalClass(MutableFst<Arc> *fst):$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::RemoveEpsPattern1	remove-eps-local-inl.h	/^  void RemoveEpsPattern1(StateId s, size_t pos, Arc arc) {$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::RemoveEpsPattern2	remove-eps-local-inl.h	/^  void RemoveEpsPattern2(StateId s, size_t pos, Arc arc) {$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::Reweight	remove-eps-local-inl.h	/^  void Reweight(StateId s, size_t pos, Weight reweight) {$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::SetArc	remove-eps-local-inl.h	/^  inline void SetArc(StateId s, size_t pos, const Arc &arc) {$/;"	f	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::StateId	remove-eps-local-inl.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::Weight	remove-eps-local-inl.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::fst_	remove-eps-local-inl.h	/^  MutableFst<Arc> *fst_;$/;"	m	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::non_coacc_state_	remove-eps-local-inl.h	/^  StateId non_coacc_state_;  \/\/  use this to delete arcs: make it nextstate$/;"	m	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::num_arcs_in_	remove-eps-local-inl.h	/^  vector<StateId> num_arcs_in_;$/;"	m	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::num_arcs_out_	remove-eps-local-inl.h	/^  vector<StateId> num_arcs_out_;$/;"	m	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalClass::reweight_plus_	remove-eps-local-inl.h	/^  ReweightPlus reweight_plus_;$/;"	m	class:fst::RemoveEpsLocalClass
fst::RemoveEpsLocalSpecial	remove-eps-local-inl.h	/^void RemoveEpsLocalSpecial(MutableFst<StdArc> *fst) {$/;"	f	namespace:fst
fst::RemoveSomeInputSymbols	fstext-utils-inl.h	/^void RemoveSomeInputSymbols(const vector<I> &to_remove,$/;"	f	namespace:fst
fst::RemoveSomeInputSymbolsMapper	factor-inl.h	/^class RemoveSomeInputSymbolsMapper {$/;"	c	namespace:fst
fst::RemoveSomeInputSymbolsMapper::FinalAction	factor-inl.h	/^  MapFinalAction FinalAction() { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
fst::RemoveSomeInputSymbolsMapper::InputSymbolsAction	factor-inl.h	/^  MapSymbolsAction InputSymbolsAction() { return MAP_CLEAR_SYMBOLS; }$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
fst::RemoveSomeInputSymbolsMapper::OutputSymbolsAction	factor-inl.h	/^  MapSymbolsAction OutputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
fst::RemoveSomeInputSymbolsMapper::Properties	factor-inl.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
fst::RemoveSomeInputSymbolsMapper::RemoveSomeInputSymbolsMapper	factor-inl.h	/^  RemoveSomeInputSymbolsMapper(const vector<I> &to_remove):$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
fst::RemoveSomeInputSymbolsMapper::operator ()	factor-inl.h	/^  Arc operator ()(const Arc &arc_in) {$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
fst::RemoveSomeInputSymbolsMapper::to_remove_set_	factor-inl.h	/^  kaldi::ConstIntegerSet<I> to_remove_set_;$/;"	m	class:fst::RemoveSomeInputSymbolsMapper
fst::RemoveUselessArcs	fstext-utils-inl.h	/^void RemoveUselessArcs(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
fst::RemoveWeights	fstext-utils-inl.h	/^void RemoveWeights(MutableFst<Arc> *ifst) {$/;"	f	namespace:fst
fst::Rescale	rescale-inl.h	/^inline void Rescale(MutableFst<Arc> *fst, typename Arc::Weight rescale) {$/;"	f	namespace:fst
fst::RescaleToStochastic	rescale-inl.h	/^inline LogWeight RescaleToStochastic(MutableFst<LogArc> *fst,$/;"	f	namespace:fst
fst::ReweightPlusDefault	remove-eps-local-inl.h	/^struct ReweightPlusDefault {$/;"	s	namespace:fst
fst::ReweightPlusDefault::operator ()	remove-eps-local-inl.h	/^  inline Weight operator () (const Weight &a, const Weight &b) {$/;"	f	struct:fst::ReweightPlusDefault
fst::ReweightPlusLogArc	remove-eps-local-inl.h	/^struct ReweightPlusLogArc {$/;"	s	namespace:fst
fst::ReweightPlusLogArc::operator ()	remove-eps-local-inl.h	/^  inline TropicalWeight operator () (const TropicalWeight &a, const TropicalWeight &b) {$/;"	f	struct:fst::ReweightPlusLogArc
fst::RhoCompose	fstext-utils-inl.h	/^void RhoCompose(const Fst<Arc> &fst1,$/;"	f	namespace:fst
fst::SafeDeterminizeMinimizeWrapper	fstext-utils-inl.h	/^void SafeDeterminizeMinimizeWrapper(MutableFst<Arc> *ifst, VectorFst<Arc> *ofst, float delta) {$/;"	f	namespace:fst
fst::SafeDeterminizeMinimizeWrapperInLog	fstext-utils-inl.h	/^void SafeDeterminizeMinimizeWrapperInLog(VectorFst<StdArc> *ifst, VectorFst<StdArc> *ofst, float delta) {$/;"	f	namespace:fst
fst::SafeDeterminizeWrapper	fstext-utils-inl.h	/^void SafeDeterminizeWrapper(MutableFst<Arc> *ifst, MutableFst<Arc> *ofst, float delta) {$/;"	f	namespace:fst
fst::SafeDeterminizeWrapperInLog	fstext-utils-inl.h	/^void SafeDeterminizeWrapperInLog(VectorFst<StdArc> *ifst, VectorFst<StdArc> *ofst, float delta) {$/;"	f	namespace:fst
fst::ScaleLattice	lattice-utils-inl.h	/^void ScaleLattice($/;"	f	namespace:fst
fst::ScaleTupleWeight	lattice-weight.h	/^                  TropicalWeightTpl<FloatType> > ScaleTupleWeight($/;"	f	namespace:fst
fst::ScaleTupleWeight	lattice-weight.h	/^inline CompactLatticeWeightTpl<Weight, IntType> ScaleTupleWeight($/;"	f	namespace:fst
fst::ScaleTupleWeight	lattice-weight.h	/^inline LatticeWeightTpl<FloatType> ScaleTupleWeight($/;"	f	namespace:fst
fst::StateId	deterministic-fst-test.cc	/^typedef fst::StdArc::StateId StateId;$/;"	t	namespace:fst	file:
fst::StateIterator	context-fst.h	/^class StateIterator< ContextFst<A> >$/;"	c	namespace:fst
fst::StateIterator	trivial-factor-weight.h	/^class StateIterator< TrivialFactorWeightFst<A, F> >$/;"	c	namespace:fst
fst::StateIterator::StateIterator	context-fst.h	/^  explicit StateIterator(const ContextFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	trivial-factor-weight.h	/^  explicit StateIterator(const TrivialFactorWeightFst<A, F> &fst)$/;"	f	class:fst::StateIterator
fst::StatePropertiesEnum	factor.h	/^enum  StatePropertiesEnum$/;"	g	namespace:fst
fst::StatePropertiesType	factor.h	/^typedef unsigned char StatePropertiesType;$/;"	t	namespace:fst
fst::StdArc	deterministic-fst-test.cc	/^typedef fst::StdArc          StdArc;$/;"	t	namespace:fst	file:
fst::StdToLatticeMapper	lattice-utils.h	/^class StdToLatticeMapper {$/;"	c	namespace:fst
fst::StdToLatticeMapper::FinalAction	lattice-utils.h	/^  MapFinalAction FinalAction() { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::StdToLatticeMapper
fst::StdToLatticeMapper::InputSymbolsAction	lattice-utils.h	/^  MapSymbolsAction InputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::StdToLatticeMapper
fst::StdToLatticeMapper::LatticeArc	lattice-utils.h	/^  typedef ArcTpl<LatticeWeight> LatticeArc;$/;"	t	class:fst::StdToLatticeMapper
fst::StdToLatticeMapper::LatticeWeight	lattice-utils.h	/^  typedef LatticeWeightTpl<Int> LatticeWeight;$/;"	t	class:fst::StdToLatticeMapper
fst::StdToLatticeMapper::OutputSymbolsAction	lattice-utils.h	/^  MapSymbolsAction OutputSymbolsAction() { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::StdToLatticeMapper
fst::StdToLatticeMapper::Properties	lattice-utils.h	/^  uint64 Properties(uint64 props) { return props; }$/;"	f	class:fst::StdToLatticeMapper
fst::StdToLatticeMapper::operator ()	lattice-utils.h	/^  LatticeArc operator()(const StdArc &arc) {$/;"	f	class:fst::StdToLatticeMapper
fst::StdVectorFst	deterministic-fst-test.cc	/^typedef fst::StdVectorFst    StdVectorFst;$/;"	t	namespace:fst	file:
fst::StringRepository	determinize-star-inl.h	/^template<class Label, class StringId> class StringRepository {$/;"	c	namespace:fst
fst::StringRepository::Destroy	determinize-star-inl.h	/^  void Destroy() {$/;"	f	class:fst::StringRepository
fst::StringRepository::IdOfEmpty	determinize-star-inl.h	/^  StringId IdOfEmpty() { return no_symbol; }$/;"	f	class:fst::StringRepository
fst::StringRepository::IdOfLabel	determinize-star-inl.h	/^  StringId IdOfLabel(Label l) {$/;"	f	class:fst::StringRepository
fst::StringRepository::IdOfSeq	determinize-star-inl.h	/^  StringId IdOfSeq(const vector<Label> &v) {  \/\/ also works for sizes 0 and 1.$/;"	f	class:fst::StringRepository
fst::StringRepository::IdOfSeqInternal	determinize-star-inl.h	/^  StringId IdOfSeqInternal(const vector<Label> &v) {$/;"	f	class:fst::StringRepository
fst::StringRepository::IsEmptyString	determinize-star-inl.h	/^  inline bool IsEmptyString(StringId id) {$/;"	f	class:fst::StringRepository
fst::StringRepository::MapType	determinize-star-inl.h	/^  typedef unordered_map<const vector<Label>*, StringId, VectorKey, VectorEqual> MapType;$/;"	t	class:fst::StringRepository
fst::StringRepository::RemovePrefix	determinize-star-inl.h	/^  StringId RemovePrefix(StringId id, size_t prefix_len) {$/;"	f	class:fst::StringRepository
fst::StringRepository::SeqOfId	determinize-star-inl.h	/^  void SeqOfId(StringId id, vector<Label> *v) {$/;"	f	class:fst::StringRepository
fst::StringRepository::StringRepository	determinize-star-inl.h	/^  StringRepository() {$/;"	f	class:fst::StringRepository
fst::StringRepository::VectorEqual	determinize-star-inl.h	/^  class VectorEqual {  \/\/ Equality-operator function object.$/;"	c	class:fst::StringRepository
fst::StringRepository::VectorEqual::operator ()	determinize-star-inl.h	/^    size_t operator()(const vector<Label> *vec1, const vector<Label> *vec2) const {$/;"	f	class:fst::StringRepository::VectorEqual
fst::StringRepository::VectorKey	determinize-star-inl.h	/^  class VectorKey { \/\/ Hash function object.$/;"	c	class:fst::StringRepository
fst::StringRepository::VectorKey::operator ()	determinize-star-inl.h	/^    size_t operator()(const vector<Label> *vec) const {$/;"	f	class:fst::StringRepository::VectorKey
fst::StringRepository::map_	determinize-star-inl.h	/^  MapType map_;$/;"	m	class:fst::StringRepository
fst::StringRepository::no_symbol	determinize-star-inl.h	/^  StringId no_symbol;  \/\/ = (numeric_limits<StringId>::max() \/ 2); \/\/ reserved for empty sequence.$/;"	m	class:fst::StringRepository
fst::StringRepository::single_symbol_range	determinize-star-inl.h	/^  StringId single_symbol_range;  \/\/ =  numeric_limits<StringId>::max() - single_symbol_start;$/;"	m	class:fst::StringRepository
fst::StringRepository::single_symbol_start	determinize-star-inl.h	/^  StringId single_symbol_start;  \/\/ =  (numeric_limits<StringId>::max() \/ 2) + 1;$/;"	m	class:fst::StringRepository
fst::StringRepository::string_end	determinize-star-inl.h	/^  StringId string_end;  \/\/ = (numeric_limits<StringId>::max() \/ 2) - 1; \/\/ all hash values must be <= this.$/;"	m	class:fst::StringRepository
fst::StringRepository::string_start	determinize-star-inl.h	/^  static const StringId string_start = (StringId) 0;  \/\/ This must not change.  It's assumed.$/;"	m	class:fst::StringRepository
fst::StringRepository::vec_	determinize-star-inl.h	/^  vector<vector<Label>* > vec_;$/;"	m	class:fst::StringRepository
fst::StringRepository::~StringRepository	determinize-star-inl.h	/^  ~StringRepository() {$/;"	f	class:fst::StringRepository
fst::TableCompose	table-matcher.h	/^void TableCompose(const Fst<Arc> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
fst::TableComposeCache	table-matcher.h	/^struct TableComposeCache {$/;"	s	namespace:fst
fst::TableComposeCache::TableComposeCache	table-matcher.h	/^  TableComposeCache(const TableComposeOptions &opts = TableComposeOptions()): matcher (NULL), opts(opts) {}$/;"	f	struct:fst::TableComposeCache
fst::TableComposeCache::matcher	table-matcher.h	/^  TableMatcher<F> *matcher;$/;"	m	struct:fst::TableComposeCache
fst::TableComposeCache::opts	table-matcher.h	/^  TableComposeOptions opts;$/;"	m	struct:fst::TableComposeCache
fst::TableComposeCache::~TableComposeCache	table-matcher.h	/^  ~TableComposeCache() { if (matcher) delete(matcher); }$/;"	f	struct:fst::TableComposeCache
fst::TableComposeOptions	table-matcher.h	/^struct TableComposeOptions: public TableMatcherOptions {$/;"	s	namespace:fst
fst::TableComposeOptions::TableComposeOptions	table-matcher.h	/^  TableComposeOptions() : connect(true), filter_type(SEQUENCE_FILTER),$/;"	f	struct:fst::TableComposeOptions
fst::TableComposeOptions::TableComposeOptions	table-matcher.h	/^  explicit TableComposeOptions(const TableMatcherOptions &mo,$/;"	f	struct:fst::TableComposeOptions
fst::TableComposeOptions::connect	table-matcher.h	/^  bool connect;  \/\/ Connect output$/;"	m	struct:fst::TableComposeOptions
fst::TableComposeOptions::filter_type	table-matcher.h	/^  ComposeFilter filter_type;  \/\/ Which pre-defined filter to use$/;"	m	struct:fst::TableComposeOptions
fst::TableComposeOptions::table_match_type	table-matcher.h	/^  MatchType table_match_type;$/;"	m	struct:fst::TableComposeOptions
fst::TableMatcher	table-matcher.h	/^class TableMatcher : public MatcherBase<typename F::Arc> {$/;"	c	namespace:fst
fst::TableMatcher::Arc	table-matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::TableMatcher
fst::TableMatcher::ArcId	table-matcher.h	/^  typedef StateId ArcId;  \/\/ Use this type to store arc offsets [it's actually size_t$/;"	t	class:fst::TableMatcher
fst::TableMatcher::Copy	table-matcher.h	/^  virtual TableMatcher<FST, BackoffMatcher> *Copy(bool safe = false) const {$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Done	table-matcher.h	/^  bool Done() const { return impl_->Done(); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Done_	table-matcher.h	/^  virtual bool Done_() const { return impl_->Done(); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::FST	table-matcher.h	/^  typedef F FST;$/;"	t	class:fst::TableMatcher
fst::TableMatcher::Find	table-matcher.h	/^  bool Find(Label match_label) { return impl_->Find(match_label); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Find_	table-matcher.h	/^  virtual bool Find_(Label label) { return impl_->Find(label); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::GetFst	table-matcher.h	/^  virtual const FST &GetFst() const { return impl_->GetFst(); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Label	table-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::TableMatcher
fst::TableMatcher::Next	table-matcher.h	/^  void Next() { return impl_->Next(); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Next_	table-matcher.h	/^  virtual void Next_() { impl_->Next(); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Properties	table-matcher.h	/^  virtual uint64 Properties(uint64 props) const { return impl_->Properties(props); } \/\/ simple matcher that does$/;"	f	class:fst::TableMatcher
fst::TableMatcher::SetState	table-matcher.h	/^  void SetState(StateId s) { return impl_->SetState(s); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::SetState_	table-matcher.h	/^  virtual void SetState_(StateId s) { impl_->SetState(s); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::StateId	table-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::TableMatcher
fst::TableMatcher::TableMatcher	table-matcher.h	/^  TableMatcher(const FST &fst, MatchType match_type,$/;"	f	class:fst::TableMatcher
fst::TableMatcher::TableMatcher	table-matcher.h	/^  TableMatcher(const TableMatcher<FST, BackoffMatcher> &matcher, bool safe):$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Type	table-matcher.h	/^  virtual MatchType Type(bool test) const { return impl_->Type(test);  }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Value	table-matcher.h	/^  const Arc &Value() {  return impl_->Value(); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Value	table-matcher.h	/^  const Arc& Value() const { return impl_->Value(); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Value_	table-matcher.h	/^  virtual const Arc& Value_() const { return impl_->Value(); }$/;"	f	class:fst::TableMatcher
fst::TableMatcher::Weight	table-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::TableMatcher
fst::TableMatcher::impl_	table-matcher.h	/^  TableMatcherImpl<F, BackoffMatcher> *impl_;$/;"	m	class:fst::TableMatcher
fst::TableMatcher::~TableMatcher	table-matcher.h	/^  virtual ~TableMatcher() {$/;"	f	class:fst::TableMatcher
fst::TableMatcherImpl	table-matcher.h	/^class TableMatcherImpl : public MatcherBase<typename F::Arc> {$/;"	c	namespace:fst
fst::TableMatcherImpl::Arc	table-matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::TableMatcherImpl
fst::TableMatcherImpl::ArcId	table-matcher.h	/^  typedef StateId ArcId;  \/\/ Use this type to store arc offsets [it's actually size_t$/;"	t	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Copy	table-matcher.h	/^  virtual TableMatcherImpl<FST> *Copy(bool safe = false) const {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::DecrRefCount	table-matcher.h	/^  int DecrRefCount() {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Done	table-matcher.h	/^  bool Done() const {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Done_	table-matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::FST	table-matcher.h	/^  typedef F FST;$/;"	t	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Find	table-matcher.h	/^  bool Find(Label match_label) {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Find_	table-matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::GetFst	table-matcher.h	/^  virtual const FST &GetFst() const { return *fst_; }$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::IncrRefCount	table-matcher.h	/^  int IncrRefCount() {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Label	table-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Next	table-matcher.h	/^  void Next() {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Next_	table-matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Properties	table-matcher.h	/^  virtual uint64 Properties(uint64 props) const { return props; } \/\/ simple matcher that does$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::RefCount	table-matcher.h	/^  int RefCount() const {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::SetState	table-matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::SetState_	table-matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::StateId	table-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::TableMatcherImpl
fst::TableMatcherImpl::TableMatcherImpl	table-matcher.h	/^  TableMatcherImpl(const FST &fst, MatchType match_type,$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Type	table-matcher.h	/^  virtual MatchType Type(bool test) const {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Value	table-matcher.h	/^  const Arc &Value() {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Value	table-matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Value_	table-matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherImpl::Weight	table-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::TableMatcherImpl
fst::TableMatcherImpl::aiter_	table-matcher.h	/^  ArcIterator<FST> *aiter_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::backoff_matcher_	table-matcher.h	/^  BackoffMatcher backoff_matcher_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::current_loop_	table-matcher.h	/^  bool current_loop_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::fst_	table-matcher.h	/^  FST *fst_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::loop_	table-matcher.h	/^  Arc loop_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::match_label_	table-matcher.h	/^  Label match_label_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::match_type_	table-matcher.h	/^  MatchType match_type_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::opts_	table-matcher.h	/^  TableMatcherOptions opts_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::ref_count_	table-matcher.h	/^  RefCounter ref_count_;        \/\/ Reference count$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::s_	table-matcher.h	/^  StateId s_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::tables_	table-matcher.h	/^  vector<vector<ArcId> *> tables_;$/;"	m	class:fst::TableMatcherImpl
fst::TableMatcherImpl::~TableMatcherImpl	table-matcher.h	/^  virtual ~TableMatcherImpl() {$/;"	f	class:fst::TableMatcherImpl
fst::TableMatcherOptions	table-matcher.h	/^struct TableMatcherOptions {$/;"	s	namespace:fst
fst::TableMatcherOptions::TableMatcherOptions	table-matcher.h	/^  TableMatcherOptions(): table_ratio(0.25), min_table_size(4) { }$/;"	f	struct:fst::TableMatcherOptions
fst::TableMatcherOptions::min_table_size	table-matcher.h	/^  int min_table_size;$/;"	m	struct:fst::TableMatcherOptions
fst::TableMatcherOptions::table_ratio	table-matcher.h	/^  float table_ratio;  \/\/ we construct the table if it would be at least this full.$/;"	m	struct:fst::TableMatcherOptions
fst::TestAcceptorMinimize	fstext-utils-test.cc	/^template<class Arc>  void TestAcceptorMinimize() {$/;"	f	namespace:fst
fst::TestAddSelfLoops	pre-determinize-test.cc	/^template<class Arc>  void TestAddSelfLoops() {$/;"	f	namespace:fst
fst::TestBackoffAndCache	deterministic-fst-test.cc	/^void TestBackoffAndCache() {$/;"	f	namespace:fst
fst::TestCompose	deterministic-fst-test.cc	/^void TestCompose() {$/;"	f	namespace:fst
fst::TestComputeTotalWeight	rescale-test.cc	/^template<class Arc> void TestComputeTotalWeight() {$/;"	f	namespace:fst
fst::TestContextFst	context-fst-test.cc	/^template<class Arc> static void TestContextFst(bool verbose, bool use_matcher) {$/;"	f	namespace:fst
fst::TestConvert	lattice-utils-test.cc	/^template<class Weight, class Int> void TestConvert(bool invert) {$/;"	f	namespace:fst
fst::TestConvert2	lattice-utils-test.cc	/^template<class Int> void TestConvert2() {$/;"	f	namespace:fst
fst::TestConvertPair	lattice-utils-test.cc	/^template<class Weight, class Int> void TestConvertPair(bool invert) {$/;"	f	namespace:fst
fst::TestDeterminize	determinize-star-test.cc	/^template<class Arc>  void TestDeterminize() {$/;"	f	namespace:fst
fst::TestDeterminize2	determinize-star-test.cc	/^template<class Arc>  void TestDeterminize2() {$/;"	f	namespace:fst
fst::TestDeterminizeGeneral	determinize-star-test.cc	/^template<class Arc> void TestDeterminizeGeneral() {$/;"	f	namespace:fst
fst::TestDeterminizeLattice	determinize-lattice-test.cc	/^template<class Arc> void TestDeterminizeLattice() {$/;"	f	namespace:fst
fst::TestDeterminizeLattice2	determinize-lattice-test.cc	/^template<class Arc> void TestDeterminizeLattice2() {$/;"	f	namespace:fst
fst::TestDeterminizeStarInLog	fstext-utils-test.cc	/^template<class Arc>  void TestDeterminizeStarInLog() {$/;"	f	namespace:fst
fst::TestEnsureEpsilonProperty	epsilon-property-test.cc	/^void TestEnsureEpsilonProperty() {$/;"	f	namespace:fst
fst::TestEqualAlign	fstext-utils-test.cc	/^void TestEqualAlign() {$/;"	f	namespace:fst
fst::TestFactor	factor-test.cc	/^template<class Arc> static void TestFactor() {$/;"	f	namespace:fst
fst::TestFactor	trivial-factor-weight-test.cc	/^template<class Arc>  void TestFactor() {$/;"	f	namespace:fst
fst::TestFunctor	fstext-utils-test.cc	/^struct TestFunctor {$/;"	s	namespace:fst	file:
fst::TestFunctor::Arg	fstext-utils-test.cc	/^  typedef typename Arc::Label Arg;$/;"	t	struct:fst::TestFunctor	file:
fst::TestFunctor::Result	fstext-utils-test.cc	/^  typedef int32 Result;$/;"	t	struct:fst::TestFunctor	file:
fst::TestFunctor::operator ()	fstext-utils-test.cc	/^  Result operator () (Arg a) const {$/;"	f	struct:fst::TestFunctor
fst::TestLatticeStringRepository	determinize-lattice-test.cc	/^void TestLatticeStringRepository() {$/;"	f	namespace:fst
fst::TestMakeLinearAcceptor	fstext-utils-test.cc	/^void TestMakeLinearAcceptor() {$/;"	f	namespace:fst
fst::TestMakeLoopFst	fstext-utils-test.cc	/^template<class Arc>  void TestMakeLoopFst() {$/;"	f	namespace:fst
fst::TestMakeSymbolsSame	fstext-utils-test.cc	/^template<class Arc>  void TestMakeSymbolsSame() {$/;"	f	namespace:fst
fst::TestMakeSymbolsSameClass	fstext-utils-test.cc	/^template<class Arc>  void TestMakeSymbolsSameClass() {$/;"	f	namespace:fst
fst::TestMinimize	determinize-star-test.cc	/^template<class Arc>  void TestMinimize() {$/;"	f	namespace:fst
fst::TestPreDeterminize	pre-determinize-test.cc	/^template<class Arc>  void TestPreDeterminize() {$/;"	f	namespace:fst
fst::TestPush	determinize-star-test.cc	/^template<class Arc>  void TestPush() {$/;"	f	namespace:fst
fst::TestPushInLog	fstext-utils-test.cc	/^void TestPushInLog() {  \/\/ also tests SafeDeterminizeMinimizeWrapper().$/;"	f	namespace:fst
fst::TestPushSpecial	push-special-test.cc	/^static void TestPushSpecial() {$/;"	f	namespace:fst
fst::TestRemoveEpsLocal	remove-eps-local-test.cc	/^template<class Arc> static void TestRemoveEpsLocal() {$/;"	f	namespace:fst
fst::TestRemoveEpsLocalSpecial	remove-eps-local-test.cc	/^static void TestRemoveEpsLocalSpecial() {$/;"	f	namespace:fst
fst::TestRemoveUselessArcs	fstext-utils-test.cc	/^void TestRemoveUselessArcs() {$/;"	f	namespace:fst
fst::TestRescaleToStochastic	rescale-test.cc	/^void TestRescaleToStochastic() {$/;"	f	namespace:fst
fst::TestSafeDeterminizeWrapper	fstext-utils-test.cc	/^template<class Arc>  void TestSafeDeterminizeWrapper() {  \/\/ also tests SafeDeterminizeMinimizeWrapper().$/;"	f	namespace:fst
fst::TestScalePair	lattice-utils-test.cc	/^template<class Weight, class Int> void TestScalePair(bool invert) {$/;"	f	namespace:fst
fst::TestShortestPath	lattice-utils-test.cc	/^template<class Weight, class Int> void TestShortestPath() {$/;"	f	namespace:fst
fst::TestStringRepository	determinize-star-test.cc	/^template<class Arc, class inttype> void TestStringRepository() {$/;"	f	namespace:fst
fst::TestStringRepository	trivial-factor-weight-test.cc	/^template<class Arc, class inttype> void TestStringRepository() {$/;"	f	namespace:fst
fst::TestTableMatcher	table-matcher-test.cc	/^template<class Arc>  void TestTableMatcher(bool connect, bool left) {$/;"	f	namespace:fst
fst::TestTableMatcherCacheLeft	table-matcher-test.cc	/^template<class Arc>  void TestTableMatcherCacheLeft(bool connect) {$/;"	f	namespace:fst
fst::TestTableMatcherCacheRight	table-matcher-test.cc	/^template<class Arc>  void TestTableMatcherCacheRight(bool connect) {$/;"	f	namespace:fst
fst::Times	lattice-weight.h	/^inline CompactLatticeWeightTpl<WeightType, IntType> Times($/;"	f	namespace:fst
fst::Times	lattice-weight.h	/^inline LatticeWeightTpl<FloatType> Times(const LatticeWeightTpl<FloatType> &w1,$/;"	f	namespace:fst
fst::TrivialFactorWeightFst	trivial-factor-weight.h	/^class TrivialFactorWeightFst : public ImplToFst< TrivialFactorWeightFstImpl<A, F> > {$/;"	c	namespace:fst
fst::TrivialFactorWeightFst::Arc	trivial-factor-weight.h	/^  typedef A Arc;$/;"	t	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::Copy	trivial-factor-weight.h	/^  virtual TrivialFactorWeightFst<A, F> *Copy(bool copy = false) const {$/;"	f	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::GetImpl	trivial-factor-weight.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::Impl	trivial-factor-weight.h	/^  typedef TrivialFactorWeightFstImpl<A, F> Impl;$/;"	t	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::InitArcIterator	trivial-factor-weight.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::InitStateIterator	trivial-factor-weight.h	/^void TrivialFactorWeightFst<A, F>::InitStateIterator(StateIteratorData<A> *data) const$/;"	f	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::State	trivial-factor-weight.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::StateId	trivial-factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::TrivialFactorWeightFst	trivial-factor-weight.h	/^  TrivialFactorWeightFst(const Fst<A> &fst)$/;"	f	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::TrivialFactorWeightFst	trivial-factor-weight.h	/^  TrivialFactorWeightFst(const Fst<A> &fst,  const TrivialFactorWeightOptions<A> &opts)$/;"	f	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::TrivialFactorWeightFst	trivial-factor-weight.h	/^  TrivialFactorWeightFst(const TrivialFactorWeightFst<A, F> &fst, bool copy)$/;"	f	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFst::Weight	trivial-factor-weight.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::TrivialFactorWeightFst
fst::TrivialFactorWeightFstImpl	trivial-factor-weight.h	/^class TrivialFactorWeightFstImpl$/;"	c	namespace:fst
fst::TrivialFactorWeightFstImpl::Arc	trivial-factor-weight.h	/^  typedef A Arc;$/;"	t	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::Element	trivial-factor-weight.h	/^  struct Element {$/;"	s	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::Element::Element	trivial-factor-weight.h	/^    Element() {}$/;"	f	struct:fst::TrivialFactorWeightFstImpl::Element
fst::TrivialFactorWeightFstImpl::Element::Element	trivial-factor-weight.h	/^    Element(StateId s, Weight w) : state(s), weight(w) {}$/;"	f	struct:fst::TrivialFactorWeightFstImpl::Element
fst::TrivialFactorWeightFstImpl::Element::state	trivial-factor-weight.h	/^    StateId state;     \/\/ Input state Id$/;"	m	struct:fst::TrivialFactorWeightFstImpl::Element
fst::TrivialFactorWeightFstImpl::Element::weight	trivial-factor-weight.h	/^    Weight weight;     \/\/ Residual weight$/;"	m	struct:fst::TrivialFactorWeightFstImpl::Element
fst::TrivialFactorWeightFstImpl::ElementEqual	trivial-factor-weight.h	/^  class ElementEqual {$/;"	c	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::ElementEqual::operator ()	trivial-factor-weight.h	/^    bool operator()(const Element &x, const Element &y) const {$/;"	f	class:fst::TrivialFactorWeightFstImpl::ElementEqual
fst::TrivialFactorWeightFstImpl::ElementKey	trivial-factor-weight.h	/^  class ElementKey {$/;"	c	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::ElementKey::kPrime	trivial-factor-weight.h	/^    static const int kPrime = 7853;$/;"	m	class:fst::TrivialFactorWeightFstImpl::ElementKey
fst::TrivialFactorWeightFstImpl::ElementKey::operator ()	trivial-factor-weight.h	/^    size_t operator()(const Element &x) const {$/;"	f	class:fst::TrivialFactorWeightFstImpl::ElementKey
fst::TrivialFactorWeightFstImpl::ElementMap	trivial-factor-weight.h	/^  typedef unordered_map<Element, StateId, ElementKey, ElementEqual> ElementMap;$/;"	t	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::Expand	trivial-factor-weight.h	/^  void Expand(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::FactorIterator	trivial-factor-weight.h	/^  typedef F FactorIterator;$/;"	t	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::Final	trivial-factor-weight.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::FindState	trivial-factor-weight.h	/^  StateId FindState(const Element &e) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::InitArcIterator	trivial-factor-weight.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::Label	trivial-factor-weight.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::NumArcs	trivial-factor-weight.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::NumInputEpsilons	trivial-factor-weight.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::NumOutputEpsilons	trivial-factor-weight.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::Start	trivial-factor-weight.h	/^  StateId Start() {$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::StateId	trivial-factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::TrivialFactorWeightFstImpl	trivial-factor-weight.h	/^  TrivialFactorWeightFstImpl(const Fst<A> &fst, const TrivialFactorWeightOptions<A> &opts)$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::TrivialFactorWeightFstImpl	trivial-factor-weight.h	/^  TrivialFactorWeightFstImpl(const TrivialFactorWeightFstImpl<A, F> &impl)$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::Weight	trivial-factor-weight.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::delta_	trivial-factor-weight.h	/^  float delta_;$/;"	m	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::element_map_	trivial-factor-weight.h	/^  ElementMap element_map_;    \/\/ mapping Elements to Fst state$/;"	m	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::elements_	trivial-factor-weight.h	/^  vector<Element> elements_;  \/\/ mapping Fst state to Elements$/;"	m	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::extra_ilabel_	trivial-factor-weight.h	/^  Label extra_ilabel_;        \/\/ ilabel of arc created when factoring final w's$/;"	m	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::extra_olabel_	trivial-factor-weight.h	/^  Label extra_olabel_;        \/\/ olabel of arc created when factoring final w's$/;"	m	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::fst_	trivial-factor-weight.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::mode_	trivial-factor-weight.h	/^  uint32 mode_;               \/\/ factoring arc and\/or final weights$/;"	m	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightFstImpl::~TrivialFactorWeightFstImpl	trivial-factor-weight.h	/^  ~TrivialFactorWeightFstImpl() {$/;"	f	class:fst::TrivialFactorWeightFstImpl
fst::TrivialFactorWeightOptions	trivial-factor-weight.h	/^struct TrivialFactorWeightOptions : CacheOptions {$/;"	s	namespace:fst
fst::TrivialFactorWeightOptions::Label	trivial-factor-weight.h	/^  typedef typename Arc::Label Label;$/;"	t	struct:fst::TrivialFactorWeightOptions
fst::TrivialFactorWeightOptions::TrivialFactorWeightOptions	trivial-factor-weight.h	/^  TrivialFactorWeightOptions(): delta(kDelta), extra_ilabel(0), extra_olabel(0) {}$/;"	f	struct:fst::TrivialFactorWeightOptions
fst::TrivialFactorWeightOptions::TrivialFactorWeightOptions	trivial-factor-weight.h	/^  TrivialFactorWeightOptions(const CacheOptions &opts, float d,$/;"	f	struct:fst::TrivialFactorWeightOptions
fst::TrivialFactorWeightOptions::TrivialFactorWeightOptions	trivial-factor-weight.h	/^  explicit TrivialFactorWeightOptions($/;"	f	struct:fst::TrivialFactorWeightOptions
fst::TrivialFactorWeightOptions::delta	trivial-factor-weight.h	/^  float delta;$/;"	m	struct:fst::TrivialFactorWeightOptions
fst::TrivialFactorWeightOptions::extra_ilabel	trivial-factor-weight.h	/^  Label extra_ilabel;  \/\/ input label of extra arcs$/;"	m	struct:fst::TrivialFactorWeightOptions
fst::TrivialFactorWeightOptions::extra_olabel	trivial-factor-weight.h	/^  Label extra_olabel;  \/\/ output label of extra arcs$/;"	m	struct:fst::TrivialFactorWeightOptions
fst::VectorFstHolder	fstext-utils.h	/^typedef VectorFstTplHolder<StdArc> VectorFstHolder;$/;"	t	namespace:fst
fst::VectorFstTplHolder	fstext-utils.h	/^class VectorFstTplHolder {$/;"	c	namespace:fst
fst::VectorFstTplHolder::Clear	fstext-utils.h	/^  void Clear() {$/;"	f	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::Copy	fstext-utils.h	/^  void Copy(const T &t) {  \/\/ copies it into the holder.$/;"	f	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::IsReadInBinary	fstext-utils.h	/^  static bool IsReadInBinary() { return true; }$/;"	f	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::Read	fstext-utils.h	/^  bool Read(std::istream &is) {$/;"	f	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::StateId	fstext-utils.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::StrToWeight	fstext-utils.h	/^  static bool StrToWeight(const std::string &s, bool allow_zero, Weight *w) {$/;"	f	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::T	fstext-utils.h	/^  typedef VectorFst<Arc> T;$/;"	t	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::Value	fstext-utils.h	/^  const T &Value() {$/;"	f	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::VectorFstTplHolder	fstext-utils.h	/^  VectorFstTplHolder(): t_(NULL) { }$/;"	f	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::Weight	fstext-utils.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::Write	fstext-utils.h	/^  static bool Write(std::ostream &os, bool binary, const T &t) {$/;"	f	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::t_	fstext-utils.h	/^  T *t_;$/;"	m	class:fst::VectorFstTplHolder
fst::VectorFstTplHolder::~VectorFstTplHolder	fstext-utils.h	/^  ~VectorFstTplHolder() { Clear(); }$/;"	f	class:fst::VectorFstTplHolder
fst::WalkSinglePath	deterministic-fst-test.cc	/^Weight WalkSinglePath(StdVectorFst *ifst, DeterministicOnDemandFst<StdArc> *dfst) {$/;"	f	namespace:fst
fst::Weight	deterministic-fst-test.cc	/^typedef fst::StdArc::Weight  Weight;$/;"	t	namespace:fst	file:
fst::WriteFstKaldi	fstext-utils-inl.h	/^inline void WriteFstKaldi(const VectorFst<StdArc> &fst,$/;"	f	namespace:fst
fst::WriteILabelInfo	context-fst-inl.h	/^void WriteILabelInfo(std::ostream &os, bool binary,$/;"	f	namespace:fst
fst::kStateArcsIn	factor.h	/^  kStateArcsIn = 0x4,$/;"	e	enum:fst::StatePropertiesEnum
fst::kStateArcsOut	factor.h	/^  kStateArcsOut = 0x10,$/;"	e	enum:fst::StatePropertiesEnum
fst::kStateFinal	factor.h	/^{ kStateFinal = 0x1,$/;"	e	enum:fst::StatePropertiesEnum
fst::kStateHasEpsilonArcsEntering	epsilon-property.h	/^  kStateHasEpsilonArcsEntering = 0x1,$/;"	e	enum:fst::__anon1
fst::kStateHasEpsilonArcsLeaving	epsilon-property.h	/^  kStateHasEpsilonArcsLeaving = 0x4,$/;"	e	enum:fst::__anon1
fst::kStateHasNonEpsilonArcsEntering	epsilon-property.h	/^  kStateHasNonEpsilonArcsEntering = 0x2,$/;"	e	enum:fst::__anon1
fst::kStateHasNonEpsilonArcsLeaving	epsilon-property.h	/^  kStateHasNonEpsilonArcsLeaving = 0x8$/;"	e	enum:fst::__anon1
fst::kStateIlabelsOut	factor.h	/^  kStateIlabelsOut = 0x80 }; $/;"	e	enum:fst::StatePropertiesEnum
fst::kStateInitial	factor.h	/^  kStateInitial = 0x2,$/;"	e	enum:fst::StatePropertiesEnum
fst::kStateMultipleArcsIn	factor.h	/^  kStateMultipleArcsIn = 0x8,$/;"	e	enum:fst::StatePropertiesEnum
fst::kStateMultipleArcsOut	factor.h	/^  kStateMultipleArcsOut = 0x20,$/;"	e	enum:fst::StatePropertiesEnum
fst::kStateOlabelsOut	factor.h	/^  kStateOlabelsOut = 0x40,$/;"	e	enum:fst::StatePropertiesEnum
fst::operator !=	lattice-weight.h	/^inline bool operator!=(const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
fst::operator !=	lattice-weight.h	/^inline bool operator!=(const LatticeWeightTpl<FloatType> &wa,$/;"	f	namespace:fst
fst::operator <<	lattice-weight.h	/^inline ostream &operator <<(ostream &strm, const CompactLatticeWeightTpl<WeightType, IntType> &w) {$/;"	f	namespace:fst
fst::operator <<	lattice-weight.h	/^inline ostream &operator <<(ostream &strm, const LatticeWeightTpl<FloatType> &w) {$/;"	f	namespace:fst
fst::operator ==	lattice-weight.h	/^inline bool operator==(const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
fst::operator ==	lattice-weight.h	/^inline bool operator==(const LatticeWeightTpl<FloatType> &wa,$/;"	f	namespace:fst
fst::operator >>	lattice-weight.h	/^inline istream &operator >>(istream &strm, CompactLatticeWeightTpl<WeightType, IntType> &w) {$/;"	f	namespace:fst
fst::operator >>	lattice-weight.h	/^inline istream &operator >>(istream &strm, LatticeWeightTpl<FloatType> &w1) {$/;"	f	namespace:fst
fst::pre_determinize_helpers	pre-determinize-inl.h	/^namespace pre_determinize_helpers {$/;"	n	namespace:fst
fst::pre_determinize_helpers::Closure	pre-determinize-inl.h	/^template<class Arc> void Closure(MutableFst<Arc> *fst, std::set<typename Arc::StateId> *S,$/;"	f	namespace:fst::pre_determinize_helpers
fst::pre_determinize_helpers::CopySetToVector	pre-determinize-inl.h	/^template<class T> void CopySetToVector(const std::set<T> s, vector<T> *v) {$/;"	f	namespace:fst::pre_determinize_helpers
fst::pre_determinize_helpers::HasBannedPrefixPlusDigits	pre-determinize-inl.h	/^inline bool HasBannedPrefixPlusDigits(SymbolTable *symTable, std::string prefix, std::string *bad_sym) {$/;"	f	namespace:fst::pre_determinize_helpers
fst::pre_determinize_helpers::InsertMember	pre-determinize-inl.h	/^vector<T>* InsertMember(const vector<T> m, vector<vector<T>*> *S) {$/;"	f	namespace:fst::pre_determinize_helpers
fst_	context-fst.h	/^  const FST *fst_;$/;"	m	class:fst::ContextMatcher
fst_	deterministic-fst.h	/^  DeterministicOnDemandFst<Arc> *fst_;$/;"	m	class:fst::CacheDeterministicOnDemandFst
fst_	deterministic-fst.h	/^  const Fst<Arc> &fst_;$/;"	m	class:fst::BackoffDeterministicOnDemandFst
fst_	push-special.cc	/^  VectorFst<StdArc> *fst_;$/;"	m	class:fst::PushSpecialClass	file:
fst_	remove-eps-local-inl.h	/^  MutableFst<Arc> *fst_;$/;"	m	class:fst::RemoveEpsLocalClass
fst_	table-matcher.h	/^  FST *fst_;$/;"	m	class:fst::TableMatcherImpl
fst_	trivial-factor-weight.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::TrivialFactorWeightFstImpl
hash_	determinize-star-inl.h	/^  SubsetHash hash_;  \/\/ hash from Subset to StateId in final Fst.$/;"	m	class:fst::DeterminizerStar
hasher_	determinize-lattice-inl.h	/^  SubsetKey hasher_;  \/\/ object that computes keys-- has no data members.$/;"	m	class:fst::LatticeDeterminizer
hasher_	determinize-star-inl.h	/^  SubsetKey hasher_;  \/\/ object that computes keys-- has no data members.$/;"	m	class:fst::DeterminizerStar
i	determinize-lattice-inl.h	/^    IntType i;$/;"	m	struct:fst::LatticeStringRepository::Entry
ifst_	determinize-lattice-inl.h	/^  const Fst<Arc> *ifst_;$/;"	m	class:fst::LatticeDeterminizer
ifst_	determinize-star-inl.h	/^  const Fst<Arc> *ifst_;$/;"	m	class:fst::DeterminizerStar
ilabel	determinize-lattice-inl.h	/^    Label ilabel;$/;"	m	struct:fst::LatticeDeterminizer::TempArc
ilabel	determinize-star-inl.h	/^    Label ilabel;$/;"	m	struct:fst::DeterminizerStar::TempArc
ilabel_info_	context-fst.h	/^  vector<vector<LabelT> > ilabel_info_;$/;"	m	class:fst::ContextFstImpl
ilabel_map_	context-fst.h	/^  VectorToLabelType ilabel_map_;$/;"	m	class:fst::ContextFstImpl
impl_	context-fst.h	/^  ContextFstImpl<Arc, LabelT> *impl_;  \/\/ protected so CacheStateIterator$/;"	m	class:fst::ContextFst
impl_	table-matcher.h	/^  TableMatcherImpl<F, BackoffMatcher> *impl_;$/;"	m	class:fst::TableMatcher
initial_hash_	determinize-lattice-inl.h	/^  InitialSubsetHash initial_hash_;   \/\/ hash from Subset to Element, which$/;"	m	class:fst::LatticeDeterminizer
initial_state_	push-special.cc	/^  StateId initial_state_;$/;"	m	class:fst::PushSpecialClass	file:
isymbol_or_final_	determinize-lattice-inl.h	/^  vector<char> isymbol_or_final_; \/\/ A kind of cache; it says whether$/;"	m	class:fst::LatticeDeterminizer
kPrime	trivial-factor-weight.h	/^    static const int kPrime = 7853;$/;"	m	class:fst::TrivialFactorWeightFstImpl::ElementKey
kStateArcsIn	factor.h	/^  kStateArcsIn = 0x4,$/;"	e	enum:fst::StatePropertiesEnum
kStateArcsOut	factor.h	/^  kStateArcsOut = 0x10,$/;"	e	enum:fst::StatePropertiesEnum
kStateFinal	factor.h	/^{ kStateFinal = 0x1,$/;"	e	enum:fst::StatePropertiesEnum
kStateHasEpsilonArcsEntering	epsilon-property.h	/^  kStateHasEpsilonArcsEntering = 0x1,$/;"	e	enum:fst::__anon1
kStateHasEpsilonArcsLeaving	epsilon-property.h	/^  kStateHasEpsilonArcsLeaving = 0x4,$/;"	e	enum:fst::__anon1
kStateHasNonEpsilonArcsEntering	epsilon-property.h	/^  kStateHasNonEpsilonArcsEntering = 0x2,$/;"	e	enum:fst::__anon1
kStateHasNonEpsilonArcsLeaving	epsilon-property.h	/^  kStateHasNonEpsilonArcsLeaving = 0x8$/;"	e	enum:fst::__anon1
kStateIlabelsOut	factor.h	/^  kStateIlabelsOut = 0x80 }; $/;"	e	enum:fst::StatePropertiesEnum
kStateInitial	factor.h	/^  kStateInitial = 0x2,$/;"	e	enum:fst::StatePropertiesEnum
kStateMultipleArcsIn	factor.h	/^  kStateMultipleArcsIn = 0x8,$/;"	e	enum:fst::StatePropertiesEnum
kStateMultipleArcsOut	factor.h	/^  kStateMultipleArcsOut = 0x20,$/;"	e	enum:fst::StatePropertiesEnum
kStateOlabelsOut	factor.h	/^  kStateOlabelsOut = 0x40,$/;"	e	enum:fst::StatePropertiesEnum
lambda_	push-special.cc	/^  double lambda_; \/\/ our current estimate of the top eigenvalue.$/;"	m	class:fst::PushSpecialClass	file:
lm	deterministic-fst.h	/^  void *lm; \/\/ wouldn't really be void.$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
lm_	deterministic-fst.h	/^  void *lm_;$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
loop_	table-matcher.h	/^  Arc loop_;$/;"	m	class:fst::TableMatcherImpl
main	context-fst-test.cc	/^int main() {$/;"	f
main	deterministic-fst-test.cc	/^int main() {$/;"	f
main	determinize-lattice-test.cc	/^int main() {$/;"	f
main	determinize-star-test.cc	/^int main() {$/;"	f
main	epsilon-property-test.cc	/^int main() {$/;"	f
main	factor-test.cc	/^int main() {$/;"	f
main	fstext-utils-test.cc	/^int main() {$/;"	f
main	lattice-utils-test.cc	/^int main() {$/;"	f
main	lattice-weight-test.cc	/^int main() {$/;"	f
main	pre-determinize-test.cc	/^int main() {$/;"	f
main	push-special-test.cc	/^int main() {$/;"	f
main	remove-eps-local-test.cc	/^int main() {$/;"	f
main	rescale-test.cc	/^int main() {$/;"	f
main	table-matcher-test.cc	/^int main() {$/;"	f
main	trivial-factor-weight-test.cc	/^int main() {$/;"	f
map_	determinize-star-inl.h	/^  MapType map_;$/;"	m	class:fst::StringRepository
match_label_	context-fst.h	/^  Label match_label_;             \/\/ Current label to be matched$/;"	m	class:fst::ContextMatcher
match_label_	table-matcher.h	/^  Label match_label_;$/;"	m	class:fst::TableMatcherImpl
match_type_	context-fst.h	/^  MatchType match_type_;          \/\/ Type of match to perform$/;"	m	class:fst::ContextMatcher
match_type_	table-matcher.h	/^  MatchType match_type_;$/;"	m	class:fst::TableMatcherImpl
matcher	table-matcher.h	/^  TableMatcher<F> *matcher;$/;"	m	struct:fst::TableComposeCache
max_loop	determinize-lattice.h	/^  int max_loop; \/\/ If >0, can be used to detect non-determinizable input$/;"	m	struct:fst::DeterminizeLatticeOptions
max_mem	determinize-lattice.h	/^  int max_mem; \/\/ If >0, determinization will fail and return false$/;"	m	struct:fst::DeterminizeLatticeOptions
max_states_	determinize-star-inl.h	/^  int max_states_;$/;"	m	class:fst::DeterminizerStar
min_table_size	table-matcher.h	/^  int min_table_size;$/;"	m	struct:fst::TableMatcherOptions
minimal_hash_	determinize-lattice-inl.h	/^  MinimalSubsetHash minimal_hash_;  \/\/ hash from Subset to OutputStateId.  Subset is "minimal$/;"	m	class:fst::LatticeDeterminizer
mode_	trivial-factor-weight.h	/^  uint32 mode_;               \/\/ factoring arc and\/or final weights$/;"	m	class:fst::TrivialFactorWeightFstImpl
n_arcs	rand-fst.h	/^  size_t n_arcs;$/;"	m	struct:fst::RandFstOptions
n_final	rand-fst.h	/^  size_t n_final;$/;"	m	struct:fst::RandFstOptions
n_states	rand-fst.h	/^  size_t n_states;$/;"	m	struct:fst::RandFstOptions
n_syms	rand-fst.h	/^  size_t n_syms;$/;"	m	struct:fst::RandFstOptions
new_entry_	determinize-lattice-inl.h	/^  Entry *new_entry_; \/\/ We always have a pre-allocated Entry ready to use,$/;"	m	class:fst::LatticeStringRepository
next_state_	deterministic-fst.h	/^  StateId next_state_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
nextstate	determinize-lattice-inl.h	/^    OutputStateId nextstate;  \/\/ or kNoState for final weights.$/;"	m	struct:fst::LatticeDeterminizer::TempArc
nextstate	determinize-star-inl.h	/^    OutputStateId nextstate;  \/\/ or kNoState for final weights.$/;"	m	struct:fst::DeterminizerStar::TempArc
no_symbol	determinize-star-inl.h	/^  StringId no_symbol;  \/\/ = (numeric_limits<StringId>::max() \/ 2); \/\/ reserved for empty sequence.$/;"	m	class:fst::StringRepository
non_coacc_state_	remove-eps-local-inl.h	/^  StateId non_coacc_state_;  \/\/  use this to delete arcs: make it nextstate$/;"	m	class:fst::RemoveEpsLocalClass
num_arcs_	determinize-lattice-inl.h	/^  int num_arcs_; \/\/ keep track of memory usage: number of arcs in output_arcs_$/;"	m	class:fst::LatticeDeterminizer
num_arcs_in_	remove-eps-local-inl.h	/^  vector<StateId> num_arcs_in_;$/;"	m	class:fst::RemoveEpsLocalClass
num_arcs_out_	remove-eps-local-inl.h	/^  vector<StateId> num_arcs_out_;$/;"	m	class:fst::RemoveEpsLocalClass
num_cached_arcs_	deterministic-fst.h	/^  StateId num_cached_arcs_;  $/;"	m	class:fst::CacheDeterministicOnDemandFst
num_elems_	determinize-lattice-inl.h	/^  int num_elems_; \/\/ keep track of memory usage: number of elems in output_states_$/;"	m	class:fst::LatticeDeterminizer
num_states_	push-special.cc	/^  StateId num_states_;$/;"	m	class:fst::PushSpecialClass	file:
occ_	push-special.cc	/^  std::vector<double> occ_; \/\/ the top eigenvector of (matrix of weights) transposed.$/;"	m	class:fst::PushSpecialClass	file:
operator !=	determinize-lattice-inl.h	/^    bool operator != (const Element &other) const {$/;"	f	struct:fst::LatticeDeterminizer::Element
operator !=	determinize-star-inl.h	/^    bool operator != (const Element &other) const  {$/;"	f	struct:fst::DeterminizerStar::Element
operator !=	lattice-weight.h	/^inline bool operator!=(const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
operator !=	lattice-weight.h	/^inline bool operator!=(const LatticeWeightTpl<FloatType> &wa,$/;"	f	namespace:fst
operator ()	determinize-lattice-inl.h	/^    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {$/;"	f	class:fst::LatticeDeterminizer::SubsetEqual
operator ()	determinize-lattice-inl.h	/^    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {$/;"	f	class:fst::LatticeDeterminizer::SubsetEqualStates
operator ()	determinize-lattice-inl.h	/^    inline bool operator () (const pair<Label, Element> &p1, const pair<Label, Element> &p2) {$/;"	f	class:fst::LatticeDeterminizer::PairComparator
operator ()	determinize-lattice-inl.h	/^    inline bool operator()(const Entry *e1, const Entry *e2) const {$/;"	f	class:fst::LatticeStringRepository::EntryEqual
operator ()	determinize-lattice-inl.h	/^    inline size_t operator()(const Entry *entry) const {$/;"	f	class:fst::LatticeStringRepository::EntryKey
operator ()	determinize-lattice-inl.h	/^    size_t operator ()(const vector<Element> * subset) const {  \/\/ hashes only the state and string.$/;"	f	class:fst::LatticeDeterminizer::SubsetKey
operator ()	determinize-star-inl.h	/^    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {$/;"	f	class:fst::DeterminizerStar::SubsetEqual
operator ()	determinize-star-inl.h	/^    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {$/;"	f	class:fst::DeterminizerStar::SubsetEqualStates
operator ()	determinize-star-inl.h	/^    inline bool operator () (const pair<Label, Element> &p1, const pair<Label, Element> &p2) {$/;"	f	class:fst::DeterminizerStar::PairComparator
operator ()	determinize-star-inl.h	/^    size_t operator ()(const vector<Element> * subset) const {  \/\/ hashes only the state and string.$/;"	f	class:fst::DeterminizerStar::SubsetKey
operator ()	determinize-star-inl.h	/^    size_t operator()(const vector<Label> *vec) const {$/;"	f	class:fst::StringRepository::VectorKey
operator ()	determinize-star-inl.h	/^    size_t operator()(const vector<Label> *vec1, const vector<Label> *vec2) const {$/;"	f	class:fst::StringRepository::VectorEqual
operator ()	factor-inl.h	/^  Arc operator ()(const Arc &arc_in) {$/;"	f	class:fst::RemoveSomeInputSymbolsMapper
operator ()	fstext-utils-inl.h	/^  Arc operator ()(const Arc &arc_in) {$/;"	f	class:fst::MapInputSymbolsMapper
operator ()	fstext-utils-inl.h	/^  T operator () (const T &t) const { return t; }$/;"	f	struct:fst::IdentityFunction
operator ()	fstext-utils-test.cc	/^  Result operator () (Arg a) const {$/;"	f	struct:fst::TestFunctor
operator ()	lattice-utils.h	/^  LatticeArc operator()(const StdArc &arc) {$/;"	f	class:fst::StdToLatticeMapper
operator ()	lattice-utils.h	/^  StdArc operator()(const LatticeArc &arc) {$/;"	f	class:fst::LatticeToStdMapper
operator ()	lattice-weight.h	/^  Weight operator()(const Weight &w1, const Weight &w2) const {$/;"	f	class:fst::CompactLatticeWeightCommonDivisorTpl
operator ()	lattice-weight.h	/^  bool operator()(const Weight &w1, const Weight &w2) const {$/;"	f	class:fst::NaturalLess
operator ()	remove-eps-local-inl.h	/^  inline TropicalWeight operator () (const TropicalWeight &a, const TropicalWeight &b) {$/;"	f	struct:fst::ReweightPlusLogArc
operator ()	remove-eps-local-inl.h	/^  inline Weight operator () (const Weight &a, const Weight &b) {$/;"	f	struct:fst::ReweightPlusDefault
operator ()	trivial-factor-weight.h	/^    bool operator()(const Element &x, const Element &y) const {$/;"	f	class:fst::TrivialFactorWeightFstImpl::ElementEqual
operator ()	trivial-factor-weight.h	/^    size_t operator()(const Element &x) const {$/;"	f	class:fst::TrivialFactorWeightFstImpl::ElementKey
operator <<	lattice-weight.h	/^inline ostream &operator <<(ostream &strm, const CompactLatticeWeightTpl<WeightType, IntType> &w) {$/;"	f	namespace:fst
operator <<	lattice-weight.h	/^inline ostream &operator <<(ostream &strm, const LatticeWeightTpl<FloatType> &w) {$/;"	f	namespace:fst
operator =	lattice-weight.h	/^  CompactLatticeWeightTpl &operator=(const CompactLatticeWeightTpl<WeightType, IntType> &w) {$/;"	f	class:fst::CompactLatticeWeightTpl
operator =	lattice-weight.h	/^  LatticeWeightTpl &operator=(const LatticeWeightTpl &w) {$/;"	f	class:fst::LatticeWeightTpl
operator ==	determinize-lattice-inl.h	/^    inline bool operator == (const Entry &other) const {$/;"	f	struct:fst::LatticeStringRepository::Entry
operator ==	lattice-weight.h	/^inline bool operator==(const CompactLatticeWeightTpl<WeightType, IntType> &w1,$/;"	f	namespace:fst
operator ==	lattice-weight.h	/^inline bool operator==(const LatticeWeightTpl<FloatType> &wa,$/;"	f	namespace:fst
operator >>	lattice-weight.h	/^inline istream &operator >>(istream &strm, CompactLatticeWeightTpl<WeightType, IntType> &w) {$/;"	f	namespace:fst
operator >>	lattice-weight.h	/^inline istream &operator >>(istream &strm, LatticeWeightTpl<FloatType> &w1) {$/;"	f	namespace:fst
opts	table-matcher.h	/^  TableComposeOptions opts;$/;"	m	struct:fst::TableComposeCache
opts_	determinize-lattice-inl.h	/^  DeterminizeLatticeOptions opts_;$/;"	m	class:fst::LatticeDeterminizer
opts_	table-matcher.h	/^  TableMatcherOptions opts_;$/;"	m	class:fst::TableMatcherImpl
order_	factor.h	/^  vector<StateId> *order_;$/;"	m	class:fst::DfsOrderVisitor
ostring	determinize-star-inl.h	/^    StringId ostring;  \/\/ Look it up in the StringRepository, it's a sequence of Labels.$/;"	m	struct:fst::DeterminizerStar::TempArc
output_arcs_	determinize-lattice-inl.h	/^  vector<vector<TempArc> > output_arcs_;  \/\/ essentially an FST in our format.$/;"	m	class:fst::LatticeDeterminizer
output_arcs_	determinize-star-inl.h	/^  vector<vector<TempArc> > output_arcs_;  \/\/ essentially an FST in our format.$/;"	m	class:fst::DeterminizerStar
output_states_	determinize-lattice-inl.h	/^  vector<vector<Element>* > output_states_; \/\/ maps from output state to$/;"	m	class:fst::LatticeDeterminizer
owned	fstext-utils-inl.h	/^  bool owned;$/;"	m	class:fst::MapInputSymbolsMapper
parent	determinize-lattice-inl.h	/^    const Entry *parent; \/\/ NULL for empty string.$/;"	m	struct:fst::LatticeStringRepository::Entry
phone_syms_	context-fst.h	/^  kaldi::ConstIntegerSet<Label> phone_syms_;$/;"	m	class:fst::ContextFstImpl
pre_determinize_helpers	pre-determinize-inl.h	/^namespace pre_determinize_helpers {$/;"	n	namespace:fst
pred_	push-special.cc	/^  std::vector<std::vector<std::pair<StateId, double> > > pred_; \/\/ List of transitions$/;"	m	class:fst::PushSpecialClass	file:
pseudo_eps_symbol_	context-fst.h	/^  int pseudo_eps_symbol_;  \/\/ This is the symbol we put on epsilon arcs at the start$/;"	m	class:fst::ContextFstImpl
queue_	determinize-lattice-inl.h	/^  vector<OutputStateId> queue_; \/\/ Queue of output-states to process.  Starts with$/;"	m	class:fst::LatticeDeterminizer
ready_	context-fst.h	/^  bool ready_;                     \/\/ True if arc is waiting to be output.$/;"	m	class:fst::ContextMatcher
ref_count_	table-matcher.h	/^  RefCounter ref_count_;        \/\/ Reference count$/;"	m	class:fst::TableMatcherImpl
repository_	determinize-lattice-inl.h	/^  LatticeStringRepository<IntType> repository_;  \/\/ defines a compact and fast way of$/;"	m	class:fst::LatticeDeterminizer
repository_	determinize-star-inl.h	/^  StringRepository<Label, StringId> repository_;  \/\/ associate integer id's with sequences of labels.$/;"	m	class:fst::DeterminizerStar
reweight_plus_	remove-eps-local-inl.h	/^  ReweightPlus reweight_plus_;$/;"	m	class:fst::RemoveEpsLocalClass
s_	context-fst.h	/^  StateId s_;                     \/\/ Current state.$/;"	m	class:fst::ContextMatcher
s_	table-matcher.h	/^  StateId s_;$/;"	m	class:fst::TableMatcherImpl
separator_	context-fst.h	/^  std::string separator_;$/;"	m	class:fst::ContextFstImpl
set_	determinize-lattice-inl.h	/^  SetType set_;$/;"	m	class:fst::LatticeStringRepository
single_symbol_range	determinize-star-inl.h	/^  StringId single_symbol_range;  \/\/ =  numeric_limits<StringId>::max() - single_symbol_start;$/;"	m	class:fst::StringRepository
single_symbol_start	determinize-star-inl.h	/^  StringId single_symbol_start;  \/\/ =  (numeric_limits<StringId>::max() \/ 2) + 1;$/;"	m	class:fst::StringRepository
start_state_	deterministic-fst.h	/^  StateId start_state_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
start_state_	deterministic-fst.h	/^  StateId start_state_;$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
state	determinize-lattice-inl.h	/^    StateId state; \/\/ use StateId as this is usually InputStateId but in one case$/;"	m	struct:fst::LatticeDeterminizer::Element
state	determinize-star-inl.h	/^    InputStateId state;$/;"	m	struct:fst::DeterminizerStar::Element
state	trivial-factor-weight.h	/^    StateId state;     \/\/ Input state Id$/;"	m	struct:fst::TrivialFactorWeightFstImpl::Element
state_map_	context-fst.h	/^  VectorToStateType state_map_;$/;"	m	class:fst::ContextFstImpl
state_map_	deterministic-fst.h	/^  MapType state_map_;$/;"	m	class:fst::ComposeDeterministicOnDemandFst
state_map_	deterministic-fst.h	/^  MapType state_map_;$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
state_seqs_	context-fst.h	/^  vector<vector<LabelT> > state_seqs_;$/;"	m	class:fst::ContextFstImpl
state_vec_	deterministic-fst.h	/^  std::vector<std::pair<StateId, StateId> > state_vec_; \/\/ maps from$/;"	m	class:fst::ComposeDeterministicOnDemandFst
state_vec_	deterministic-fst.h	/^  std::vector<std::vector<Label> > state_vec_; \/\/ maps from history-state to pair.$/;"	m	class:fst::LmExampleDeterministicOnDemandFst
string	determinize-lattice-inl.h	/^    StringId string;  \/\/ Look it up in the StringRepository, it's a sequence of Labels.$/;"	m	struct:fst::LatticeDeterminizer::TempArc
string	determinize-lattice-inl.h	/^    StringId string;$/;"	m	struct:fst::LatticeDeterminizer::Element
string	determinize-star-inl.h	/^    StringId string;$/;"	m	struct:fst::DeterminizerStar::Element
string_	lattice-weight.h	/^  vector<IntType> string_; $/;"	m	class:fst::CompactLatticeWeightTpl
string_end	determinize-star-inl.h	/^  StringId string_end;  \/\/ = (numeric_limits<StringId>::max() \/ 2) - 1; \/\/ all hash values must be <= this.$/;"	m	class:fst::StringRepository
string_start	determinize-star-inl.h	/^  static const StringId string_start = (StringId) 0;  \/\/ This must not change.  It's assumed.$/;"	m	class:fst::StringRepository
subsequential_symbol_	context-fst.h	/^  Label subsequential_symbol_;$/;"	m	class:fst::ContextFstImpl
symbol_mapping_	fstext-utils-inl.h	/^  const vector<I> *symbol_mapping_;$/;"	m	class:fst::MapInputSymbolsMapper
t_	fstext-utils.h	/^  T *t_;$/;"	m	class:fst::VectorFstTplHolder
table_match_type	table-matcher.h	/^  MatchType table_match_type;$/;"	m	struct:fst::TableComposeOptions
table_ratio	table-matcher.h	/^  float table_ratio;  \/\/ we construct the table if it would be at least this full.$/;"	m	struct:fst::TableMatcherOptions
tables_	table-matcher.h	/^  vector<vector<ArcId> *> tables_;$/;"	m	class:fst::TableMatcherImpl
to_remove_set_	factor-inl.h	/^  kaldi::ConstIntegerSet<I> to_remove_set_;$/;"	m	class:fst::RemoveSomeInputSymbolsMapper
value1_	lattice-weight.h	/^  T value1_;$/;"	m	class:fst::LatticeWeightTpl
value2_	lattice-weight.h	/^  T value2_;$/;"	m	class:fst::LatticeWeightTpl
vec_	determinize-star-inl.h	/^  vector<vector<Label>* > vec_;$/;"	m	class:fst::StringRepository
weight	determinize-lattice-inl.h	/^    Weight weight;$/;"	m	struct:fst::LatticeDeterminizer::Element
weight	determinize-lattice-inl.h	/^    Weight weight;$/;"	m	struct:fst::LatticeDeterminizer::TempArc
weight	determinize-star-inl.h	/^    Weight weight;$/;"	m	struct:fst::DeterminizerStar::Element
weight	determinize-star-inl.h	/^    Weight weight;$/;"	m	struct:fst::DeterminizerStar::TempArc
weight	trivial-factor-weight.h	/^    Weight weight;     \/\/ Residual weight$/;"	m	struct:fst::TrivialFactorWeightFstImpl::Element
weight_	lattice-weight.h	/^  W weight_;$/;"	m	class:fst::CompactLatticeWeightTpl
weight_multiplier	rand-fst.h	/^  float weight_multiplier;$/;"	m	struct:fst::RandFstOptions
~ContextFst	context-fst.h	/^  virtual ~ContextFst() { if (!impl_->DecrRefCount()) delete impl_;  }$/;"	f	class:fst::ContextFst
~ContextFstImpl	context-fst.h	/^  ~ContextFstImpl() { }$/;"	f	class:fst::ContextFstImpl
~ContextMatcher	context-fst.h	/^  virtual ~ContextMatcher() {$/;"	f	class:fst::ContextMatcher
~DeterministicOnDemandFst	deterministic-fst.h	/^  virtual ~DeterministicOnDemandFst() { }$/;"	f	class:fst::DeterministicOnDemandFst
~DeterminizerStar	determinize-star-inl.h	/^  ~DeterminizerStar() {$/;"	f	class:fst::DeterminizerStar
~LatticeDeterminizer	determinize-lattice-inl.h	/^  ~LatticeDeterminizer() {$/;"	f	class:fst::LatticeDeterminizer
~LatticeStringRepository	determinize-lattice-inl.h	/^  ~LatticeStringRepository() { Destroy(); }$/;"	f	class:fst::LatticeStringRepository
~MapInputSymbolsMapper	fstext-utils-inl.h	/^  ~MapInputSymbolsMapper() { if (owned && symbol_mapping_ != NULL) delete symbol_mapping_; }$/;"	f	class:fst::MapInputSymbolsMapper
~StringRepository	determinize-star-inl.h	/^  ~StringRepository() {$/;"	f	class:fst::StringRepository
~TableComposeCache	table-matcher.h	/^  ~TableComposeCache() { if (matcher) delete(matcher); }$/;"	f	struct:fst::TableComposeCache
~TableMatcher	table-matcher.h	/^  virtual ~TableMatcher() {$/;"	f	class:fst::TableMatcher
~TableMatcherImpl	table-matcher.h	/^  virtual ~TableMatcherImpl() {$/;"	f	class:fst::TableMatcherImpl
~TrivialFactorWeightFstImpl	trivial-factor-weight.h	/^  ~TrivialFactorWeightFstImpl() {$/;"	f	class:fst::TrivialFactorWeightFstImpl
~VectorFstTplHolder	fstext-utils.h	/^  ~VectorFstTplHolder() { Clear(); }$/;"	f	class:fst::VectorFstTplHolder
