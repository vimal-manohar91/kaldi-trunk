!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	lookahead-filter.h	/^  typedef LogArc A;$/;"	t	class:fst::DefaultLookAhead
A	lookahead-filter.h	/^  typedef StdArc A;$/;"	t	class:fst::DefaultLookAhead
ALT_SEQUENCE_FILTER	compose.h	/^enum ComposeFilter { AUTO_FILTER, SEQUENCE_FILTER, ALT_SEQUENCE_FILTER,$/;"	e	enum:fst::ComposeFilter
AStarWeightCompare	queue.h	/^  AStarWeightCompare(const vector<Weight>& weights, const L &less,$/;"	f	class:fst::AStarWeightCompare
AStarWeightCompare	queue.h	/^class AStarWeightCompare {$/;"	c	namespace:fst
ATTRIBUTE_DEPRECATED	log.h	64;"	d
AUTO_FILTER	compose.h	/^enum ComposeFilter { AUTO_FILTER, SEQUENCE_FILTER, ALT_SEQUENCE_FILTER,$/;"	e	enum:fst::ComposeFilter
AUTO_QUEUE	queue.h	/^  AUTO_QUEUE = 7,            \/\/ Auto-selected queue$/;"	e	enum:fst::QueueType
AW	arc-map.h	/^  typedef typename A::Weight AW;$/;"	t	struct:fst::FromGallicMapper
AW	arc-map.h	/^  typedef typename A::Weight AW;$/;"	t	struct:fst::GallicToNewSymbolsMapper
AW	arc-map.h	/^  typedef typename A::Weight AW;$/;"	t	struct:fst::ToGallicMapper
AWeight	arc.h	/^  typedef typename A::Weight AWeight;$/;"	t	struct:fst::ReverseArc
A_	heap.h	/^  vector<T>   A_;$/;"	m	class:fst::Heap
AcceptorCompactor	compact-fst.h	/^class AcceptorCompactor {$/;"	c	namespace:fst
AcceptorMinimize	minimize.h	/^void AcceptorMinimize(MutableFst<A>* fst) {$/;"	f	namespace:fst
AcyclicMinimizer	minimize.h	/^  AcyclicMinimizer(const ExpandedFst<A>& fst):$/;"	f	class:fst::AcyclicMinimizer
AcyclicMinimizer	minimize.h	/^class AcyclicMinimizer {$/;"	c	namespace:fst
Add	partition.h	/^  void Add(T element_id, T class_id) {$/;"	f	class:fst::Partition
AddArc	cache.h	/^  void AddArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CacheBaseImpl
AddArc	compose.h	/^   void AddArc(StateId s, const Arc &arc1, const Arc &arc2,$/;"	f	class:fst::ComposeFstImpl
AddArc	determinize.h	/^  void AddArc(StateId s, Label label, Subset *dest_subset) {$/;"	f	class:fst::DeterminizeFsaImpl
AddArc	edit-fst.h	/^  const A *AddArc(StateId s, const Arc &arc, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
AddArc	edit-fst.h	/^  void AddArc(StateId s, const Arc &arc) {$/;"	f	class:fst::EditFstImpl
AddArc	mutable-fst.h	/^  virtual void AddArc(StateId s, const Arc &arc) {$/;"	f	class:fst::ImplToMutableFst
AddArc	vector-fst.h	/^  void AddArc(StateId s, const A &arc) {$/;"	f	class:fst::VectorFstImpl
AddArc	vector-fst.h	/^  void AddArc(StateId s, const Arc &arc) {$/;"	f	class:fst::VectorFstBaseImpl
AddArcProperties	properties.h	/^uint64 AddArcProperties(uint64 inprops, typename A::StateId s,$/;"	f	namespace:fst
AddClass	partition.h	/^  size_t AddClass() {$/;"	f	class:fst::Partition
AddClosure	rational.h	/^  void AddClosure(ClosureType closure_type) {$/;"	f	class:fst::RationalFstImpl
AddConcat	rational.h	/^  void AddConcat(const Fst<A> &fst, bool append) {$/;"	f	class:fst::RationalFstImpl
AddLabel	arcfilter.h	/^  void AddLabel(Label label) {$/;"	f	class:fst::MultiLabelArcFilter
AddMultiEpsLabel	matcher.h	/^  void AddMultiEpsLabel(Label label) {$/;"	f	class:fst::MultiEpsMatcher
AddOnImpl	add-on.h	/^  AddOnImpl(const AddOnImpl<F, T> &impl)$/;"	f	class:fst::AddOnImpl
AddOnImpl	add-on.h	/^  AddOnImpl(const F &fst, const string &type, T *t = 0)$/;"	f	class:fst::AddOnImpl
AddOnImpl	add-on.h	/^  AddOnImpl(const Fst<Arc> &fst, const string &type, T *t = 0)$/;"	f	class:fst::AddOnImpl
AddOnImpl	add-on.h	/^  explicit AddOnImpl(const string &type) : t_(0) {$/;"	f	class:fst::AddOnImpl
AddOnImpl	add-on.h	/^class AddOnImpl : public FstImpl<typename F::Arc> {$/;"	c	namespace:fst
AddOnPair	add-on.h	/^  AddOnPair(A1 *a1, A2 *a2)$/;"	f	class:fst::AddOnPair
AddOnPair	add-on.h	/^class AddOnPair {$/;"	c	namespace:fst
AddState	edit-fst.h	/^  StateId AddState() {$/;"	f	class:fst::EditFstImpl
AddState	edit-fst.h	/^  StateId AddState(StateId curr_num_states) {$/;"	f	class:fst::EditFstData
AddState	mutable-fst.h	/^  virtual StateId AddState() {$/;"	f	class:fst::ImplToMutableFst
AddState	vector-fst.h	/^  StateId AddState() {$/;"	f	class:fst::VectorFstBaseImpl
AddState	vector-fst.h	/^  StateId AddState() {$/;"	f	class:fst::VectorFstImpl
AddState	vector-fst.h	/^  StateId AddState(State *state) {$/;"	f	class:fst::VectorFstBaseImpl
AddStateProperties	properties.h	/^uint64 AddStateProperties(uint64 inprops) {$/;"	f	namespace:fst
AddSymbol	symbol-table.h	/^  int64 AddSymbol(const string& symbol) {$/;"	f	class:fst::SymbolTableImpl
AddSymbol	symbol-table.h	/^  virtual int64 AddSymbol(const string& symbol) {$/;"	f	class:fst::SymbolTable
AddSymbol	symbol-table.h	/^  virtual int64 AddSymbol(const string& symbol, int64 key) {$/;"	f	class:fst::SymbolTable
AddUnion	rational.h	/^  void AddUnion(const Fst<A> &fst) {$/;"	f	class:fst::RationalFstImpl
AddWeights	accumulator.h	/^  void AddWeights(StateId s, vector<double> *weights) {$/;"	f	class:fst::CacheLogAccumulatorData
Allocate	cache.h	/^  S *Allocate(StateId s) {$/;"	f	struct:fst::DefaultCacheStateAllocator
AllocateClasses	partition.h	/^  void AllocateClasses(T num_classes) {$/;"	f	class:fst::Partition
Allocator	cache.h	/^  typedef C Allocator;$/;"	t	class:fst::CacheBaseImpl
AltSequenceComposeFilter	compose-filter.h	/^  AltSequenceComposeFilter(const AltSequenceComposeFilter<M1, M2> &filter,$/;"	f	class:fst::AltSequenceComposeFilter
AltSequenceComposeFilter	compose-filter.h	/^  AltSequenceComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::AltSequenceComposeFilter
AltSequenceComposeFilter	compose-filter.h	/^class AltSequenceComposeFilter {$/;"	c	namespace:fst
AnyArcFilter	arcfilter.h	/^class AnyArcFilter {$/;"	c	namespace:fst
ApproxEqual	float-weight.h	/^inline bool ApproxEqual(const FloatWeightTpl<T> &w1,$/;"	f	namespace:fst
ApproxEqual	pair-weight.h	/^inline bool ApproxEqual(const PairWeight<W1, W2> &w1,$/;"	f	namespace:fst
ApproxEqual	signed-log-weight.h	/^inline bool ApproxEqual(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
ApproxEqual	sparse-power-weight.h	/^inline bool ApproxEqual(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
ApproxEqual	string-weight.h	/^inline bool ApproxEqual(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
ApproxEqual	tuple-weight.h	/^inline bool ApproxEqual(const TupleWeight<W, n> &w1,$/;"	f	namespace:fst
Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::CacheLogAccumulator
Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::CacheLogAccumulatorData
Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::DefaultAccumulator
Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::FastLogAccumulator
Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::LogAccumulator
Arc	accumulator.h	/^  typedef typename Accumulator::Arc Arc;$/;"	t	class:fst::ReplaceAccumulator
Arc	accumulator.h	/^  typedef typename Accumulator::Arc Arc;$/;"	t	class:fst::ReplaceAccumulatorData
Arc	add-on.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::AddOnImpl
Arc	arc-map.h	/^  typedef B Arc;$/;"	t	class:fst::ArcMapFst
Arc	arc-map.h	/^  typedef B Arc;$/;"	t	class:fst::ArcMapFstImpl
Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::ExpectationArc
Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::GallicArc
Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::PowerArc
Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::ReverseArc
Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::SparsePowerArc
Arc	arcsort.h	/^  typedef A Arc;$/;"	t	class:fst::ArcSortFst
Arc	arcsort.h	/^  typedef StdArc Arc;$/;"	t	class:fst::StdArcSortFst
Arc	cache.h	/^  typedef A Arc;$/;"	t	struct:fst::CacheState
Arc	cache.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::CacheArcIterator
Arc	cache.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::CacheMutableArcIterator
Arc	cache.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::CacheStateIterator
Arc	cache.h	/^  typedef typename State::Arc Arc;$/;"	t	class:fst::CacheBaseImpl
Arc	closure.h	/^  typedef A Arc;$/;"	t	class:fst::ClosureFst
Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::AcceptorCompactor
Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::CompactFst
Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::CompactFstImpl
Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::StringCompactor
Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::UnweightedAcceptorCompactor
Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::UnweightedCompactor
Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::WeightedStringCompactor
Arc	complement.h	/^  typedef A Arc;$/;"	t	class:fst::ComplementFst
Arc	complement.h	/^  typedef A Arc;$/;"	t	class:fst::ComplementFstImpl
Arc	compose-filter.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::MultiEpsFilter
Arc	compose-filter.h	/^  typedef typename FST1::Arc Arc;$/;"	t	class:fst::AltSequenceComposeFilter
Arc	compose-filter.h	/^  typedef typename FST1::Arc Arc;$/;"	t	class:fst::MatchComposeFilter
Arc	compose-filter.h	/^  typedef typename FST1::Arc Arc;$/;"	t	class:fst::SequenceComposeFilter
Arc	compose.h	/^  typedef A Arc;$/;"	t	class:fst::ComposeFst
Arc	compose.h	/^  typedef typename M1::Arc Arc;$/;"	t	class:fst::ComposeFstImpl
Arc	concat.h	/^  typedef A Arc;$/;"	t	class:fst::ConcatFst
Arc	connect.h	/^  typedef A Arc;$/;"	t	class:fst::CcVisitor
Arc	connect.h	/^  typedef A Arc;$/;"	t	class:fst::SccVisitor
Arc	const-fst.h	/^  typedef A Arc;$/;"	t	class:fst::ConstFst
Arc	const-fst.h	/^  typedef A Arc;$/;"	t	class:fst::ConstFstImpl
Arc	determinize.h	/^  typedef A Arc;$/;"	t	class:fst::DeterminizeFst
Arc	difference.h	/^  typedef A Arc;$/;"	t	class:fst::DifferenceFst
Arc	edit-fst.h	/^  typedef A Arc;$/;"	t	class:fst::EditFst
Arc	edit-fst.h	/^  typedef A Arc;$/;"	t	class:fst::EditFstData
Arc	edit-fst.h	/^  typedef A Arc;$/;"	t	class:fst::EditFstImpl
Arc	encode.h	/^  typedef A Arc;$/;"	t	class:fst::DecodeFst
Arc	encode.h	/^  typedef A Arc;$/;"	t	class:fst::EncodeFst
Arc	expanded-fst.h	/^  typedef A Arc;$/;"	t	class:fst::ExpandedFst
Arc	expanded-fst.h	/^  typedef typename I::Arc Arc;$/;"	t	class:fst::ImplToExpandedFst
Arc	factor-weight.h	/^  typedef A Arc;$/;"	t	class:fst::FactorWeightFst
Arc	factor-weight.h	/^  typedef A Arc;$/;"	t	class:fst::FactorWeightFstImpl
Arc	fst.h	/^  typedef A Arc;$/;"	t	class:fst::ArcIteratorBase
Arc	fst.h	/^  typedef A Arc;$/;"	t	class:fst::Fst
Arc	fst.h	/^  typedef A Arc;$/;"	t	class:fst::StateIteratorBase
Arc	fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::ArcIterator
Arc	fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::StateIterator
Arc	fst.h	/^  typedef typename I::Arc Arc;$/;"	t	class:fst::ImplToFst
Arc	intersect.h	/^  typedef A Arc;$/;"	t	class:fst::IntersectFst
Arc	invert.h	/^  typedef A Arc;$/;"	t	class:fst::InvertFst
Arc	label-reachable.h	/^  typedef A Arc;$/;"	t	class:fst::LabelReachable
Arc	lookahead-filter.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::LookAheadComposeFilter
Arc	lookahead-filter.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::PushLabelsComposeFilter
Arc	lookahead-filter.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::PushWeightsComposeFilter
Arc	lookahead-filter.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::LookAheadSelector
Arc	lookahead-matcher.h	/^  typedef A Arc;$/;"	t	class:fst::LookAheadMatcherBase
Arc	lookahead-matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::LookAheadMatcher
Arc	lookahead-matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::ArcLookAheadMatcher
Arc	lookahead-matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::LabelLookAheadMatcher
Arc	lookahead-matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::TrivialLookAheadMatcher
Arc	map.h	/^  typedef B Arc;$/;"	t	class:fst::MapFst
Arc	matcher-fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::LookAheadMatcher
Arc	matcher-fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::Matcher
Arc	matcher-fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::MatcherFst
Arc	matcher.h	/^  typedef A Arc;$/;"	t	class:fst::MatcherBase
Arc	matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::Matcher
Arc	matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::SortedMatcher
Arc	matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::MultiEpsMatcher
Arc	matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::PhiMatcher
Arc	matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::RhoMatcher
Arc	matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::SigmaMatcher
Arc	mutable-fst.h	/^  typedef A Arc;$/;"	t	class:fst::MutableArcIteratorBase
Arc	mutable-fst.h	/^  typedef A Arc;$/;"	t	class:fst::MutableFst
Arc	mutable-fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::MutableArcIterator
Arc	mutable-fst.h	/^  typedef typename I::Arc Arc;$/;"	t	class:fst::ImplToMutableFst
Arc	project.h	/^  typedef A Arc;$/;"	t	class:fst::ProjectFst
Arc	randgen.h	/^  typedef B Arc;$/;"	t	class:fst::RandGenFst
Arc	randgen.h	/^  typedef B Arc;$/;"	t	class:fst::RandGenFstImpl
Arc	rational.h	/^  typedef A Arc;$/;"	t	class:fst::RationalFst
Arc	rational.h	/^  typedef A Arc;$/;"	t	class:fst::RationalFstImpl
Arc	register.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::FstRegisterer
Arc	relabel.h	/^  typedef A Arc;$/;"	t	class:fst::RelabelFst
Arc	relabel.h	/^  typedef A Arc;$/;"	t	class:fst::RelabelFstImpl
Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::ArcIterator
Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::DefaultReplaceStateTable
Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::ReplaceFst
Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::ReplaceFstImpl
Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::ReplaceFstMatcher
Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::VectorHashReplaceStateTable
Arc	rmepsilon.h	/^  typedef A Arc;$/;"	t	class:fst::RmEpsilonFst
Arc	state-map.h	/^  typedef B Arc;$/;"	t	class:fst::StateMapFst
Arc	state-map.h	/^  typedef B Arc;$/;"	t	class:fst::StateMapFstImpl
Arc	state-reachable.h	/^  typedef A Arc;$/;"	t	class:fst::StateReachable
Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::DetStringComposeStateTable
Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::ErasableComposeStateTable
Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::GenericComposeStateTable
Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::ProductComposeStateTable
Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::StringDetComposeStateTable
Arc	string.h	/^  typedef A Arc;$/;"	t	class:fst::StringCompiler
Arc	string.h	/^  typedef A Arc;$/;"	t	class:fst::StringPrinter
Arc	synchronize.h	/^  typedef A Arc;$/;"	t	class:fst::SynchronizeFst
Arc	synchronize.h	/^  typedef A Arc;$/;"	t	class:fst::SynchronizeFstImpl
Arc	topsort.h	/^  typedef A Arc;$/;"	t	class:fst::TopOrderVisitor
Arc	union.h	/^  typedef A Arc;$/;"	t	class:fst::UnionFst
Arc	vector-fst.h	/^  typedef A Arc;$/;"	t	class:fst::VectorFst
Arc	vector-fst.h	/^  typedef A Arc;$/;"	t	struct:fst::VectorState
Arc	vector-fst.h	/^  typedef typename State::Arc Arc;$/;"	t	class:fst::VectorFstBaseImpl
Arc	visit.h	/^  typedef A Arc;$/;"	t	class:fst::CopyVisitor
Arc	visit.h	/^  typedef A Arc;$/;"	t	class:fst::PartialVisitor
ArcIter	minimize.h	/^  typedef ArcIterator<Fst<RevA> > ArcIter;$/;"	t	class:fst::CyclicMinimizer
ArcIterCompare	minimize.h	/^    ArcIterCompare(const ArcIterCompare& comp)$/;"	f	class:fst::CyclicMinimizer::ArcIterCompare
ArcIterCompare	minimize.h	/^    ArcIterCompare(const Partition<StateId>& partition)$/;"	f	class:fst::CyclicMinimizer::ArcIterCompare
ArcIterCompare	minimize.h	/^  class ArcIterCompare {$/;"	c	class:fst::CyclicMinimizer
ArcIterQueue	minimize.h	/^  ArcIterQueue;$/;"	t	class:fst::CyclicMinimizer
ArcIterator	arc-map.h	/^  ArcIterator(const ArcMapFst<A, B, C> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	arc-map.h	/^class ArcIterator< ArcMapFst<A, B, C> >$/;"	c	namespace:fst
ArcIterator	arcsort.h	/^  ArcIterator(const ArcSortFst<A, C> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	arcsort.h	/^class ArcIterator< ArcSortFst<A, C> >$/;"	c	namespace:fst
ArcIterator	closure.h	/^  ArcIterator(const ClosureFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	closure.h	/^class ArcIterator< ClosureFst<A> > : public ArcIterator< RationalFst<A> > {$/;"	c	namespace:fst
ArcIterator	compact-fst.h	/^  ArcIterator(const CompactFst<A, C, U> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	compact-fst.h	/^class ArcIterator< CompactFst<A, C, U> > {$/;"	c	namespace:fst
ArcIterator	complement.h	/^  ArcIterator(const ComplementFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	complement.h	/^class ArcIterator< ComplementFst<A> > : public ArcIteratorBase<A> {$/;"	c	namespace:fst
ArcIterator	compose.h	/^  ArcIterator(const ComposeFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	compose.h	/^class ArcIterator< ComposeFst<A> >$/;"	c	namespace:fst
ArcIterator	concat.h	/^  ArcIterator(const ConcatFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	concat.h	/^class ArcIterator< ConcatFst<A> > : public ArcIterator< RationalFst<A> > {$/;"	c	namespace:fst
ArcIterator	const-fst.h	/^  ArcIterator(const ConstFst<A, U> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	const-fst.h	/^class ArcIterator< ConstFst<A, U> > {$/;"	c	namespace:fst
ArcIterator	determinize.h	/^  ArcIterator(const DeterminizeFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	determinize.h	/^class ArcIterator< DeterminizeFst<A> >$/;"	c	namespace:fst
ArcIterator	difference.h	/^  ArcIterator(const DifferenceFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	difference.h	/^class ArcIterator< DifferenceFst<A> >$/;"	c	namespace:fst
ArcIterator	encode.h	/^  ArcIterator(const DecodeFst<A> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	encode.h	/^  ArcIterator(const EncodeFst<A> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	encode.h	/^class ArcIterator< DecodeFst<A> >$/;"	c	namespace:fst
ArcIterator	encode.h	/^class ArcIterator< EncodeFst<A> >$/;"	c	namespace:fst
ArcIterator	factor-weight.h	/^  ArcIterator(const FactorWeightFst<A, F> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	factor-weight.h	/^class ArcIterator< FactorWeightFst<A, F> >$/;"	c	namespace:fst
ArcIterator	fst.h	/^  ArcIterator(const F &fst, StateId s) : i_(0) {$/;"	f	class:fst::ArcIterator
ArcIterator	fst.h	/^  explicit ArcIterator(const ArcIteratorData<Arc> &data) : data_(data), i_(0) {$/;"	f	class:fst::ArcIterator
ArcIterator	fst.h	/^class ArcIterator {$/;"	c	namespace:fst
ArcIterator	intersect.h	/^  ArcIterator(const IntersectFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	intersect.h	/^class ArcIterator< IntersectFst<A> >$/;"	c	namespace:fst
ArcIterator	invert.h	/^  ArcIterator(const InvertFst<A> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	invert.h	/^class ArcIterator< InvertFst<A> >$/;"	c	namespace:fst
ArcIterator	map.h	/^  ArcIterator(const ArcMapFst<A, B, C> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	map.h	/^class ArcIterator< MapFst<A, B, C> >$/;"	c	namespace:fst
ArcIterator	matcher-fst.h	/^  ArcIterator(const MatcherFst<F, M, N, I> &fst, typename F::Arc::StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	matcher-fst.h	/^class ArcIterator< MatcherFst<F, M, N, I> > : public ArcIterator<F> {$/;"	c	namespace:fst
ArcIterator	project.h	/^  ArcIterator(const ProjectFst<A> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	project.h	/^class ArcIterator< ProjectFst<A> >$/;"	c	namespace:fst
ArcIterator	randgen.h	/^  ArcIterator(const RandGenFst<A, B, S> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	randgen.h	/^class ArcIterator< RandGenFst<A, B, S> >$/;"	c	namespace:fst
ArcIterator	rational.h	/^  ArcIterator(const RationalFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	rational.h	/^class ArcIterator< RationalFst<A> >$/;"	c	namespace:fst
ArcIterator	relabel.h	/^  ArcIterator(const RelabelFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	relabel.h	/^class ArcIterator< RelabelFst<A> >$/;"	c	namespace:fst
ArcIterator	replace.h	/^  ArcIterator(const ReplaceFst<A, T> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	replace.h	/^class ArcIterator< ReplaceFst<A, T> > {$/;"	c	namespace:fst
ArcIterator	rmepsilon.h	/^  ArcIterator(const RmEpsilonFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	rmepsilon.h	/^class ArcIterator< RmEpsilonFst<A> >$/;"	c	namespace:fst
ArcIterator	state-map.h	/^  ArcIterator(const StateMapFst<A, B, C> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	state-map.h	/^class ArcIterator< StateMapFst<A, B, C> >$/;"	c	namespace:fst
ArcIterator	synchronize.h	/^  ArcIterator(const SynchronizeFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	synchronize.h	/^class ArcIterator< SynchronizeFst<A> >$/;"	c	namespace:fst
ArcIterator	union.h	/^  ArcIterator(const UnionFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	union.h	/^class ArcIterator< UnionFst<A> > : public ArcIterator< RationalFst<A> > {$/;"	c	namespace:fst
ArcIterator	vector-fst.h	/^  ArcIterator(const VectorFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
ArcIterator	vector-fst.h	/^class ArcIterator< VectorFst<A> > {$/;"	c	namespace:fst
ArcIteratorBase	fst.h	/^class ArcIteratorBase {$/;"	c	namespace:fst
ArcIteratorData	fst.h	/^template <class A> struct ArcIteratorData {$/;"	s	namespace:fst
ArcIteratorFlags	replace.h	/^  uint32 ArcIteratorFlags() const {$/;"	f	class:fst::ReplaceFstImpl
ArcLookAheadMatcher	lookahead-matcher.h	/^  ArcLookAheadMatcher(const ArcLookAheadMatcher<M, F> &lmatcher,$/;"	f	class:fst::ArcLookAheadMatcher
ArcLookAheadMatcher	lookahead-matcher.h	/^  ArcLookAheadMatcher(const FST &fst, MatchType match_type,$/;"	f	class:fst::ArcLookAheadMatcher
ArcLookAheadMatcher	lookahead-matcher.h	/^class ArcLookAheadMatcher$/;"	c	namespace:fst
ArcMap	arc-map.h	/^void ArcMap(MutableFst<A> *fst, C mapper) {$/;"	f	namespace:fst
ArcMap	arc-map.h	/^void ArcMap(MutableFst<A> *fst, C* mapper) {$/;"	f	namespace:fst
ArcMap	arc-map.h	/^void ArcMap(const Fst<A> &ifst, MutableFst<B> *ofst, C mapper) {$/;"	f	namespace:fst
ArcMap	arc-map.h	/^void ArcMap(const Fst<A> &ifst, MutableFst<B> *ofst, C* mapper) {$/;"	f	namespace:fst
ArcMapFst	arc-map.h	/^  ArcMapFst(const ArcMapFst<A, B, C> &fst, bool safe = false)$/;"	f	class:fst::ArcMapFst
ArcMapFst	arc-map.h	/^  ArcMapFst(const Fst<A> &fst, C* mapper)$/;"	f	class:fst::ArcMapFst
ArcMapFst	arc-map.h	/^  ArcMapFst(const Fst<A> &fst, C* mapper, const ArcMapFstOptions& opts)$/;"	f	class:fst::ArcMapFst
ArcMapFst	arc-map.h	/^  ArcMapFst(const Fst<A> &fst, const C &mapper)$/;"	f	class:fst::ArcMapFst
ArcMapFst	arc-map.h	/^  ArcMapFst(const Fst<A> &fst, const C &mapper, const ArcMapFstOptions& opts)$/;"	f	class:fst::ArcMapFst
ArcMapFst	arc-map.h	/^class ArcMapFst : public ImplToFst< ArcMapFstImpl<A, B, C> > {$/;"	c	namespace:fst
ArcMapFstImpl	arc-map.h	/^  ArcMapFstImpl(const ArcMapFstImpl<A, B, C> &impl)$/;"	f	class:fst::ArcMapFstImpl
ArcMapFstImpl	arc-map.h	/^  ArcMapFstImpl(const Fst<A> &fst, C *mapper,$/;"	f	class:fst::ArcMapFstImpl
ArcMapFstImpl	arc-map.h	/^  ArcMapFstImpl(const Fst<A> &fst, const C &mapper,$/;"	f	class:fst::ArcMapFstImpl
ArcMapFstImpl	arc-map.h	/^class ArcMapFstImpl : public CacheImpl<B> {$/;"	c	namespace:fst
ArcMapFstOptions	arc-map.h	/^  ArcMapFstOptions() : CacheOptions(true, 0) {}$/;"	f	struct:fst::ArcMapFstOptions
ArcMapFstOptions	arc-map.h	/^  ArcMapFstOptions(const CacheOptions& opts) : CacheOptions(opts) {}$/;"	f	struct:fst::ArcMapFstOptions
ArcMapFstOptions	arc-map.h	/^struct ArcMapFstOptions : public CacheOptions {$/;"	s	namespace:fst
ArcSampler	randgen.h	/^  ArcSampler(const ArcSampler<A, S> &sampler, const Fst<A> *fst = 0)$/;"	f	class:fst::ArcSampler
ArcSampler	randgen.h	/^  ArcSampler(const Fst<A> &fst, const S &arc_selector, int max_length = INT_MAX)$/;"	f	class:fst::ArcSampler
ArcSampler	randgen.h	/^  ArcSampler(const Fst<A> &fst, const S &arc_selector,$/;"	f	class:fst::ArcSampler
ArcSampler	randgen.h	/^class ArcSampler {$/;"	c	namespace:fst
ArcSampler	randgen.h	/^class ArcSampler<A, FastLogProbArcSelector<A> > {$/;"	c	namespace:fst
ArcSort	arcsort.h	/^void ArcSort(MutableFst<Arc> *fst, Compare comp) {$/;"	f	namespace:fst
ArcSortFst	arcsort.h	/^  ArcSortFst(const ArcSortFst<A, C> &fst, bool safe = false)$/;"	f	class:fst::ArcSortFst
ArcSortFst	arcsort.h	/^  ArcSortFst(const Fst<A> &fst, const C &comp)$/;"	f	class:fst::ArcSortFst
ArcSortFst	arcsort.h	/^  ArcSortFst(const Fst<A> &fst, const C &comp, const ArcSortFstOptions &opts)$/;"	f	class:fst::ArcSortFst
ArcSortFst	arcsort.h	/^class ArcSortFst : public StateMapFst<A, A, ArcSortMapper<A, C> > {$/;"	c	namespace:fst
ArcSortFstOptions	arcsort.h	/^typedef CacheOptions ArcSortFstOptions;$/;"	t	namespace:fst
ArcSortMapper	arcsort.h	/^  ArcSortMapper(const ArcSortMapper<Arc, Compare> &mapper,$/;"	f	class:fst::ArcSortMapper
ArcSortMapper	arcsort.h	/^  ArcSortMapper(const Fst<Arc> &fst, const Compare &comp)$/;"	f	class:fst::ArcSortMapper
ArcSortMapper	arcsort.h	/^class ArcSortMapper {$/;"	c	namespace:fst
ArcSumMapper	state-map.h	/^  ArcSumMapper(const ArcSumMapper<A> &mapper,$/;"	f	class:fst::ArcSumMapper
ArcSumMapper	state-map.h	/^  explicit ArcSumMapper(const Fst<A> &fst) : fst_(fst), i_(0) {}$/;"	f	class:fst::ArcSumMapper
ArcSumMapper	state-map.h	/^class ArcSumMapper {$/;"	c	namespace:fst
ArcTpl	arc.h	/^  ArcTpl() {}$/;"	f	class:fst::ArcTpl
ArcTpl	arc.h	/^  ArcTpl(Label i, Label o, const Weight& w, StateId s)$/;"	f	class:fst::ArcTpl
ArcTpl	arc.h	/^class ArcTpl {$/;"	c	namespace:fst
ArcType	fst.h	/^  const string &ArcType() const { return arctype_; }$/;"	f	class:fst::FstHeader
ArcUniqueMapper	state-map.h	/^  ArcUniqueMapper(const ArcSumMapper<A> &mapper,$/;"	f	class:fst::ArcUniqueMapper
ArcUniqueMapper	state-map.h	/^  explicit ArcUniqueMapper(const Fst<A> &fst) : fst_(fst), i_(0) {}$/;"	f	class:fst::ArcUniqueMapper
ArcUniqueMapper	state-map.h	/^class ArcUniqueMapper {$/;"	c	namespace:fst
Arcs	const-fst.h	/^  A *Arcs(StateId s) { return arcs_ + states_[s].pos; }$/;"	f	class:fst::ConstFstImpl
Arcs	rmepsilon.h	/^  vector<Arc> &Arcs() { return arcs_; }$/;"	f	class:fst::RmEpsilonState
AutoQueue	queue.h	/^  AutoQueue(const Fst<Arc> &fst, const vector<typename Arc::Weight> *distance,$/;"	f	class:fst::AutoQueue
AutoQueue	queue.h	/^class AutoQueue : public QueueBase<S> {$/;"	c	namespace:fst
AvailableKey	symbol-table.h	/^  int64 AvailableKey() const {$/;"	f	class:fst::SymbolTableImpl
AvailableKey	symbol-table.h	/^  virtual int64 AvailableKey(void) const {$/;"	f	class:fst::SymbolTable
BYTE	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringCompiler::TokenType
BYTE	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringPrinter::TokenType
BackArc	connect.h	/^  bool BackArc(StateId s, const A &arc) {$/;"	f	class:fst::SccVisitor
BackArc	minimize.h	/^    bool BackArc(StateId s, const A& arc) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
BackArc	randgen.h	/^  bool BackArc(StateId s, const IArc &arc) {$/;"	f	class:fst::RandGenVisitor
BackArc	state-reachable.h	/^  bool BackArc(StateId s, const A &arc) {$/;"	f	class:fst::IntervalReachVisitor
BackArc	topsort.h	/^  bool BackArc(StateId s, const A &arc) { return (*acyclic_ = false); }$/;"	f	class:fst::TopOrderVisitor
BaseImpl	vector-fst.h	/^  typedef VectorFstBaseImpl< VectorState<A> > BaseImpl;$/;"	t	class:fst::VectorFstImpl
Begin	util.h	/^  const_iterator Begin() const { return set_.begin(); }$/;"	f	class:fst::CompactSet
Better	heap.h	/^  bool Better(const T& x, const T& y) {$/;"	f	class:fst::Heap
BlackArc	connect.h	/^  bool BlackArc(StateId s, const A &arc) {$/;"	f	class:fst::CcVisitor
BlackArc	visit.h	/^  bool BlackArc(StateId s, const Arc &arc) { return true; }$/;"	f	class:fst::PartialVisitor
BlackArc	visit.h	/^  bool BlackArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CopyVisitor
BuildEntry	register.h	/^  Entry BuildEntry() {$/;"	f	class:fst::FstRegisterer
C	encode.h	/^  typedef EncodeMapper<A> C;$/;"	t	class:fst::DecodeFst
C	encode.h	/^  typedef EncodeMapper<A> C;$/;"	t	class:fst::EncodeFst
C	invert.h	/^  typedef InvertMapper<A> C;$/;"	t	class:fst::InvertFst
C	project.h	/^  typedef ProjectMapper<A> C;$/;"	t	class:fst::ProjectFst
C	queue.h	/^  typedef AStarWeightCompare<S, NaturalLess<W>, E> C;$/;"	t	class:fst::NaturalAStarQueue
C	queue.h	/^  typedef StateWeightCompare<S, NaturalLess<W> > C;$/;"	t	class:fst::NaturalShortestFirstQueue
C	randgen.h	/^  typedef CacheLogAccumulator<A> C;$/;"	t	class:fst::ArcSampler
CHECK	log.h	/^inline void CHECK(bool x) { assert(x); }$/;"	f
CHECK_EQ	log.h	56;"	d
CHECK_GE	log.h	60;"	d
CHECK_GT	log.h	58;"	d
CHECK_LE	log.h	59;"	d
CHECK_LT	log.h	57;"	d
CHECK_NE	log.h	61;"	d
CLOSURE_PLUS	rational.h	/^                   CLOSURE_PLUS = 1 };  \/\/ T+ -> don't add the empty string$/;"	e	enum:fst::ClosureType
CLOSURE_STAR	rational.h	/^enum ClosureType { CLOSURE_STAR = 0,    \/\/ T* -> add the empty string$/;"	e	enum:fst::ClosureType
CacheArcIterator	cache.h	/^  CacheArcIterator(Impl *impl, StateId s) : i_(0) {$/;"	f	class:fst::CacheArcIterator
CacheArcIterator	cache.h	/^class CacheArcIterator {$/;"	c	namespace:fst
CacheBaseImpl	cache.h	/^  CacheBaseImpl(const CacheBaseImpl &impl)$/;"	f	class:fst::CacheBaseImpl
CacheBaseImpl	cache.h	/^  explicit CacheBaseImpl(C *allocator = 0)$/;"	f	class:fst::CacheBaseImpl
CacheBaseImpl	cache.h	/^  explicit CacheBaseImpl(const CacheOptions &opts, C *allocator = 0)$/;"	f	class:fst::CacheBaseImpl
CacheBaseImpl	cache.h	/^class CacheBaseImpl : public VectorFstBaseImpl<S> {$/;"	c	namespace:fst
CacheDisabled	accumulator.h	/^  bool CacheDisabled() const { return cache_gc_ && cache_limit_ == 0; }$/;"	f	class:fst::CacheLogAccumulatorData
CacheImpl	cache.h	/^  CacheImpl() {}$/;"	f	class:fst::CacheImpl
CacheImpl	cache.h	/^  CacheImpl(const CacheImpl<State> &impl) : CacheBaseImpl<State>(impl) {}$/;"	f	class:fst::CacheImpl
CacheImpl	cache.h	/^  explicit CacheImpl(const CacheOptions &opts)$/;"	f	class:fst::CacheImpl
CacheImpl	cache.h	/^class CacheImpl : public CacheBaseImpl< CacheState<A> > {$/;"	c	namespace:fst
CacheLogAccumulator	accumulator.h	/^  CacheLogAccumulator(const CacheLogAccumulator<A> &acc)$/;"	f	class:fst::CacheLogAccumulator
CacheLogAccumulator	accumulator.h	/^  explicit CacheLogAccumulator(ssize_t arc_limit = 10, bool gc = false,$/;"	f	class:fst::CacheLogAccumulator
CacheLogAccumulator	accumulator.h	/^class CacheLogAccumulator {$/;"	c	namespace:fst
CacheLogAccumulatorData	accumulator.h	/^  CacheLogAccumulatorData(bool gc, size_t gc_limit)$/;"	f	class:fst::CacheLogAccumulatorData
CacheLogAccumulatorData	accumulator.h	/^class CacheLogAccumulatorData {$/;"	c	namespace:fst
CacheMutableArcIterator	cache.h	/^  CacheMutableArcIterator(Impl *impl, StateId s) : i_(0), s_(s), impl_(impl) {$/;"	f	class:fst::CacheMutableArcIterator
CacheMutableArcIterator	cache.h	/^class CacheMutableArcIterator$/;"	c	namespace:fst
CacheOptions	cache.h	/^  CacheOptions()$/;"	f	struct:fst::CacheOptions
CacheOptions	cache.h	/^  CacheOptions(bool g, size_t l) : gc(g), gc_limit(l) {}$/;"	f	struct:fst::CacheOptions
CacheOptions	cache.h	/^struct CacheOptions {$/;"	s	namespace:fst
CacheState	accumulator.h	/^    CacheState(vector<double> *w, bool r) : weights(w), recent(r) {}$/;"	f	struct:fst::CacheLogAccumulatorData::CacheState
CacheState	accumulator.h	/^  struct CacheState {$/;"	s	class:fst::CacheLogAccumulatorData
CacheState	cache.h	/^  CacheState() :  final(Weight::Zero()), flags(0), ref_count(0) {}$/;"	f	struct:fst::CacheState
CacheState	cache.h	/^struct CacheState {$/;"	s	namespace:fst
CacheStateIterator	cache.h	/^  CacheStateIterator(const F &fst, Impl *impl)$/;"	f	class:fst::CacheStateIterator
CacheStateIterator	cache.h	/^class CacheStateIterator : public StateIteratorBase<typename F::Arc> {$/;"	c	namespace:fst
Car	synchronize.h	/^  Label Car(const String *s, Label l = 0) const {$/;"	f	class:fst::SynchronizeFstImpl
Cast	fst.h	/^template<class F, class G> void Cast(const F &ifst, G *ofst) {$/;"	f	namespace:fst
CcVisitor	connect.h	/^  CcVisitor(UnionFind<StateId> *comps)$/;"	f	class:fst::CcVisitor
CcVisitor	connect.h	/^  CcVisitor(vector<StateId> *cc)$/;"	f	class:fst::CcVisitor
CcVisitor	connect.h	/^class CcVisitor {$/;"	c	namespace:fst
Cdr	synchronize.h	/^  const String *Cdr(const String *s, Label l = 0) {$/;"	f	class:fst::SynchronizeFstImpl
CharFilterState	compose-filter.h	/^typedef IntegerFilterState<signed char> CharFilterState;$/;"	t	namespace:fst
CharFilterState	fst-decl.h	/^typedef IntegerFilterState<signed char> CharFilterState;$/;"	t	namespace:fst
CheckMutableFsts	replace-util.h	/^void ReplaceUtil<Arc>::CheckMutableFsts() {$/;"	f	class:fst::ReplaceUtil
CheckState	cache.h	/^  const S *CheckState(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
CheckSum	symbol-table.h	/^  string CheckSum() const {$/;"	f	class:fst::SymbolTableImpl
CheckSum	symbol-table.h	/^  virtual string CheckSum() const {$/;"	f	class:fst::SymbolTable
CheckSummer	compat.h	/^  CheckSummer() : count_(0) {$/;"	f	class:fst::CheckSummer
CheckSummer	compat.h	/^class CheckSummer {$/;"	c	namespace:fst
CheckSuperfinal	arc-map.h	/^  void CheckSuperfinal() {$/;"	f	class:fst::StateIterator
ClassId	minimize.h	/^  typedef typename A::StateId ClassId;$/;"	t	class:fst::AcyclicMinimizer
ClassId	minimize.h	/^  typedef typename A::StateId ClassId;$/;"	t	class:fst::CyclicMinimizer
Clear	heap.h	/^  void Clear() {$/;"	f	class:fst::Heap
Clear	interval-set.h	/^  void Clear() {$/;"	f	class:fst::IntervalSet
Clear	queue.h	/^  void Clear() { Clear_(); }$/;"	f	class:fst::QueueBase
Clear	queue.h	/^  void Clear() { clear(); }$/;"	f	class:fst::FifoQueue
Clear	queue.h	/^  void Clear() { clear(); }$/;"	f	class:fst::LifoQueue
Clear	queue.h	/^  void Clear() { front_ = kNoStateId; }$/;"	f	class:fst::TrivialQueue
Clear	queue.h	/^  void Clear() { queue_->Clear(); }$/;"	f	class:fst::AutoQueue
Clear	queue.h	/^  void Clear() { queue_->Clear(); }$/;"	f	class:fst::PruneQueue
Clear	queue.h	/^  void Clear() {$/;"	f	class:fst::SccQueue
Clear	queue.h	/^  void Clear() {$/;"	f	class:fst::ShortestFirstQueue
Clear	queue.h	/^  void Clear() {$/;"	f	class:fst::StateOrderQueue
Clear	queue.h	/^  void Clear() {$/;"	f	class:fst::TopOrderQueue
Clear	string-weight.h	/^  void Clear() { first_ = 0; rest_.clear(); }$/;"	f	class:fst::StringWeight
Clear	util.h	/^  void Clear() {$/;"	f	class:fst::CompactSet
ClearDependencies	replace-util.h	/^  void ClearDependencies() const {$/;"	f	class:fst::ReplaceUtil
ClearLookAheadPrefix	lookahead-matcher.h	/^  void ClearLookAheadPrefix() { prefix_arc_.nextstate = kNoStateId; }$/;"	f	class:fst::LookAheadMatcherBase
ClearMultiEpsLabels	matcher.h	/^  void ClearMultiEpsLabels() {$/;"	f	class:fst::MultiEpsMatcher
Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::AutoQueue
Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::FifoQueue
Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::LifoQueue
Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::PruneQueue
Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::SccQueue
Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::ShortestFirstQueue
Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::StateOrderQueue
Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::TopOrderQueue
Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::TrivialQueue
Closure	closure.h	/^void Closure(MutableFst<Arc> *fst, ClosureType closure_type) {$/;"	f	namespace:fst
Closure	closure.h	/^void Closure(RationalFst<Arc> *fst, ClosureType closure_type) {$/;"	f	namespace:fst
ClosureFst	closure.h	/^  ClosureFst(const ClosureFst<A> &fst, bool safe = false)$/;"	f	class:fst::ClosureFst
ClosureFst	closure.h	/^  ClosureFst(const Fst<A> &fst, ClosureType closure_type) {$/;"	f	class:fst::ClosureFst
ClosureFst	closure.h	/^  ClosureFst(const Fst<A> &fst, const ClosureFstOptions &opts)$/;"	f	class:fst::ClosureFst
ClosureFst	closure.h	/^class ClosureFst : public RationalFst<A> {$/;"	c	namespace:fst
ClosureFstOptions	closure.h	/^  ClosureFstOptions() : type(CLOSURE_STAR) {}$/;"	f	struct:fst::ClosureFstOptions
ClosureFstOptions	closure.h	/^  ClosureFstOptions(const RationalFstOptions &opts, ClosureType t)$/;"	f	struct:fst::ClosureFstOptions
ClosureFstOptions	closure.h	/^  explicit ClosureFstOptions(ClosureType t) : type(t) {}$/;"	f	struct:fst::ClosureFstOptions
ClosureFstOptions	closure.h	/^struct ClosureFstOptions : RationalFstOptions {$/;"	s	namespace:fst
ClosureType	rational.h	/^enum ClosureType { CLOSURE_STAR = 0,    \/\/ T* -> add the empty string$/;"	g	namespace:fst
CommonDivisor	determinize.h	/^  typedef GallicCommonDivisor<Label, Weight, S> CommonDivisor;$/;"	t	class:fst::DeterminizeFstImpl
Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const { return arc.ilabel; }$/;"	f	class:fst::StringCompactor
Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const {$/;"	f	class:fst::AcceptorCompactor
Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const {$/;"	f	class:fst::UnweightedAcceptorCompactor
Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const {$/;"	f	class:fst::UnweightedCompactor
Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const {$/;"	f	class:fst::WeightedStringCompactor
CompactElement	compact-fst.h	/^  typedef E CompactElement;$/;"	t	class:fst::CompactFstData
CompactElement	compact-fst.h	/^  typedef typename C::Element CompactElement;$/;"	t	class:fst::ArcIterator
CompactElement	compact-fst.h	/^  typedef typename C::Element CompactElement;$/;"	t	class:fst::CompactFstImpl
CompactFst	compact-fst.h	/^  CompactFst() : ImplToExpandedFst<Impl>(new Impl()) {}$/;"	f	class:fst::CompactFst
CompactFst	compact-fst.h	/^  CompactFst(Impl *impl) : ImplToExpandedFst<Impl>(impl) {}$/;"	f	class:fst::CompactFst
CompactFst	compact-fst.h	/^  CompactFst(const CompactFst<A, C, U> &fst, bool safe = false)$/;"	f	class:fst::CompactFst
CompactFst	compact-fst.h	/^  CompactFst(const Fst<A> &fst, C *compactor,$/;"	f	class:fst::CompactFst
CompactFst	compact-fst.h	/^  CompactFst(const Iterator &begin, const Iterator &end,$/;"	f	class:fst::CompactFst
CompactFst	compact-fst.h	/^  explicit CompactFst(const Fst<A> &fst, const C &compactor = C(),$/;"	f	class:fst::CompactFst
CompactFst	compact-fst.h	/^  explicit CompactFst(const Iterator &begin, const Iterator &end,$/;"	f	class:fst::CompactFst
CompactFst	compact-fst.h	/^class CompactFst : public ImplToExpandedFst< CompactFstImpl<A, C, U> > {$/;"	c	namespace:fst
CompactFstData	compact-fst.h	/^  CompactFstData()$/;"	f	class:fst::CompactFstData
CompactFstData	compact-fst.h	/^CompactFstData<E, U>::CompactFstData(const Fst<A> &fst, const C &compactor)$/;"	f	class:fst::CompactFstData
CompactFstData	compact-fst.h	/^CompactFstData<E, U>::CompactFstData(const Iterator &begin,$/;"	f	class:fst::CompactFstData
CompactFstData	compact-fst.h	/^class CompactFstData {$/;"	c	namespace:fst
CompactFstImpl	compact-fst.h	/^  CompactFstImpl()$/;"	f	class:fst::CompactFstImpl
CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const CompactFstImpl<A, C, U> &impl)$/;"	f	class:fst::CompactFstImpl
CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const Fst<Arc> &fst, C *compactor,$/;"	f	class:fst::CompactFstImpl
CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const Fst<Arc> &fst, const C &compactor,$/;"	f	class:fst::CompactFstImpl
CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const Iterator &b, const Iterator &e, C *compactor,$/;"	f	class:fst::CompactFstImpl
CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const Iterator &b, const Iterator &e, const C &compactor,$/;"	f	class:fst::CompactFstImpl
CompactFstImpl	compact-fst.h	/^  explicit CompactFstImpl(const CompactFstImpl<B, D, U> &impl)$/;"	f	class:fst::CompactFstImpl
CompactFstImpl	compact-fst.h	/^class CompactFstImpl : public CacheImpl<A> {$/;"	c	namespace:fst
CompactFstOptions	compact-fst.h	/^  CompactFstOptions() : CacheOptions(true, 0) {}$/;"	f	struct:fst::CompactFstOptions
CompactFstOptions	compact-fst.h	/^  CompactFstOptions(const CacheOptions &opts) : CacheOptions(opts) {}$/;"	f	struct:fst::CompactFstOptions
CompactFstOptions	compact-fst.h	/^struct CompactFstOptions : public CacheOptions {$/;"	s	namespace:fst
CompactHashBiTable	bi-table.h	/^  CompactHashBiTable()$/;"	f	class:fst::CompactHashBiTable
CompactHashBiTable	bi-table.h	/^  explicit CompactHashBiTable(size_t table_size)$/;"	f	class:fst::CompactHashBiTable
CompactHashBiTable	bi-table.h	/^class CompactHashBiTable {$/;"	c	namespace:fst
CompactHashStateTable	state-table.h	/^  CompactHashStateTable() : CompactHashBiTable<StateId, T, H>() {}$/;"	f	class:fst::CompactHashStateTable
CompactHashStateTable	state-table.h	/^  explicit CompactHashStateTable(size_t table_size)$/;"	f	class:fst::CompactHashStateTable
CompactHashStateTable	state-table.h	/^class CompactHashStateTable$/;"	c	namespace:fst
CompactSet	util.h	/^  CompactSet()$/;"	f	class:fst::CompactSet
CompactSet	util.h	/^  CompactSet(const CompactSet<Key, NoKey> &compact_set)$/;"	f	class:fst::CompactSet
CompactSet	util.h	/^class CompactSet {$/;"	c	namespace:fst
Compactor	compact-fst.h	/^  typedef C Compactor;$/;"	t	class:fst::CompactFstImpl
Compacts	compact-fst.h	/^  const CompactElement &Compacts(size_t i) const { return compacts_[i]; }$/;"	f	class:fst::CompactFstData
Compare	arcsort.h	/^  typedef C Compare;$/;"	t	class:fst::StdArcSortFst
Compare	queue.h	/^  typedef C Compare;$/;"	t	class:fst::ShortestFirstQueue
Compare	state-map.h	/^  struct Compare {$/;"	s	class:fst::ArcSumMapper
Compare	state-map.h	/^  struct Compare {$/;"	s	class:fst::ArcUniqueMapper
CompatProperties	test-properties.h	/^inline bool CompatProperties(uint64 props1, uint64 props2) {$/;"	f	namespace:fst
CompatSymbols	symbol-table.h	/^inline bool CompatSymbols(const SymbolTable *syms1, const SymbolTable *syms2,$/;"	f	namespace:fst
Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::AcceptorCompactor
Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::StringCompactor
Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::UnweightedAcceptorCompactor
Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::UnweightedCompactor
Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::WeightedStringCompactor
Compile	string.h	/^  void Compile(const vector<Label> &labels, CompactFst<A, StringCompactor<A>,$/;"	f	class:fst::StringCompiler
Compile	string.h	/^  void Compile(const vector<Label> &labels, MutableFst<A> *fst) const {$/;"	f	class:fst::StringCompiler
Complement	interval-set.h	/^void IntervalSet<T>::Complement(T maxval, IntervalSet<T> *oset) const {$/;"	f	class:fst::IntervalSet
ComplementFst	complement.h	/^  ComplementFst(const ComplementFst<A> &fst, bool safe = false)$/;"	f	class:fst::ComplementFst
ComplementFst	complement.h	/^  explicit ComplementFst(const Fst<A> &fst)$/;"	f	class:fst::ComplementFst
ComplementFst	complement.h	/^class ComplementFst : public ImplToFst< ComplementFstImpl<A> > {$/;"	c	namespace:fst
ComplementFstImpl	complement.h	/^  ComplementFstImpl(const ComplementFstImpl<A> &impl)$/;"	f	class:fst::ComplementFstImpl
ComplementFstImpl	complement.h	/^  explicit ComplementFstImpl(const Fst<A> &fst) : fst_(fst.Copy()) {$/;"	f	class:fst::ComplementFstImpl
ComplementFstImpl	complement.h	/^class ComplementFstImpl : public FstImpl<A> {$/;"	c	namespace:fst
Compose	compose.h	/^void Compose(const Fst<Arc> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
ComposeFilter	compose.h	/^enum ComposeFilter { AUTO_FILTER, SEQUENCE_FILTER, ALT_SEQUENCE_FILTER,$/;"	g	namespace:fst
ComposeFilter	lookahead-filter.h	/^  typedef LookAheadComposeFilter<SF, M> ComposeFilter;$/;"	t	class:fst::DefaultLookAhead
ComposeFilter	lookahead-filter.h	/^  typedef PushLabelsComposeFilter<WF, M> ComposeFilter;$/;"	t	class:fst::DefaultLookAhead
ComposeFilter	lookahead-filter.h	/^  typedef SequenceComposeFilter<M> ComposeFilter;$/;"	t	class:fst::DefaultLookAhead
ComposeFingerprint	state-table.h	/^  ComposeFingerprint() : mult1_(8192), mult2_(8192) {$/;"	f	class:fst::ComposeFingerprint
ComposeFingerprint	state-table.h	/^  ComposeFingerprint(StateId nstates1, StateId nstates2)$/;"	f	class:fst::ComposeFingerprint
ComposeFingerprint	state-table.h	/^class ComposeFingerprint {$/;"	c	namespace:fst
ComposeFst	compose.h	/^  ComposeFst() {}$/;"	f	class:fst::ComposeFst
ComposeFst	compose.h	/^  ComposeFst(const ComposeFst<A> &fst, bool safe = false) {$/;"	f	class:fst::ComposeFst
ComposeFst	compose.h	/^  ComposeFst(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ComposeFst
ComposeFst	compose.h	/^  ComposeFst(const typename M1::FST &fst1, const typename M2::FST &fst2,$/;"	f	class:fst::ComposeFst
ComposeFst	compose.h	/^class ComposeFst : public ImplToFst< ComposeFstImplBase<A> > {$/;"	c	namespace:fst
ComposeFstImpl	compose.h	/^  ComposeFstImpl(const ComposeFstImpl<M1, M2, F, T> &impl)$/;"	f	class:fst::ComposeFstImpl
ComposeFstImpl	compose.h	/^ComposeFstImpl<M1, M2, F, T>::ComposeFstImpl($/;"	f	class:fst::ComposeFstImpl
ComposeFstImpl	compose.h	/^class ComposeFstImpl : public ComposeFstImplBase<typename M1::Arc> {$/;"	c	namespace:fst
ComposeFstImplBase	compose.h	/^  ComposeFstImplBase(const ComposeFstImplBase<A> &impl)$/;"	f	class:fst::ComposeFstImplBase
ComposeFstImplBase	compose.h	/^  ComposeFstImplBase(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ComposeFstImplBase
ComposeFstImplBase	compose.h	/^class ComposeFstImplBase : public CacheImpl<A> {$/;"	c	namespace:fst
ComposeFstImplOptions	compose.h	/^  ComposeFstImplOptions()$/;"	f	struct:fst::ComposeFstImplOptions
ComposeFstImplOptions	compose.h	/^  explicit ComposeFstImplOptions(const CacheOptions &opts,$/;"	f	struct:fst::ComposeFstImplOptions
ComposeFstImplOptions	compose.h	/^struct ComposeFstImplOptions : public CacheOptions {$/;"	s	namespace:fst
ComposeFstOptions	compose.h	/^  ComposeFstOptions() : matcher1(0), matcher2(0), filter(0), state_table(0) {}$/;"	f	struct:fst::ComposeFstOptions
ComposeFstOptions	compose.h	/^  explicit ComposeFstOptions(const CacheOptions &opts,$/;"	f	struct:fst::ComposeFstOptions
ComposeFstOptions	compose.h	/^struct ComposeFstOptions : public CacheOptions {$/;"	s	namespace:fst
ComposeHash	state-table.h	/^class ComposeHash {$/;"	c	namespace:fst
ComposeOptions	compose.h	/^  ComposeOptions() : connect(true), filter_type(AUTO_FILTER) {}$/;"	f	struct:fst::ComposeOptions
ComposeOptions	compose.h	/^  ComposeOptions(bool c, ComposeFilter ft = AUTO_FILTER)$/;"	f	struct:fst::ComposeOptions
ComposeOptions	compose.h	/^struct ComposeOptions {$/;"	s	namespace:fst
ComposeState1Fingerprint	state-table.h	/^class ComposeState1Fingerprint {$/;"	c	namespace:fst
ComposeState2Fingerprint	state-table.h	/^class ComposeState2Fingerprint {$/;"	c	namespace:fst
ComposeStateTuple	state-table.h	/^  ComposeStateTuple()$/;"	f	struct:fst::ComposeStateTuple
ComposeStateTuple	state-table.h	/^  ComposeStateTuple(StateId s1, StateId s2, const FilterState &f)$/;"	f	struct:fst::ComposeStateTuple
ComposeStateTuple	state-table.h	/^struct ComposeStateTuple {$/;"	s	namespace:fst
Compute	minimize.h	/^  void Compute(const Fst<A>& fst) {$/;"	f	class:fst::CyclicMinimizer
ComputeArc	compact-fst.h	/^  Arc ComputeArc(StateId s, Unsigned i, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::CompactFstImpl
ComputeArc	replace.h	/^  bool ComputeArc(const StateTuple &tuple, const A &arc, A* arcp,$/;"	f	class:fst::ReplaceFstImpl
ComputeDistance	determinize.h	/^  Weight ComputeDistance(const Subset *subset) {$/;"	f	class:fst::DeterminizeFsaImpl
ComputeFinal	compose.h	/^  Weight ComputeFinal(StateId s) {$/;"	f	class:fst::ComposeFstImpl
ComputeFinal	determinize.h	/^  virtual Weight ComputeFinal(StateId s) { return from_fst_->Final(s); }$/;"	f	class:fst::DeterminizeFstImpl
ComputeFinal	determinize.h	/^  virtual Weight ComputeFinal(StateId s) {$/;"	f	class:fst::DeterminizeFsaImpl
ComputeFinalArc	replace.h	/^  bool ComputeFinalArc(const StateTuple &tuple, A* arcp,$/;"	f	class:fst::ReplaceFstImpl
ComputeProperties	test-properties.h	/^uint64 ComputeProperties(const Fst<Arc> &fst, uint64 mask, uint64 *known,$/;"	f	namespace:fst
ComputeStart	compose.h	/^  StateId ComputeStart() {$/;"	f	class:fst::ComposeFstImpl
ComputeStart	determinize.h	/^  virtual StateId ComputeStart() { return from_fst_->Start(); }$/;"	f	class:fst::DeterminizeFstImpl
ComputeStart	determinize.h	/^  virtual StateId ComputeStart() {$/;"	f	class:fst::DeterminizeFsaImpl
ComputeTotalWeight	push.h	/^typename Arc::Weight ComputeTotalWeight($/;"	f	namespace:fst::internal
Concat	concat.h	/^void Concat(MutableFst<Arc> *fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
Concat	concat.h	/^void Concat(RationalFst<Arc> *fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
Concat	concat.h	/^void Concat(const Fst<Arc> &fst1, MutableFst<Arc> *fst2) {$/;"	f	namespace:fst
Concat	concat.h	/^void Concat(const Fst<Arc> &fst1, RationalFst<Arc> *fst2) {$/;"	f	namespace:fst
Concat	synchronize.h	/^  const String *Concat(const String *s, Label l = 0) {$/;"	f	class:fst::SynchronizeFstImpl
ConcatFst	concat.h	/^  ConcatFst(const ConcatFst<A> &fst, bool safe = false)$/;"	f	class:fst::ConcatFst
ConcatFst	concat.h	/^  ConcatFst(const Fst<A> &fst1, const Fst<A> &fst2) {$/;"	f	class:fst::ConcatFst
ConcatFst	concat.h	/^  ConcatFst(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ConcatFst
ConcatFst	concat.h	/^class ConcatFst : public RationalFst<A> {$/;"	c	namespace:fst
ConcatFstOptions	concat.h	/^typedef RationalFstOptions ConcatFstOptions;$/;"	t	namespace:fst
Connect	connect.h	/^void Connect(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
Connect	replace-util.h	/^void ReplaceUtil<Arc>::Connect() {$/;"	f	class:fst::ReplaceUtil
Connected	replace-util.h	/^  bool Connected() const {$/;"	f	class:fst::ReplaceUtil
ConstFst	const-fst.h	/^  ConstFst() : ImplToExpandedFst<Impl>(new Impl()) {}$/;"	f	class:fst::ConstFst
ConstFst	const-fst.h	/^  ConstFst(const ConstFst<A, U> &fst) : ImplToExpandedFst<Impl>(fst) {}$/;"	f	class:fst::ConstFst
ConstFst	const-fst.h	/^  explicit ConstFst(Impl *impl) : ImplToExpandedFst<Impl>(impl) {}$/;"	f	class:fst::ConstFst
ConstFst	const-fst.h	/^  explicit ConstFst(const Fst<A> &fst)$/;"	f	class:fst::ConstFst
ConstFst	const-fst.h	/^class ConstFst : public ImplToExpandedFst< ConstFstImpl<A, U> > {$/;"	c	namespace:fst
ConstFstImpl	const-fst.h	/^  ConstFstImpl()$/;"	f	class:fst::ConstFstImpl
ConstFstImpl	const-fst.h	/^ConstFstImpl<A, U>::ConstFstImpl(const Fst<A> &fst) : nstates_(0), narcs_(0) {$/;"	f	class:fst::ConstFstImpl
ConstFstImpl	const-fst.h	/^class ConstFstImpl : public FstImpl<A> {$/;"	c	namespace:fst
Contains	interval-set.h	/^bool IntervalSet<T>::Contains(const IntervalSet<T> &iset) const {$/;"	f	class:fst::IntervalSet
Convert	register.h	/^  static Fst<Arc> *Convert(const Fst<Arc> &fst) { return new F(fst); }$/;"	f	class:fst::FstRegisterer
Convert	register.h	/^Fst<A> *Convert(const Fst<A> &fst, const string &ftype) {$/;"	f	namespace:fst
ConvertKeyToSoFilename	register.h	/^  virtual string ConvertKeyToSoFilename(const string& key) const {$/;"	f	class:fst::FstRegister
ConvertStringToLabels	string.h	/^  bool ConvertStringToLabels(const string &str, vector<Label> *labels) const {$/;"	f	class:fst::StringCompiler
ConvertSymbolToLabel	string.h	/^  bool ConvertSymbolToLabel(const char *s, Label* output) const {$/;"	f	class:fst::StringCompiler
Converter	register.h	/^  typedef Fst<A> *(*Converter)(const Fst<A> &fst);$/;"	t	struct:fst::FstRegisterEntry
Converter	register.h	/^  typedef typename FstRegisterEntry<A>::Converter Converter;$/;"	t	class:fst::FstRegister
Copy	arc-map.h	/^  virtual ArcMapFst<A, B, C> *Copy(bool safe = false) const {$/;"	f	class:fst::ArcMapFst
Copy	arcsort.h	/^  virtual ArcSortFst<A, C> *Copy(bool safe = false) const {$/;"	f	class:fst::ArcSortFst
Copy	closure.h	/^  virtual ClosureFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ClosureFst
Copy	compact-fst.h	/^  virtual CompactFst<A, C, U> *Copy(bool safe = false) const {$/;"	f	class:fst::CompactFst
Copy	complement.h	/^  virtual ComplementFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ComplementFst
Copy	compose.h	/^  virtual ComposeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ComposeFst
Copy	compose.h	/^  virtual ComposeFstImpl<M1, M2, F, T> *Copy() {$/;"	f	class:fst::ComposeFstImpl
Copy	concat.h	/^  virtual ConcatFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ConcatFst
Copy	const-fst.h	/^  virtual ConstFst<A, U> *Copy(bool safe = false) const {$/;"	f	class:fst::ConstFst
Copy	determinize.h	/^  virtual DeterminizeFsaImpl<A, D> *Copy() {$/;"	f	class:fst::DeterminizeFsaImpl
Copy	determinize.h	/^  virtual DeterminizeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::DeterminizeFst
Copy	determinize.h	/^  virtual DeterminizeFstImpl<A, S> *Copy() {$/;"	f	class:fst::DeterminizeFstImpl
Copy	difference.h	/^  virtual DifferenceFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::DifferenceFst
Copy	edit-fst.h	/^  virtual EditFst<A, WrappedFstT, MutableFstT> *Copy(bool safe = false) const {$/;"	f	class:fst::EditFst
Copy	encode.h	/^  virtual DecodeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::DecodeFst
Copy	encode.h	/^  virtual EncodeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::EncodeFst
Copy	factor-weight.h	/^  virtual FactorWeightFst<A, F> *Copy(bool copy = false) const {$/;"	f	class:fst::FactorWeightFst
Copy	intersect.h	/^  virtual IntersectFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::IntersectFst
Copy	invert.h	/^  virtual InvertFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::InvertFst
Copy	lookahead-matcher.h	/^  ArcLookAheadMatcher<M, F> *Copy(bool safe = false) const {$/;"	f	class:fst::ArcLookAheadMatcher
Copy	lookahead-matcher.h	/^  LabelLookAheadMatcher<M, F, S> *Copy(bool safe = false) const {$/;"	f	class:fst::LabelLookAheadMatcher
Copy	lookahead-matcher.h	/^  LookAheadMatcher<F> *Copy(bool safe = false) const {$/;"	f	class:fst::LookAheadMatcher
Copy	lookahead-matcher.h	/^  TrivialLookAheadMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::TrivialLookAheadMatcher
Copy	map.h	/^virtual MapFst<A, B, C> *Copy(bool safe = false) const {$/;"	f	class:fst::MapFst
Copy	matcher-fst.h	/^  LookAheadMatcher<FST> *Copy(bool safe = false) const {$/;"	f	class:fst::LookAheadMatcher
Copy	matcher-fst.h	/^  Matcher<FST> *Copy() const {$/;"	f	class:fst::Matcher
Copy	matcher-fst.h	/^  virtual MatcherFst<F, M, N, I> *Copy(bool safe = false) const {$/;"	f	class:fst::MatcherFst
Copy	matcher.h	/^  Matcher<F> *Copy(bool safe = false) const {$/;"	f	class:fst::Matcher
Copy	matcher.h	/^  MultiEpsMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::MultiEpsMatcher
Copy	matcher.h	/^  virtual PhiMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::PhiMatcher
Copy	matcher.h	/^  virtual RhoMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::RhoMatcher
Copy	matcher.h	/^  virtual SigmaMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::SigmaMatcher
Copy	matcher.h	/^  virtual SortedMatcher<F> *Copy(bool safe = false) const {$/;"	f	class:fst::SortedMatcher
Copy	project.h	/^  virtual ProjectFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ProjectFst
Copy	randgen.h	/^  virtual RandGenFst<A, B, S> *Copy(bool safe = false) const {$/;"	f	class:fst::RandGenFst
Copy	relabel.h	/^  virtual RelabelFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::RelabelFst
Copy	replace.h	/^  virtual ReplaceFst<A, T> *Copy(bool safe = false) const {$/;"	f	class:fst::ReplaceFst
Copy	replace.h	/^  virtual ReplaceFstMatcher<A, T> *Copy(bool safe = false) const {$/;"	f	class:fst::ReplaceFstMatcher
Copy	rmepsilon.h	/^  virtual RmEpsilonFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::RmEpsilonFst
Copy	state-map.h	/^  virtual StateMapFst<A, B, C> *Copy(bool safe = false) const {$/;"	f	class:fst::StateMapFst
Copy	symbol-table.h	/^  virtual SymbolTable* Copy() const {$/;"	f	class:fst::SymbolTable
Copy	synchronize.h	/^  virtual SynchronizeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::SynchronizeFst
Copy	union.h	/^  virtual UnionFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::UnionFst
Copy	vector-fst.h	/^  virtual VectorFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::VectorFst
CopyVisitor	visit.h	/^  CopyVisitor(MutableFst<Arc> *ofst) : ifst_(0), ofst_(ofst) {}$/;"	f	class:fst::CopyVisitor
CopyVisitor	visit.h	/^class CopyVisitor {$/;"	c	namespace:fst
Count	interval-set.h	/^  const T Count() const { return count_; }$/;"	f	class:fst::IntervalSet
CountEpsilons	compact-fst.h	/^  size_t CountEpsilons(StateId s, bool output_epsilons) {$/;"	f	class:fst::CompactFstImpl
CountStates	expanded-fst.h	/^typename Arc::StateId CountStates(const Fst<Arc> &fst) {$/;"	f	namespace:fst
CreateBase	compose.h	/^  static Impl *CreateBase(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ComposeFst
CreateBase1	compose.h	/^  static Impl *CreateBase1(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ComposeFst
CreateBase2	compose.h	/^  static Impl *CreateBase2($/;"	f	class:fst::ComposeFst
CreateImpl	matcher-fst.h	/^  static Impl *CreateImpl(const F &fst, const string &name) {$/;"	f	class:fst::MatcherFst
CreateImpl	matcher-fst.h	/^  static Impl *CreateImpl(const Fst<Arc> &fst, const string &name) {$/;"	f	class:fst::MatcherFst
CreateState	determinize.h	/^  StateId CreateState(Subset *subset) {$/;"	f	class:fst::DeterminizeFsaImpl
CyclicDependencies	replace-util.h	/^  bool CyclicDependencies() const {$/;"	f	class:fst::ReplaceUtil
CyclicDependencies	replace.h	/^  bool CyclicDependencies() const {$/;"	f	class:fst::ReplaceFst
CyclicDependencies	replace.h	/^  bool CyclicDependencies() const {$/;"	f	class:fst::ReplaceFstImpl
CyclicMinimizer	minimize.h	/^  CyclicMinimizer(const ExpandedFst<A>& fst):$/;"	f	class:fst::CyclicMinimizer
CyclicMinimizer	minimize.h	/^class CyclicMinimizer {$/;"	c	namespace:fst
D	lookahead-matcher.h	/^  typedef AddOnPair<MatcherData, MatcherData> D;$/;"	t	class:fst::LabelLookAheadRelabeler
D	matcher-fst.h	/^  typedef AddOnPair<typename M::MatcherData, typename M::MatcherData> D;$/;"	t	class:fst::MatcherFst
D	matcher-fst.h	/^  typedef AddOnPair<typename M::MatcherData, typename M::MatcherData> D;$/;"	t	class:fst::NullMatcherFstInit
DECLARE_bool	flags.h	53;"	d
DECLARE_double	flags.h	57;"	d
DECLARE_int32	flags.h	55;"	d
DECLARE_int64	flags.h	56;"	d
DECLARE_string	flags.h	54;"	d
DECODE	encode.h	/^enum EncodeType { ENCODE = 1, DECODE = 2 };$/;"	e	enum:fst::EncodeType
DEFINE_VAR	flags.h	209;"	d
DEFINE_bool	flags.h	218;"	d
DEFINE_double	flags.h	223;"	d
DEFINE_int32	flags.h	221;"	d
DEFINE_int64	flags.h	222;"	d
DEFINE_string	flags.h	219;"	d
DISALLOW_COPY_AND_ASSIGN	compat.h	33;"	d
DIVIDE_ANY	weight.h	/^                  DIVIDE_ANY };  \/\/ division in a commutative semiring$/;"	e	enum:fst::DivideType
DIVIDE_LEFT	weight.h	/^enum DivideType { DIVIDE_LEFT,   \/\/ left division$/;"	e	enum:fst::DivideType
DIVIDE_RIGHT	weight.h	/^                  DIVIDE_RIGHT,  \/\/ right division$/;"	e	enum:fst::DivideType
Data	compact-fst.h	/^  CompactFstData<CompactElement, U> *Data() const { return data_; }$/;"	f	class:fst::CompactFstImpl
Decode	encode.h	/^  const Tuple* Decode(Label key) const {$/;"	f	class:fst::EncodeTable
Decode	encode.h	/^void Decode(MutableFst<A>* fst, const EncodeMapper<A>& mapper) {$/;"	f	namespace:fst
DecodeFst	encode.h	/^  DecodeFst(const DecodeFst<A> &fst, bool safe = false)$/;"	f	class:fst::DecodeFst
DecodeFst	encode.h	/^  DecodeFst(const Fst<A> &fst, const EncodeMapper<A>& encoder)$/;"	f	class:fst::DecodeFst
DecodeFst	encode.h	/^class DecodeFst : public ArcMapFst<A, A, EncodeMapper<A> > {$/;"	c	namespace:fst
Decr	lock.h	/^  int Decr() const {  return --count_; }$/;"	f	class:fst::RefCounter
DecrRefCount	accumulator.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::CacheLogAccumulatorData
DecrRefCount	accumulator.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::FastLogAccumulatorData
DecrRefCount	accumulator.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::ReplaceAccumulatorData
DecrRefCount	add-on.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::NullAddOn
DecrRefCount	add-on.h	/^  int DecrRefCount() {$/;"	f	class:fst::AddOnPair
DecrRefCount	compact-fst.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::CompactFstData
DecrRefCount	edit-fst.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::EditFstData
DecrRefCount	encode.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::EncodeTable
DecrRefCount	fst.h	/^  int DecrRefCount() {$/;"	f	class:fst::FstImpl
DecrRefCount	label-reachable.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::LabelReachableData
DecrRefCount	symbol-table.h	/^  int DecrRefCount() const {$/;"	f	class:fst::SymbolTableImpl
DefaultAccumulator	accumulator.h	/^  DefaultAccumulator() {}$/;"	f	class:fst::DefaultAccumulator
DefaultAccumulator	accumulator.h	/^  DefaultAccumulator(const DefaultAccumulator<A> &acc) {}$/;"	f	class:fst::DefaultAccumulator
DefaultAccumulator	accumulator.h	/^class DefaultAccumulator {$/;"	c	namespace:fst
DefaultCacheStateAllocator	cache.h	/^  DefaultCacheStateAllocator() : mru_(NULL) { }$/;"	f	struct:fst::DefaultCacheStateAllocator
DefaultCacheStateAllocator	cache.h	/^struct DefaultCacheStateAllocator {$/;"	s	namespace:fst
DefaultCommonDivisor	determinize.h	/^class DefaultCommonDivisor {$/;"	c	namespace:fst
DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead {$/;"	c	namespace:fst
DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<A, MATCH_INPUT> {$/;"	c	namespace:fst
DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<A, MATCH_OUTPUT> {$/;"	c	namespace:fst
DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<LogArc, MATCH_INPUT> {$/;"	c	namespace:fst
DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<LogArc, MATCH_OUTPUT> {$/;"	c	namespace:fst
DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<StdArc, MATCH_INPUT> {$/;"	c	namespace:fst
DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<StdArc, MATCH_OUTPUT> {$/;"	c	namespace:fst
DefaultReplaceStateTable	replace.h	/^  DefaultReplaceStateTable($/;"	f	class:fst::DefaultReplaceStateTable
DefaultReplaceStateTable	replace.h	/^  DefaultReplaceStateTable(const DefaultReplaceStateTable<A, P> &table)$/;"	f	class:fst::DefaultReplaceStateTable
DefaultReplaceStateTable	replace.h	/^class DefaultReplaceStateTable : public CompactHashStateTable<$/;"	c	namespace:fst
DefaultValue	sparse-tuple-weight.h	/^  const W& DefaultValue() const { return default_; }$/;"	f	class:fst::SparseTupleWeight
DeleteAllStatesProperties	properties.h	/^uint64 DeleteAllStatesProperties(uint64 inprops, uint64 staticprops) {$/;"	f	namespace:fst
DeleteArcs	cache.h	/^  void DeleteArcs(StateId s) {$/;"	f	class:fst::CacheBaseImpl
DeleteArcs	cache.h	/^  void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::CacheBaseImpl
DeleteArcs	edit-fst.h	/^  void DeleteArcs(StateId s) {$/;"	f	class:fst::EditFstImpl
DeleteArcs	edit-fst.h	/^  void DeleteArcs(StateId s, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
DeleteArcs	edit-fst.h	/^  void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::EditFstImpl
DeleteArcs	edit-fst.h	/^  void DeleteArcs(StateId s, size_t n, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
DeleteArcs	mutable-fst.h	/^  virtual void DeleteArcs(StateId s) {$/;"	f	class:fst::ImplToMutableFst
DeleteArcs	mutable-fst.h	/^  virtual void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::ImplToMutableFst
DeleteArcs	vector-fst.h	/^  void DeleteArcs(StateId s) { states_[s]->arcs.clear(); }$/;"	f	class:fst::VectorFstBaseImpl
DeleteArcs	vector-fst.h	/^  void DeleteArcs(StateId s) {$/;"	f	class:fst::VectorFstImpl
DeleteArcs	vector-fst.h	/^  void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::VectorFstBaseImpl
DeleteArcs	vector-fst.h	/^  void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::VectorFstImpl
DeleteArcsProperties	properties.h	/^uint64 DeleteArcsProperties(uint64 inprops) {$/;"	f	namespace:fst
DeleteStates	edit-fst.h	/^  void DeleteStates() {$/;"	f	class:fst::EditFstData
DeleteStates	edit-fst.h	/^  void DeleteStates(const vector<StateId>& dstates) {$/;"	f	class:fst::EditFstImpl
DeleteStates	edit-fst.h	/^inline void EditFstImpl<A, WrappedFstT, MutableFstT>::DeleteStates() {$/;"	f	class:fst::EditFstImpl
DeleteStates	mutable-fst.h	/^  virtual void DeleteStates() {$/;"	f	class:fst::ImplToMutableFst
DeleteStates	mutable-fst.h	/^  virtual void DeleteStates(const vector<StateId> &dstates) {$/;"	f	class:fst::ImplToMutableFst
DeleteStates	vector-fst.h	/^  void DeleteStates() {$/;"	f	class:fst::VectorFstBaseImpl
DeleteStates	vector-fst.h	/^  void DeleteStates() {$/;"	f	class:fst::VectorFstImpl
DeleteStates	vector-fst.h	/^  void DeleteStates(const vector<StateId> &dstates) {$/;"	f	class:fst::VectorFstImpl
DeleteStates	vector-fst.h	/^  void DeleteStates(const vector<StateId>& dstates) {$/;"	f	class:fst::VectorFstBaseImpl
DeleteStatesProperties	properties.h	/^uint64 DeleteStatesProperties(uint64 inprops) {$/;"	f	namespace:fst
Depth	replace.h	/^    size_t Depth() const {$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
Dequeue	queue.h	/^  void Dequeue() { Dequeue_(); }$/;"	f	class:fst::QueueBase
Dequeue	queue.h	/^  void Dequeue() { front_ = kNoStateId; }$/;"	f	class:fst::TrivialQueue
Dequeue	queue.h	/^  void Dequeue() { pop_back(); }$/;"	f	class:fst::FifoQueue
Dequeue	queue.h	/^  void Dequeue() { pop_front(); }$/;"	f	class:fst::LifoQueue
Dequeue	queue.h	/^  void Dequeue() { queue_->Dequeue(); }$/;"	f	class:fst::AutoQueue
Dequeue	queue.h	/^  void Dequeue() { queue_->Dequeue(); }$/;"	f	class:fst::PruneQueue
Dequeue	queue.h	/^  void Dequeue() {$/;"	f	class:fst::SccQueue
Dequeue	queue.h	/^  void Dequeue() {$/;"	f	class:fst::ShortestFirstQueue
Dequeue	queue.h	/^  void Dequeue() {$/;"	f	class:fst::StateOrderQueue
Dequeue	queue.h	/^  void Dequeue() {$/;"	f	class:fst::TopOrderQueue
Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::AutoQueue
Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::FifoQueue
Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::LifoQueue
Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::PruneQueue
Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::SccQueue
Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::ShortestFirstQueue
Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::StateOrderQueue
Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::TopOrderQueue
Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::TrivialQueue
DetStringComposeStateTable	state-table.h	/^  DetStringComposeStateTable(const DetStringComposeStateTable<A, F> &table)$/;"	f	class:fst::DetStringComposeStateTable
DetStringComposeStateTable	state-table.h	/^  DetStringComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2)$/;"	f	class:fst::DetStringComposeStateTable
DetStringComposeStateTable	state-table.h	/^class DetStringComposeStateTable : public$/;"	c	namespace:fst
Determinize	determinize.h	/^void Determinize(const Fst<Arc> &ifst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
DeterminizeFsaImpl	determinize.h	/^  DeterminizeFsaImpl(const DeterminizeFsaImpl<A, D> &impl)$/;"	f	class:fst::DeterminizeFsaImpl
DeterminizeFsaImpl	determinize.h	/^  DeterminizeFsaImpl(const Fst<A> &fst, D common_divisor,$/;"	f	class:fst::DeterminizeFsaImpl
DeterminizeFsaImpl	determinize.h	/^class DeterminizeFsaImpl : public DeterminizeFstImplBase<A> {$/;"	c	namespace:fst
DeterminizeFst	determinize.h	/^  DeterminizeFst($/;"	f	class:fst::DeterminizeFst
DeterminizeFst	determinize.h	/^  DeterminizeFst(const DeterminizeFst<A> &fst, bool safe = false) {$/;"	f	class:fst::DeterminizeFst
DeterminizeFst	determinize.h	/^  DeterminizeFst(const Fst<A> &fst, const D &common_div,$/;"	f	class:fst::DeterminizeFst
DeterminizeFst	determinize.h	/^  explicit DeterminizeFst($/;"	f	class:fst::DeterminizeFst
DeterminizeFst	determinize.h	/^class DeterminizeFst : public ImplToFst< DeterminizeFstImplBase<A> >  {$/;"	c	namespace:fst
DeterminizeFstImpl	determinize.h	/^  DeterminizeFstImpl(const DeterminizeFstImpl<A, S> &impl)$/;"	f	class:fst::DeterminizeFstImpl
DeterminizeFstImpl	determinize.h	/^  DeterminizeFstImpl(const Fst<A> &fst, const DeterminizeFstOptions<A> &opts)$/;"	f	class:fst::DeterminizeFstImpl
DeterminizeFstImpl	determinize.h	/^class DeterminizeFstImpl : public DeterminizeFstImplBase<A> {$/;"	c	namespace:fst
DeterminizeFstImplBase	determinize.h	/^  DeterminizeFstImplBase(const DeterminizeFstImplBase<A> &impl)$/;"	f	class:fst::DeterminizeFstImplBase
DeterminizeFstImplBase	determinize.h	/^  DeterminizeFstImplBase(const Fst<A> &fst,$/;"	f	class:fst::DeterminizeFstImplBase
DeterminizeFstImplBase	determinize.h	/^class DeterminizeFstImplBase : public CacheImpl<A> {$/;"	c	namespace:fst
DeterminizeFstOptions	determinize.h	/^  explicit DeterminizeFstOptions(const CacheOptions &opts,$/;"	f	struct:fst::DeterminizeFstOptions
DeterminizeFstOptions	determinize.h	/^  explicit DeterminizeFstOptions(float del = kDelta, Label lab = 0)$/;"	f	struct:fst::DeterminizeFstOptions
DeterminizeFstOptions	determinize.h	/^struct DeterminizeFstOptions : CacheOptions {$/;"	s	namespace:fst
DeterminizeOptions	determinize.h	/^  explicit DeterminizeOptions(float d = kDelta, Weight w = Weight::Zero(),$/;"	f	struct:fst::DeterminizeOptions
DeterminizeOptions	determinize.h	/^struct DeterminizeOptions {$/;"	s	namespace:fst
DfsState	dfs-visit.h	/^  DfsState(const Fst<Arc> &fst, StateId s): state_id(s), arc_iter(fst, s) {}$/;"	f	struct:fst::DfsState
DfsState	dfs-visit.h	/^struct DfsState {$/;"	s	namespace:fst
DfsVisit	dfs-visit.h	/^void DfsVisit(const Fst<Arc> &fst, V *visitor) {$/;"	f	namespace:fst
DfsVisit	dfs-visit.h	/^void DfsVisit(const Fst<Arc> &fst, V *visitor, ArcFilter filter) {$/;"	f	namespace:fst
Difference	difference.h	/^void Difference(const Fst<Arc> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
Difference	interval-set.h	/^void IntervalSet<T>::Difference(const IntervalSet<T> &iset,$/;"	f	class:fst::IntervalSet
DifferenceFst	difference.h	/^  DifferenceFst(const DifferenceFst<A> &fst, bool safe = false)$/;"	f	class:fst::DifferenceFst
DifferenceFst	difference.h	/^  DifferenceFst(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::DifferenceFst
DifferenceFst	difference.h	/^class DifferenceFst : public ComposeFst<A> {$/;"	c	namespace:fst
DifferenceFstOptions	difference.h	/^  DifferenceFstOptions() {}$/;"	f	struct:fst::DifferenceFstOptions
DifferenceFstOptions	difference.h	/^  explicit DifferenceFstOptions(const CacheOptions &opts,$/;"	f	struct:fst::DifferenceFstOptions
DifferenceFstOptions	difference.h	/^struct DifferenceFstOptions : public ComposeFstOptions<A, M, F, T> {$/;"	s	namespace:fst
DifferenceOptions	difference.h	/^typedef ComposeOptions DifferenceOptions;$/;"	t	namespace:fst
Digest	compat.h	/^  string Digest() {$/;"	f	class:fst::CheckSummer
Divide	expectation-weight.h	/^inline ExpectationWeight<X1, X2> Divide(const ExpectationWeight<X1, X2> &w,$/;"	f	namespace:fst
Divide	float-weight.h	/^inline LogWeightTpl<T> Divide(const LogWeightTpl<T> &w1,$/;"	f	namespace:fst
Divide	float-weight.h	/^inline LogWeightTpl<double> Divide(const LogWeightTpl<double> &w1,$/;"	f	namespace:fst
Divide	float-weight.h	/^inline LogWeightTpl<float> Divide(const LogWeightTpl<float> &w1,$/;"	f	namespace:fst
Divide	float-weight.h	/^inline MinMaxWeightTpl<T> Divide(const MinMaxWeightTpl<T> &w1,$/;"	f	namespace:fst
Divide	float-weight.h	/^inline MinMaxWeightTpl<double> Divide(const MinMaxWeightTpl<double> &w1,$/;"	f	namespace:fst
Divide	float-weight.h	/^inline MinMaxWeightTpl<float> Divide(const MinMaxWeightTpl<float> &w1,$/;"	f	namespace:fst
Divide	float-weight.h	/^inline TropicalWeightTpl<T> Divide(const TropicalWeightTpl<T> &w1,$/;"	f	namespace:fst
Divide	float-weight.h	/^inline TropicalWeightTpl<double> Divide(const TropicalWeightTpl<double> &w1,$/;"	f	namespace:fst
Divide	float-weight.h	/^inline TropicalWeightTpl<float> Divide(const TropicalWeightTpl<float> &w1,$/;"	f	namespace:fst
Divide	lexicographic-weight.h	/^inline LexicographicWeight<W1, W2> Divide(const LexicographicWeight<W1, W2> &w,$/;"	f	namespace:fst
Divide	power-weight.h	/^inline PowerWeight<W, n> Divide(const PowerWeight<W, n> &w1,$/;"	f	namespace:fst
Divide	product-weight.h	/^inline ProductWeight<W1, W2> Divide(const ProductWeight<W1, W2> &w,$/;"	f	namespace:fst
Divide	signed-log-weight.h	/^inline SignedLogWeightTpl<T> Divide(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
Divide	sparse-power-weight.h	/^inline SparsePowerWeight<W, K> Divide(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
Divide	string-weight.h	/^Divide(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
Divide	string-weight.h	/^Divide(const StringWeight<L, STRING_RIGHT> &w1,$/;"	f	namespace:fst
Divide	string-weight.h	/^Divide(const StringWeight<L, STRING_RIGHT_RESTRICT> &w1,$/;"	f	namespace:fst
DivideType	weight.h	/^enum DivideType { DIVIDE_LEFT,   \/\/ left division$/;"	g	namespace:fst
Done	arc-map.h	/^  bool Done() const { return siter_.Done() && !superfinal_; }$/;"	f	class:fst::StateIterator
Done	arcsort.h	/^  bool Done() const { return i_ >= arcs_.size(); }$/;"	f	class:fst::ArcSortMapper
Done	cache.h	/^  bool Done() const { return i_ >= state_->arcs.size(); }$/;"	f	class:fst::CacheArcIterator
Done	cache.h	/^  bool Done() const { return i_ >= state_->arcs.size(); }$/;"	f	class:fst::CacheMutableArcIterator
Done	cache.h	/^  bool Done() const {$/;"	f	class:fst::CacheStateIterator
Done	compact-fst.h	/^  bool Done() const { return pos_ >= num_arcs_; }$/;"	f	class:fst::ArcIterator
Done	compact-fst.h	/^  bool Done() const { return s_ >= nstates_; }$/;"	f	class:fst::StateIterator
Done	complement.h	/^  bool Done() const { return s_ > 0 && siter_.Done(); }$/;"	f	class:fst::StateIterator
Done	complement.h	/^  bool Done() const {$/;"	f	class:fst::ArcIterator
Done	const-fst.h	/^  bool Done() const { return i_ >= narcs_; }$/;"	f	class:fst::ArcIterator
Done	const-fst.h	/^  bool Done() const { return s_ >= nstates_; }$/;"	f	class:fst::StateIterator
Done	factor-weight.h	/^  bool Done() const { return done_; }$/;"	f	class:fst::GallicFactor
Done	factor-weight.h	/^  bool Done() const { return done_; }$/;"	f	class:fst::StringFactor
Done	factor-weight.h	/^  bool Done() const { return true; }$/;"	f	class:fst::IdentityFactor
Done	fst.h	/^  bool Done() const { return Done_(); }            \/\/ End of iterator?$/;"	f	class:fst::ArcIteratorBase
Done	fst.h	/^  bool Done() const { return Done_(); }       \/\/ End of iterator?$/;"	f	class:fst::StateIteratorBase
Done	fst.h	/^  bool Done() const {$/;"	f	class:fst::ArcIterator
Done	fst.h	/^  bool Done() const {$/;"	f	class:fst::StateIterator
Done	lookahead-matcher.h	/^  bool Done() const { return base_->Done(); }$/;"	f	class:fst::LookAheadMatcher
Done	lookahead-matcher.h	/^  bool Done() const { return matcher_.Done(); }$/;"	f	class:fst::ArcLookAheadMatcher
Done	lookahead-matcher.h	/^  bool Done() const { return matcher_.Done(); }$/;"	f	class:fst::LabelLookAheadMatcher
Done	lookahead-matcher.h	/^  bool Done() const { return matcher_.Done(); }$/;"	f	class:fst::TrivialLookAheadMatcher
Done	matcher-fst.h	/^  bool Done() const { return matcher_->Done(); }$/;"	f	class:fst::LookAheadMatcher
Done	matcher-fst.h	/^  bool Done() const { return matcher_->Done(); }$/;"	f	class:fst::Matcher
Done	matcher.h	/^  bool Done() const { return Done_(); }$/;"	f	class:fst::MatcherBase
Done	matcher.h	/^  bool Done() const { return base_->Done(); }$/;"	f	class:fst::Matcher
Done	matcher.h	/^  bool Done() const { return matcher_->Done(); }$/;"	f	class:fst::PhiMatcher
Done	matcher.h	/^  bool Done() const { return matcher_->Done(); }$/;"	f	class:fst::RhoMatcher
Done	matcher.h	/^  bool Done() const {$/;"	f	class:fst::MultiEpsMatcher
Done	matcher.h	/^  bool Done() const {$/;"	f	class:fst::SigmaMatcher
Done	matcher.h	/^  bool Done() const {$/;"	f	class:fst::SortedMatcher
Done	mutable-fst.h	/^  bool Done() const { return data_.base->Done(); }$/;"	f	class:fst::MutableArcIterator
Done	partition.h	/^  bool Done() {$/;"	f	class:fst::PartitionIterator
Done	randgen.h	/^  bool Done() const { return sample_iter_ == sample_map_.end(); }$/;"	f	class:fst::ArcSampler
Done	relabel.h	/^  bool Done() const { return siter_.Done(); }$/;"	f	class:fst::StateIterator
Done	replace.h	/^  bool Done() const { return pos_ >= num_arcs_; }$/;"	f	class:fst::ArcIterator
Done	sparse-tuple-weight.h	/^  bool Done() const {$/;"	f	class:fst::SparseTupleWeightIterator
Done	state-map.h	/^  bool Done() const { return aiter_->Done(); }$/;"	f	class:fst::IdentityStateMapper
Done	state-map.h	/^  bool Done() const { return i_ >= arcs_.size(); }$/;"	f	class:fst::ArcSumMapper
Done	state-map.h	/^  bool Done() const { return i_ >= arcs_.size(); }$/;"	f	class:fst::ArcUniqueMapper
Done	string-weight.h	/^  bool Done() const { return fin_; }$/;"	f	class:fst::StringWeightReverseIterator
Done	string-weight.h	/^  bool Done() const {$/;"	f	class:fst::StringWeightIterator
Done	symbol-table.h	/^  bool Done(void) {$/;"	f	class:fst::SymbolTableIterator
Done	vector-fst.h	/^  bool Done() const { return i_ >= arcs_.size(); }$/;"	f	class:fst::ArcIterator
Done	vector-fst.h	/^  bool Done() const { return i_ >= state_->arcs.size(); }$/;"	f	class:fst::MutableArcIterator
Done	vector-fst.h	/^  bool Done() const { return s_ >= nstates_; }$/;"	f	class:fst::StateIterator
Done_	arc-map.h	/^  bool Done_() const { return Done(); }$/;"	f	class:fst::StateIterator
Done_	cache.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::CacheMutableArcIterator
Done_	cache.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::CacheStateIterator
Done_	complement.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::ArcIterator
Done_	complement.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::StateIterator
Done_	lookahead-matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::ArcLookAheadMatcher
Done_	lookahead-matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::LabelLookAheadMatcher
Done_	lookahead-matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::TrivialLookAheadMatcher
Done_	matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::PhiMatcher
Done_	matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::RhoMatcher
Done_	matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::SigmaMatcher
Done_	matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::SortedMatcher
Done_	relabel.h	/^  bool Done_() const { return Done(); }$/;"	f	class:fst::StateIterator
Done_	replace.h	/^  virtual bool Done_() const {$/;"	f	class:fst::ReplaceFstMatcher
Done_	vector-fst.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::MutableArcIterator
DotProduct	power-weight.h	/^inline W DotProduct(const PowerWeight<W, n> &w1,$/;"	f	namespace:fst
DotProduct	sparse-power-weight.h	/^inline const W& DotProduct(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
ENCODE	encode.h	/^enum EncodeType { ENCODE = 1, DECODE = 2 };$/;"	e	enum:fst::EncodeType
EPS_NORM_INPUT	epsnormalize.h	/^enum EpsNormalizeType {EPS_NORM_INPUT, EPS_NORM_OUTPUT};$/;"	e	enum:fst::EpsNormalizeType
EPS_NORM_OUTPUT	epsnormalize.h	/^enum EpsNormalizeType {EPS_NORM_INPUT, EPS_NORM_OUTPUT};$/;"	e	enum:fst::EpsNormalizeType
EditFst	edit-fst.h	/^  EditFst() : ImplToMutableFst<Impl>(new Impl()) {}$/;"	f	class:fst::EditFst
EditFst	edit-fst.h	/^  EditFst(const EditFst<A, WrappedFstT, MutableFstT> &fst, bool safe = false) :$/;"	f	class:fst::EditFst
EditFst	edit-fst.h	/^  explicit EditFst(Impl *impl) : ImplToMutableFst<Impl>(impl) {}$/;"	f	class:fst::EditFst
EditFst	edit-fst.h	/^  explicit EditFst(const Fst<A> &fst) :$/;"	f	class:fst::EditFst
EditFst	edit-fst.h	/^  explicit EditFst(const WrappedFstT &fst) :$/;"	f	class:fst::EditFst
EditFst	edit-fst.h	/^class EditFst :$/;"	c	namespace:fst
EditFstData	edit-fst.h	/^  EditFstData() : num_new_states_(0) {$/;"	f	class:fst::EditFstData
EditFstData	edit-fst.h	/^  EditFstData(const EditFstData &other) :$/;"	f	class:fst::EditFstData
EditFstData	edit-fst.h	/^class EditFstData {$/;"	c	namespace:fst
EditFstImpl	edit-fst.h	/^  EditFstImpl() {$/;"	f	class:fst::EditFstImpl
EditFstImpl	edit-fst.h	/^  EditFstImpl(const EditFstImpl &impl)$/;"	f	class:fst::EditFstImpl
EditFstImpl	edit-fst.h	/^  explicit EditFstImpl(const Fst<A> &wrapped)$/;"	f	class:fst::EditFstImpl
EditFstImpl	edit-fst.h	/^class EditFstImpl : public FstImpl<A> {$/;"	c	namespace:fst
EditedStart	edit-fst.h	/^  StateId EditedStart() const {$/;"	f	class:fst::EditFstData
Element	compact-fst.h	/^  typedef pair< pair<Label, Label>, StateId > Element;$/;"	t	class:fst::UnweightedCompactor
Element	compact-fst.h	/^  typedef pair< pair<Label, Weight>, StateId > Element;$/;"	t	class:fst::AcceptorCompactor
Element	compact-fst.h	/^  typedef pair<Label, StateId> Element;$/;"	t	class:fst::UnweightedAcceptorCompactor
Element	compact-fst.h	/^  typedef pair<Label, Weight> Element;$/;"	t	class:fst::WeightedStringCompactor
Element	compact-fst.h	/^  typedef typename A::Label Element;$/;"	t	class:fst::StringCompactor
Element	determinize.h	/^    Element() {}$/;"	f	struct:fst::DeterminizeFsaImpl::Element
Element	determinize.h	/^    Element(StateId s, Weight w) : state_id(s), weight(w) {}$/;"	f	struct:fst::DeterminizeFsaImpl::Element
Element	determinize.h	/^  struct Element {$/;"	s	class:fst::DeterminizeFsaImpl
Element	factor-weight.h	/^    Element() {}$/;"	f	struct:fst::FactorWeightFstImpl::Element
Element	factor-weight.h	/^    Element(StateId s, Weight w) : state(s), weight(w) {}$/;"	f	struct:fst::FactorWeightFstImpl::Element
Element	factor-weight.h	/^  struct Element {$/;"	s	class:fst::FactorWeightFstImpl
Element	partition.h	/^    Element() : value(0), next(0), prev(0) {}$/;"	f	struct:fst::Partition::Element
Element	partition.h	/^    Element(T v) : value(v), next(0), prev(0) {}$/;"	f	struct:fst::Partition::Element
Element	partition.h	/^  struct Element {$/;"	s	class:fst::Partition
Element	partition.h	/^  typedef typename Partition<T>::Element Element;$/;"	t	class:fst::PartitionIterator
Element	rmepsilon.h	/^    Element() {}$/;"	f	struct:fst::RmEpsilonState::Element
Element	rmepsilon.h	/^    Element(Label i, Label o, StateId s)$/;"	f	struct:fst::RmEpsilonState::Element
Element	rmepsilon.h	/^  struct Element {$/;"	s	class:fst::RmEpsilonState
Element	synchronize.h	/^    Element() {}$/;"	f	struct:fst::SynchronizeFstImpl::Element
Element	synchronize.h	/^    Element(StateId s, const String *i, const String *o)$/;"	f	struct:fst::SynchronizeFstImpl::Element
Element	synchronize.h	/^  struct Element {$/;"	s	class:fst::SynchronizeFstImpl
ElementEqual	factor-weight.h	/^  class ElementEqual {$/;"	c	class:fst::FactorWeightFstImpl
ElementEqual	rmepsilon.h	/^  class ElementEqual {$/;"	c	class:fst::RmEpsilonState
ElementEqual	synchronize.h	/^  class ElementEqual {$/;"	c	class:fst::SynchronizeFstImpl
ElementKey	factor-weight.h	/^  class ElementKey {$/;"	c	class:fst::FactorWeightFstImpl
ElementKey	rmepsilon.h	/^  class ElementKey {$/;"	c	class:fst::RmEpsilonState
ElementKey	synchronize.h	/^  class ElementKey {$/;"	c	class:fst::SynchronizeFstImpl
ElementMap	factor-weight.h	/^  typedef unordered_map<Element, StateId, ElementKey, ElementEqual> ElementMap;$/;"	t	class:fst::FactorWeightFstImpl
ElementMap	rmepsilon.h	/^                   ElementKey, ElementEqual> ElementMap;$/;"	t	class:fst::RmEpsilonState
ElementMap	synchronize.h	/^  typedef unordered_map<Element, StateId, ElementKey, ElementEqual> ElementMap;$/;"	t	class:fst::SynchronizeFstImpl
Empty	heap.h	/^  bool Empty() const {$/;"	f	class:fst::Heap
Empty	interval-set.h	/^  const bool Empty() const { return intervals_.empty(); }$/;"	f	class:fst::IntervalSet
Empty	queue.h	/^  bool Empty() const { return Empty_(); }$/;"	f	class:fst::QueueBase
Empty	queue.h	/^  bool Empty() const { return empty(); }$/;"	f	class:fst::FifoQueue
Empty	queue.h	/^  bool Empty() const { return empty(); }$/;"	f	class:fst::LifoQueue
Empty	queue.h	/^  bool Empty() const { return front_ == kNoStateId; }$/;"	f	class:fst::TrivialQueue
Empty	queue.h	/^  bool Empty() const { return front_ > back_; }$/;"	f	class:fst::StateOrderQueue
Empty	queue.h	/^  bool Empty() const { return front_ > back_; }$/;"	f	class:fst::TopOrderQueue
Empty	queue.h	/^  bool Empty() const { return heap_.Empty(); }$/;"	f	class:fst::ShortestFirstQueue
Empty	queue.h	/^  bool Empty() const { return queue_->Empty(); }$/;"	f	class:fst::AutoQueue
Empty	queue.h	/^  bool Empty() const { return queue_->Empty(); }$/;"	f	class:fst::PruneQueue
Empty	queue.h	/^  bool Empty() const {$/;"	f	class:fst::SccQueue
Empty	synchronize.h	/^  bool Empty(const String *s, Label l = 0) const {$/;"	f	class:fst::SynchronizeFstImpl
Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::AutoQueue
Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::FifoQueue
Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::LifoQueue
Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::PruneQueue
Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::SccQueue
Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::ShortestFirstQueue
Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::StateOrderQueue
Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::TopOrderQueue
Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::TrivialQueue
Encode	encode.h	/^  Label Encode(const A &arc) {$/;"	f	class:fst::EncodeTable
Encode	encode.h	/^void Encode(MutableFst<A> *fst, EncodeMapper<A>* mapper) {$/;"	f	namespace:fst
EncodeFst	encode.h	/^  EncodeFst(const EncodeFst<A> &fst, bool copy = false)$/;"	f	class:fst::EncodeFst
EncodeFst	encode.h	/^  EncodeFst(const Fst<A> &fst, EncodeMapper<A>* encoder)$/;"	f	class:fst::EncodeFst
EncodeFst	encode.h	/^  EncodeFst(const Fst<A> &fst, const EncodeMapper<A>& encoder)$/;"	f	class:fst::EncodeFst
EncodeFst	encode.h	/^class EncodeFst : public ArcMapFst<A, A, EncodeMapper<A> > {$/;"	c	namespace:fst
EncodeHash	encode.h	/^                   TupleEqual> EncodeHash;$/;"	t	class:fst::EncodeTable
EncodeMapper	encode.h	/^  EncodeMapper(const EncodeMapper& mapper)$/;"	f	class:fst::EncodeMapper
EncodeMapper	encode.h	/^  EncodeMapper(const EncodeMapper& mapper, EncodeType type)$/;"	f	class:fst::EncodeMapper
EncodeMapper	encode.h	/^  EncodeMapper(uint32 flags, EncodeType type)$/;"	f	class:fst::EncodeMapper
EncodeMapper	encode.h	/^  explicit EncodeMapper(uint32 flags, EncodeType type, EncodeTable<A> *table)$/;"	f	class:fst::EncodeMapper
EncodeMapper	encode.h	/^template <class A> class EncodeMapper {$/;"	c	namespace:fst
EncodeTable	encode.h	/^  explicit EncodeTable(uint32 encode_flags)$/;"	f	class:fst::EncodeTable
EncodeTable	encode.h	/^template <class A>  class EncodeTable {$/;"	c	namespace:fst
EncodeType	encode.h	/^enum EncodeType { ENCODE = 1, DECODE = 2 };$/;"	g	namespace:fst
End	util.h	/^  const_iterator End() const { return set_.end(); }$/;"	f	class:fst::CompactSet
Enqueue	queue.h	/^  void Enqueue(StateId s) { Enqueue_(s); }$/;"	f	class:fst::QueueBase
Enqueue	queue.h	/^  void Enqueue(StateId s) { front_ = s; }$/;"	f	class:fst::TrivialQueue
Enqueue	queue.h	/^  void Enqueue(StateId s) { push_front(s); }$/;"	f	class:fst::FifoQueue
Enqueue	queue.h	/^  void Enqueue(StateId s) { push_front(s); }$/;"	f	class:fst::LifoQueue
Enqueue	queue.h	/^  void Enqueue(StateId s) { queue_->Enqueue(s); }$/;"	f	class:fst::AutoQueue
Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::PruneQueue
Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::SccQueue
Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::ShortestFirstQueue
Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::StateOrderQueue
Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::TopOrderQueue
Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::AutoQueue
Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::FifoQueue
Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::LifoQueue
Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::PruneQueue
Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::SccQueue
Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::ShortestFirstQueue
Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::StateOrderQueue
Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::TopOrderQueue
Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::TrivialQueue
Entry	generic-register.h	/^  typedef EntryType Entry;$/;"	t	class:fst::GenericRegister
Entry	generic-register.h	/^  typedef typename RegisterType::Entry Entry;$/;"	t	class:fst::GenericRegisterer
Entry	register.h	/^  typedef typename FstRegister<Arc>::Entry Entry;$/;"	t	class:fst::FstRegisterer
EpsNormalize	epsnormalize.h	/^void EpsNormalize(const Fst<Arc> &ifst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
EpsNormalizeType	epsnormalize.h	/^enum EpsNormalizeType {EPS_NORM_INPUT, EPS_NORM_OUTPUT};$/;"	g	namespace:fst
EpsilonArcFilter	arcfilter.h	/^class EpsilonArcFilter {$/;"	c	namespace:fst
EpsilonOnReplace	replace.h	/^  bool EpsilonOnReplace() const { return epsilon_on_replace_; }$/;"	f	class:fst::ReplaceFstImpl
Equal	equal.h	/^bool Equal(const Fst<Arc> &fst1, const Fst<Arc> &fst2, float delta = kDelta) {$/;"	f	namespace:fst
Equal	state-map.h	/^  struct Equal {$/;"	s	class:fst::ArcSumMapper
Equal	state-map.h	/^  struct Equal {$/;"	s	class:fst::ArcUniqueMapper
EquivalenceUtil	equivalent.h	/^struct EquivalenceUtil {$/;"	s	namespace:fst
Equivalent	equivalent.h	/^bool Equivalent(const Fst<Arc> &fst1,$/;"	f	namespace:fst
ErasableBiTable	bi-table.h	/^  ErasableBiTable() : first_(0) {}$/;"	f	class:fst::ErasableBiTable
ErasableBiTable	bi-table.h	/^class ErasableBiTable {$/;"	c	namespace:fst
ErasableComposeStateTable	state-table.h	/^  ErasableComposeStateTable(const ErasableComposeStateTable<A, F> &table) {}$/;"	f	class:fst::ErasableComposeStateTable
ErasableComposeStateTable	state-table.h	/^  ErasableComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2) {}$/;"	f	class:fst::ErasableComposeStateTable
ErasableComposeStateTable	state-table.h	/^class ErasableComposeStateTable : public$/;"	c	namespace:fst
ErasableStateTable	state-table.h	/^  ErasableStateTable() : ErasableBiTable<StateId, T, F>() {}$/;"	f	class:fst::ErasableStateTable
ErasableStateTable	state-table.h	/^class ErasableStateTable : public ErasableBiTable<typename T::StateId, T, F> {$/;"	c	namespace:fst
Erase	bi-table.h	/^  void Erase(I s) {$/;"	f	class:fst::ErasableBiTable
Error	accumulator.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::CacheLogAccumulator
Error	accumulator.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::FastLogAccumulator
Error	accumulator.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::ReplaceAccumulator
Error	accumulator.h	/^  bool Error() const { return false; }$/;"	f	class:fst::DefaultAccumulator
Error	accumulator.h	/^  bool Error() const { return false; }$/;"	f	class:fst::LogAccumulator
Error	compact-fst.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::CompactFstData
Error	label-reachable.h	/^  bool Error() const { return error_ || accumulator_->Error(); }$/;"	f	class:fst::LabelReachable
Error	queue.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::QueueBase
Error	randgen.h	/^  bool Error() const { return accumulator_->Error(); }$/;"	f	class:fst::ArcSampler
Error	randgen.h	/^  bool Error() const { return false; }$/;"	f	class:fst::ArcSampler
Error	rmepsilon.h	/^  bool Error() const { return sd_state_.Error(); }$/;"	f	class:fst::RmEpsilonState
Error	shortest-distance.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::ShortestDistanceState
Error	state-reachable.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::IntervalReachVisitor
Error	state-reachable.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::StateReachable
Error	state-table.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::DetStringComposeStateTable
Error	state-table.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::StringDetComposeStateTable
Error	state-table.h	/^  bool Error() const { return false; }$/;"	f	class:fst::ErasableComposeStateTable
Error	state-table.h	/^  bool Error() const { return false; }$/;"	f	class:fst::GenericComposeStateTable
Error	state-table.h	/^  bool Error() const { return false; }$/;"	f	class:fst::ProductComposeStateTable
Expand	arc-map.h	/^  void Expand(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::AcceptorCompactor
Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::StringCompactor
Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::UnweightedAcceptorCompactor
Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::UnweightedCompactor
Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::WeightedStringCompactor
Expand	compact-fst.h	/^  void Expand(StateId s) {$/;"	f	class:fst::CompactFstImpl
Expand	compose.h	/^  void Expand(StateId s) {$/;"	f	class:fst::ComposeFstImpl
Expand	determinize.h	/^  virtual void Expand(StateId s) {$/;"	f	class:fst::DeterminizeFsaImpl
Expand	determinize.h	/^  virtual void Expand(StateId s) {$/;"	f	class:fst::DeterminizeFstImpl
Expand	factor-weight.h	/^  void Expand(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
Expand	randgen.h	/^  void Expand(StateId s) {$/;"	f	class:fst::RandGenFstImpl
Expand	relabel.h	/^  void Expand(StateId s) {$/;"	f	class:fst::RelabelFstImpl
Expand	replace.h	/^  void Expand(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
Expand	replace.h	/^  void Expand(StateId s, const StateTuple &tuple,$/;"	f	class:fst::ReplaceFstImpl
Expand	rmepsilon.h	/^  void Expand(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
Expand	rmepsilon.h	/^void RmEpsilonState<Arc,Queue>::Expand(typename Arc::StateId source) {$/;"	f	class:fst::RmEpsilonState
Expand	state-map.h	/^  void Expand(StateId s) {$/;"	f	class:fst::StateMapFstImpl
Expand	synchronize.h	/^  void Expand(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
ExpandAndCache	replace.h	/^  void ExpandAndCache() const   {$/;"	f	class:fst::ArcIterator
ExpandedFst	expanded-fst.h	/^class ExpandedFst : public Fst<A> {$/;"	c	namespace:fst
ExpandedState	cache.h	/^  void ExpandedState(StateId s) {$/;"	f	class:fst::CacheBaseImpl
ExpectationArc	arc.h	/^  ExpectationArc() {}$/;"	f	struct:fst::ExpectationArc
ExpectationArc	arc.h	/^  ExpectationArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::ExpectationArc
ExpectationArc	arc.h	/^struct ExpectationArc {$/;"	s	namespace:fst
ExpectationWeight	expectation-weight.h	/^  ExpectationWeight() : PairWeight<X1, X2>(Zero()) { }$/;"	f	class:fst::ExpectationWeight
ExpectationWeight	expectation-weight.h	/^  ExpectationWeight(const ExpectationWeight<X1, X2>& w)$/;"	f	class:fst::ExpectationWeight
ExpectationWeight	expectation-weight.h	/^  ExpectationWeight(const PairWeight<X1, X2>& w)$/;"	f	class:fst::ExpectationWeight
ExpectationWeight	expectation-weight.h	/^  ExpectationWeight(const X1& x1, const X2& x2)$/;"	f	class:fst::ExpectationWeight
ExpectationWeight	expectation-weight.h	/^class ExpectationWeight : public PairWeight<X1, X2> {$/;"	c	namespace:fst
ExtendState	cache.h	/^  S *ExtendState(StateId s) {$/;"	f	class:fst::CacheBaseImpl
F	lookahead-filter.h	/^  typedef typename M::FST F;$/;"	t	class:fst::LookAheadSelector
F1	lookahead-filter.h	/^  typedef typename M1::FST F1;$/;"	t	class:fst::LookAheadSelector
F2	lookahead-filter.h	/^  typedef typename M2::FST F2;$/;"	t	class:fst::LookAheadSelector
FIFO_QUEUE	queue.h	/^  FIFO_QUEUE = 1,            \/\/ First-in, first-out queue$/;"	e	enum:fst::QueueType
FST	fst.h	/^  typedef F FST;$/;"	t	class:fst::ArcIterator
FST	fst.h	/^  typedef F FST;$/;"	t	class:fst::StateIterator
FST	lookahead-matcher.h	/^  typedef F FST;$/;"	t	class:fst::LookAheadMatcher
FST	lookahead-matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::ArcLookAheadMatcher
FST	lookahead-matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::LabelLookAheadMatcher
FST	lookahead-matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::TrivialLookAheadMatcher
FST	matcher-fst.h	/^  typedef F FST;$/;"	t	class:fst::MatcherFst
FST	matcher-fst.h	/^  typedef MatcherFst<F, M, N, I> FST;$/;"	t	class:fst::LookAheadMatcher
FST	matcher-fst.h	/^  typedef MatcherFst<F, M, N, I> FST;$/;"	t	class:fst::Matcher
FST	matcher.h	/^  typedef F FST;$/;"	t	class:fst::Matcher
FST	matcher.h	/^  typedef F FST;$/;"	t	class:fst::SortedMatcher
FST	matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::MultiEpsMatcher
FST	matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::PhiMatcher
FST	matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::RhoMatcher
FST	matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::SigmaMatcher
FST	mutable-fst.h	/^  typedef F FST;$/;"	t	class:fst::MutableArcIterator
FST1	compose-filter.h	/^  typedef typename F::FST1 FST1;$/;"	t	class:fst::MultiEpsFilter
FST1	compose-filter.h	/^  typedef typename M1::FST FST1;$/;"	t	class:fst::AltSequenceComposeFilter
FST1	compose-filter.h	/^  typedef typename M1::FST FST1;$/;"	t	class:fst::MatchComposeFilter
FST1	compose-filter.h	/^  typedef typename M1::FST FST1;$/;"	t	class:fst::SequenceComposeFilter
FST1	compose.h	/^  typedef typename M1::FST FST1;$/;"	t	class:fst::ComposeFstImpl
FST1	lookahead-filter.h	/^  typedef typename F::FST1 FST1;$/;"	t	class:fst::LookAheadComposeFilter
FST1	lookahead-filter.h	/^  typedef typename F::FST1 FST1;$/;"	t	class:fst::PushLabelsComposeFilter
FST1	lookahead-filter.h	/^  typedef typename F::FST1 FST1;$/;"	t	class:fst::PushWeightsComposeFilter
FST2	compose-filter.h	/^  typedef typename F::FST2 FST2;$/;"	t	class:fst::MultiEpsFilter
FST2	compose-filter.h	/^  typedef typename M2::FST FST2;$/;"	t	class:fst::AltSequenceComposeFilter
FST2	compose-filter.h	/^  typedef typename M2::FST FST2;$/;"	t	class:fst::MatchComposeFilter
FST2	compose-filter.h	/^  typedef typename M2::FST FST2;$/;"	t	class:fst::SequenceComposeFilter
FST2	compose.h	/^  typedef typename M2::FST FST2;$/;"	t	class:fst::ComposeFstImpl
FST2	lookahead-filter.h	/^  typedef typename F::FST2 FST2;$/;"	t	class:fst::LookAheadComposeFilter
FST2	lookahead-filter.h	/^  typedef typename F::FST2 FST2;$/;"	t	class:fst::PushLabelsComposeFilter
FST2	lookahead-filter.h	/^  typedef typename F::FST2 FST2;$/;"	t	class:fst::PushWeightsComposeFilter
FSTERROR	util.h	52;"	d
FST_LIB_ACCUMULATOR_H__	accumulator.h	22;"	d
FST_LIB_ADD_ON_FST_H__	add-on.h	24;"	d
FST_LIB_ARCFILTER_H__	arcfilter.h	22;"	d
FST_LIB_ARCSORT_H__	arcsort.h	22;"	d
FST_LIB_ARC_H__	arc.h	23;"	d
FST_LIB_ARC_MAP_H__	arc-map.h	24;"	d
FST_LIB_BI_TABLE_H__	bi-table.h	23;"	d
FST_LIB_CACHE_H__	cache.h	23;"	d
FST_LIB_CLOSURE_H__	closure.h	22;"	d
FST_LIB_COMPACT_FST_H__	compact-fst.h	24;"	d
FST_LIB_COMPAT_H__	compat.h	21;"	d
FST_LIB_COMPLEMENT_H__	complement.h	22;"	d
FST_LIB_COMPOSE_FILTER_H__	compose-filter.h	23;"	d
FST_LIB_COMPOSE_H__	compose.h	22;"	d
FST_LIB_CONCAT_H__	concat.h	22;"	d
FST_LIB_CONNECT_H__	connect.h	22;"	d
FST_LIB_CONST_FST_H__	const-fst.h	23;"	d
FST_LIB_DETERMINIZE_H__	determinize.h	23;"	d
FST_LIB_DFS_VISIT_H__	dfs-visit.h	23;"	d
FST_LIB_DIFFERENCE_H__	difference.h	22;"	d
FST_LIB_EDIT_FST_H_	edit-fst.h	21;"	d
FST_LIB_ENCODE_H__	encode.h	22;"	d
FST_LIB_EPSNORMALIZE_H__	epsnormalize.h	22;"	d
FST_LIB_EQUAL_H__	equal.h	22;"	d
FST_LIB_EQUIVALENT_H__	equivalent.h	22;"	d
FST_LIB_EXPANDED_FST_H__	expanded-fst.h	23;"	d
FST_LIB_EXPECTATION_WEIGHT_H_	expectation-weight.h	32;"	d
FST_LIB_FACTOR_WEIGHT_H__	factor-weight.h	22;"	d
FST_LIB_FLAGS_H__	flags.h	21;"	d
FST_LIB_FLOAT_WEIGHT_H__	float-weight.h	23;"	d
FST_LIB_FSTLIB_H__	fstlib.h	45;"	d
FST_LIB_FST_DECL_H__	fst-decl.h	23;"	d
FST_LIB_FST_H__	fst.h	24;"	d
FST_LIB_GENERIC_REGISTER_H_	generic-register.h	18;"	d
FST_LIB_HEAP_H__	heap.h	24;"	d
FST_LIB_ICU_H_	icu.h	25;"	d
FST_LIB_INTERSECT_H__	intersect.h	22;"	d
FST_LIB_INTERVAL_SET_H__	interval-set.h	22;"	d
FST_LIB_INVERT_H__	invert.h	22;"	d
FST_LIB_LABEL_REACHABLE_H__	label-reachable.h	24;"	d
FST_LIB_LEXICOGRAPHIC_WEIGHT_H__	lexicographic-weight.h	29;"	d
FST_LIB_LOCK_H__	lock.h	24;"	d
FST_LIB_LOG_H__	log.h	21;"	d
FST_LIB_LOOKAHEAD_FILTER_H__	lookahead-filter.h	23;"	d
FST_LIB_LOOKAHEAD_MATCHER_H__	lookahead-matcher.h	23;"	d
FST_LIB_MAP_H__	map.h	23;"	d
FST_LIB_MATCHER_FST_FST_H__	matcher-fst.h	22;"	d
FST_LIB_MATCHER_H__	matcher.h	22;"	d
FST_LIB_MINIMIZE_H__	minimize.h	23;"	d
FST_LIB_MUTABLE_FST_H__	mutable-fst.h	24;"	d
FST_LIB_PAIR_WEIGHT_H_	pair-weight.h	23;"	d
FST_LIB_PARTITION_H__	partition.h	22;"	d
FST_LIB_POWER_WEIGHT_H__	power-weight.h	22;"	d
FST_LIB_PRODUCT_WEIGHT_H__	product-weight.h	22;"	d
FST_LIB_PROJECT_H__	project.h	22;"	d
FST_LIB_PROPERTIES_H__	properties.h	21;"	d
FST_LIB_PRUNE_H__	prune.h	22;"	d
FST_LIB_PUSH_H__	push.h	22;"	d
FST_LIB_QUEUE_H__	queue.h	23;"	d
FST_LIB_RANDGEN_H__	randgen.h	22;"	d
FST_LIB_RANDOM_WEIGHT_H__	random-weight.h	23;"	d
FST_LIB_RATIONAL_H__	rational.h	23;"	d
FST_LIB_REGISTER_H__	register.h	23;"	d
FST_LIB_RELABEL_H__	relabel.h	22;"	d
FST_LIB_REPLACE_H__	replace.h	23;"	d
FST_LIB_REPLACE_UTIL_H__	replace-util.h	24;"	d
FST_LIB_REVERSE_H__	reverse.h	22;"	d
FST_LIB_REWEIGHT_H__	reweight.h	22;"	d
FST_LIB_RMEPSILON_H__	rmepsilon.h	22;"	d
FST_LIB_RMFINALEPSILON_H__	rmfinalepsilon.h	22;"	d
FST_LIB_SHORTEST_DISTANCE_H__	shortest-distance.h	22;"	d
FST_LIB_SHORTEST_PATH_H__	shortest-path.h	22;"	d
FST_LIB_SIGNED_LOG_WEIGHT_H_	signed-log-weight.h	24;"	d
FST_LIB_SLIST_H__	slist.h	21;"	d
FST_LIB_SPARSE_POWER_WEIGHT_H__	sparse-power-weight.h	24;"	d
FST_LIB_SPARSE_TUPLE_WEIGHT_H__	sparse-tuple-weight.h	31;"	d
FST_LIB_STATESORT_H__	statesort.h	22;"	d
FST_LIB_STATE_MAP_H__	state-map.h	23;"	d
FST_LIB_STATE_REACHABLE_H__	state-reachable.h	23;"	d
FST_LIB_STATE_TABLE_H__	state-table.h	22;"	d
FST_LIB_STRING_H_	string.h	24;"	d
FST_LIB_STRING_WEIGHT_H__	string-weight.h	22;"	d
FST_LIB_SYMBOL_TABLE_H__	symbol-table.h	23;"	d
FST_LIB_SYMBOL_TABLE_OPS_H_	symbol-table-ops.h	18;"	d
FST_LIB_SYNCHRONIZE_H__	synchronize.h	22;"	d
FST_LIB_TEST_PROPERTIES_H__	test-properties.h	22;"	d
FST_LIB_TOPSORT_H__	topsort.h	22;"	d
FST_LIB_TUPLE_WEIGHT_H__	tuple-weight.h	22;"	d
FST_LIB_TYPES_H__	types.h	26;"	d
FST_LIB_UNION_H__	union.h	22;"	d
FST_LIB_UTIL_H__	util.h	22;"	d
FST_LIB_VECTOR_FST_H__	vector-fst.h	23;"	d
FST_LIB_VERIFY_H__	verify.h	22;"	d
FST_LIB_VISIT_H__	visit.h	23;"	d
FST_LIB_WEIGHT_H__	weight.h	73;"	d
FST_ONCE_INIT	lock.h	/^static const int FST_ONCE_INIT = 1;$/;"	m	namespace:fst
FST_RANDEQUIVALENT_H__	randequivalent.h	23;"	d
FactorIterator	determinize.h	/^  typedef GallicFactor<Label, Weight, S> FactorIterator;$/;"	t	class:fst::DeterminizeFstImpl
FactorIterator	factor-weight.h	/^  typedef F FactorIterator;$/;"	t	class:fst::FactorWeightFstImpl
FactorWeightFst	factor-weight.h	/^  FactorWeightFst(const FactorWeightFst<A, F> &fst, bool copy)$/;"	f	class:fst::FactorWeightFst
FactorWeightFst	factor-weight.h	/^  FactorWeightFst(const Fst<A> &fst)$/;"	f	class:fst::FactorWeightFst
FactorWeightFst	factor-weight.h	/^  FactorWeightFst(const Fst<A> &fst,  const FactorWeightOptions<A> &opts)$/;"	f	class:fst::FactorWeightFst
FactorWeightFst	factor-weight.h	/^class FactorWeightFst : public ImplToFst< FactorWeightFstImpl<A, F> > {$/;"	c	namespace:fst
FactorWeightFstImpl	factor-weight.h	/^  FactorWeightFstImpl(const FactorWeightFstImpl<A, F> &impl)$/;"	f	class:fst::FactorWeightFstImpl
FactorWeightFstImpl	factor-weight.h	/^  FactorWeightFstImpl(const Fst<A> &fst, const FactorWeightOptions<A> &opts)$/;"	f	class:fst::FactorWeightFstImpl
FactorWeightFstImpl	factor-weight.h	/^class FactorWeightFstImpl$/;"	c	namespace:fst
FactorWeightOptions	factor-weight.h	/^  FactorWeightOptions(const CacheOptions &opts, float d,$/;"	f	struct:fst::FactorWeightOptions
FactorWeightOptions	factor-weight.h	/^  FactorWeightOptions(uint32 m = kFactorArcWeights | kFactorFinalWeights,$/;"	f	struct:fst::FactorWeightOptions
FactorWeightOptions	factor-weight.h	/^  explicit FactorWeightOptions($/;"	f	struct:fst::FactorWeightOptions
FactorWeightOptions	factor-weight.h	/^struct FactorWeightOptions : CacheOptions {$/;"	s	namespace:fst
FastLogAccumulator	accumulator.h	/^  FastLogAccumulator(const FastLogAccumulator<A> &acc)$/;"	f	class:fst::FastLogAccumulator
FastLogAccumulator	accumulator.h	/^  explicit FastLogAccumulator(ssize_t arc_limit = 20, ssize_t arc_period = 10)$/;"	f	class:fst::FastLogAccumulator
FastLogAccumulator	accumulator.h	/^class FastLogAccumulator {$/;"	c	namespace:fst
FastLogAccumulatorData	accumulator.h	/^  FastLogAccumulatorData() {}$/;"	f	class:fst::FastLogAccumulatorData
FastLogAccumulatorData	accumulator.h	/^class FastLogAccumulatorData {$/;"	c	namespace:fst
FastLogProbArcSelector	randgen.h	/^  FastLogProbArcSelector(int seed = time(0))$/;"	f	class:fst::FastLogProbArcSelector
FastLogProbArcSelector	randgen.h	/^class FastLogProbArcSelector : public LogProbArcSelector<A> {$/;"	c	namespace:fst
FifoQueue	queue.h	/^  FifoQueue() : QueueBase<S>(FIFO_QUEUE) {}$/;"	f	class:fst::FifoQueue
FifoQueue	queue.h	/^class FifoQueue : public QueueBase<S>, public deque<S> {$/;"	c	namespace:fst
Filter	compose-filter.h	/^  typedef MultiEpsFilter<F> Filter;$/;"	t	class:fst::MultiEpsFilter
Filter	lookahead-filter.h	/^  typedef LookAheadComposeFilter<F, M1, M2, MT> Filter;$/;"	t	class:fst::LookAheadComposeFilter
FilterArc	compose-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::AltSequenceComposeFilter
FilterArc	compose-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::MatchComposeFilter
FilterArc	compose-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::MultiEpsFilter
FilterArc	compose-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::SequenceComposeFilter
FilterArc	lookahead-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::LookAheadComposeFilter
FilterArc	lookahead-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::PushLabelsComposeFilter
FilterArc	lookahead-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::PushWeightsComposeFilter
FilterFinal	compose-filter.h	/^  void FilterFinal(Weight *, Weight *) const {}$/;"	f	class:fst::AltSequenceComposeFilter
FilterFinal	compose-filter.h	/^  void FilterFinal(Weight *, Weight *) const {}$/;"	f	class:fst::MatchComposeFilter
FilterFinal	compose-filter.h	/^  void FilterFinal(Weight *, Weight *) const {}$/;"	f	class:fst::SequenceComposeFilter
FilterFinal	compose-filter.h	/^  void FilterFinal(Weight *w1, Weight *w2) const {$/;"	f	class:fst::MultiEpsFilter
FilterFinal	lookahead-filter.h	/^  void FilterFinal(Weight *weight1, Weight *weight2) const {$/;"	f	class:fst::LookAheadComposeFilter
FilterFinal	lookahead-filter.h	/^  void FilterFinal(Weight *weight1, Weight *weight2) const {$/;"	f	class:fst::PushLabelsComposeFilter
FilterFinal	lookahead-filter.h	/^  void FilterFinal(Weight *weight1, Weight *weight2) const {$/;"	f	class:fst::PushWeightsComposeFilter
FilterState	compose-filter.h	/^  typedef CharFilterState FilterState;$/;"	t	class:fst::AltSequenceComposeFilter
FilterState	compose-filter.h	/^  typedef CharFilterState FilterState;$/;"	t	class:fst::MatchComposeFilter
FilterState	compose-filter.h	/^  typedef CharFilterState FilterState;$/;"	t	class:fst::SequenceComposeFilter
FilterState	compose-filter.h	/^  typedef typename F::FilterState FilterState;$/;"	t	class:fst::MultiEpsFilter
FilterState	compose.h	/^  typedef typename F::FilterState FilterState;$/;"	t	class:fst::ComposeFstImpl
FilterState	lookahead-filter.h	/^  typedef PairFilterState<FilterState1, FilterState2> FilterState;$/;"	t	class:fst::PushLabelsComposeFilter
FilterState	lookahead-filter.h	/^  typedef PairFilterState<FilterState1, FilterState2> FilterState;$/;"	t	class:fst::PushWeightsComposeFilter
FilterState	lookahead-filter.h	/^  typedef typename F::FilterState FilterState;$/;"	t	class:fst::LookAheadComposeFilter
FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ComposeFingerprint
FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ComposeState1Fingerprint
FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ComposeState2Fingerprint
FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::DetStringComposeStateTable
FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ErasableComposeStateTable
FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::GenericComposeStateTable
FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ProductComposeStateTable
FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::StringDetComposeStateTable
FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	struct:fst::ComposeStateTuple
FilterState1	lookahead-filter.h	/^  typedef typename F::FilterState FilterState1;$/;"	t	class:fst::PushLabelsComposeFilter
FilterState1	lookahead-filter.h	/^  typedef typename F::FilterState FilterState1;$/;"	t	class:fst::PushWeightsComposeFilter
FilterState2	lookahead-filter.h	/^  typedef IntegerFilterState<typename Arc::Label> FilterState2;$/;"	t	class:fst::PushLabelsComposeFilter
FilterState2	lookahead-filter.h	/^  typedef WeightFilterState<typename Arc::Weight> FilterState2;$/;"	t	class:fst::PushWeightsComposeFilter
Final	add-on.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::AddOnImpl
Final	arc-map.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
Final	arcsort.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::ArcSortMapper
Final	cache.h	/^  Weight Final(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
Final	compact-fst.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::CompactFstImpl
Final	complement.h	/^  Weight Final(StateId s) const {$/;"	f	class:fst::ComplementFstImpl
Final	compose.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::ComposeFstImplBase
Final	const-fst.h	/^  Weight Final(StateId s) const { return states_[s].final; }$/;"	f	class:fst::ConstFstImpl
Final	determinize.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::DeterminizeFstImplBase
Final	edit-fst.h	/^  Weight Final(StateId s) const {$/;"	f	class:fst::EditFstImpl
Final	edit-fst.h	/^  Weight Final(StateId s, const WrappedFstT *wrapped) const {$/;"	f	class:fst::EditFstData
Final	expanded-fst.h	/^typename A::Weight Final(const ExpandedFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
Final	factor-weight.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
Final	fst.h	/^  virtual Weight Final(StateId s) const { return impl_->Final(s); }$/;"	f	class:fst::ImplToFst
Final	fst.h	/^typename A::Weight Final(const Fst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
Final	fst.h	/^typename F::Arc::Weight Final(const F &fst, typename F::Arc::StateId s) {$/;"	f	namespace:fst::internal
Final	mutable-fst.h	/^typename A::Weight Final(const MutableFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
Final	randgen.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::RandGenFstImpl
Final	rational.h	/^  Weight Final(StateId s) { return Replace()->Final(s); }$/;"	f	class:fst::RationalFstImpl
Final	relabel.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::RelabelFstImpl
Final	replace.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
Final	rmepsilon.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
Final	rmepsilon.h	/^  const Weight &Final() const { return final_; }$/;"	f	class:fst::RmEpsilonState
Final	state-map.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::ArcSumMapper
Final	state-map.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::ArcUniqueMapper
Final	state-map.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::IdentityStateMapper
Final	state-map.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::StateMapFstImpl
Final	synchronize.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
Final	vector-fst.h	/^  Weight Final(StateId s) const { return states_[s]->final; }$/;"	f	class:fst::VectorFstBaseImpl
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_ALLOW_SUPERFINAL; }$/;"	f	struct:fst::FromGallicMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_ALLOW_SUPERFINAL; }$/;"	f	struct:fst::GallicToNewSymbolsMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::WeightConvertMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::IdentityArcMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::InvertWeightMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::PlusMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::QuantizeMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::ReverseWeightMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::RmWeightMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::TimesMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::ToGallicMapper
FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_REQUIRE_SUPERFINAL; }$/;"	f	struct:fst::SuperFinalMapper
FinalAction	encode.h	/^  MapFinalAction FinalAction() const {$/;"	f	class:fst::EncodeMapper
FinalAction	invert.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::InvertMapper
FinalAction	map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::IdentityMapper
FinalAction	project.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::ProjectMapper
FinalLabel	label-reachable.h	/^  Label FinalLabel() {$/;"	f	class:fst::LabelReachableData
FinalWeightIterator	edit-fst.h	/^      FinalWeightIterator;$/;"	t	class:fst::EditFstData
FinalWeightIterator	edit-fst.h	/^    FinalWeightIterator;$/;"	t	class:fst::EditFstImpl
FinalizeSplit	partition.h	/^  void FinalizeSplit(Queue* L) {$/;"	f	class:fst::Partition
Find	lookahead-matcher.h	/^  bool Find(Label label) { return base_->Find(label); }$/;"	f	class:fst::LookAheadMatcher
Find	lookahead-matcher.h	/^  bool Find(Label label) { return matcher_.Find(label); }$/;"	f	class:fst::ArcLookAheadMatcher
Find	lookahead-matcher.h	/^  bool Find(Label label) { return matcher_.Find(label); }$/;"	f	class:fst::TrivialLookAheadMatcher
Find	lookahead-matcher.h	/^  bool Find(Label label) {$/;"	f	class:fst::LabelLookAheadMatcher
Find	matcher-fst.h	/^  bool Find(Label label) { return matcher_->Find(label); }$/;"	f	class:fst::LookAheadMatcher
Find	matcher-fst.h	/^  bool Find(Label label) { return matcher_->Find(label); }$/;"	f	class:fst::Matcher
Find	matcher.h	/^  bool Find(Label label) { return Find_(label); }$/;"	f	class:fst::MatcherBase
Find	matcher.h	/^  bool Find(Label label) { return base_->Find(label); }$/;"	f	class:fst::Matcher
Find	matcher.h	/^  bool Find(Label match_label) {$/;"	f	class:fst::RhoMatcher
Find	matcher.h	/^  bool Find(Label match_label) {$/;"	f	class:fst::SigmaMatcher
Find	matcher.h	/^bool MultiEpsMatcher<M>::Find(Label match_label) {$/;"	f	class:fst::MultiEpsMatcher
Find	matcher.h	/^bool PhiMatcher<M>::Find(Label match_label) {$/;"	f	class:fst::PhiMatcher
Find	matcher.h	/^bool SortedMatcher<F>::Find(Label match_label) {$/;"	f	class:fst::SortedMatcher
Find	symbol-table.h	/^  int64 Find(const char* symbol) const {$/;"	f	class:fst::SymbolTableImpl
Find	symbol-table.h	/^  int64 Find(const string& symbol) const {$/;"	f	class:fst::SymbolTableImpl
Find	symbol-table.h	/^  string Find(int64 key) const {$/;"	f	class:fst::SymbolTableImpl
Find	symbol-table.h	/^  virtual int64 Find(const char* symbol) const {$/;"	f	class:fst::SymbolTable
Find	symbol-table.h	/^  virtual int64 Find(const string& symbol) const {$/;"	f	class:fst::SymbolTable
Find	symbol-table.h	/^  virtual string Find(int64 key) const {$/;"	f	class:fst::SymbolTable
Find	util.h	/^  const_iterator Find(Key key) const {$/;"	f	class:fst::CompactSet
FindEntry	bi-table.h	/^  const T &FindEntry(I s) const { return id2entry_[s - first_]; }$/;"	f	class:fst::ErasableBiTable
FindEntry	bi-table.h	/^  const T &FindEntry(I s) const { return id2entry_[s]; }$/;"	f	class:fst::CompactHashBiTable
FindEntry	bi-table.h	/^  const T &FindEntry(I s) const { return id2entry_[s]; }$/;"	f	class:fst::VectorBiTable
FindEntry	bi-table.h	/^  const T &FindEntry(I s) const {$/;"	f	class:fst::HashBiTable
FindEntry	bi-table.h	/^  const T &FindEntry(I s) const {$/;"	f	class:fst::VectorHashBiTable
FindIState	arc-map.h	/^  StateId FindIState(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::CompactHashBiTable
FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::ErasableBiTable
FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::HashBiTable
FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::VectorBiTable
FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::VectorHashBiTable
FindIntervals	label-reachable.h	/^  void FindIntervals(StateId ins) {$/;"	f	class:fst::LabelReachable
FindOState	arc-map.h	/^  StateId FindOState(StateId is) {$/;"	f	class:fst::ArcMapFstImpl
FindSet	equivalent.h	/^  static MappedId FindSet(UnionFind<MappedId> *sets, MappedId id) {$/;"	f	struct:fst::EquivalenceUtil
FindSet	union-find.h	/^  T FindSet(T item) {$/;"	f	class:fst::UnionFind
FindState	determinize.h	/^  StateId FindState(Subset *subset) {$/;"	f	class:fst::DeterminizeFsaImpl
FindState	factor-weight.h	/^  StateId FindState(const Element &e) {$/;"	f	class:fst::FactorWeightFstImpl
FindState	replace.h	/^  StateId FindState(const StateTuple &tuple) {$/;"	f	class:fst::VectorHashReplaceStateTable
FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::CompactHashStateTable
FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::ErasableStateTable
FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::HashStateTable
FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::VectorHashStateTable
FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::VectorStateTable
FindState	synchronize.h	/^  StateId FindState(const Element &e) {$/;"	f	class:fst::SynchronizeFstImpl
FindString	synchronize.h	/^  const String *FindString(const String *s) {$/;"	f	class:fst::SynchronizeFstImpl
Find_	lookahead-matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::ArcLookAheadMatcher
Find_	lookahead-matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::LabelLookAheadMatcher
Find_	lookahead-matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::TrivialLookAheadMatcher
Find_	matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::PhiMatcher
Find_	matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::RhoMatcher
Find_	matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::SigmaMatcher
Find_	matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::SortedMatcher
Find_	replace.h	/^  virtual bool Find_(Label label) {$/;"	f	class:fst::ReplaceFstMatcher
Fingerprint	bi-table.h	/^  const FP &Fingerprint() const { return *fp_; }$/;"	f	class:fst::VectorBiTable
Fingerprint	bi-table.h	/^  const FP &Fingerprint() const { return *fp_; }$/;"	f	class:fst::VectorHashBiTable
FinishState	connect.h	/^  void FinishState(StateId s) { }$/;"	f	class:fst::CcVisitor
FinishState	connect.h	/^void SccVisitor<A>::FinishState(StateId s, StateId p, const A *) {$/;"	f	class:fst::SccVisitor
FinishState	minimize.h	/^    void FinishState(StateId s, StateId parent, const A* parent_arc) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
FinishState	randgen.h	/^  void FinishState(StateId s, StateId p, const IArc *) {$/;"	f	class:fst::RandGenVisitor
FinishState	state-reachable.h	/^  void FinishState(StateId s, StateId p, const A *arc) {$/;"	f	class:fst::IntervalReachVisitor
FinishState	topsort.h	/^  void FinishState(StateId s, StateId p, const A *) { finish_->push_back(s); }$/;"	f	class:fst::TopOrderVisitor
FinishState	visit.h	/^  void FinishState(StateId s) {$/;"	f	class:fst::CopyVisitor
FinishState	visit.h	/^  void FinishState(StateId s) {}$/;"	f	class:fst::PartialVisitor
FinishVisit	connect.h	/^  void FinishVisit() {$/;"	f	class:fst::CcVisitor
FinishVisit	connect.h	/^  void FinishVisit() {$/;"	f	class:fst::SccVisitor
FinishVisit	minimize.h	/^    void FinishVisit() {}$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
FinishVisit	randgen.h	/^  void FinishVisit() {}$/;"	f	class:fst::RandGenVisitor
FinishVisit	state-reachable.h	/^  void FinishVisit() {}$/;"	f	class:fst::IntervalReachVisitor
FinishVisit	topsort.h	/^  void FinishVisit() {$/;"	f	class:fst::TopOrderVisitor
FinishVisit	visit.h	/^  void FinishVisit() {}$/;"	f	class:fst::CopyVisitor
FinishVisit	visit.h	/^  void FinishVisit() {}$/;"	f	class:fst::PartialVisitor
First	add-on.h	/^  A1 *First() const { return a1_; }$/;"	f	class:fst::AddOnPair
FlagDescription	flags.h	/^  FlagDescription(T *addr, const char *doc, const char *type,$/;"	f	struct:FlagDescription
FlagDescription	flags.h	/^struct FlagDescription {$/;"	s
FlagDescription::FlagDescription	flags.h	/^  FlagDescription(T *addr, const char *doc, const char *type,$/;"	f	struct:FlagDescription
FlagDescription::address	flags.h	/^  T *address;$/;"	m	struct:FlagDescription
FlagDescription::default_value	flags.h	/^  const T default_value;$/;"	m	struct:FlagDescription
FlagDescription::doc_string	flags.h	/^  const char *doc_string;$/;"	m	struct:FlagDescription
FlagDescription::file_name	flags.h	/^  const char *file_name;$/;"	m	struct:FlagDescription
FlagDescription::type_name	flags.h	/^  const char *type_name;$/;"	m	struct:FlagDescription
FlagRegister	flags.h	/^class FlagRegister {$/;"	c
FlagRegister::GetDefault	flags.h	/^  string GetDefault(bool default_value) const {$/;"	f	class:FlagRegister
FlagRegister::GetDefault	flags.h	/^  string GetDefault(const string &default_value) const {$/;"	f	class:FlagRegister
FlagRegister::GetDefault	flags.h	/^  template<typename V> string GetDefault(const V& default_value) const {$/;"	f	class:FlagRegister
FlagRegister::GetFlagDescription	flags.h	/^  const FlagDescription<T> &GetFlagDescription(const string &name) const {$/;"	f	class:FlagRegister
FlagRegister::GetRegister	flags.h	/^  static FlagRegister<T> *GetRegister() {$/;"	f	class:FlagRegister
FlagRegister::GetUsage	flags.h	/^  void GetUsage(std::set< std::pair<string, string> > *usage_set) const {$/;"	f	class:FlagRegister
FlagRegister::Init	flags.h	/^  static void Init() {$/;"	f	class:FlagRegister
FlagRegister::SetDescription	flags.h	/^  void SetDescription(const string &name,$/;"	f	class:FlagRegister
FlagRegister::SetFlag	flags.h	/^  bool SetFlag(const string &arg, const string &val) const {$/;"	f	class:FlagRegister
FlagRegister::SetFlag	flags.h	/^  bool SetFlag(const string &val, bool *address) const {$/;"	f	class:FlagRegister
FlagRegister::SetFlag	flags.h	/^  bool SetFlag(const string &val, double *address) const {$/;"	f	class:FlagRegister
FlagRegister::SetFlag	flags.h	/^  bool SetFlag(const string &val, int32 *address) const {$/;"	f	class:FlagRegister
FlagRegister::SetFlag	flags.h	/^  bool SetFlag(const string &val, int64 *address) const {$/;"	f	class:FlagRegister
FlagRegister::SetFlag	flags.h	/^  bool SetFlag(const string &val, string *address) const {$/;"	f	class:FlagRegister
FlagRegister::flag_table_	flags.h	/^  std::map< string, FlagDescription<T> > flag_table_;$/;"	m	class:FlagRegister
FlagRegister::register_	flags.h	/^  static FlagRegister<T> *register_;$/;"	m	class:FlagRegister
FlagRegister::register_	flags.h	/^FlagRegister<T> *FlagRegister<T>::register_ = 0;$/;"	m	class:FlagRegister
FlagRegister::register_init_	flags.h	/^  static fst::FstOnceType register_init_;   \/\/ ensures only called once$/;"	m	class:FlagRegister
FlagRegister::register_init_	flags.h	/^fst::FstOnceType FlagRegister<T>::register_init_ = fst::FST_ONCE_INIT;$/;"	m	class:FlagRegister
FlagRegister::register_lock_	flags.h	/^  static fst::Mutex* register_lock_;        \/\/ multithreading lock$/;"	m	class:FlagRegister
FlagRegister::register_lock_	flags.h	/^fst::Mutex *FlagRegister<T>::register_lock_ = 0;$/;"	m	class:FlagRegister
FlagRegisterer	flags.h	/^  FlagRegisterer(const string &name, const FlagDescription<T> &desc) {$/;"	f	class:FlagRegisterer
FlagRegisterer	flags.h	/^class FlagRegisterer {$/;"	c
FlagRegisterer::FlagRegisterer	flags.h	/^  FlagRegisterer(const string &name, const FlagDescription<T> &desc) {$/;"	f	class:FlagRegisterer
Flags	cache.h	/^  uint32 Flags() const {$/;"	f	class:fst::CacheArcIterator
Flags	cache.h	/^  uint32 Flags() const {$/;"	f	class:fst::CacheMutableArcIterator
Flags	compact-fst.h	/^  uint32 Flags() const { return flags_; }$/;"	f	class:fst::ArcIterator
Flags	complement.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcIterator
Flags	const-fst.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcIterator
Flags	fst.h	/^  uint32 Flags() const { return Flags_(); }  \/\/ Return current behavorial flags$/;"	f	class:fst::ArcIteratorBase
Flags	fst.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcIterator
Flags	fst.h	/^  } Flags;$/;"	m	class:fst::FstHeader	typeref:enum:fst::FstHeader::__anon1
Flags	lookahead-matcher.h	/^  uint32 Flags() const { return base_->Flags(); }$/;"	f	class:fst::LookAheadMatcher
Flags	lookahead-matcher.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcLookAheadMatcher
Flags	lookahead-matcher.h	/^  uint32 Flags() const {$/;"	f	class:fst::LabelLookAheadMatcher
Flags	lookahead-matcher.h	/^  uint32 Flags() const {$/;"	f	class:fst::TrivialLookAheadMatcher
Flags	matcher-fst.h	/^  uint32 Flags() const { return matcher_->Flags(); }$/;"	f	class:fst::LookAheadMatcher
Flags	matcher-fst.h	/^  uint32 Flags() const { return matcher_->Flags(); }$/;"	f	class:fst::Matcher
Flags	matcher.h	/^  uint32 Flags() const { return base_->Flags() & kMatcherFlags; }$/;"	f	class:fst::Matcher
Flags	matcher.h	/^  uint32 Flags() const { return matcher_->Flags(); }$/;"	f	class:fst::MultiEpsMatcher
Flags	matcher.h	/^  virtual uint32 Flags() const { return 0; }$/;"	f	class:fst::MatcherBase
Flags	mutable-fst.h	/^  uint32 Flags() const { return data_.base->Flags(); }$/;"	f	class:fst::MutableArcIterator
Flags	replace.h	/^  uint32 Flags() const { return flags_; }$/;"	f	class:fst::ArcIterator
Flags	vector-fst.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcIterator
Flags	vector-fst.h	/^  uint32 Flags() const {$/;"	f	class:fst::MutableArcIterator
Flags_	cache.h	/^  uint32 Flags_() const { return Flags(); }$/;"	f	class:fst::CacheMutableArcIterator
Flags_	complement.h	/^  uint32 Flags_() const { return Flags(); }$/;"	f	class:fst::ArcIterator
Flags_	vector-fst.h	/^  uint32 Flags_() const { return Flags(); }$/;"	f	class:fst::MutableArcIterator
FloatLimits	float-weight.h	/^class FloatLimits {$/;"	c	namespace:fst
FloatWeight	float-weight.h	/^typedef FloatWeightTpl<float> FloatWeight;$/;"	t	namespace:fst
FloatWeight	fst-decl.h	/^typedef FloatWeightTpl<float> FloatWeight;$/;"	t	namespace:fst
FloatWeightTpl	float-weight.h	/^  FloatWeightTpl() {}$/;"	f	class:fst::FloatWeightTpl
FloatWeightTpl	float-weight.h	/^  FloatWeightTpl(T f) : value_(f) {}$/;"	f	class:fst::FloatWeightTpl
FloatWeightTpl	float-weight.h	/^  FloatWeightTpl(const FloatWeightTpl<T> &w) : value_(w.value_) {}$/;"	f	class:fst::FloatWeightTpl
FloatWeightTpl	float-weight.h	/^class FloatWeightTpl {$/;"	c	namespace:fst
ForwardOrCrossArc	connect.h	/^  bool ForwardOrCrossArc(StateId s, const A &arc) {$/;"	f	class:fst::SccVisitor
ForwardOrCrossArc	minimize.h	/^    bool ForwardOrCrossArc(StateId s, const A& arc) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
ForwardOrCrossArc	randgen.h	/^  bool ForwardOrCrossArc(StateId s, const IArc &arc) {$/;"	f	class:fst::RandGenVisitor
ForwardOrCrossArc	state-reachable.h	/^  bool ForwardOrCrossArc(StateId s, const A &arc) {$/;"	f	class:fst::IntervalReachVisitor
ForwardOrCrossArc	topsort.h	/^  bool ForwardOrCrossArc(StateId s, const A &arc) { return true; }$/;"	f	class:fst::TopOrderVisitor
Free	cache.h	/^  void Free(S *state, StateId s) {$/;"	f	struct:fst::DefaultCacheStateAllocator
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	class:fst::WeightConvertMapper
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::IdentityArcMapper
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::InvertWeightMapper
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::PlusMapper
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::QuantizeMapper
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::ReverseWeightMapper
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::RmWeightMapper
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::SuperFinalMapper
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::TimesMapper
FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::ToGallicMapper
FromArc	arc-map.h	/^  typedef GallicArc<A, S> FromArc;$/;"	t	struct:fst::FromGallicMapper
FromArc	arc-map.h	/^  typedef GallicArc<A, S> FromArc;$/;"	t	struct:fst::GallicToNewSymbolsMapper
FromArc	arcsort.h	/^  typedef Arc FromArc;$/;"	t	class:fst::ArcSortMapper
FromArc	map.h	/^  typedef A FromArc;$/;"	t	struct:fst::IdentityMapper
FromArc	state-map.h	/^  typedef A FromArc;$/;"	t	class:fst::ArcSumMapper
FromArc	state-map.h	/^  typedef A FromArc;$/;"	t	class:fst::ArcUniqueMapper
FromArc	state-map.h	/^  typedef A FromArc;$/;"	t	class:fst::IdentityStateMapper
FromFst	determinize.h	/^  typedef ArcMapFst<ToArc, A, FromMapper> FromFst;$/;"	t	class:fst::DeterminizeFstImpl
FromGallicMapper	arc-map.h	/^  FromGallicMapper(Label superfinal_label = 0)$/;"	f	struct:fst::FromGallicMapper
FromGallicMapper	arc-map.h	/^struct FromGallicMapper {$/;"	s	namespace:fst
FromMapper	determinize.h	/^  typedef FromGallicMapper<A, S> FromMapper;$/;"	t	class:fst::DeterminizeFstImpl
FromWeight	arc-map.h	/^  typedef typename FromArc::Weight FromWeight;$/;"	t	class:fst::WeightConvertMapper
FromWeight	arc-map.h	/^  typedef typename FromArc::Weight FromWeight;$/;"	t	struct:fst::QuantizeMapper
FromWeight	arc-map.h	/^  typedef typename FromArc::Weight FromWeight;$/;"	t	struct:fst::RmWeightMapper
Fst	fst.h	/^class Fst {$/;"	c	namespace:fst
FstHeader	fst.h	/^  FstHeader() : version_(0), flags_(0), properties_(0), start_(-1),$/;"	f	class:fst::FstHeader
FstHeader	fst.h	/^class FstHeader {$/;"	c	namespace:fst
FstImpl	fst.h	/^  FstImpl()$/;"	f	class:fst::FstImpl
FstImpl	fst.h	/^  FstImpl(const FstImpl<A> &impl)$/;"	f	class:fst::FstImpl
FstImpl	fst.h	/^template <class A> class FstImpl {$/;"	c	namespace:fst
FstMatcher	lookahead-filter.h	/^  typedef M FstMatcher;$/;"	t	class:fst::DefaultLookAhead
FstMatcher	matcher-fst.h	/^  typedef M FstMatcher;$/;"	t	class:fst::MatcherFst
FstOnceInit	lock.h	/^inline int FstOnceInit(FstOnceType *once, void (*init)(void)) {$/;"	f	namespace:fst
FstOnceType	lock.h	/^typedef int FstOnceType;$/;"	t	namespace:fst
FstPair	replace-util.h	/^  typedef pair<Label, const Fst<Arc>*> FstPair;$/;"	t	class:fst::ReplaceUtil
FstReadOptions	fst.h	/^  explicit FstReadOptions(const string& src = "<unspecfied>",$/;"	f	struct:fst::FstReadOptions
FstReadOptions	fst.h	/^  explicit FstReadOptions(const string& src,$/;"	f	struct:fst::FstReadOptions
FstReadOptions	fst.h	/^struct FstReadOptions {$/;"	s	namespace:fst
FstRegister	register.h	/^class FstRegister : public GenericRegister<string, FstRegisterEntry<A>,$/;"	c	namespace:fst
FstRegisterEntry	register.h	/^  FstRegisterEntry() : reader(0), converter(0) {}$/;"	f	struct:fst::FstRegisterEntry
FstRegisterEntry	register.h	/^  FstRegisterEntry(Reader r, Converter c) : reader(r), converter(c) { }$/;"	f	struct:fst::FstRegisterEntry
FstRegisterEntry	register.h	/^struct FstRegisterEntry {$/;"	s	namespace:fst
FstRegisterer	register.h	/^  FstRegisterer() :$/;"	f	class:fst::FstRegisterer
FstRegisterer	register.h	/^class FstRegisterer$/;"	c	namespace:fst
FstToLabels	string.h	/^  bool FstToLabels(const Fst<A> &fst) {$/;"	f	class:fst::StringPrinter
FstToString	fst.h	/^void FstToString(const Fst<A> &fst, string *result) {$/;"	f	namespace:fst
FstType	fst.h	/^  const string &FstType() const { return fsttype_; }$/;"	f	class:fst::FstHeader
FstWriteOptions	fst.h	/^  explicit FstWriteOptions(const string& src = "<unspecifed>",$/;"	f	struct:fst::FstWriteOptions
FstWriteOptions	fst.h	/^struct FstWriteOptions {$/;"	s	namespace:fst
GC	accumulator.h	/^  void GC(bool free_recent) {$/;"	f	class:fst::CacheLogAccumulatorData
GC	cache.h	/^  void GC(StateId current, bool free_recent) {$/;"	f	class:fst::CacheBaseImpl
GW	arc-map.h	/^  typedef typename GallicArc<A, S>::Weight GW;$/;"	t	struct:fst::FromGallicMapper
GW	arc-map.h	/^  typedef typename GallicArc<A, S>::Weight GW;$/;"	t	struct:fst::GallicToNewSymbolsMapper
GW	arc-map.h	/^  typedef typename GallicArc<A, S>::Weight GW;$/;"	t	struct:fst::ToGallicMapper
GallicArc	arc.h	/^  GallicArc() {}$/;"	f	struct:fst::GallicArc
GallicArc	arc.h	/^  GallicArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::GallicArc
GallicArc	arc.h	/^  GallicArc(const A &arc)$/;"	f	struct:fst::GallicArc
GallicArc	arc.h	/^struct GallicArc {$/;"	s	namespace:fst
GallicCommonDivisor	determinize.h	/^class GallicCommonDivisor {$/;"	c	namespace:fst
GallicFactor	factor-weight.h	/^  GallicFactor(const GallicWeight<L, W, S> &w)$/;"	f	class:fst::GallicFactor
GallicFactor	factor-weight.h	/^class GallicFactor {$/;"	c	namespace:fst
GallicToNewSymbolsMapper	arc-map.h	/^  GallicToNewSymbolsMapper(MutableFst<ToArc> *fst)$/;"	f	struct:fst::GallicToNewSymbolsMapper
GallicToNewSymbolsMapper	arc-map.h	/^struct GallicToNewSymbolsMapper {$/;"	s	namespace:fst
GallicWeight	string-weight.h	/^  GallicWeight() {}$/;"	f	struct:fst::GallicWeight
GallicWeight	string-weight.h	/^  GallicWeight(StringWeight<L, S> w1, W w2)$/;"	f	struct:fst::GallicWeight
GallicWeight	string-weight.h	/^  GallicWeight(const ProductWeight<StringWeight<L, S>, W> &w)$/;"	f	struct:fst::GallicWeight
GallicWeight	string-weight.h	/^  explicit GallicWeight(const string &s, int *nread = 0)$/;"	f	struct:fst::GallicWeight
GallicWeight	string-weight.h	/^struct GallicWeight : public ProductWeight<StringWeight<L, S>, W> {$/;"	s	namespace:fst
GallicWeightGenerator	random-weight.h	/^  GallicWeightGenerator(const PG &pg) : PG(pg) {}$/;"	f	class:fst::GallicWeightGenerator
GallicWeightGenerator	random-weight.h	/^  GallicWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::GallicWeightGenerator
GallicWeightGenerator	random-weight.h	/^class GallicWeightGenerator$/;"	c	namespace:fst
GenericComposeStateTable	state-table.h	/^  GenericComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2) {}$/;"	f	class:fst::GenericComposeStateTable
GenericComposeStateTable	state-table.h	/^  GenericComposeStateTable(const GenericComposeStateTable<A, F> &table) {}$/;"	f	class:fst::GenericComposeStateTable
GenericComposeStateTable	state-table.h	/^class GenericComposeStateTable : public H {$/;"	c	namespace:fst
GenericRegister	generic-register.h	/^class GenericRegister {$/;"	c	namespace:fst
GenericRegisterer	generic-register.h	/^  GenericRegisterer(Key key, Entry entry) {$/;"	f	class:fst::GenericRegisterer
GenericRegisterer	generic-register.h	/^class GenericRegisterer {$/;"	c	namespace:fst
GetAccumulator	accumulator.h	/^  Accumulator *GetAccumulator(size_t i) { return accumulators_[i]; }$/;"	f	class:fst::ReplaceAccumulatorData
GetAddOn	add-on.h	/^  T *GetAddOn() const { return t_; }$/;"	f	class:fst::AddOnImpl
GetCacheGc	cache.h	/^  bool GetCacheGc() const { return cache_gc_; }$/;"	f	class:fst::CacheBaseImpl
GetCacheLimit	cache.h	/^  size_t GetCacheLimit() const { return cache_limit_; }$/;"	f	class:fst::CacheBaseImpl
GetCacheSize	cache.h	/^  size_t GetCacheSize() const { return cache_size_; }$/;"	f	class:fst::CacheBaseImpl
GetCcVector	connect.h	/^  int GetCcVector(vector<StateId> *cc) {$/;"	f	class:fst::CcVisitor
GetCompactor	compact-fst.h	/^  C *GetCompactor() const { return compactor_; }$/;"	f	class:fst::CompactFstImpl
GetConverter	register.h	/^  const Converter GetConverter(const string &type) const {$/;"	f	class:fst::FstRegister
GetData	label-reachable.h	/^  LabelReachableData<Label> *GetData() const { return data_; }$/;"	f	class:fst::LabelReachable
GetData	lookahead-matcher.h	/^  MatcherData *GetData() const { return 0; }$/;"	f	class:fst::ArcLookAheadMatcher
GetData	lookahead-matcher.h	/^  MatcherData *GetData() const {$/;"	f	class:fst::LabelLookAheadMatcher
GetData	matcher-fst.h	/^  typename M::MatcherData *GetData(MatchType match_type) const {$/;"	f	class:fst::MatcherFst
GetDefault	flags.h	/^  string GetDefault(bool default_value) const {$/;"	f	class:FlagRegister
GetDefault	flags.h	/^  string GetDefault(const string &default_value) const {$/;"	f	class:FlagRegister
GetDefault	flags.h	/^  template<typename V> string GetDefault(const V& default_value) const {$/;"	f	class:FlagRegister
GetDependencies	replace-util.h	/^void ReplaceUtil<Arc>::GetDependencies(bool stats) const {$/;"	f	class:fst::ReplaceUtil
GetEditableInternalId	edit-fst.h	/^  StateId GetEditableInternalId(StateId s, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
GetEditedIdMapIterator	edit-fst.h	/^  IdMapIterator GetEditedIdMapIterator(StateId s) const {$/;"	f	class:fst::EditFstData
GetEntry	generic-register.h	/^  EntryType GetEntry(const KeyType &key) const {$/;"	f	class:fst::GenericRegister
GetFinalWeightIterator	edit-fst.h	/^  FinalWeightIterator GetFinalWeightIterator(StateId s) const {$/;"	f	class:fst::EditFstData
GetFlagDescription	flags.h	/^  const FlagDescription<T> &GetFlagDescription(const string &name) const {$/;"	f	class:FlagRegister
GetFlags	fst.h	/^  int32 GetFlags() const { return flags_; }$/;"	f	class:fst::FstHeader
GetFst	accumulator.h	/^  const Fst<Arc> *GetFst(size_t i) const { return fst_array_[i]; }$/;"	f	class:fst::ReplaceAccumulatorData
GetFst	add-on.h	/^  F &GetFst() { return fst_; }$/;"	f	class:fst::AddOnImpl
GetFst	add-on.h	/^  const F &GetFst() const { return fst_; }$/;"	f	class:fst::AddOnImpl
GetFst	determinize.h	/^  const Fst<A> &GetFst() const { return *fst_; }$/;"	f	class:fst::DeterminizeFstImplBase
GetFst	lookahead-filter.h	/^  const F &GetFst() const {$/;"	f	class:fst::LookAheadSelector
GetFst	lookahead-filter.h	/^  const F1 &GetFst() const { return *fst_; }$/;"	f	class:fst::LookAheadSelector
GetFst	lookahead-filter.h	/^  const F2 &GetFst() const { return *fst_; }$/;"	f	class:fst::LookAheadSelector
GetFst	lookahead-matcher.h	/^  const F &GetFst() const { return static_cast<const F &>(base_->GetFst()); }$/;"	f	class:fst::LookAheadMatcher
GetFst	lookahead-matcher.h	/^  const FST &GetFst() const { return fst_; }$/;"	f	class:fst::ArcLookAheadMatcher
GetFst	lookahead-matcher.h	/^  const FST &GetFst() const { return matcher_.GetFst(); }$/;"	f	class:fst::LabelLookAheadMatcher
GetFst	lookahead-matcher.h	/^  virtual const FST &GetFst() const { return matcher_.GetFst(); }$/;"	f	class:fst::TrivialLookAheadMatcher
GetFst	matcher-fst.h	/^  F& GetFst() const { return GetImpl()->GetFst(); }$/;"	f	class:fst::MatcherFst
GetFst	matcher-fst.h	/^  const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::LookAheadMatcher
GetFst	matcher.h	/^  const F &GetFst() const { return static_cast<const F &>(base_->GetFst()); }$/;"	f	class:fst::Matcher
GetFst	matcher.h	/^  const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::MultiEpsMatcher
GetFst	matcher.h	/^  virtual const F &GetFst() const { return *fst_; }$/;"	f	class:fst::SortedMatcher
GetFst	matcher.h	/^  virtual const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::PhiMatcher
GetFst	matcher.h	/^  virtual const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::RhoMatcher
GetFst	matcher.h	/^  virtual const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::SigmaMatcher
GetFst	replace.h	/^  const Fst<A>* GetFst(Label fst_id) const {$/;"	f	class:fst::ReplaceFstImpl
GetFst	replace.h	/^  virtual const Fst<A> &GetFst() const {$/;"	f	class:fst::ReplaceFstMatcher
GetFstPairs	replace-util.h	/^void ReplaceUtil<Arc>::GetFstPairs(vector<FstPair> *fst_pairs) {$/;"	f	class:fst::ReplaceUtil
GetImpl	arc-map.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::ArcMapFst
GetImpl	compact-fst.h	/^  Impl *GetImpl() const { return ImplToFst<Impl, ExpandedFst<A> >::GetImpl(); }$/;"	f	class:fst::CompactFst
GetImpl	complement.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::ComplementFst
GetImpl	compose.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::ComposeFst
GetImpl	const-fst.h	/^  Impl *GetImpl() const { return ImplToFst<Impl, ExpandedFst<A> >::GetImpl(); }$/;"	f	class:fst::ConstFst
GetImpl	determinize.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::DeterminizeFst
GetImpl	edit-fst.h	/^  Impl *GetImpl() const { return ImplToFst< Impl, MutableFst<A> >::GetImpl(); }$/;"	f	class:fst::EditFst
GetImpl	factor-weight.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::FactorWeightFst
GetImpl	fst.h	/^  I *GetImpl() const { return impl_; }$/;"	f	class:fst::ImplToFst
GetImpl	matcher-fst.h	/^  Impl *GetImpl() const {$/;"	f	class:fst::MatcherFst
GetImpl	randgen.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::RandGenFst
GetImpl	rational.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::RationalFst
GetImpl	relabel.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::RelabelFst
GetImpl	replace.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::ReplaceFst
GetImpl	rmepsilon.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::RmEpsilonFst
GetImpl	state-map.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::StateMapFst
GetImpl	synchronize.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::SynchronizeFst
GetImpl	vector-fst.h	/^  Impl *GetImpl() const { return ImplToFst< Impl, MutableFst<A> >::GetImpl(); }$/;"	f	class:fst::VectorFst
GetLabel	encode.h	/^  Label GetLabel(const A &arc) const {$/;"	f	class:fst::EncodeTable
GetMatcher	lookahead-filter.h	/^  M *GetMatcher() const {$/;"	f	class:fst::LookAheadSelector
GetMatcher	lookahead-filter.h	/^  M1 *GetMatcher() const { return lmatcher_; }$/;"	f	class:fst::LookAheadSelector
GetMatcher	lookahead-filter.h	/^  M2 *GetMatcher() const { return lmatcher_; }$/;"	f	class:fst::LookAheadSelector
GetMatcher1	compose-filter.h	/^  Matcher1 *GetMatcher1() { return filter_.GetMatcher1(); }$/;"	f	class:fst::MultiEpsFilter
GetMatcher1	compose-filter.h	/^  Matcher1 *GetMatcher1() { return matcher1_; }$/;"	f	class:fst::AltSequenceComposeFilter
GetMatcher1	compose-filter.h	/^  Matcher1 *GetMatcher1() { return matcher1_; }$/;"	f	class:fst::MatchComposeFilter
GetMatcher1	compose-filter.h	/^  Matcher1 *GetMatcher1() { return matcher1_; }$/;"	f	class:fst::SequenceComposeFilter
GetMatcher1	lookahead-filter.h	/^  Matcher1 *GetMatcher1() { return &matcher1_; }$/;"	f	class:fst::PushLabelsComposeFilter
GetMatcher1	lookahead-filter.h	/^  Matcher1 *GetMatcher1() { return filter_.GetMatcher1(); }$/;"	f	class:fst::LookAheadComposeFilter
GetMatcher1	lookahead-filter.h	/^  Matcher1 *GetMatcher1() { return filter_.GetMatcher1(); }$/;"	f	class:fst::PushWeightsComposeFilter
GetMatcher2	compose-filter.h	/^  Matcher2 *GetMatcher2() { return filter_.GetMatcher2(); }$/;"	f	class:fst::MultiEpsFilter
GetMatcher2	compose-filter.h	/^  Matcher2 *GetMatcher2() { return matcher2_; }$/;"	f	class:fst::AltSequenceComposeFilter
GetMatcher2	compose-filter.h	/^  Matcher2 *GetMatcher2() { return matcher2_; }$/;"	f	class:fst::MatchComposeFilter
GetMatcher2	compose-filter.h	/^  Matcher2 *GetMatcher2() { return matcher2_; }$/;"	f	class:fst::SequenceComposeFilter
GetMatcher2	lookahead-filter.h	/^  Matcher2 *GetMatcher2() { return &matcher2_; }$/;"	f	class:fst::PushLabelsComposeFilter
GetMatcher2	lookahead-filter.h	/^  Matcher2 *GetMatcher2() { return filter_.GetMatcher2(); }$/;"	f	class:fst::LookAheadComposeFilter
GetMatcher2	lookahead-filter.h	/^  Matcher2 *GetMatcher2() { return filter_.GetMatcher2(); }$/;"	f	class:fst::PushWeightsComposeFilter
GetMutableFstPairs	replace-util.h	/^void ReplaceUtil<Arc>::GetMutableFstPairs($/;"	f	class:fst::ReplaceUtil
GetNthKey	symbol-table.h	/^  int64 GetNthKey(ssize_t pos) const {$/;"	f	class:fst::SymbolTableImpl
GetNthKey	symbol-table.h	/^  virtual int64 GetNthKey(ssize_t pos) const {$/;"	f	class:fst::SymbolTable
GetPrecisionString	float-weight.h	/^  inline static string GetPrecisionString() {$/;"	f	class:fst::FloatWeightTpl
GetPrefixId	replace.h	/^  PrefixId GetPrefixId(const StackPrefix& prefix) {$/;"	f	class:fst::ReplaceFstImpl
GetReader	register.h	/^  const Reader GetReader(const string &type) const {$/;"	f	class:fst::FstRegister
GetRegister	flags.h	/^  static FlagRegister<T> *GetRegister() {$/;"	f	class:FlagRegister
GetRegister	generic-register.h	/^  static RegisterType *GetRegister() {$/;"	f	class:fst::GenericRegister
GetState	cache.h	/^  S *GetState(StateId s) {$/;"	f	class:fst::CacheBaseImpl
GetState	cache.h	/^  const S *GetState(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
GetState	compose-filter.h	/^  T GetState() const { return state_; }$/;"	f	class:fst::IntegerFilterState
GetState	vector-fst.h	/^  State *GetState(StateId s) { return states_[s]; }$/;"	f	class:fst::VectorFstBaseImpl
GetState	vector-fst.h	/^  const State *GetState(StateId s) const { return states_[s]; }$/;"	f	class:fst::VectorFstBaseImpl
GetState1	compose-filter.h	/^  const F1 &GetState1() const { return f1_; }$/;"	f	class:fst::PairFilterState
GetState2	compose-filter.h	/^  const F2 &GetState2() const { return f2_; }$/;"	f	class:fst::PairFilterState
GetStateTable	replace.h	/^  T* GetStateTable() const {$/;"	f	class:fst::ReplaceFstImpl
GetTopOrder	replace-util.h	/^bool ReplaceUtil<Arc>::GetTopOrder(const Fst<Arc> &fst,$/;"	f	class:fst::ReplaceUtil
GetTuple	accumulator.h	/^  const StateTuple &GetTuple(StateId s) const {$/;"	f	class:fst::ReplaceAccumulatorData
GetUsage	flags.h	/^  void GetUsage(std::set< std::pair<string, string> > *usage_set) const {$/;"	f	class:FlagRegister
GetWeight	compose-filter.h	/^  W GetWeight() const { return weight_; }$/;"	f	class:fst::WeightFilterState
GetWeights	accumulator.h	/^  vector<double> *GetWeights(StateId s) {$/;"	f	class:fst::CacheLogAccumulatorData
GreyArc	connect.h	/^  bool GreyArc(StateId s, const A &arc) {$/;"	f	class:fst::CcVisitor
GreyArc	visit.h	/^  bool GreyArc(StateId s, const Arc &arc) { return true; }$/;"	f	class:fst::PartialVisitor
GreyArc	visit.h	/^  bool GreyArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CopyVisitor
HAS_ISYMBOLS	fst.h	/^    HAS_ISYMBOLS = 0x1,          \/\/ Has input symbol table$/;"	e	enum:fst::FstHeader::__anon1
HAS_OSYMBOLS	fst.h	/^    HAS_OSYMBOLS = 0x2,          \/\/ Has output symbol table$/;"	e	enum:fst::FstHeader::__anon1
HAVE_STD__TR1__HASH_LONG_LONG_UNSIGNED_	config.h	9;"	d
HAVE___GNU_CXX__SLIST_INT_	config.h	12;"	d
HasArcs	cache.h	/^  bool HasArcs(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
HasFinal	cache.h	/^  bool HasFinal(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
HasStart	cache.h	/^  bool HasStart() const {$/;"	f	class:fst::CacheBaseImpl
Hash	bi-table.h	/^  const H &Hash() const { return *h_; }$/;"	f	class:fst::VectorHashBiTable
Hash	compose-filter.h	/^  size_t Hash() const { return static_cast<size_t>(state_); }$/;"	f	class:fst::IntegerFilterState
Hash	compose-filter.h	/^  size_t Hash() const { return weight_.Hash(); }$/;"	f	class:fst::WeightFilterState
Hash	compose-filter.h	/^  size_t Hash() const {$/;"	f	class:fst::PairFilterState
Hash	float-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::FloatWeightTpl
Hash	pair-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::PairWeight
Hash	signed-log-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::SignedLogWeightTpl
Hash	sparse-tuple-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::SparseTupleWeight
Hash	string-weight.h	/^inline size_t StringWeight<L, S>::Hash() const {$/;"	f	class:fst::StringWeight
Hash	tuple-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::TupleWeight
HashBiTable	bi-table.h	/^  HashBiTable() {$/;"	f	class:fst::HashBiTable
HashBiTable	bi-table.h	/^class HashBiTable {$/;"	c	namespace:fst
HashEqual	bi-table.h	/^    HashEqual(const CompactHashBiTable &ht) : ht_(&ht) {}$/;"	f	class:fst::CompactHashBiTable::HashEqual
HashEqual	bi-table.h	/^    HashEqual(const VectorHashBiTable &ht) : ht_(&ht) {}$/;"	f	class:fst::VectorHashBiTable::HashEqual
HashEqual	bi-table.h	/^  class HashEqual {$/;"	c	class:fst::CompactHashBiTable
HashEqual	bi-table.h	/^  class HashEqual {$/;"	c	class:fst::VectorHashBiTable
HashFunc	bi-table.h	/^    HashFunc(const CompactHashBiTable &ht) : ht_(&ht) {}$/;"	f	class:fst::CompactHashBiTable::HashFunc
HashFunc	bi-table.h	/^    HashFunc(const VectorHashBiTable &ht) : ht_(&ht) {}$/;"	f	class:fst::VectorHashBiTable::HashFunc
HashFunc	bi-table.h	/^  class HashFunc {$/;"	c	class:fst::CompactHashBiTable
HashFunc	bi-table.h	/^  class HashFunc {$/;"	c	class:fst::VectorHashBiTable
HashStateTable	state-table.h	/^  HashStateTable() : HashBiTable<StateId, T, H>() {}$/;"	f	class:fst::HashStateTable
HashStateTable	state-table.h	/^class HashStateTable : public HashBiTable<typename T::StateId, T, H> {$/;"	c	namespace:fst
Head	queue.h	/^  StateId Head() const { return Head_(); }$/;"	f	class:fst::QueueBase
Head	queue.h	/^  StateId Head() const { return back(); }$/;"	f	class:fst::FifoQueue
Head	queue.h	/^  StateId Head() const { return front(); }$/;"	f	class:fst::LifoQueue
Head	queue.h	/^  StateId Head() const { return front_; }$/;"	f	class:fst::StateOrderQueue
Head	queue.h	/^  StateId Head() const { return front_; }$/;"	f	class:fst::TrivialQueue
Head	queue.h	/^  StateId Head() const { return heap_.Top(); }$/;"	f	class:fst::ShortestFirstQueue
Head	queue.h	/^  StateId Head() const { return queue_->Head(); }$/;"	f	class:fst::AutoQueue
Head	queue.h	/^  StateId Head() const { return queue_->Head(); }$/;"	f	class:fst::PruneQueue
Head	queue.h	/^  StateId Head() const { return state_[front_]; }$/;"	f	class:fst::TopOrderQueue
Head	queue.h	/^  StateId Head() const {$/;"	f	class:fst::SccQueue
Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::AutoQueue
Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::FifoQueue
Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::LifoQueue
Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::PruneQueue
Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::SccQueue
Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::ShortestFirstQueue
Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::StateOrderQueue
Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::TopOrderQueue
Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::TrivialQueue
Heap	heap.h	/^  Heap() : size_(0) { }$/;"	f	class:fst::Heap
Heap	heap.h	/^  Heap(Compare comp) : comp_(comp), size_(0) { }$/;"	f	class:fst::Heap
Heap	heap.h	/^class Heap {$/;"	c	namespace:fst
Heapify	heap.h	/^  void Heapify(int i) {$/;"	f	class:fst::Heap
HeightVisitor	minimize.h	/^    HeightVisitor() : max_height_(0), num_states_(0) { }$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
HeightVisitor	minimize.h	/^  class HeightVisitor {$/;"	c	class:fst::AcyclicMinimizer
ILabelCompare	arcsort.h	/^template<class A> class ILabelCompare {$/;"	c	namespace:fst
IS_ALIGNED	fst.h	/^    IS_ALIGNED   = 0x4,          \/\/ Memory-aligned (where appropriate)$/;"	e	enum:fst::FstHeader::__anon1
IdMapIterator	edit-fst.h	/^      IdMapIterator;$/;"	t	class:fst::EditFstData
IdMapIterator	edit-fst.h	/^    IdMapIterator;$/;"	t	class:fst::EditFstImpl
IdentityArcMapper	arc-map.h	/^struct IdentityArcMapper {$/;"	s	namespace:fst
IdentityFactor	factor-weight.h	/^  IdentityFactor(const W &w) {}$/;"	f	class:fst::IdentityFactor
IdentityFactor	factor-weight.h	/^class IdentityFactor {$/;"	c	namespace:fst
IdentityMapper	map.h	/^struct IdentityMapper {$/;"	s	namespace:fst
IdentityStateMapper	state-map.h	/^  IdentityStateMapper(const IdentityStateMapper<A> &mapper,$/;"	f	class:fst::IdentityStateMapper
IdentityStateMapper	state-map.h	/^  explicit IdentityStateMapper(const Fst<A> &fst) : fst_(fst), aiter_(0) {}$/;"	f	class:fst::IdentityStateMapper
IdentityStateMapper	state-map.h	/^class IdentityStateMapper {$/;"	c	namespace:fst
Impl	arc-map.h	/^  typedef ArcMapFstImpl<A, B, C> Impl;$/;"	t	class:fst::ArcMapFst
Impl	cache.h	/^  typedef CacheBaseImpl<State, C> Impl;$/;"	t	class:fst::CacheArcIterator
Impl	cache.h	/^  typedef CacheBaseImpl<State, C> Impl;$/;"	t	class:fst::CacheMutableArcIterator
Impl	cache.h	/^  typedef CacheBaseImpl<State> Impl;$/;"	t	class:fst::CacheStateIterator
Impl	compact-fst.h	/^  typedef CompactFstImpl<A, C, U> Impl;$/;"	t	class:fst::CompactFst
Impl	complement.h	/^  typedef ComplementFstImpl<A> Impl;$/;"	t	class:fst::ComplementFst
Impl	compose.h	/^  typedef ComposeFstImplBase<A> Impl;$/;"	t	class:fst::ComposeFst
Impl	const-fst.h	/^  typedef ConstFstImpl<A, U> Impl;$/;"	t	class:fst::ConstFst
Impl	determinize.h	/^  typedef DeterminizeFstImplBase<A> Impl;$/;"	t	class:fst::DeterminizeFst
Impl	edit-fst.h	/^  typedef EditFstImpl<A, WrappedFstT, MutableFstT> Impl;$/;"	t	class:fst::EditFst
Impl	encode.h	/^  typedef ArcMapFstImpl< A, A, EncodeMapper<A> > Impl;$/;"	t	class:fst::DecodeFst
Impl	encode.h	/^  typedef ArcMapFstImpl< A, A, EncodeMapper<A> > Impl;$/;"	t	class:fst::EncodeFst
Impl	factor-weight.h	/^  typedef FactorWeightFstImpl<A, F> Impl;$/;"	t	class:fst::FactorWeightFst
Impl	invert.h	/^  typedef ArcMapFstImpl< A, A, InvertMapper<A> > Impl;$/;"	t	class:fst::InvertFst
Impl	matcher-fst.h	/^  typedef AddOnImpl<F, D> Impl;$/;"	t	class:fst::MatcherFst
Impl	matcher-fst.h	/^  typedef AddOnImpl<typename M::FST, D> Impl;$/;"	t	class:fst::NullMatcherFstInit
Impl	project.h	/^  typedef ArcMapFstImpl< A, A, ProjectMapper<A> > Impl;$/;"	t	class:fst::ProjectFst
Impl	randgen.h	/^  typedef RandGenFstImpl<A, B, S> Impl;$/;"	t	class:fst::RandGenFst
Impl	rational.h	/^  typedef RationalFstImpl<A> Impl;$/;"	t	class:fst::RationalFst
Impl	relabel.h	/^  typedef RelabelFstImpl<A> Impl;$/;"	t	class:fst::RelabelFst
Impl	replace.h	/^  typedef ReplaceFstImpl<A, T> Impl;$/;"	t	class:fst::ReplaceFst
Impl	rmepsilon.h	/^  typedef RmEpsilonFstImpl<A> Impl;$/;"	t	class:fst::RmEpsilonFst
Impl	state-map.h	/^  typedef StateMapFstImpl<A, B, C> Impl;$/;"	t	class:fst::StateMapFst
Impl	symbol-table.h	/^  const SymbolTableImpl* Impl() const {$/;"	f	class:fst::SymbolTable
Impl	synchronize.h	/^  typedef SynchronizeFstImpl<A> Impl;$/;"	t	class:fst::SynchronizeFst
Impl	vector-fst.h	/^  typedef VectorFstImpl<A> Impl;$/;"	t	class:fst::VectorFst
ImplToExpandedFst	expanded-fst.h	/^  ImplToExpandedFst() : ImplToFst<I, F>() {}$/;"	f	class:fst::ImplToExpandedFst
ImplToExpandedFst	expanded-fst.h	/^  ImplToExpandedFst(I *impl) : ImplToFst<I, F>(impl) {}$/;"	f	class:fst::ImplToExpandedFst
ImplToExpandedFst	expanded-fst.h	/^  ImplToExpandedFst(const ImplToExpandedFst<I, F> &fst)$/;"	f	class:fst::ImplToExpandedFst
ImplToExpandedFst	expanded-fst.h	/^  ImplToExpandedFst(const ImplToExpandedFst<I, F> &fst, bool safe)$/;"	f	class:fst::ImplToExpandedFst
ImplToExpandedFst	expanded-fst.h	/^class ImplToExpandedFst : public ImplToFst<I, F> {$/;"	c	namespace:fst
ImplToFst	fst.h	/^  ImplToFst() : impl_(0) {}$/;"	f	class:fst::ImplToFst
ImplToFst	fst.h	/^  ImplToFst(I *impl) : impl_(impl) {}$/;"	f	class:fst::ImplToFst
ImplToFst	fst.h	/^  ImplToFst(const ImplToFst<I, F> &fst) {$/;"	f	class:fst::ImplToFst
ImplToFst	fst.h	/^  ImplToFst(const ImplToFst<I, F> &fst, bool safe) {$/;"	f	class:fst::ImplToFst
ImplToFst	fst.h	/^class ImplToFst : public F {$/;"	c	namespace:fst
ImplToMutableFst	mutable-fst.h	/^  ImplToMutableFst() : ImplToExpandedFst<I, F>() {}$/;"	f	class:fst::ImplToMutableFst
ImplToMutableFst	mutable-fst.h	/^  ImplToMutableFst(I *impl) : ImplToExpandedFst<I, F>(impl) {}$/;"	f	class:fst::ImplToMutableFst
ImplToMutableFst	mutable-fst.h	/^  ImplToMutableFst(const ImplToMutableFst<I, F> &fst)$/;"	f	class:fst::ImplToMutableFst
ImplToMutableFst	mutable-fst.h	/^  ImplToMutableFst(const ImplToMutableFst<I, F> &fst, bool safe)$/;"	f	class:fst::ImplToMutableFst
ImplToMutableFst	mutable-fst.h	/^class ImplToMutableFst : public ImplToExpandedFst<I, F> {$/;"	c	namespace:fst
Incr	lock.h	/^  int Incr() const { return ++count_; }$/;"	f	class:fst::RefCounter
IncrRefCount	accumulator.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::CacheLogAccumulatorData
IncrRefCount	accumulator.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::FastLogAccumulatorData
IncrRefCount	accumulator.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::ReplaceAccumulatorData
IncrRefCount	add-on.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::NullAddOn
IncrRefCount	add-on.h	/^  int IncrRefCount() {$/;"	f	class:fst::AddOnPair
IncrRefCount	compact-fst.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::CompactFstData
IncrRefCount	edit-fst.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::EditFstData
IncrRefCount	encode.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::EncodeTable
IncrRefCount	fst.h	/^  int IncrRefCount() {$/;"	f	class:fst::FstImpl
IncrRefCount	label-reachable.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::LabelReachableData
IncrRefCount	symbol-table.h	/^  int IncrRefCount() const {$/;"	f	class:fst::SymbolTableImpl
Index	state-reachable.h	/^  typedef I Index;$/;"	t	class:fst::StateReachable
InheritPropertiesFromWrapped	edit-fst.h	/^  void InheritPropertiesFromWrapped() {$/;"	f	class:fst::EditFstImpl
Init	accumulator.h	/^  void Init(const F &fst, bool copy = false) {$/;"	f	class:fst::FastLogAccumulator
Init	accumulator.h	/^  void Init(const Fst<A> &fst, bool copy = false) {$/;"	f	class:fst::CacheLogAccumulator
Init	accumulator.h	/^  void Init(const Fst<A>& fst, bool copy = false) {}$/;"	f	class:fst::DefaultAccumulator
Init	accumulator.h	/^  void Init(const Fst<A>& fst, bool copy = false) {}$/;"	f	class:fst::LogAccumulator
Init	accumulator.h	/^  void Init(const vector<pair<Label, const Fst<Arc>*> > &fst_tuples,$/;"	f	class:fst::ReplaceAccumulator
Init	accumulator.h	/^  void Init(const vector<pair<Label, const Fst<Arc>*> > &fst_tuples,$/;"	f	class:fst::ReplaceAccumulatorData
Init	arc-map.h	/^  void Init() {$/;"	f	class:fst::ArcMapFstImpl
Init	compact-fst.h	/^  void Init(const Fst<Arc> &fst) {$/;"	f	class:fst::CompactFstImpl
Init	compact-fst.h	/^  void Init(const Iterator &b, const Iterator &e) {$/;"	f	class:fst::CompactFstImpl
Init	determinize.h	/^void DeterminizeFstImpl<A, S>::Init(const Fst<A> &fst) {$/;"	f	class:fst::DeterminizeFstImpl
Init	flags.h	/^  static void Init() {$/;"	f	class:FlagRegister
Init	generic-register.h	/^  static void Init() {$/;"	f	class:fst::GenericRegister
Init	replace.h	/^  void Init() {$/;"	f	class:fst::ArcIterator
Init	sparse-tuple-weight.h	/^  void Init() {$/;"	f	class:fst::SparseTupleWeight
Init	sparse-tuple-weight.h	/^  void Init(const W& default_value) {$/;"	f	class:fst::SparseTupleWeight
Init	state-map.h	/^  void Init() {$/;"	f	class:fst::StateMapFstImpl
Init	string-weight.h	/^  void Init() { first_ = 0; }$/;"	f	class:fst::StringWeight
InitArcIterator	add-on.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::AddOnImpl
InitArcIterator	arc-map.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<B> *data) const {$/;"	f	class:fst::ArcMapFst
InitArcIterator	arc-map.h	/^  void InitArcIterator(StateId s, ArcIteratorData<B> *data) {$/;"	f	class:fst::ArcMapFstImpl
InitArcIterator	cache.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::CacheBaseImpl
InitArcIterator	compact-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::CompactFst
InitArcIterator	compact-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::CompactFstImpl
InitArcIterator	complement.h	/^ComplementFst<A>::InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::ComplementFst
InitArcIterator	compose.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::ComposeFst
InitArcIterator	compose.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::ComposeFstImplBase
InitArcIterator	const-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::ConstFst
InitArcIterator	const-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::ConstFstImpl
InitArcIterator	determinize.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::DeterminizeFst
InitArcIterator	determinize.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::DeterminizeFstImplBase
InitArcIterator	edit-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::EditFst
InitArcIterator	edit-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::EditFstImpl
InitArcIterator	edit-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data,$/;"	f	class:fst::EditFstData
InitArcIterator	factor-weight.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::FactorWeightFst
InitArcIterator	factor-weight.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::FactorWeightFstImpl
InitArcIterator	matcher-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::MatcherFst
InitArcIterator	randgen.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<B> *data) const {$/;"	f	class:fst::RandGenFst
InitArcIterator	randgen.h	/^  void InitArcIterator(StateId s, ArcIteratorData<B> *data) {$/;"	f	class:fst::RandGenFstImpl
InitArcIterator	rational.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::RationalFst
InitArcIterator	relabel.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::RelabelFst
InitArcIterator	relabel.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A>* data) {$/;"	f	class:fst::RelabelFstImpl
InitArcIterator	replace.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::ReplaceFst
InitArcIterator	replace.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::ReplaceFstImpl
InitArcIterator	rmepsilon.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::RmEpsilonFst
InitArcIterator	rmepsilon.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::RmEpsilonFstImpl
InitArcIterator	state-map.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<B> *data) const {$/;"	f	class:fst::StateMapFst
InitArcIterator	state-map.h	/^  void InitArcIterator(StateId s, ArcIteratorData<B> *data) {$/;"	f	class:fst::StateMapFstImpl
InitArcIterator	synchronize.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::SynchronizeFst
InitArcIterator	synchronize.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::SynchronizeFstImpl
InitArcIterator	vector-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::VectorFst
InitArcIterator	vector-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::VectorFstBaseImpl
InitClosure	rational.h	/^  void InitClosure(const Fst<A> &fst, ClosureType closure_type) {$/;"	f	class:fst::RationalFstImpl
InitConcat	rational.h	/^  void InitConcat(const Fst<A> &fst1, const Fst<A> &fst2) {$/;"	f	class:fst::RationalFstImpl
InitFst	flags.h	/^inline void InitFst(const char *usage, int *argc, char ***argv, bool rmflags) {$/;"	f
InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {$/;"	f	class:fst::ArcLookAheadMatcher
InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {$/;"	f	class:fst::LabelLookAheadMatcher
InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {$/;"	f	class:fst::LookAheadMatcher
InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {}$/;"	f	class:fst::TrivialLookAheadMatcher
InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const L& fst, bool copy = false) {$/;"	f	class:fst::LabelLookAheadMatcher
InitLookAheadFst	matcher-fst.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {$/;"	f	class:fst::LookAheadMatcher
InitMatcher	compact-fst.h	/^  virtual MatcherBase<A> *InitMatcher(MatchType match_type) const {$/;"	f	class:fst::CompactFst
InitMatcher	fst.h	/^MatcherBase<A> *Fst<A>::InitMatcher(MatchType match_type) const {$/;"	f	class:fst::Fst
InitMatcher	matcher-fst.h	/^  virtual M *InitMatcher(MatchType match_type) const {$/;"	f	class:fst::MatcherFst
InitMatcher	replace.h	/^  virtual MatcherBase<A> *InitMatcher(MatchType match_type) const {$/;"	f	class:fst::ReplaceFst
InitMatchers	replace.h	/^  void InitMatchers() {$/;"	f	class:fst::ReplaceFstMatcher
InitMutableArcIterator	edit-fst.h	/^  void InitMutableArcIterator(StateId s, MutableArcIteratorData<A> *data) {$/;"	f	class:fst::EditFst
InitMutableArcIterator	edit-fst.h	/^  void InitMutableArcIterator(StateId s, MutableArcIteratorData<A> *data) {$/;"	f	class:fst::EditFstImpl
InitMutableArcIterator	edit-fst.h	/^  void InitMutableArcIterator(StateId s, MutableArcIteratorData<A> *data,$/;"	f	class:fst::EditFstData
InitMutableArcIterator	vector-fst.h	/^void VectorFst<A>::InitMutableArcIterator($/;"	f	class:fst::VectorFst
InitState	connect.h	/^  bool InitState(StateId s, StateId root) {$/;"	f	class:fst::CcVisitor
InitState	connect.h	/^bool SccVisitor<A>::InitState(StateId s, StateId root) {$/;"	f	class:fst::SccVisitor
InitState	minimize.h	/^    bool InitState(StateId s, StateId root) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
InitState	randgen.h	/^  bool InitState(StateId s, StateId root) { return true; }$/;"	f	class:fst::RandGenVisitor
InitState	state-reachable.h	/^  bool InitState(StateId s, StateId r) {$/;"	f	class:fst::IntervalReachVisitor
InitState	topsort.h	/^  bool InitState(StateId s, StateId r) { return true; }$/;"	f	class:fst::TopOrderVisitor
InitState	visit.h	/^  bool InitState(StateId s, StateId) {$/;"	f	class:fst::CopyVisitor
InitState	visit.h	/^  bool InitState(StateId s, StateId) {$/;"	f	class:fst::PartialVisitor
InitStateIterator	add-on.h	/^  void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::AddOnImpl
InitStateIterator	arc-map.h	/^void ArcMapFst<A, B, C>::InitStateIterator(StateIteratorData<B> *data)$/;"	f	class:fst::ArcMapFst
InitStateIterator	compact-fst.h	/^  virtual void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::CompactFst
InitStateIterator	compact-fst.h	/^  void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::CompactFstImpl
InitStateIterator	complement.h	/^ComplementFst<A>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ComplementFst
InitStateIterator	compose.h	/^void ComposeFst<A>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ComposeFst
InitStateIterator	const-fst.h	/^  virtual void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::ConstFst
InitStateIterator	const-fst.h	/^  void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ConstFstImpl
InitStateIterator	determinize.h	/^void DeterminizeFst<A>::InitStateIterator(StateIteratorData<A> *data) const$/;"	f	class:fst::DeterminizeFst
InitStateIterator	edit-fst.h	/^  virtual void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::EditFst
InitStateIterator	edit-fst.h	/^  void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::EditFstImpl
InitStateIterator	factor-weight.h	/^void FactorWeightFst<A, F>::InitStateIterator(StateIteratorData<A> *data) const$/;"	f	class:fst::FactorWeightFst
InitStateIterator	matcher-fst.h	/^  virtual void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::MatcherFst
InitStateIterator	randgen.h	/^void RandGenFst<A, B, S>::InitStateIterator(StateIteratorData<B> *data) const$/;"	f	class:fst::RandGenFst
InitStateIterator	rational.h	/^  virtual void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::RationalFst
InitStateIterator	relabel.h	/^void RelabelFst<A>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::RelabelFst
InitStateIterator	replace.h	/^void ReplaceFst<A, T>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ReplaceFst
InitStateIterator	rmepsilon.h	/^void RmEpsilonFst<A>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::RmEpsilonFst
InitStateIterator	state-map.h	/^  virtual void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::StateMapFst
InitStateIterator	state-map.h	/^  void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::StateMapFstImpl
InitStateIterator	synchronize.h	/^void SynchronizeFst<A>::InitStateIterator(StateIteratorData<A> *data) const$/;"	f	class:fst::SynchronizeFst
InitStateIterator	vector-fst.h	/^  virtual void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::VectorFst
InitStateIterator	vector-fst.h	/^  void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::VectorFstBaseImpl
InitUnion	rational.h	/^  void InitUnion(const Fst<A> &fst1, const Fst<A> &fst2) {$/;"	f	class:fst::RationalFstImpl
InitVisit	connect.h	/^  void InitVisit(const Fst<A> &fst) { }$/;"	f	class:fst::CcVisitor
InitVisit	connect.h	/^void SccVisitor<A>::InitVisit(const Fst<A> &fst) {$/;"	f	class:fst::SccVisitor
InitVisit	minimize.h	/^    void InitVisit(const Fst<A>& fst) {}$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
InitVisit	randgen.h	/^  void InitVisit(const Fst<IArc> &ifst) {$/;"	f	class:fst::RandGenVisitor
InitVisit	state-reachable.h	/^  void InitVisit(const Fst<A> &fst) { error_ = false; }$/;"	f	class:fst::IntervalReachVisitor
InitVisit	topsort.h	/^  void InitVisit(const Fst<A> &fst) {$/;"	f	class:fst::TopOrderVisitor
InitVisit	visit.h	/^  void InitVisit(const Fst<A> &ifst) { nvisit_ = 0; }$/;"	f	class:fst::PartialVisitor
InitVisit	visit.h	/^  void InitVisit(const Fst<A> &ifst) {$/;"	f	class:fst::CopyVisitor
Initialize	minimize.h	/^  void Initialize(const Fst<A>& fst) {$/;"	f	class:fst::AcyclicMinimizer
Initialize	minimize.h	/^  void Initialize(const Fst<A>& fst) {$/;"	f	class:fst::CyclicMinimizer
Initialize	partition.h	/^  void Initialize(size_t num_states) {$/;"	f	class:fst::Partition
InputEpsilonArcFilter	arcfilter.h	/^class InputEpsilonArcFilter {$/;"	c	namespace:fst
InputSymbols	encode.h	/^  SymbolTable *InputSymbols() const { return isymbols_; }$/;"	f	class:fst::EncodeTable
InputSymbols	encode.h	/^  SymbolTable *InputSymbols() const { return table_->InputSymbols(); }$/;"	f	class:fst::EncodeMapper
InputSymbols	fst.h	/^  SymbolTable* InputSymbols() { return isymbols_; }$/;"	f	class:fst::FstImpl
InputSymbols	fst.h	/^  const SymbolTable* InputSymbols() const { return isymbols_; }$/;"	f	class:fst::FstImpl
InputSymbols	fst.h	/^  virtual const SymbolTable* InputSymbols() const {$/;"	f	class:fst::ImplToFst
InputSymbols	mutable-fst.h	/^  virtual const SymbolTable* InputSymbols() const {$/;"	f	class:fst::ImplToMutableFst
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::WeightConvertMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::FromGallicMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::GallicToNewSymbolsMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::IdentityArcMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::InvertWeightMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::PlusMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::QuantizeMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::ReverseWeightMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::RmWeightMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::SuperFinalMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::TimesMapper
InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::ToGallicMapper
InputSymbolsAction	arcsort.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcSortMapper
InputSymbolsAction	encode.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_CLEAR_SYMBOLS; }$/;"	f	class:fst::EncodeMapper
InputSymbolsAction	invert.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_CLEAR_SYMBOLS; }$/;"	f	struct:fst::InvertMapper
InputSymbolsAction	map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::IdentityMapper
InputSymbolsAction	project.h	/^  MapSymbolsAction InputSymbolsAction() const {$/;"	f	class:fst::ProjectMapper
InputSymbolsAction	state-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcSumMapper
InputSymbolsAction	state-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcUniqueMapper
InputSymbolsAction	state-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::IdentityStateMapper
Insert	heap.h	/^  int Insert(const T& val) {$/;"	f	class:fst::Heap
Insert	heap.h	/^  int Insert(const T& val, int i) {$/;"	f	class:fst::Heap
Insert	util.h	/^  void Insert(Key key) {$/;"	f	class:fst::CompactSet
IntFilterState	compose-filter.h	/^typedef IntegerFilterState<int> IntFilterState;$/;"	t	namespace:fst
IntFilterState	fst-decl.h	/^typedef IntegerFilterState<int> IntFilterState;$/;"	t	namespace:fst
IntegerFilterState	compose-filter.h	/^  IntegerFilterState() : state_(kNoStateId) {}$/;"	f	class:fst::IntegerFilterState
IntegerFilterState	compose-filter.h	/^  explicit IntegerFilterState(T s) : state_(s) {}$/;"	f	class:fst::IntegerFilterState
IntegerFilterState	compose-filter.h	/^class IntegerFilterState {$/;"	c	namespace:fst
Intersect	intersect.h	/^void Intersect(const Fst<Arc> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
Intersect	interval-set.h	/^void IntervalSet<T>::Intersect(const IntervalSet<T> &iset,$/;"	f	class:fst::IntervalSet
IntersectFst	intersect.h	/^  IntersectFst(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::IntersectFst
IntersectFst	intersect.h	/^  IntersectFst(const IntersectFst<A> &fst, bool safe = false) :$/;"	f	class:fst::IntersectFst
IntersectFst	intersect.h	/^class IntersectFst : public ComposeFst<A> {$/;"	c	namespace:fst
IntersectFstOptions	intersect.h	/^  IntersectFstOptions() {}$/;"	f	struct:fst::IntersectFstOptions
IntersectFstOptions	intersect.h	/^  explicit IntersectFstOptions(const CacheOptions &opts,$/;"	f	struct:fst::IntersectFstOptions
IntersectFstOptions	intersect.h	/^struct IntersectFstOptions : public ComposeFstOptions<A, M, F, T> {$/;"	s	namespace:fst
IntersectOptions	intersect.h	/^typedef ComposeOptions IntersectOptions;$/;"	t	namespace:fst
Interval	interval-set.h	/^    Interval() : begin(-1), end(-1) {}$/;"	f	struct:fst::IntervalSet::Interval
Interval	interval-set.h	/^    Interval(T b, T e) : begin(b), end(e) {}$/;"	f	struct:fst::IntervalSet::Interval
Interval	interval-set.h	/^  struct Interval {$/;"	s	class:fst::IntervalSet
Interval	label-reachable.h	/^  typedef typename IntervalSet<L>::Interval Interval;$/;"	t	class:fst::LabelReachableData
Interval	label-reachable.h	/^  typedef typename IntervalSet<Label>::Interval Interval;$/;"	t	class:fst::LabelReachable
Interval	state-reachable.h	/^  typedef typename IntervalSet<I>::Interval Interval;$/;"	t	class:fst::IntervalReachVisitor
Interval	state-reachable.h	/^  typedef typename IntervalSet<I>::Interval Interval;$/;"	t	class:fst::StateReachable
IntervalReachVisitor	state-reachable.h	/^  IntervalReachVisitor(const Fst<A> &fst,$/;"	f	class:fst::IntervalReachVisitor
IntervalReachVisitor	state-reachable.h	/^class IntervalReachVisitor {$/;"	c	namespace:fst
IntervalSet	interval-set.h	/^  IntervalSet() : count_(-1) {}$/;"	f	class:fst::IntervalSet
IntervalSet	interval-set.h	/^class IntervalSet {$/;"	c	namespace:fst
IntervalSets	label-reachable.h	/^  vector< IntervalSet<L> > *IntervalSets() { return &isets_; }$/;"	f	class:fst::LabelReachableData
IntervalSets	state-reachable.h	/^  const vector< IntervalSet<I> > &IntervalSets() { return isets_; }$/;"	f	class:fst::StateReachable
Intervals	interval-set.h	/^  const vector<Interval> *Intervals() const { return &intervals_; }$/;"	f	class:fst::IntervalSet
Intervals	interval-set.h	/^  vector<Interval> *Intervals() { return &intervals_; }$/;"	f	class:fst::IntervalSet
Invert	invert.h	/^void Invert(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
InvertFst	invert.h	/^  InvertFst(const InvertFst<A> &fst, bool safe = false)$/;"	f	class:fst::InvertFst
InvertFst	invert.h	/^  explicit InvertFst(const Fst<A> &fst) : ArcMapFst<A, A, C>(fst, C()) {$/;"	f	class:fst::InvertFst
InvertFst	invert.h	/^class InvertFst : public ArcMapFst<A, A, InvertMapper<A> > {$/;"	c	namespace:fst
InvertMapper	invert.h	/^  InvertMapper() {}$/;"	f	struct:fst::InvertMapper
InvertMapper	invert.h	/^template <class A> struct InvertMapper {$/;"	s	namespace:fst
InvertWeightMapper	arc-map.h	/^struct InvertWeightMapper {$/;"	s	namespace:fst
IsFinal	equivalent.h	/^  static bool IsFinal(const Fst<Arc> &fa, MappedId s) {$/;"	f	struct:fst::EquivalenceUtil
IsMultiEps	matcher.h	/^  bool IsMultiEps(const set<Label> &multi_eps_labels, Label label) const {$/;"	f	class:fst::MultiEpsMatcher
IsNonTerminal	replace.h	/^  bool IsNonTerminal(Label l) const {$/;"	f	class:fst::ReplaceFstImpl
Key	generic-register.h	/^  typedef KeyType Key;$/;"	t	class:fst::GenericRegister
Key	generic-register.h	/^  typedef typename RegisterType::Key Key;$/;"	t	class:fst::GenericRegisterer
Key2Entry	bi-table.h	/^  const T &Key2Entry(I k) const {$/;"	f	class:fst::VectorHashBiTable
Key2T	bi-table.h	/^  const T &Key2T(I k) const {$/;"	f	class:fst::CompactHashBiTable
KeyHashSet	bi-table.h	/^  typedef unordered_set<I, HashFunc, HashEqual> KeyHashSet;$/;"	t	class:fst::CompactHashBiTable
KeyHashSet	bi-table.h	/^  typedef unordered_set<I, HashFunc, HashEqual> KeyHashSet;$/;"	t	class:fst::VectorHashBiTable
KnownProperties	test-properties.h	/^inline uint64 KnownProperties(uint64 props) {$/;"	f	namespace:fst
LBase	lookahead-matcher.h	/^  typedef LookAheadMatcherBase<Arc> LBase;$/;"	t	class:fst::LookAheadMatcher
LF	lookahead-filter.h	/^  typedef LookAheadComposeFilter<SF, M>  LF;$/;"	t	class:fst::DefaultLookAhead
LF	lookahead-filter.h	/^  typedef LookAheadComposeFilter<SF, M> LF;$/;"	t	class:fst::DefaultLookAhead
LIFO_QUEUE	queue.h	/^  LIFO_QUEUE = 2,            \/\/ Last-in, first-out queue$/;"	e	enum:fst::QueueType
LOG	log.h	50;"	d
L_	minimize.h	/^  Queue L_;$/;"	m	class:fst::CyclicMinimizer
Label	accumulator.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ReplaceAccumulator
Label	accumulator.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ReplaceAccumulatorData
Label	add-on.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::AddOnImpl
Label	arc-map.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::FromGallicMapper
Label	arc-map.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::GallicToNewSymbolsMapper
Label	arc.h	/^  typedef int Label;$/;"	t	class:fst::ArcTpl
Label	arc.h	/^  typedef int Label;$/;"	t	class:fst::StringArc
Label	arc.h	/^  typedef int Label;$/;"	t	struct:fst::LexicographicArc
Label	arc.h	/^  typedef int Label;$/;"	t	struct:fst::ProductArc
Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::ExpectationArc
Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::GallicArc
Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::PowerArc
Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::ReverseArc
Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::SparsePowerArc
Label	arcfilter.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::MultiLabelArcFilter
Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::AcceptorCompactor
Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StringCompactor
Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::UnweightedAcceptorCompactor
Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::UnweightedCompactor
Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::WeightedStringCompactor
Label	complement.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ArcIterator
Label	complement.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ComplementFst
Label	complement.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ComplementFstImpl
Label	complement.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StateIterator
Label	compose-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::AltSequenceComposeFilter
Label	compose-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::MatchComposeFilter
Label	compose-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::MultiEpsFilter
Label	compose-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::SequenceComposeFilter
Label	compose.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ComposeFstImplBase
Label	compose.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ComposeFstImpl
Label	determinize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DeterminizeFsaImpl
Label	determinize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DeterminizeFst
Label	determinize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DeterminizeFstImpl
Label	determinize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DeterminizeFstImplBase
Label	determinize.h	/^  typedef typename Arc::Label Label;$/;"	t	struct:fst::DeterminizeFstOptions
Label	determinize.h	/^  typedef typename Arc::Label Label;$/;"	t	struct:fst::DeterminizeOptions
Label	encode.h	/^  typedef typename A::Label  Label;$/;"	t	class:fst::EncodeMapper
Label	encode.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::EncodeTable
Label	factor-weight.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::FactorWeightFstImpl
Label	factor-weight.h	/^  typedef typename Arc::Label Label;$/;"	t	struct:fst::FactorWeightOptions
Label	label-reachable.h	/^  typedef L Label;$/;"	t	class:fst::LabelReachableData
Label	label-reachable.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::LabelReachable
Label	lookahead-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LookAheadComposeFilter
Label	lookahead-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::PushLabelsComposeFilter
Label	lookahead-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::PushWeightsComposeFilter
Label	lookahead-matcher.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::LabelLookAheadRelabeler
Label	lookahead-matcher.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::LookAheadMatcherBase
Label	lookahead-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ArcLookAheadMatcher
Label	lookahead-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LabelLookAheadMatcher
Label	lookahead-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LookAheadMatcher
Label	lookahead-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::TrivialLookAheadMatcher
Label	matcher-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LookAheadMatcher
Label	matcher-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::Matcher
Label	matcher.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::MatcherBase
Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::Matcher
Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::MultiEpsMatcher
Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::PhiMatcher
Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::RhoMatcher
Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::SigmaMatcher
Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::SortedMatcher
Label	minimize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::AcyclicMinimizer
Label	minimize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::CyclicMinimizer
Label	randgen.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::RandGenFst
Label	randgen.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::RandGenFstImpl
Label	rational.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::RationalFstImpl
Label	relabel.h	/^  typedef typename A::Label   Label;$/;"	t	class:fst::RelabelFst
Label	relabel.h	/^  typedef typename A::Label   Label;$/;"	t	class:fst::RelabelFstImpl
Label	replace-util.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ReplaceUtil
Label	replace.h	/^  typedef typename A::Label   Label;$/;"	t	class:fst::ReplaceFst
Label	replace.h	/^  typedef typename A::Label   Label;$/;"	t	class:fst::ReplaceFstImpl
Label	replace.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DefaultReplaceStateTable
Label	replace.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ReplaceFstMatcher
Label	replace.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::VectorHashReplaceStateTable
Label	rmepsilon.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::RmEpsilonFstImpl
Label	rmepsilon.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::RmEpsilonState
Label	state-reachable.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::IntervalReachVisitor
Label	state-reachable.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StateReachable
Label	string-weight.h	/^  typedef L Label;$/;"	t	class:fst::StringWeight
Label	string.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StringCompiler
Label	string.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StringPrinter
Label	synchronize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::SynchronizeFstImpl
Label2Index	label-reachable.h	/^  const unordered_map<Label, Label>& Label2Index() const {$/;"	f	class:fst::LabelReachable
Label2Index	label-reachable.h	/^  unordered_map<L, L> *Label2Index() {$/;"	f	class:fst::LabelReachableData
LabelCommonDivisor	determinize.h	/^class LabelCommonDivisor {$/;"	c	namespace:fst
LabelLookAheadMatcher	lookahead-matcher.h	/^  LabelLookAheadMatcher(const FST &fst, MatchType match_type,$/;"	f	class:fst::LabelLookAheadMatcher
LabelLookAheadMatcher	lookahead-matcher.h	/^  LabelLookAheadMatcher(const LabelLookAheadMatcher<M, F, S> &lmatcher,$/;"	f	class:fst::LabelLookAheadMatcher
LabelLookAheadMatcher	lookahead-matcher.h	/^class LabelLookAheadMatcher$/;"	c	namespace:fst
LabelLookAheadRelabeler	lookahead-matcher.h	/^LabelLookAheadRelabeler<A>::LabelLookAheadRelabeler(I **impl) {$/;"	f	class:fst::LabelLookAheadRelabeler
LabelLookAheadRelabeler	lookahead-matcher.h	/^class LabelLookAheadRelabeler {$/;"	c	namespace:fst
LabelMap	determinize.h	/^  typedef map<Label, Subset*> LabelMap;$/;"	t	class:fst::DeterminizeFsaImpl
LabelReachable	label-reachable.h	/^  LabelReachable(const Fst<A> &fst, bool reach_input, S *s = 0,$/;"	f	class:fst::LabelReachable
LabelReachable	label-reachable.h	/^  LabelReachable(const LabelReachable<A, S> &reachable) :$/;"	f	class:fst::LabelReachable
LabelReachable	label-reachable.h	/^  explicit LabelReachable(LabelReachableData<Label> *data, S *s = 0)$/;"	f	class:fst::LabelReachable
LabelReachable	label-reachable.h	/^class LabelReachable {$/;"	c	namespace:fst
LabelReachableData	label-reachable.h	/^  LabelReachableData() {}$/;"	f	class:fst::LabelReachableData
LabelReachableData	label-reachable.h	/^  explicit LabelReachableData(bool reach_input, bool keep_relabel_data = true)$/;"	f	class:fst::LabelReachableData
LabelReachableData	label-reachable.h	/^class LabelReachableData {$/;"	c	namespace:fst
LabelSubsets	determinize.h	/^  void LabelSubsets(StateId s, LabelMap *label_map) {$/;"	f	class:fst::DeterminizeFsaImpl
LabeledCheckSum	symbol-table.h	/^  string LabeledCheckSum() const {$/;"	f	class:fst::SymbolTableImpl
LabeledCheckSum	symbol-table.h	/^  virtual string LabeledCheckSum() const {$/;"	f	class:fst::SymbolTable
LabelsToUTF8String	icu.h	/^bool LabelsToUTF8String(const vector<Label> &labels, string *str) {$/;"	f	namespace:fst
Left	heap.h	/^  int Left(int i) {$/;"	f	class:fst::Heap
Length	tuple-weight.h	/^  static unsigned int Length() {$/;"	f	class:fst::TupleWeight
Less	queue.h	/^  typedef L Less;$/;"	t	class:fst::AStarWeightCompare
Less	queue.h	/^  typedef L Less;$/;"	t	class:fst::StateWeightCompare
LexicographicArc	arc.h	/^  LexicographicArc() {}$/;"	f	struct:fst::LexicographicArc
LexicographicArc	arc.h	/^  LexicographicArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::LexicographicArc
LexicographicArc	arc.h	/^struct LexicographicArc {$/;"	s	namespace:fst
LexicographicWeight	lexicographic-weight.h	/^  LexicographicWeight() {}$/;"	f	class:fst::LexicographicWeight
LexicographicWeight	lexicographic-weight.h	/^  LexicographicWeight(W1 w1, W2 w2) : PairWeight<W1, W2>(w1, w2) {$/;"	f	class:fst::LexicographicWeight
LexicographicWeight	lexicographic-weight.h	/^  LexicographicWeight(const PairWeight<W1, W2>& w)$/;"	f	class:fst::LexicographicWeight
LexicographicWeight	lexicographic-weight.h	/^class LexicographicWeight : public PairWeight<W1, W2> {$/;"	c	namespace:fst
LexicographicWeightGenerator	random-weight.h	/^  LexicographicWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::LexicographicWeightGenerator
LexicographicWeightGenerator	random-weight.h	/^class LexicographicWeightGenerator {$/;"	c	namespace:fst
LifoQueue	queue.h	/^  LifoQueue() : QueueBase<S>(LIFO_QUEUE) {}$/;"	f	class:fst::LifoQueue
LifoQueue	queue.h	/^class LifoQueue : public QueueBase<S>, public deque<S> {$/;"	c	namespace:fst
Link	union-find.h	/^  void Link(T x, T y) {$/;"	f	class:fst::UnionFind
LoadEntryFromSharedObject	generic-register.h	/^  virtual EntryType LoadEntryFromSharedObject(const KeyType &key) const {$/;"	f	class:fst::GenericRegister
LocalMatcher	replace.h	/^  typedef MultiEpsMatcher<Matcher<Fst<A> > > LocalMatcher;$/;"	t	class:fst::ReplaceFstMatcher
Log64Arc	arc.h	/^typedef ArcTpl<Log64Weight> Log64Arc;$/;"	t	namespace:fst
Log64ToLogMapper	arc-map.h	/^typedef WeightConvertMapper<Log64Arc, LogArc> Log64ToLogMapper;$/;"	t	namespace:fst
Log64ToStdMapper	arc-map.h	/^typedef WeightConvertMapper<Log64Arc, StdArc> Log64ToStdMapper;$/;"	t	namespace:fst
Log64Weight	float-weight.h	/^typedef LogWeightTpl<double> Log64Weight;$/;"	t	namespace:fst
LogAccumulator	accumulator.h	/^  LogAccumulator() {}$/;"	f	class:fst::LogAccumulator
LogAccumulator	accumulator.h	/^  LogAccumulator(const LogAccumulator<A> &acc) {}$/;"	f	class:fst::LogAccumulator
LogAccumulator	accumulator.h	/^class LogAccumulator {$/;"	c	namespace:fst
LogArc	arc.h	/^typedef ArcTpl<LogWeight> LogArc;$/;"	t	namespace:fst
LogArc	fst-decl.h	/^typedef ArcTpl<LogWeight> LogArc;$/;"	t	namespace:fst
LogArcLookAheadFst	matcher-fst.h	/^                   arc_lookahead_fst_type> LogArcLookAheadFst;$/;"	t	namespace:fst
LogArcSelector	randgen.h	/^typedef LogProbArcSelector<LogArc> LogArcSelector;$/;"	t	namespace:fst
LogExp	float-weight.h	/^inline T LogExp(T x) { return log(1.0F + exp(-x)); }$/;"	f	namespace:fst
LogILabelLookAheadFst	matcher-fst.h	/^                   LabelLookAheadRelabeler<LogArc> > LogILabelLookAheadFst;$/;"	t	namespace:fst
LogMessage	log.h	/^  LogMessage(const string &type) : fatal_(type == "FATAL") {$/;"	f	class:LogMessage
LogMessage	log.h	/^class LogMessage {$/;"	c
LogMessage::LogMessage	log.h	/^  LogMessage(const string &type) : fatal_(type == "FATAL") {$/;"	f	class:LogMessage
LogMessage::fatal_	log.h	/^  bool fatal_;$/;"	m	class:LogMessage
LogMessage::stream	log.h	/^  std::ostream &stream() { return std::cerr; }$/;"	f	class:LogMessage
LogMessage::~LogMessage	log.h	/^  ~LogMessage() {$/;"	f	class:LogMessage
LogMinus	accumulator.h	/^  Weight LogMinus(double f1, double f2) {$/;"	f	class:fst::CacheLogAccumulator
LogMinus	accumulator.h	/^  Weight LogMinus(double f1, double f2) {$/;"	f	class:fst::FastLogAccumulator
LogMinusExp	accumulator.h	/^  double LogMinusExp(double x) {$/;"	f	class:fst::CacheLogAccumulator
LogMinusExp	accumulator.h	/^  double LogMinusExp(double x) {$/;"	f	class:fst::FastLogAccumulator
LogOLabelLookAheadFst	matcher-fst.h	/^                   LabelLookAheadRelabeler<LogArc> > LogOLabelLookAheadFst;$/;"	t	namespace:fst
LogPlus	accumulator.h	/^  Weight LogPlus(Weight w, Weight v) {$/;"	f	class:fst::CacheLogAccumulator
LogPlus	accumulator.h	/^  Weight LogPlus(Weight w, Weight v) {$/;"	f	class:fst::FastLogAccumulator
LogPlus	accumulator.h	/^  Weight LogPlus(Weight w, Weight v) {$/;"	f	class:fst::LogAccumulator
LogPlus	accumulator.h	/^  double LogPlus(double f1, Weight v) {$/;"	f	class:fst::CacheLogAccumulator
LogPlus	accumulator.h	/^  double LogPlus(double f1, Weight v) {$/;"	f	class:fst::FastLogAccumulator
LogPosExp	accumulator.h	/^  double LogPosExp(double x) { return log(1.0F + exp(-x)); }$/;"	f	class:fst::LogAccumulator
LogPosExp	accumulator.h	/^  double LogPosExp(double x) {$/;"	f	class:fst::CacheLogAccumulator
LogPosExp	accumulator.h	/^  double LogPosExp(double x) {$/;"	f	class:fst::FastLogAccumulator
LogProbArcSelector	randgen.h	/^  LogProbArcSelector(int seed = time(0)) { srand(seed); }$/;"	f	class:fst::LogProbArcSelector
LogProbArcSelector	randgen.h	/^class LogProbArcSelector {$/;"	c	namespace:fst
LogToLog64Mapper	arc-map.h	/^typedef WeightConvertMapper<LogArc, Log64Arc> LogToLog64Mapper;$/;"	t	namespace:fst
LogToStdMapper	arc-map.h	/^typedef WeightConvertMapper<LogArc, StdArc> LogToStdMapper;$/;"	t	namespace:fst
LogWeight	float-weight.h	/^typedef LogWeightTpl<float> LogWeight;$/;"	t	namespace:fst
LogWeight	fst-decl.h	/^typedef LogWeightTpl<float> LogWeight;$/;"	t	namespace:fst
LogWeightGenerator	random-weight.h	/^typedef LogWeightGenerator_<float> LogWeightGenerator;$/;"	t	namespace:fst
LogWeightGenerator_	random-weight.h	/^  LogWeightGenerator_(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::LogWeightGenerator_
LogWeightGenerator_	random-weight.h	/^class LogWeightGenerator_ {$/;"	c	namespace:fst
LogWeightTpl	float-weight.h	/^  LogWeightTpl() : FloatWeightTpl<T>() {}$/;"	f	class:fst::LogWeightTpl
LogWeightTpl	float-weight.h	/^  LogWeightTpl(T f) : FloatWeightTpl<T>(f) {}$/;"	f	class:fst::LogWeightTpl
LogWeightTpl	float-weight.h	/^  LogWeightTpl(const LogWeightTpl<T> &w) : FloatWeightTpl<T>(w) {}$/;"	f	class:fst::LogWeightTpl
LogWeightTpl	float-weight.h	/^class LogWeightTpl : public FloatWeightTpl<T> {$/;"	c	namespace:fst
LookAheadArc	lookahead-filter.h	/^  bool LookAheadArc() const { return filter_.LookAheadArc(); }$/;"	f	class:fst::PushLabelsComposeFilter
LookAheadArc	lookahead-filter.h	/^  bool LookAheadArc() const { return filter_.LookAheadArc(); }$/;"	f	class:fst::PushWeightsComposeFilter
LookAheadArc	lookahead-filter.h	/^  bool LookAheadArc() const { return lookahead_arc_; }$/;"	f	class:fst::LookAheadComposeFilter
LookAheadCheck	lookahead-matcher.h	/^  bool LookAheadCheck() const {$/;"	f	class:fst::LookAheadMatcher
LookAheadComposeFilter	lookahead-filter.h	/^  LookAheadComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::LookAheadComposeFilter
LookAheadComposeFilter	lookahead-filter.h	/^  LookAheadComposeFilter(const LookAheadComposeFilter<F, M1, M2, MT> &filter,$/;"	f	class:fst::LookAheadComposeFilter
LookAheadComposeFilter	lookahead-filter.h	/^class LookAheadComposeFilter {$/;"	c	namespace:fst
LookAheadFilterArc	lookahead-filter.h	/^  FilterState LookAheadFilterArc(Arc *arca, Arc *arcb,$/;"	f	class:fst::LookAheadComposeFilter
LookAheadFlags	lookahead-filter.h	/^  uint32 LookAheadFlags() const { return filter_.LookAheadFlags(); }$/;"	f	class:fst::PushLabelsComposeFilter
LookAheadFlags	lookahead-filter.h	/^  uint32 LookAheadFlags() const { return filter_.LookAheadFlags(); }$/;"	f	class:fst::PushWeightsComposeFilter
LookAheadFlags	lookahead-filter.h	/^  uint32 LookAheadFlags() const { return flags_; }$/;"	f	class:fst::LookAheadComposeFilter
LookAheadFst	lookahead-matcher.h	/^  bool LookAheadFst(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::LookAheadMatcher
LookAheadFst	lookahead-matcher.h	/^  bool LookAheadFst(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::LookAheadMatcherBase
LookAheadFst	lookahead-matcher.h	/^  bool LookAheadFst(const Fst<Arc> &fst, StateId s) {return true; }$/;"	f	class:fst::TrivialLookAheadMatcher
LookAheadFst	lookahead-matcher.h	/^bool ArcLookAheadMatcher<M, F>::LookAheadFst(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::ArcLookAheadMatcher
LookAheadFst	lookahead-matcher.h	/^bool LabelLookAheadMatcher<M, F, S>::LookAheadFst(const L &fst, StateId s) {$/;"	f	class:fst::LabelLookAheadMatcher
LookAheadFst	matcher-fst.h	/^  bool LookAheadFst(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::LookAheadMatcher
LookAheadFst_	lookahead-matcher.h	/^  bool LookAheadFst_(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::ArcLookAheadMatcher
LookAheadFst_	lookahead-matcher.h	/^  bool LookAheadFst_(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::LabelLookAheadMatcher
LookAheadFst_	lookahead-matcher.h	/^  bool LookAheadFst_(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::TrivialLookAheadMatcher
LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const { return LookAheadLabel_(label); }$/;"	f	class:fst::LookAheadMatcherBase
LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const { return matcher_.Find(label); }$/;"	f	class:fst::ArcLookAheadMatcher
LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const { return true;  }$/;"	f	class:fst::TrivialLookAheadMatcher
LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const {$/;"	f	class:fst::LabelLookAheadMatcher
LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const {$/;"	f	class:fst::LookAheadMatcher
LookAheadLabel	matcher-fst.h	/^  bool LookAheadLabel(Label label) const {$/;"	f	class:fst::LookAheadMatcher
LookAheadLabel_	lookahead-matcher.h	/^  bool LookAheadLabel_(Label l) const { return LookAheadLabel(l); }$/;"	f	class:fst::ArcLookAheadMatcher
LookAheadLabel_	lookahead-matcher.h	/^  bool LookAheadLabel_(Label l) const { return LookAheadLabel(l); }$/;"	f	class:fst::LabelLookAheadMatcher
LookAheadLabel_	lookahead-matcher.h	/^  bool LookAheadLabel_(Label l) const { return LookAheadLabel(l); }$/;"	f	class:fst::TrivialLookAheadMatcher
LookAheadMatchType	lookahead-filter.h	/^MatchType LookAheadMatchType(const Fst<Arc> &fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
LookAheadMatchType	lookahead-filter.h	/^MatchType LookAheadMatchType(const M1 &m1, const M2 &m2) {$/;"	f	namespace:fst
LookAheadMatcher	lookahead-matcher.h	/^  LookAheadMatcher(const F &fst, MatchType match_type) {$/;"	f	class:fst::LookAheadMatcher
LookAheadMatcher	lookahead-matcher.h	/^  LookAheadMatcher(const LookAheadMatcher<F> &matcher, bool safe = false) {$/;"	f	class:fst::LookAheadMatcher
LookAheadMatcher	lookahead-matcher.h	/^class LookAheadMatcher {$/;"	c	namespace:fst
LookAheadMatcher	matcher-fst.h	/^  LookAheadMatcher(const FST &fst, MatchType match_type) {$/;"	f	class:fst::LookAheadMatcher
LookAheadMatcher	matcher-fst.h	/^  LookAheadMatcher(const LookAheadMatcher<FST> &matcher, bool safe = false) {$/;"	f	class:fst::LookAheadMatcher
LookAheadMatcher	matcher-fst.h	/^class LookAheadMatcher< MatcherFst<F, M, N, I> > {$/;"	c	namespace:fst
LookAheadMatcherBase	lookahead-matcher.h	/^  LookAheadMatcherBase()$/;"	f	class:fst::LookAheadMatcherBase
LookAheadMatcherBase	lookahead-matcher.h	/^class LookAheadMatcherBase : public MatcherBase<A> {$/;"	c	namespace:fst
LookAheadOutput	lookahead-filter.h	/^  bool LookAheadOutput() const { return filter_.LookAheadOutput(); }$/;"	f	class:fst::PushLabelsComposeFilter
LookAheadOutput	lookahead-filter.h	/^  bool LookAheadOutput() const { return filter_.LookAheadOutput(); }$/;"	f	class:fst::PushWeightsComposeFilter
LookAheadOutput	lookahead-filter.h	/^  bool LookAheadOutput() const {$/;"	f	class:fst::LookAheadComposeFilter
LookAheadPrefix	lookahead-matcher.h	/^  bool LookAheadPrefix(Arc *arc) const { return false; }$/;"	f	class:fst::TrivialLookAheadMatcher
LookAheadPrefix	lookahead-matcher.h	/^  bool LookAheadPrefix(Arc *arc) const {$/;"	f	class:fst::LookAheadMatcher
LookAheadPrefix	lookahead-matcher.h	/^  bool LookAheadPrefix(Arc *arc) const {$/;"	f	class:fst::LookAheadMatcherBase
LookAheadPrefix	matcher-fst.h	/^  bool LookAheadPrefix(Arc *arc) const {$/;"	f	class:fst::LookAheadMatcher
LookAheadPrefix_	lookahead-matcher.h	/^  bool LookAheadPrefix_(Arc *arc) const { return LookAheadPrefix(arc); }$/;"	f	class:fst::TrivialLookAheadMatcher
LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(M *lmatcher1, M *lmatcher2, MatchType type)$/;"	f	class:fst::LookAheadSelector
LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(M1 *lmatcher1, M2 *lmatcher2, MatchType)$/;"	f	class:fst::LookAheadSelector
LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(const LookAheadSelector<M, M, MT> &selector)$/;"	f	class:fst::LookAheadSelector
LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(const LookAheadSelector<M1, M2, MATCH_INPUT> &selector)$/;"	f	class:fst::LookAheadSelector
LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(const LookAheadSelector<M1, M2, MATCH_OUTPUT> &selector)$/;"	f	class:fst::LookAheadSelector
LookAheadSelector	lookahead-filter.h	/^class LookAheadSelector {$/;"	c	namespace:fst
LookAheadSelector	lookahead-filter.h	/^class LookAheadSelector<M, M, MT> {$/;"	c	namespace:fst
LookAheadSelector	lookahead-filter.h	/^class LookAheadSelector<M1, M2, MATCH_INPUT> {$/;"	c	namespace:fst
LookAheadSelector	lookahead-filter.h	/^class LookAheadSelector<M1, M2, MATCH_OUTPUT> {$/;"	c	namespace:fst
LookAheadWeight	lookahead-matcher.h	/^  Weight LookAheadWeight() const { return Weight::One(); }$/;"	f	class:fst::TrivialLookAheadMatcher
LookAheadWeight	lookahead-matcher.h	/^  Weight LookAheadWeight() const { return weight_; }$/;"	f	class:fst::LookAheadMatcherBase
LookAheadWeight	lookahead-matcher.h	/^  Weight LookAheadWeight() const {$/;"	f	class:fst::LookAheadMatcher
LookAheadWeight	matcher-fst.h	/^  Weight LookAheadWeight() const { return matcher_->LookAheadWeight(); }$/;"	f	class:fst::LookAheadMatcher
LookAheadWeight_	lookahead-matcher.h	/^  Weight LookAheadWeight_() const { return LookAheadWeight(); }$/;"	f	class:fst::TrivialLookAheadMatcher
LookupEntry	generic-register.h	/^  virtual const EntryType *LookupEntry($/;"	f	class:fst::GenericRegister
LowerBound	accumulator.h	/^  size_t LowerBound(double w, Iterator *aiter) {$/;"	f	class:fst::CacheLogAccumulator
LowerBound	label-reachable.h	/^  ssize_t LowerBound(Iterator *aiter, ssize_t aiter_begin,$/;"	f	class:fst::LabelReachable
M	arcsort.h	/^ typedef ArcSortMapper<A, C> M;$/;"	t	class:fst::ArcSortFst
M	lookahead-filter.h	/^  typedef LookAheadMatcher< Fst<A> > M;$/;"	t	class:fst::DefaultLookAhead
M	lookahead-filter.h	/^  typedef Matcher< Fst<A> > M;$/;"	t	class:fst::DefaultLookAhead
MAP_ALLOW_SUPERFINAL	arc-map.h	/^  MAP_ALLOW_SUPERFINAL,$/;"	e	enum:fst::MapFinalAction
MAP_CLEAR_SYMBOLS	arc-map.h	/^  MAP_CLEAR_SYMBOLS,$/;"	e	enum:fst::MapSymbolsAction
MAP_COPY_SYMBOLS	arc-map.h	/^  MAP_COPY_SYMBOLS,$/;"	e	enum:fst::MapSymbolsAction
MAP_NOOP_SYMBOLS	arc-map.h	/^  MAP_NOOP_SYMBOLS$/;"	e	enum:fst::MapSymbolsAction
MAP_NO_SUPERFINAL	arc-map.h	/^  MAP_NO_SUPERFINAL,$/;"	e	enum:fst::MapFinalAction
MAP_REQUIRE_SUPERFINAL	arc-map.h	/^  MAP_REQUIRE_SUPERFINAL$/;"	e	enum:fst::MapFinalAction
MATCHER_REWRITE_ALWAYS	matcher.h	/^  MATCHER_REWRITE_ALWAYS,$/;"	e	enum:fst::MatcherRewriteMode
MATCHER_REWRITE_AUTO	matcher.h	/^  MATCHER_REWRITE_AUTO = 0,    \/\/ Rewrites both sides iff acceptor.$/;"	e	enum:fst::MatcherRewriteMode
MATCHER_REWRITE_NEVER	matcher.h	/^  MATCHER_REWRITE_NEVER$/;"	e	enum:fst::MatcherRewriteMode
MATCH_BOTH	fst.h	/^                 MATCH_BOTH,       \/\/ Match input or output label.$/;"	e	enum:fst::MatchType
MATCH_FILTER	compose.h	/^                     MATCH_FILTER };$/;"	e	enum:fst::ComposeFilter
MATCH_INPUT	fst.h	/^enum MatchType { MATCH_INPUT,      \/\/ Match input label.$/;"	e	enum:fst::MatchType
MATCH_NONE	fst.h	/^                 MATCH_NONE,       \/\/ Match nothing.$/;"	e	enum:fst::MatchType
MATCH_OUTPUT	fst.h	/^                 MATCH_OUTPUT,     \/\/ Match output label.$/;"	e	enum:fst::MatchType
MATCH_UNKNOWN	fst.h	/^                 MATCH_UNKNOWN };  \/\/ Match type unknown.$/;"	e	enum:fst::MatchType
MakeAllSet	union-find.h	/^  void MakeAllSet(T max) {$/;"	f	class:fst::UnionFind
MakeSet	union-find.h	/^  T MakeSet(T item) {$/;"	f	class:fst::UnionFind
Map	arc-map.h	/^  typedef unordered_map<SW, Label, StringKey> Map;$/;"	t	struct:fst::GallicToNewSymbolsMapper
Map	map.h	/^void Map(MutableFst<A> *fst, C mapper) {$/;"	f	namespace:fst
Map	map.h	/^void Map(MutableFst<A> *fst, C* mapper) {$/;"	f	namespace:fst
Map	map.h	/^void Map(const Fst<A> &ifst, MutableFst<B> *ofst, C mapper) {$/;"	f	namespace:fst
Map	map.h	/^void Map(const Fst<A> &ifst, MutableFst<B> *ofst, C* mapper) {$/;"	f	namespace:fst
Map	sparse-power-weight.h	/^  W Map(const K& k, const W& v1, const W& v2) const {$/;"	f	struct:fst::SparseTupleWeightApproxMapper
Map	sparse-power-weight.h	/^  W Map(const K& k, const W& v1, const W& v2) const {$/;"	f	struct:fst::SparseTupleWeightDivideMapper
Map	sparse-power-weight.h	/^  W Map(const K& k, const W& v1, const W& v2) const {$/;"	f	struct:fst::SparseTupleWeightPlusMapper
Map	sparse-power-weight.h	/^  W Map(const K& k, const W& v1, const W& v2) const {$/;"	f	struct:fst::SparseTupleWeightTimesMapper
MapFinalAction	arc-map.h	/^enum MapFinalAction {$/;"	g	namespace:fst
MapFst	map.h	/^  MapFst(const ArcMapFst<A, B, C> &fst, bool safe = false)$/;"	f	class:fst::MapFst
MapFst	map.h	/^  MapFst(const Fst<A> &fst, C* mapper) : ArcMapFst<A, B, C>(fst, mapper) {}$/;"	f	class:fst::MapFst
MapFst	map.h	/^  MapFst(const Fst<A> &fst, C* mapper, const MapFstOptions& opts)$/;"	f	class:fst::MapFst
MapFst	map.h	/^  MapFst(const Fst<A> &fst, const C &mapper)$/;"	f	class:fst::MapFst
MapFst	map.h	/^  MapFst(const Fst<A> &fst, const C &mapper, const MapFstOptions& opts)$/;"	f	class:fst::MapFst
MapFst	map.h	/^class MapFst : public ArcMapFst<A, B, C> {$/;"	c	namespace:fst
MapFstOptions	map.h	/^typedef ArcMapFstOptions MapFstOptions;$/;"	t	namespace:fst
MapState	equivalent.h	/^  static MappedId MapState(StateId s, int32 which_fst) {$/;"	f	struct:fst::EquivalenceUtil
MapSymbolsAction	arc-map.h	/^enum MapSymbolsAction {$/;"	g	namespace:fst
MappedId	equivalent.h	/^  typedef StateId MappedId;  \/\/ ID for an equivalence class.$/;"	t	struct:fst::EquivalenceUtil
MatchArc	compose.h	/^  void MatchArc(StateId s, Matcher *matchera,$/;"	f	class:fst::ComposeFstImpl
MatchComposeFilter	compose-filter.h	/^  MatchComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::MatchComposeFilter
MatchComposeFilter	compose-filter.h	/^  MatchComposeFilter(const MatchComposeFilter<M1, M2> &filter,$/;"	f	class:fst::MatchComposeFilter
MatchComposeFilter	compose-filter.h	/^class MatchComposeFilter {$/;"	c	namespace:fst
MatchType	fst.h	/^enum MatchType { MATCH_INPUT,      \/\/ Match input label.$/;"	g	namespace:fst
Matcher	matcher-fst.h	/^  Matcher(const FST &fst, MatchType match_type) {$/;"	f	class:fst::Matcher
Matcher	matcher-fst.h	/^  Matcher(const Matcher<FST> &matcher) {$/;"	f	class:fst::Matcher
Matcher	matcher-fst.h	/^class Matcher< MatcherFst<F, M, N, I> > {$/;"	c	namespace:fst
Matcher	matcher.h	/^  Matcher(MatcherBase<Arc>* base_matcher) { base_ = base_matcher; }$/;"	f	class:fst::Matcher
Matcher	matcher.h	/^  Matcher(const F &fst, MatchType match_type) {$/;"	f	class:fst::Matcher
Matcher	matcher.h	/^  Matcher(const Matcher<F> &matcher, bool safe = false) {$/;"	f	class:fst::Matcher
Matcher	matcher.h	/^class Matcher {$/;"	c	namespace:fst
Matcher1	compose-filter.h	/^  typedef M1 Matcher1;$/;"	t	class:fst::AltSequenceComposeFilter
Matcher1	compose-filter.h	/^  typedef M1 Matcher1;$/;"	t	class:fst::MatchComposeFilter
Matcher1	compose-filter.h	/^  typedef M1 Matcher1;$/;"	t	class:fst::SequenceComposeFilter
Matcher1	compose-filter.h	/^  typedef typename F::Matcher1 Matcher1;$/;"	t	class:fst::MultiEpsFilter
Matcher1	compose.h	/^  typedef typename F::Matcher1 Matcher1;$/;"	t	class:fst::ComposeFstImpl
Matcher1	lookahead-filter.h	/^  typedef MultiEpsMatcher<typename F::Matcher1> Matcher1;$/;"	t	class:fst::PushLabelsComposeFilter
Matcher1	lookahead-filter.h	/^  typedef typename F::Matcher1 Matcher1;$/;"	t	class:fst::LookAheadComposeFilter
Matcher1	lookahead-filter.h	/^  typedef typename F::Matcher1 Matcher1;$/;"	t	class:fst::PushWeightsComposeFilter
Matcher2	compose-filter.h	/^  typedef M2 Matcher2;$/;"	t	class:fst::AltSequenceComposeFilter
Matcher2	compose-filter.h	/^  typedef M2 Matcher2;$/;"	t	class:fst::MatchComposeFilter
Matcher2	compose-filter.h	/^  typedef M2 Matcher2;$/;"	t	class:fst::SequenceComposeFilter
Matcher2	compose-filter.h	/^  typedef typename F::Matcher2 Matcher2;$/;"	t	class:fst::MultiEpsFilter
Matcher2	compose.h	/^  typedef typename F::Matcher2 Matcher2;$/;"	t	class:fst::ComposeFstImpl
Matcher2	lookahead-filter.h	/^  typedef MultiEpsMatcher<typename F::Matcher2> Matcher2;$/;"	t	class:fst::PushLabelsComposeFilter
Matcher2	lookahead-filter.h	/^  typedef typename F::Matcher2 Matcher2;$/;"	t	class:fst::LookAheadComposeFilter
Matcher2	lookahead-filter.h	/^  typedef typename F::Matcher2 Matcher2;$/;"	t	class:fst::PushWeightsComposeFilter
MatcherBase	matcher.h	/^class MatcherBase {$/;"	c	namespace:fst
MatcherData	lookahead-matcher.h	/^  typedef LabelReachableData<Label> MatcherData;$/;"	t	class:fst::LabelLookAheadMatcher
MatcherData	lookahead-matcher.h	/^  typedef LabelReachableData<Label> MatcherData;$/;"	t	class:fst::LabelLookAheadRelabeler
MatcherData	lookahead-matcher.h	/^  typedef NullAddOn MatcherData;$/;"	t	class:fst::ArcLookAheadMatcher
MatcherFst	matcher-fst.h	/^  MatcherFst() : ImplToExpandedFst<Impl>(new Impl(F(), N)) {}$/;"	f	class:fst::MatcherFst
MatcherFst	matcher-fst.h	/^  MatcherFst(const MatcherFst<F, M, N, I> &fst, bool safe = false)$/;"	f	class:fst::MatcherFst
MatcherFst	matcher-fst.h	/^  explicit MatcherFst(Impl *impl) : ImplToExpandedFst<Impl>(impl) {}$/;"	f	class:fst::MatcherFst
MatcherFst	matcher-fst.h	/^  explicit MatcherFst(const F &fst)$/;"	f	class:fst::MatcherFst
MatcherFst	matcher-fst.h	/^  explicit MatcherFst(const Fst<Arc> &fst)$/;"	f	class:fst::MatcherFst
MatcherFst	matcher-fst.h	/^class MatcherFst$/;"	c	namespace:fst
MatcherRewriteMode	matcher.h	/^enum MatcherRewriteMode {$/;"	g	namespace:fst
Member	expectation-weight.h	/^  bool Member() const {$/;"	f	class:fst::ExpectationWeight
Member	float-weight.h	/^  bool Member() const {$/;"	f	class:fst::LogWeightTpl
Member	float-weight.h	/^  bool Member() const {$/;"	f	class:fst::MinMaxWeightTpl
Member	float-weight.h	/^  bool Member() const {$/;"	f	class:fst::TropicalWeightTpl
Member	interval-set.h	/^  bool Member(T value) const {$/;"	f	class:fst::IntervalSet
Member	lexicographic-weight.h	/^  bool Member() const {$/;"	f	class:fst::LexicographicWeight
Member	pair-weight.h	/^  bool Member() const { return value1_.Member() && value2_.Member(); }$/;"	f	class:fst::PairWeight
Member	signed-log-weight.h	/^  bool Member() const {$/;"	f	class:fst::SignedLogWeightTpl
Member	sparse-tuple-weight.h	/^  bool Member() const {$/;"	f	class:fst::SparseTupleWeight
Member	string-weight.h	/^inline bool StringWeight<L, S>::Member() const {$/;"	f	class:fst::StringWeight
Member	tuple-weight.h	/^  bool Member() const {$/;"	f	class:fst::TupleWeight
MergeStates	minimize.h	/^void MergeStates($/;"	f	namespace:fst
MinMaxArc	arc.h	/^typedef ArcTpl<MinMaxWeight> MinMaxArc;$/;"	t	namespace:fst
MinMaxWeight	float-weight.h	/^typedef MinMaxWeightTpl<float> MinMaxWeight;$/;"	t	namespace:fst
MinMaxWeight	fst-decl.h	/^typedef MinMaxWeightTpl<float> MinMaxWeight;$/;"	t	namespace:fst
MinMaxWeightGenerator	random-weight.h	/^typedef MinMaxWeightGenerator_<float> MinMaxWeightGenerator;$/;"	t	namespace:fst
MinMaxWeightGenerator_	random-weight.h	/^  MinMaxWeightGenerator_(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::MinMaxWeightGenerator_
MinMaxWeightGenerator_	random-weight.h	/^class MinMaxWeightGenerator_ {$/;"	c	namespace:fst
MinMaxWeightTpl	float-weight.h	/^  MinMaxWeightTpl() : FloatWeightTpl<T>() {}$/;"	f	class:fst::MinMaxWeightTpl
MinMaxWeightTpl	float-weight.h	/^  MinMaxWeightTpl(T f) : FloatWeightTpl<T>(f) {}$/;"	f	class:fst::MinMaxWeightTpl
MinMaxWeightTpl	float-weight.h	/^  MinMaxWeightTpl(const MinMaxWeightTpl<T> &w) : FloatWeightTpl<T>(w) {}$/;"	f	class:fst::MinMaxWeightTpl
MinMaxWeightTpl	float-weight.h	/^class MinMaxWeightTpl : public FloatWeightTpl<T> {$/;"	c	namespace:fst
MinUnexpandedState	cache.h	/^  StateId MinUnexpandedState() const {$/;"	f	class:fst::CacheBaseImpl
Minimize	minimize.h	/^void Minimize(MutableFst<A>* fst,$/;"	f	namespace:fst
Minus	signed-log-weight.h	/^inline SignedLogWeightTpl<T> Minus(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
Move	partition.h	/^  void Move(T element_id, T class_id) {$/;"	f	class:fst::Partition
MultiEpsFilter	compose-filter.h	/^  MultiEpsFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::MultiEpsFilter
MultiEpsFilter	compose-filter.h	/^  MultiEpsFilter(const Filter &filter, bool safe = false)$/;"	f	class:fst::MultiEpsFilter
MultiEpsFilter	compose-filter.h	/^class MultiEpsFilter {$/;"	c	namespace:fst
MultiEpsMatcher	matcher.h	/^  MultiEpsMatcher(const FST &fst, MatchType match_type,$/;"	f	class:fst::MultiEpsMatcher
MultiEpsMatcher	matcher.h	/^  MultiEpsMatcher(const MultiEpsMatcher<M> &matcher, bool safe = false)$/;"	f	class:fst::MultiEpsMatcher
MultiEpsMatcher	matcher.h	/^class MultiEpsMatcher {$/;"	c	namespace:fst
MultiLabelArcFilter	arcfilter.h	/^  MultiLabelArcFilter(bool match_input = true, bool keep_match = true)$/;"	f	class:fst::MultiLabelArcFilter
MultiLabelArcFilter	arcfilter.h	/^class MultiLabelArcFilter {$/;"	c	namespace:fst
MutableArcIterator	mutable-fst.h	/^  MutableArcIterator(F *fst, StateId s) {$/;"	f	class:fst::MutableArcIterator
MutableArcIterator	mutable-fst.h	/^class MutableArcIterator {$/;"	c	namespace:fst
MutableArcIterator	vector-fst.h	/^  MutableArcIterator(VectorFst<A> *fst, StateId s) : i_(0) {$/;"	f	class:fst::MutableArcIterator
MutableArcIterator	vector-fst.h	/^class MutableArcIterator< VectorFst<A> >$/;"	c	namespace:fst
MutableArcIteratorBase	mutable-fst.h	/^class MutableArcIteratorBase : public ArcIteratorBase<A> {$/;"	c	namespace:fst
MutableArcIteratorData	mutable-fst.h	/^struct MutableArcIteratorData {$/;"	s	namespace:fst
MutableFst	mutable-fst.h	/^class MutableFst : public ExpandedFst<A> {$/;"	c	namespace:fst
MutableFstPair	replace-util.h	/^  typedef pair<Label, MutableFst<Arc>*> MutableFstPair;$/;"	t	class:fst::ReplaceUtil
MutableInputSymbols	mutable-fst.h	/^  virtual SymbolTable* MutableInputSymbols() {$/;"	f	class:fst::ImplToMutableFst
MutableOutputSymbols	mutable-fst.h	/^  virtual SymbolTable* MutableOutputSymbols() {$/;"	f	class:fst::ImplToMutableFst
MutateCheck	edit-fst.h	/^  void MutateCheck() {$/;"	f	class:fst::EditFstImpl
MutateCheck	mutable-fst.h	/^  void MutateCheck() {$/;"	f	class:fst::ImplToMutableFst
MutateCheck	symbol-table.h	/^  void MutateCheck() {$/;"	f	class:fst::SymbolTable
MutateCheck	vector-fst.h	/^  void MutateCheck() { return ImplToMutableFst<Impl>::MutateCheck(); }$/;"	f	class:fst::VectorFst
Mutex	lock.h	/^  Mutex() {}$/;"	f	class:fst::Mutex
Mutex	lock.h	/^class Mutex {$/;"	c	namespace:fst
MutexLock	lock.h	/^  MutexLock(Mutex *) {}$/;"	f	class:fst::MutexLock
MutexLock	lock.h	/^class MutexLock {$/;"	c	namespace:fst
NShortestPath	shortest-path.h	/^void NShortestPath(const Fst<RevArc> &ifst,$/;"	f	namespace:fst
Name	symbol-table.h	/^  const string& Name() const { return name_; }$/;"	f	class:fst::SymbolTableImpl
Name	symbol-table.h	/^  virtual const string& Name() const {$/;"	f	class:fst::SymbolTable
NaturalAStarQueue	queue.h	/^  NaturalAStarQueue(const vector<W> &distance, const E &estimate) :$/;"	f	class:fst::NaturalAStarQueue
NaturalAStarQueue	queue.h	/^class NaturalAStarQueue :$/;"	c	namespace:fst
NaturalLess	weight.h	/^  NaturalLess() {$/;"	f	class:fst::NaturalLess
NaturalLess	weight.h	/^class NaturalLess {$/;"	c	namespace:fst
NaturalPruneQueue	queue.h	/^  NaturalPruneQueue(const vector<W> &distance, Q *queue,$/;"	f	class:fst::NaturalPruneQueue
NaturalPruneQueue	queue.h	/^class NaturalPruneQueue :$/;"	c	namespace:fst
NaturalShortestFirstQueue	queue.h	/^  NaturalShortestFirstQueue(const vector<W> &distance) :$/;"	f	class:fst::NaturalShortestFirstQueue
NaturalShortestFirstQueue	queue.h	/^class NaturalShortestFirstQueue :$/;"	c	namespace:fst
NegInfinity	float-weight.h	/^  static const T NegInfinity() {$/;"	f	class:fst::FloatLimits
Next	arc-map.h	/^  void Next() {$/;"	f	class:fst::StateIterator
Next	arcsort.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcSortMapper
Next	cache.h	/^  void Next() { ++i_; }$/;"	f	class:fst::CacheArcIterator
Next	cache.h	/^  void Next() { ++i_; }$/;"	f	class:fst::CacheMutableArcIterator
Next	cache.h	/^  void Next() { ++s_; }$/;"	f	class:fst::CacheStateIterator
Next	compact-fst.h	/^  void Next() { ++pos_; }$/;"	f	class:fst::ArcIterator
Next	compact-fst.h	/^  void Next() { ++s_; }$/;"	f	class:fst::StateIterator
Next	complement.h	/^  void Next() {$/;"	f	class:fst::ArcIterator
Next	complement.h	/^  void Next() {$/;"	f	class:fst::StateIterator
Next	const-fst.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcIterator
Next	const-fst.h	/^  void Next() { ++s_; }$/;"	f	class:fst::StateIterator
Next	factor-weight.h	/^  void Next() { done_ = true; }$/;"	f	class:fst::GallicFactor
Next	factor-weight.h	/^  void Next() { done_ = true; }$/;"	f	class:fst::StringFactor
Next	factor-weight.h	/^  void Next() {}$/;"	f	class:fst::IdentityFactor
Next	fst.h	/^  void Next() { Next_(); }           \/\/ Advance to next arc (when !Done)$/;"	f	class:fst::ArcIteratorBase
Next	fst.h	/^  void Next() { Next_(); }      \/\/ Advance to next state (when !Done)$/;"	f	class:fst::StateIteratorBase
Next	fst.h	/^  void Next() {$/;"	f	class:fst::ArcIterator
Next	fst.h	/^  void Next() {$/;"	f	class:fst::StateIterator
Next	lookahead-matcher.h	/^  void Next() { base_->Next(); }$/;"	f	class:fst::LookAheadMatcher
Next	lookahead-matcher.h	/^  void Next() { matcher_.Next(); }$/;"	f	class:fst::ArcLookAheadMatcher
Next	lookahead-matcher.h	/^  void Next() { matcher_.Next(); }$/;"	f	class:fst::LabelLookAheadMatcher
Next	lookahead-matcher.h	/^  void Next() { matcher_.Next(); }$/;"	f	class:fst::TrivialLookAheadMatcher
Next	matcher-fst.h	/^  void Next() { matcher_->Next(); }$/;"	f	class:fst::LookAheadMatcher
Next	matcher-fst.h	/^  void Next() { matcher_->Next(); }$/;"	f	class:fst::Matcher
Next	matcher.h	/^  void Next() { Next_(); }$/;"	f	class:fst::MatcherBase
Next	matcher.h	/^  void Next() { base_->Next(); }$/;"	f	class:fst::Matcher
Next	matcher.h	/^  void Next() { matcher_->Next(); }$/;"	f	class:fst::PhiMatcher
Next	matcher.h	/^  void Next() { matcher_->Next(); }$/;"	f	class:fst::RhoMatcher
Next	matcher.h	/^  void Next() {$/;"	f	class:fst::MultiEpsMatcher
Next	matcher.h	/^  void Next() {$/;"	f	class:fst::SigmaMatcher
Next	matcher.h	/^  void Next() {$/;"	f	class:fst::SortedMatcher
Next	mutable-fst.h	/^  void Next() { data_.base->Next(); }$/;"	f	class:fst::MutableArcIterator
Next	partition.h	/^  void Next() {$/;"	f	class:fst::PartitionIterator
Next	randgen.h	/^  void Next() { ++sample_iter_; }$/;"	f	class:fst::ArcSampler
Next	relabel.h	/^  void Next() {$/;"	f	class:fst::StateIterator
Next	replace.h	/^  void Next() { ++pos_; }$/;"	f	class:fst::ArcIterator
Next	sparse-tuple-weight.h	/^  void Next() {$/;"	f	class:fst::SparseTupleWeightIterator
Next	state-map.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcSumMapper
Next	state-map.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcUniqueMapper
Next	state-map.h	/^  void Next() { aiter_->Next(); }$/;"	f	class:fst::IdentityStateMapper
Next	string-weight.h	/^  void Next() {$/;"	f	class:fst::StringWeightIterator
Next	string-weight.h	/^  void Next() {$/;"	f	class:fst::StringWeightReverseIterator
Next	symbol-table.h	/^  void Next(void) {$/;"	f	class:fst::SymbolTableIterator
Next	vector-fst.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcIterator
Next	vector-fst.h	/^  void Next() { ++i_; }$/;"	f	class:fst::MutableArcIterator
Next	vector-fst.h	/^  void Next() { ++s_; }$/;"	f	class:fst::StateIterator
Next_	arc-map.h	/^  void Next_() { Next(); }$/;"	f	class:fst::StateIterator
Next_	cache.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::CacheMutableArcIterator
Next_	cache.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::CacheStateIterator
Next_	complement.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::ArcIterator
Next_	complement.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::StateIterator
Next_	lookahead-matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::ArcLookAheadMatcher
Next_	lookahead-matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::LabelLookAheadMatcher
Next_	lookahead-matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::TrivialLookAheadMatcher
Next_	matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::PhiMatcher
Next_	matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::RhoMatcher
Next_	matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::SigmaMatcher
Next_	matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::SortedMatcher
Next_	relabel.h	/^  void Next_() { Next(); }$/;"	f	class:fst::StateIterator
Next_	replace.h	/^  virtual void Next_() {$/;"	f	class:fst::ReplaceFstMatcher
Next_	vector-fst.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::MutableArcIterator
NoState	compose-filter.h	/^  static const IntegerFilterState NoState() { return IntegerFilterState(); }$/;"	f	class:fst::IntegerFilterState
NoState	compose-filter.h	/^  static const PairFilterState NoState() { return PairFilterState(); }$/;"	f	class:fst::PairFilterState
NoState	compose-filter.h	/^  static const WeightFilterState NoState() { return WeightFilterState(); }$/;"	f	class:fst::WeightFilterState
NoWeight	expectation-weight.h	/^  static const ExpectationWeight<X1, X2> &NoWeight() {$/;"	f	class:fst::ExpectationWeight
NoWeight	float-weight.h	/^  static const LogWeightTpl<T> NoWeight() {$/;"	f	class:fst::LogWeightTpl
NoWeight	float-weight.h	/^  static const MinMaxWeightTpl<T> NoWeight() {$/;"	f	class:fst::MinMaxWeightTpl
NoWeight	float-weight.h	/^  static const TropicalWeightTpl<T> NoWeight() {$/;"	f	class:fst::TropicalWeightTpl
NoWeight	lexicographic-weight.h	/^  static const LexicographicWeight<W1, W2> &NoWeight() {$/;"	f	class:fst::LexicographicWeight
NoWeight	pair-weight.h	/^  static const PairWeight<W1, W2> &NoWeight() {$/;"	f	class:fst::PairWeight
NoWeight	power-weight.h	/^  static const PowerWeight<W, n> &NoWeight() {$/;"	f	class:fst::PowerWeight
NoWeight	product-weight.h	/^  static const ProductWeight<W1, W2> &NoWeight() {$/;"	f	class:fst::ProductWeight
NoWeight	signed-log-weight.h	/^  static const SignedLogWeightTpl<T> &NoWeight() {$/;"	f	class:fst::SignedLogWeightTpl
NoWeight	sparse-power-weight.h	/^  static const SparsePowerWeight<W, K> &NoWeight() {$/;"	f	class:fst::SparsePowerWeight
NoWeight	sparse-tuple-weight.h	/^  static const SparseTupleWeight<W, K> &NoWeight() {$/;"	f	class:fst::SparseTupleWeight
NoWeight	string-weight.h	/^  static const StringWeight<L, S> &NoWeight() {$/;"	f	class:fst::StringWeight
NoWeight	tuple-weight.h	/^  static const TupleWeight<W, n> &NoWeight() {$/;"	f	class:fst::TupleWeight
NonTerminalHash	replace-util.h	/^  typedef unordered_map<Label, Label> NonTerminalHash;$/;"	t	class:fst::ReplaceUtil
NonTerminalHash	replace.h	/^  typedef unordered_map<Label, Label> NonTerminalHash;$/;"	t	class:fst::ReplaceFstImpl
Normalize	interval-set.h	/^void IntervalSet<T>::Normalize() {$/;"	f	class:fst::IntervalSet
NotInEditedMap	edit-fst.h	/^  IdMapIterator NotInEditedMap() const {$/;"	f	class:fst::EditFstData
NotInFinalWeightMap	edit-fst.h	/^  FinalWeightIterator NotInFinalWeightMap() const {$/;"	f	class:fst::EditFstData
NullAddOn	add-on.h	/^  NullAddOn() {}$/;"	f	class:fst::NullAddOn
NullAddOn	add-on.h	/^class NullAddOn {$/;"	c	namespace:fst
NullMatcherFstInit	matcher-fst.h	/^  NullMatcherFstInit(Impl **) {}$/;"	f	class:fst::NullMatcherFstInit
NullMatcherFstInit	matcher-fst.h	/^class NullMatcherFstInit {$/;"	c	namespace:fst
NumArcs	add-on.h	/^  size_t NumArcs(StateId s) const { return fst_.NumArcs(s); }$/;"	f	class:fst::AddOnImpl
NumArcs	arc-map.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
NumArcs	cache.h	/^  size_t NumArcs(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
NumArcs	compact-fst.h	/^  size_t NumArcs() const { return narcs_; }$/;"	f	class:fst::CompactFstData
NumArcs	compact-fst.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::CompactFstImpl
NumArcs	complement.h	/^  size_t NumArcs(StateId s) const {$/;"	f	class:fst::ComplementFstImpl
NumArcs	compose.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::ComposeFstImplBase
NumArcs	const-fst.h	/^  size_t NumArcs(StateId s) const { return states_[s].narcs; }$/;"	f	class:fst::ConstFstImpl
NumArcs	determinize.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::DeterminizeFstImplBase
NumArcs	edit-fst.h	/^  size_t NumArcs(StateId s) const {$/;"	f	class:fst::EditFstImpl
NumArcs	edit-fst.h	/^  size_t NumArcs(StateId s, const WrappedFstT *wrapped) const {$/;"	f	class:fst::EditFstData
NumArcs	expanded-fst.h	/^ssize_t NumArcs(const ExpandedFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
NumArcs	factor-weight.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
NumArcs	fst.h	/^  int64 NumArcs() const { return numarcs_; }$/;"	f	class:fst::FstHeader
NumArcs	fst.h	/^  virtual size_t NumArcs(StateId s) const { return impl_->NumArcs(s); }$/;"	f	class:fst::ImplToFst
NumArcs	fst.h	/^ssize_t NumArcs(const F &fst, typename F::Arc::StateId s) {$/;"	f	namespace:fst::internal
NumArcs	fst.h	/^ssize_t NumArcs(const Fst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
NumArcs	mutable-fst.h	/^ssize_t NumArcs(const MutableFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
NumArcs	randgen.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::RandGenFstImpl
NumArcs	rational.h	/^  size_t NumArcs(StateId s) { return Replace()->NumArcs(s); }$/;"	f	class:fst::RationalFstImpl
NumArcs	relabel.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::RelabelFstImpl
NumArcs	replace.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
NumArcs	rmepsilon.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
NumArcs	state-map.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::StateMapFstImpl
NumArcs	synchronize.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
NumArcs	vector-fst.h	/^  size_t NumArcs(StateId s) const { return states_[s]->arcs.size(); }$/;"	f	class:fst::VectorFstBaseImpl
NumCompacts	compact-fst.h	/^  size_t NumCompacts() const { return ncompacts_; }$/;"	f	class:fst::CompactFstData
NumInputEpsilons	add-on.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::AddOnImpl
NumInputEpsilons	arc-map.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
NumInputEpsilons	cache.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
NumInputEpsilons	compact-fst.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::CompactFstImpl
NumInputEpsilons	complement.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::ComplementFstImpl
NumInputEpsilons	compose.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::ComposeFstImplBase
NumInputEpsilons	const-fst.h	/^  size_t NumInputEpsilons(StateId s) const { return states_[s].niepsilons; }$/;"	f	class:fst::ConstFstImpl
NumInputEpsilons	determinize.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::DeterminizeFstImplBase
NumInputEpsilons	edit-fst.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::EditFstImpl
NumInputEpsilons	edit-fst.h	/^  size_t NumInputEpsilons(StateId s, const WrappedFstT *wrapped) const {$/;"	f	class:fst::EditFstData
NumInputEpsilons	expanded-fst.h	/^ssize_t NumInputEpsilons(const ExpandedFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
NumInputEpsilons	factor-weight.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
NumInputEpsilons	fst.h	/^  virtual size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::ImplToFst
NumInputEpsilons	fst.h	/^ssize_t NumInputEpsilons(const F &fst, typename F::Arc::StateId s) {$/;"	f	namespace:fst::internal
NumInputEpsilons	fst.h	/^ssize_t NumInputEpsilons(const Fst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
NumInputEpsilons	mutable-fst.h	/^ssize_t NumInputEpsilons(const MutableFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
NumInputEpsilons	randgen.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::RandGenFstImpl
NumInputEpsilons	rational.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::RationalFstImpl
NumInputEpsilons	relabel.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::RelabelFstImpl
NumInputEpsilons	replace.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
NumInputEpsilons	rmepsilon.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
NumInputEpsilons	state-map.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::StateMapFstImpl
NumInputEpsilons	synchronize.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
NumInputEpsilons	vector-fst.h	/^  size_t NumInputEpsilons(StateId s) const { return GetState(s)->niepsilons; }$/;"	f	class:fst::VectorFstImpl
NumKnownStates	cache.h	/^  StateId NumKnownStates() const { return nknown_states_; }$/;"	f	class:fst::CacheBaseImpl
NumNewStates	edit-fst.h	/^  StateId NumNewStates() const {$/;"	f	class:fst::EditFstData
NumOutputEpsilons	add-on.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::AddOnImpl
NumOutputEpsilons	arc-map.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
NumOutputEpsilons	cache.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
NumOutputEpsilons	compact-fst.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::CompactFstImpl
NumOutputEpsilons	complement.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::ComplementFstImpl
NumOutputEpsilons	compose.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::ComposeFstImplBase
NumOutputEpsilons	const-fst.h	/^  size_t NumOutputEpsilons(StateId s) const { return states_[s].noepsilons; }$/;"	f	class:fst::ConstFstImpl
NumOutputEpsilons	determinize.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::DeterminizeFstImplBase
NumOutputEpsilons	edit-fst.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::EditFstImpl
NumOutputEpsilons	edit-fst.h	/^  size_t NumOutputEpsilons(StateId s, const WrappedFstT *wrapped) const {$/;"	f	class:fst::EditFstData
NumOutputEpsilons	expanded-fst.h	/^ssize_t NumOutputEpsilons(const ExpandedFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
NumOutputEpsilons	factor-weight.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
NumOutputEpsilons	fst.h	/^  virtual size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::ImplToFst
NumOutputEpsilons	fst.h	/^ssize_t NumOutputEpsilons(const F &fst, typename F::Arc::StateId s) {$/;"	f	namespace:fst::internal
NumOutputEpsilons	fst.h	/^ssize_t NumOutputEpsilons(const Fst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
NumOutputEpsilons	mutable-fst.h	/^ssize_t NumOutputEpsilons(const MutableFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
NumOutputEpsilons	randgen.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::RandGenFstImpl
NumOutputEpsilons	rational.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::RationalFstImpl
NumOutputEpsilons	relabel.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::RelabelFstImpl
NumOutputEpsilons	replace.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
NumOutputEpsilons	rmepsilon.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
NumOutputEpsilons	state-map.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::StateMapFstImpl
NumOutputEpsilons	synchronize.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
NumOutputEpsilons	vector-fst.h	/^  size_t NumOutputEpsilons(StateId s) const { return GetState(s)->noepsilons; }$/;"	f	class:fst::VectorFstImpl
NumStates	add-on.h	/^  size_t NumStates() const { return fst_.NumStates(); }$/;"	f	class:fst::AddOnImpl
NumStates	compact-fst.h	/^  StateId NumStates() const {$/;"	f	class:fst::CompactFstImpl
NumStates	compact-fst.h	/^  size_t NumStates() const { return nstates_; }$/;"	f	class:fst::CompactFstData
NumStates	const-fst.h	/^  StateId NumStates() const { return nstates_; }$/;"	f	class:fst::ConstFstImpl
NumStates	edit-fst.h	/^  StateId NumStates() const {$/;"	f	class:fst::EditFstImpl
NumStates	expanded-fst.h	/^  virtual StateId NumStates() const { return GetImpl()->NumStates(); }$/;"	f	class:fst::ImplToExpandedFst
NumStates	fst.h	/^  int64 NumStates() const { return numstates_; }$/;"	f	class:fst::FstHeader
NumStates	vector-fst.h	/^  StateId NumStates() const { return states_.size(); }$/;"	f	class:fst::VectorFstBaseImpl
NumSymbols	symbol-table.h	/^  size_t NumSymbols() const {$/;"	f	class:fst::SymbolTableImpl
NumSymbols	symbol-table.h	/^  virtual size_t NumSymbols(void) const {$/;"	f	class:fst::SymbolTable
NumberBad	float-weight.h	/^  static const T NumberBad() {$/;"	f	class:fst::FloatLimits
OLabelCompare	arcsort.h	/^template<class A> class OLabelCompare {$/;"	c	namespace:fst
OTHER_QUEUE	queue.h	/^  OTHER_QUEUE = 8$/;"	e	enum:fst::QueueType
One	expectation-weight.h	/^  static const ExpectationWeight<X1, X2> &One() {$/;"	f	class:fst::ExpectationWeight
One	float-weight.h	/^  static const LogWeightTpl<T> One() {$/;"	f	class:fst::LogWeightTpl
One	float-weight.h	/^  static const MinMaxWeightTpl<T> One() {$/;"	f	class:fst::MinMaxWeightTpl
One	float-weight.h	/^  static const TropicalWeightTpl<T> One() {$/;"	f	class:fst::TropicalWeightTpl
One	lexicographic-weight.h	/^  static const LexicographicWeight<W1, W2> &One() {$/;"	f	class:fst::LexicographicWeight
One	pair-weight.h	/^  static const PairWeight<W1, W2> &One() {$/;"	f	class:fst::PairWeight
One	power-weight.h	/^  static const PowerWeight<W, n> &One() {$/;"	f	class:fst::PowerWeight
One	product-weight.h	/^  static const ProductWeight<W1, W2> &One() {$/;"	f	class:fst::ProductWeight
One	signed-log-weight.h	/^  static const SignedLogWeightTpl<T> &One() {$/;"	f	class:fst::SignedLogWeightTpl
One	sparse-power-weight.h	/^  static const SparsePowerWeight<W, K> &One() {$/;"	f	class:fst::SparsePowerWeight
One	sparse-tuple-weight.h	/^  static const SparseTupleWeight<W, K> &One() {$/;"	f	class:fst::SparseTupleWeight
One	string-weight.h	/^  static const StringWeight<L, S> &One() {$/;"	f	class:fst::StringWeight
One	tuple-weight.h	/^  static const TupleWeight<W, n> &One() {$/;"	f	class:fst::TupleWeight
OrderedExpand	compose.h	/^  void OrderedExpand(StateId s, const Fst<Arc> &, StateId sa,$/;"	f	class:fst::ComposeFstImpl
OutputEpsilonArcFilter	arcfilter.h	/^class OutputEpsilonArcFilter {$/;"	c	namespace:fst
OutputPath	randgen.h	/^  void OutputPath() {$/;"	f	class:fst::RandGenVisitor
OutputSymbols	encode.h	/^  SymbolTable *OutputSymbols() const { return osymbols_; }$/;"	f	class:fst::EncodeTable
OutputSymbols	encode.h	/^  SymbolTable *OutputSymbols() const { return table_->OutputSymbols(); }$/;"	f	class:fst::EncodeMapper
OutputSymbols	fst.h	/^  SymbolTable* OutputSymbols() { return osymbols_; }$/;"	f	class:fst::FstImpl
OutputSymbols	fst.h	/^  const SymbolTable* OutputSymbols() const { return osymbols_; }$/;"	f	class:fst::FstImpl
OutputSymbols	fst.h	/^  virtual const SymbolTable* OutputSymbols() const {$/;"	f	class:fst::ImplToFst
OutputSymbols	mutable-fst.h	/^  virtual const SymbolTable* OutputSymbols() const {$/;"	f	class:fst::ImplToMutableFst
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS; }$/;"	f	struct:fst::GallicToNewSymbolsMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS;}$/;"	f	struct:fst::FromGallicMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS;}$/;"	f	struct:fst::ToGallicMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	class:fst::WeightConvertMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::IdentityArcMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::InvertWeightMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::PlusMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::QuantizeMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::ReverseWeightMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::RmWeightMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::SuperFinalMapper
OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::TimesMapper
OutputSymbolsAction	arcsort.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcSortMapper
OutputSymbolsAction	encode.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS;}$/;"	f	class:fst::EncodeMapper
OutputSymbolsAction	invert.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS;}$/;"	f	struct:fst::InvertMapper
OutputSymbolsAction	map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::IdentityMapper
OutputSymbolsAction	project.h	/^  MapSymbolsAction OutputSymbolsAction() const {$/;"	f	class:fst::ProjectMapper
OutputSymbolsAction	state-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcSumMapper
OutputSymbolsAction	state-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcUniqueMapper
OutputSymbolsAction	state-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	class:fst::IdentityStateMapper
Overlaps	interval-set.h	/^bool IntervalSet<T>::Overlaps(const IntervalSet<T> &iset) const {$/;"	f	class:fst::IntervalSet
PG	random-weight.h	/^  typedef ProductWeightGenerator<StringWeightGenerator<L, S>, G> PG;$/;"	t	class:fst::GallicWeightGenerator
PROJECT_INPUT	project.h	/^enum ProjectType { PROJECT_INPUT = 1, PROJECT_OUTPUT = 2 };$/;"	e	enum:fst::ProjectType
PROJECT_OUTPUT	project.h	/^enum ProjectType { PROJECT_INPUT = 1, PROJECT_OUTPUT = 2 };$/;"	e	enum:fst::ProjectType
P_	minimize.h	/^  Partition<StateId> P_;$/;"	m	class:fst::CyclicMinimizer
Pair	shortest-path.h	/^  typedef pair<StateId, Weight> Pair;$/;"	t	class:fst::ShortestPathCompare
Pair	sparse-tuple-weight.h	/^  typedef pair<K, W> Pair;$/;"	t	class:fst::SparseTupleWeight
Pair	sparse-tuple-weight.h	/^  typedef typename SparseTupleWeight<W, K>::Pair Pair;$/;"	t	class:fst::SparseTupleWeightIterator
PairFilterState	compose-filter.h	/^  PairFilterState() : f1_(F1::NoState()), f2_(F2::NoState()) {}$/;"	f	class:fst::PairFilterState
PairFilterState	compose-filter.h	/^  PairFilterState(const F1 &f1, const F2 &f2) : f1_(f1), f2_(f2) {}$/;"	f	class:fst::PairFilterState
PairFilterState	compose-filter.h	/^class PairFilterState {$/;"	c	namespace:fst
PairWeight	pair-weight.h	/^  PairWeight() {}$/;"	f	class:fst::PairWeight
PairWeight	pair-weight.h	/^  PairWeight(W1 w1, W2 w2) : value1_(w1), value2_(w2) {}$/;"	f	class:fst::PairWeight
PairWeight	pair-weight.h	/^  PairWeight(const PairWeight& w) : value1_(w.value1_), value2_(w.value2_) {}$/;"	f	class:fst::PairWeight
PairWeight	pair-weight.h	/^class PairWeight {$/;"	c	namespace:fst
Parent	heap.h	/^  int Parent(int i) {$/;"	f	class:fst::Heap
PartialVisitor	visit.h	/^  explicit PartialVisitor(StateId maxvisit) : maxvisit_(maxvisit) {}$/;"	f	class:fst::PartialVisitor
PartialVisitor	visit.h	/^class PartialVisitor {$/;"	c	namespace:fst
Partition	partition.h	/^  Partition(bool allow_repeated_split):$/;"	f	class:fst::Partition
Partition	partition.h	/^  Partition(bool allow_repeated_split, T num_states):$/;"	f	class:fst::Partition
Partition	partition.h	/^class Partition {$/;"	c	namespace:fst
PartitionIterator	partition.h	/^  PartitionIterator(const Partition<T>& partition, T class_id)$/;"	f	class:fst::PartitionIterator
PartitionIterator	partition.h	/^class PartitionIterator {$/;"	c	namespace:fst
PhiMatcher	matcher.h	/^  PhiMatcher(const FST &fst,$/;"	f	class:fst::PhiMatcher
PhiMatcher	matcher.h	/^  PhiMatcher(const PhiMatcher<M> &matcher, bool safe = false)$/;"	f	class:fst::PhiMatcher
PhiMatcher	matcher.h	/^class PhiMatcher : public MatcherBase<typename M::Arc> {$/;"	c	namespace:fst
Plus	expectation-weight.h	/^inline ExpectationWeight<X1, X2> Plus(const ExpectationWeight<X1, X2> &w,$/;"	f	namespace:fst
Plus	float-weight.h	/^inline LogWeightTpl<T> Plus(const LogWeightTpl<T> &w1,$/;"	f	namespace:fst
Plus	float-weight.h	/^inline LogWeightTpl<double> Plus(const LogWeightTpl<double> &w1,$/;"	f	namespace:fst
Plus	float-weight.h	/^inline LogWeightTpl<float> Plus(const LogWeightTpl<float> &w1,$/;"	f	namespace:fst
Plus	float-weight.h	/^inline MinMaxWeightTpl<T> Plus($/;"	f	namespace:fst
Plus	float-weight.h	/^inline MinMaxWeightTpl<double> Plus($/;"	f	namespace:fst
Plus	float-weight.h	/^inline MinMaxWeightTpl<float> Plus($/;"	f	namespace:fst
Plus	float-weight.h	/^inline TropicalWeightTpl<T> Plus(const TropicalWeightTpl<T> &w1,$/;"	f	namespace:fst
Plus	float-weight.h	/^inline TropicalWeightTpl<double> Plus(const TropicalWeightTpl<double> &w1,$/;"	f	namespace:fst
Plus	float-weight.h	/^inline TropicalWeightTpl<float> Plus(const TropicalWeightTpl<float> &w1,$/;"	f	namespace:fst
Plus	lexicographic-weight.h	/^inline LexicographicWeight<W1, W2> Plus(const LexicographicWeight<W1, W2> &w,$/;"	f	namespace:fst
Plus	power-weight.h	/^inline PowerWeight<W, n> Plus(const PowerWeight<W, n> &w1,$/;"	f	namespace:fst
Plus	product-weight.h	/^inline ProductWeight<W1, W2> Plus(const ProductWeight<W1, W2> &w,$/;"	f	namespace:fst
Plus	signed-log-weight.h	/^inline SignedLogWeightTpl<T> Plus(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
Plus	sparse-power-weight.h	/^inline SparsePowerWeight<W, K> Plus(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
Plus	string-weight.h	/^Plus(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
Plus	string-weight.h	/^Plus(const StringWeight<L, STRING_LEFT> &w1,$/;"	f	namespace:fst
Plus	string-weight.h	/^Plus(const StringWeight<L, STRING_RIGHT> &w1,$/;"	f	namespace:fst
PlusMapper	arc-map.h	/^  explicit PlusMapper(Weight w) : weight_(w) {}$/;"	f	struct:fst::PlusMapper
PlusMapper	arc-map.h	/^struct PlusMapper {$/;"	s	namespace:fst
Pop	heap.h	/^  T Pop() {$/;"	f	class:fst::Heap
Pop	replace.h	/^    void Pop() {$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
PopPrefix	replace.h	/^  PrefixId PopPrefix(StackPrefix prefix) {$/;"	f	class:fst::ReplaceFstImpl
PosInfinity	float-weight.h	/^  static const T PosInfinity() {$/;"	f	class:fst::FloatLimits
Position	cache.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::CacheArcIterator
Position	cache.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::CacheMutableArcIterator
Position	compact-fst.h	/^  size_t Position() const { return pos_; }$/;"	f	class:fst::ArcIterator
Position	complement.h	/^  size_t Position() const {$/;"	f	class:fst::ArcIterator
Position	const-fst.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::ArcIterator
Position	fst.h	/^  size_t Position() const { return Position_(); }  \/\/ Return current position$/;"	f	class:fst::ArcIteratorBase
Position	fst.h	/^  size_t Position() const {$/;"	f	class:fst::ArcIterator
Position	mutable-fst.h	/^  size_t Position() const { return data_.base->Position(); }$/;"	f	class:fst::MutableArcIterator
Position	replace.h	/^  size_t Position() const { return pos_; }$/;"	f	class:fst::ArcIterator
Position	vector-fst.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::ArcIterator
Position	vector-fst.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::MutableArcIterator
Position_	cache.h	/^  virtual size_t Position_() const { return Position(); }$/;"	f	class:fst::CacheMutableArcIterator
Position_	complement.h	/^  virtual size_t Position_() const { return Position(); }$/;"	f	class:fst::ArcIterator
Position_	vector-fst.h	/^  virtual size_t Position_() const { return Position(); }$/;"	f	class:fst::MutableArcIterator
Power	weight.h	/^W Power(W w, size_t n) {$/;"	f	namespace:fst
PowerArc	arc.h	/^  PowerArc() {}$/;"	f	struct:fst::PowerArc
PowerArc	arc.h	/^  PowerArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::PowerArc
PowerArc	arc.h	/^struct PowerArc {$/;"	s	namespace:fst
PowerWeight	power-weight.h	/^  PowerWeight() {}$/;"	f	class:fst::PowerWeight
PowerWeight	power-weight.h	/^  PowerWeight(Iterator begin, Iterator end) : TupleWeight<W, n>(begin, end) {}$/;"	f	class:fst::PowerWeight
PowerWeight	power-weight.h	/^  PowerWeight(const TupleWeight<W, n> &w) : TupleWeight<W, n>(w) {}$/;"	f	class:fst::PowerWeight
PowerWeight	power-weight.h	/^class PowerWeight : public TupleWeight<W, n> {$/;"	c	namespace:fst
PowerWeightGenerator	random-weight.h	/^  PowerWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::PowerWeightGenerator
PowerWeightGenerator	random-weight.h	/^class PowerWeightGenerator {$/;"	c	namespace:fst
PrePartition	minimize.h	/^  void PrePartition(const Fst<A>& fst) {$/;"	f	class:fst::CyclicMinimizer
PrefixId	replace.h	/^  typedef P PrefixId;$/;"	t	class:fst::DefaultReplaceStateTable
PrefixId	replace.h	/^  typedef P PrefixId;$/;"	t	class:fst::VectorHashReplaceStateTable
PrefixId	replace.h	/^  typedef P PrefixId;$/;"	t	struct:fst::ReplaceStateTuple
PrefixId	replace.h	/^  typedef typename T::PrefixId PrefixId;$/;"	t	class:fst::ReplaceFstImpl
PrefixTuple	replace.h	/^    PrefixTuple(Label f, StateId s) : fst_id(f), nextstate(s) {}$/;"	f	struct:fst::ReplaceFstImpl::PrefixTuple
PrefixTuple	replace.h	/^  struct PrefixTuple {$/;"	s	class:fst::ReplaceFstImpl
PrintLabel	string.h	/^  bool PrintLabel(Label lab, ostream& ostrm) {$/;"	f	class:fst::StringPrinter
PrintMap	edit-fst.h	/^  void PrintMap() {$/;"	f	class:fst::EditFstData
ProductArc	arc.h	/^  ProductArc() {}$/;"	f	struct:fst::ProductArc
ProductArc	arc.h	/^  ProductArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::ProductArc
ProductArc	arc.h	/^struct ProductArc {$/;"	s	namespace:fst
ProductComposeStateTable	state-table.h	/^  ProductComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2)$/;"	f	class:fst::ProductComposeStateTable
ProductComposeStateTable	state-table.h	/^  ProductComposeStateTable(const ProductComposeStateTable<A, F> &table)$/;"	f	class:fst::ProductComposeStateTable
ProductComposeStateTable	state-table.h	/^class ProductComposeStateTable : public$/;"	c	namespace:fst
ProductWeight	product-weight.h	/^  ProductWeight() {}$/;"	f	class:fst::ProductWeight
ProductWeight	product-weight.h	/^  ProductWeight(W1 w1, W2 w2) : PairWeight<W1, W2>(w1, w2) {}$/;"	f	class:fst::ProductWeight
ProductWeight	product-weight.h	/^  ProductWeight(const PairWeight<W1, W2>& w) : PairWeight<W1, W2>(w) {}$/;"	f	class:fst::ProductWeight
ProductWeight	product-weight.h	/^class ProductWeight : public PairWeight<W1, W2> {$/;"	c	namespace:fst
ProductWeightGenerator	random-weight.h	/^  ProductWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::ProductWeightGenerator
ProductWeightGenerator	random-weight.h	/^class ProductWeightGenerator {$/;"	c	namespace:fst
Project	project.h	/^void Project(MutableFst<Arc> *fst, ProjectType project_type) {$/;"	f	namespace:fst
ProjectFst	project.h	/^  ProjectFst(const Fst<A> &fst, ProjectType project_type)$/;"	f	class:fst::ProjectFst
ProjectFst	project.h	/^  ProjectFst(const ProjectFst<A> &fst, bool safe = false)$/;"	f	class:fst::ProjectFst
ProjectFst	project.h	/^class ProjectFst : public ArcMapFst<A, A, ProjectMapper<A> > {$/;"	c	namespace:fst
ProjectMapper	project.h	/^  explicit ProjectMapper(ProjectType project_type)$/;"	f	class:fst::ProjectMapper
ProjectMapper	project.h	/^template <class A> class ProjectMapper {$/;"	c	namespace:fst
ProjectType	project.h	/^enum ProjectType { PROJECT_INPUT = 1, PROJECT_OUTPUT = 2 };$/;"	g	namespace:fst
Properties	arc-map.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::ArcMapFstImpl
Properties	arc-map.h	/^  uint64 Properties(uint64 inprops) const {$/;"	f	struct:fst::FromGallicMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 inprops) const {$/;"	f	struct:fst::GallicToNewSymbolsMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::ArcMapFstImpl
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::WeightConvertMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	struct:fst::IdentityArcMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	struct:fst::ReverseWeightMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::InvertWeightMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::PlusMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::QuantizeMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::RmWeightMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::SuperFinalMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::TimesMapper
Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::ToGallicMapper
Properties	arcsort.h	/^  uint64 Properties(uint64 props) const { return comp_.Properties(props); }$/;"	f	class:fst::ArcSortMapper
Properties	arcsort.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::ILabelCompare
Properties	arcsort.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::OLabelCompare
Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::AcceptorCompactor
Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::StringCompactor
Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::UnweightedAcceptorCompactor
Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::UnweightedCompactor
Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::WeightedStringCompactor
Properties	complement.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::ComplementFstImpl
Properties	complement.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::ComplementFstImpl
Properties	compose-filter.h	/^  uint64 Properties(uint64 iprops) const {$/;"	f	class:fst::MultiEpsFilter
Properties	compose-filter.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::AltSequenceComposeFilter
Properties	compose-filter.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::MatchComposeFilter
Properties	compose-filter.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::SequenceComposeFilter
Properties	compose.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::ComposeFstImpl
Properties	compose.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::ComposeFstImpl
Properties	determinize.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::DeterminizeFsaImpl
Properties	determinize.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::DeterminizeFstImpl
Properties	determinize.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::DeterminizeFsaImpl
Properties	determinize.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::DeterminizeFstImpl
Properties	encode.h	/^  uint64 Properties(uint64 inprops) {$/;"	f	class:fst::EncodeMapper
Properties	expectation-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::ExpectationWeight
Properties	factor-weight.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::FactorWeightFstImpl
Properties	factor-weight.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::FactorWeightFstImpl
Properties	float-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::LogWeightTpl
Properties	float-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::MinMaxWeightTpl
Properties	float-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::TropicalWeightTpl
Properties	fst.h	/^  uint64 Properties() const { return properties_; }$/;"	f	class:fst::FstHeader
Properties	fst.h	/^  virtual uint64 Properties() const { return properties_; }$/;"	f	class:fst::FstImpl
Properties	fst.h	/^  virtual uint64 Properties(uint64 mask) const { return properties_ & mask; }$/;"	f	class:fst::FstImpl
Properties	fst.h	/^  virtual uint64 Properties(uint64 mask, bool test) const {$/;"	f	class:fst::ImplToFst
Properties	invert.h	/^  uint64 Properties(uint64 props) { return InvertProperties(props); }$/;"	f	struct:fst::InvertMapper
Properties	lexicographic-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::LexicographicWeight
Properties	lookahead-filter.h	/^  uint64 Properties(uint64 inprops) const {$/;"	f	class:fst::LookAheadComposeFilter
Properties	lookahead-filter.h	/^  uint64 Properties(uint64 iprops) const {$/;"	f	class:fst::PushLabelsComposeFilter
Properties	lookahead-filter.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::PushWeightsComposeFilter
Properties	lookahead-matcher.h	/^  uint64 Properties(uint64 inprops) const {$/;"	f	class:fst::LabelLookAheadMatcher
Properties	lookahead-matcher.h	/^  uint64 Properties(uint64 props) const { return base_->Properties(props); }$/;"	f	class:fst::LookAheadMatcher
Properties	lookahead-matcher.h	/^  uint64 Properties(uint64 props) const { return matcher_.Properties(props); }$/;"	f	class:fst::ArcLookAheadMatcher
Properties	lookahead-matcher.h	/^  uint64 Properties(uint64 props) const { return matcher_.Properties(props); }$/;"	f	class:fst::TrivialLookAheadMatcher
Properties	map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	struct:fst::IdentityMapper
Properties	matcher-fst.h	/^  uint64 Properties(uint64 props) const { return matcher_->Properties(props); }$/;"	f	class:fst::LookAheadMatcher
Properties	matcher-fst.h	/^  uint64 Properties(uint64 props) const { return matcher_->Properties(props); }$/;"	f	class:fst::Matcher
Properties	matcher.h	/^  uint64 Properties(uint64 props) const { return base_->Properties(props); }$/;"	f	class:fst::Matcher
Properties	matcher.h	/^  uint64 Properties(uint64 props) const { return matcher_->Properties(props); }$/;"	f	class:fst::MultiEpsMatcher
Properties	matcher.h	/^  virtual uint64 Properties(uint64 inprops) const {$/;"	f	class:fst::SortedMatcher
Properties	matcher.h	/^uint64 PhiMatcher<M>::Properties(uint64 inprops) const {$/;"	f	class:fst::PhiMatcher
Properties	matcher.h	/^uint64 RhoMatcher<M>::Properties(uint64 inprops) const {$/;"	f	class:fst::RhoMatcher
Properties	matcher.h	/^uint64 SigmaMatcher<M>::Properties(uint64 inprops) const {$/;"	f	class:fst::SigmaMatcher
Properties	power-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::PowerWeight
Properties	product-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::ProductWeight
Properties	project.h	/^  uint64 Properties(uint64 props) {$/;"	f	class:fst::ProjectMapper
Properties	randgen.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::RandGenFstImpl
Properties	randgen.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::RandGenFstImpl
Properties	rational.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::RationalFstImpl
Properties	rational.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::RationalFstImpl
Properties	relabel.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::RelabelFstImpl
Properties	relabel.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::RelabelFstImpl
Properties	replace.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::ReplaceFstImpl
Properties	replace.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::ReplaceFstImpl
Properties	replace.h	/^  virtual uint64 Properties(uint64 props) const {$/;"	f	class:fst::ReplaceFstMatcher
Properties	rmepsilon.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::RmEpsilonFstImpl
Properties	rmepsilon.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::RmEpsilonFstImpl
Properties	signed-log-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::SignedLogWeightTpl
Properties	sparse-power-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::SparsePowerWeight
Properties	state-map.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::StateMapFstImpl
Properties	state-map.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::StateMapFstImpl
Properties	state-map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::IdentityStateMapper
Properties	state-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::ArcSumMapper
Properties	state-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::ArcUniqueMapper
Properties	string-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::StringWeight
Properties	synchronize.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::SynchronizeFstImpl
Properties	synchronize.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::SynchronizeFstImpl
Prune	prune.h	/^void Prune(MutableFst<Arc> *fst,$/;"	f	namespace:fst
Prune	prune.h	/^void Prune(const Fst<Arc> &ifst,$/;"	f	namespace:fst
PruneCompare	prune.h	/^  PruneCompare(const vector<Weight> &idistance,$/;"	f	class:fst::PruneCompare
PruneCompare	prune.h	/^class PruneCompare {$/;"	c	namespace:fst
PruneOptions	prune.h	/^  explicit PruneOptions(const Weight& w, StateId s, ArcFilter f,$/;"	f	class:fst::PruneOptions
PruneOptions	prune.h	/^class PruneOptions {$/;"	c	namespace:fst
PruneQueue	queue.h	/^  PruneQueue(const vector<Weight> &distance, Q *queue, L comp,$/;"	f	class:fst::PruneQueue
PruneQueue	queue.h	/^class PruneQueue : public QueueBase<typename Q::StateId> {$/;"	c	namespace:fst
PruneSymbolTable	symbol-table-ops.h	/^SymbolTable *PruneSymbolTable(const Fst<Arc> &fst, const SymbolTable &syms,$/;"	f	namespace:fst
Push	push.h	/^void Push(MutableFst<Arc> *fst,$/;"	f	namespace:fst
Push	push.h	/^void Push(const Fst<Arc> &ifst,$/;"	f	namespace:fst
Push	replace.h	/^    void Push(StateId fst_id, StateId nextstate) {$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
Push	sparse-tuple-weight.h	/^  inline void Push(const K &k, const W &w, bool default_value_check = true) {$/;"	f	class:fst::SparseTupleWeight
Push	sparse-tuple-weight.h	/^  inline void Push(const Pair &p, bool default_value_check = true) {$/;"	f	class:fst::SparseTupleWeight
PushArc	cache.h	/^  void PushArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CacheBaseImpl
PushBack	string-weight.h	/^  void PushBack(L l) {$/;"	f	class:fst::StringWeight
PushFront	string-weight.h	/^  void PushFront(L l) {$/;"	f	class:fst::StringWeight
PushLabelFilterArc	lookahead-filter.h	/^  FilterState PushLabelFilterArc(Arc *arca, Arc *arcb,$/;"	f	class:fst::PushLabelsComposeFilter
PushLabelsComposeFilter	lookahead-filter.h	/^  PushLabelsComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::PushLabelsComposeFilter
PushLabelsComposeFilter	lookahead-filter.h	/^  PushLabelsComposeFilter(const PushLabelsComposeFilter<F, M1, M2, MT> &filter,$/;"	f	class:fst::PushLabelsComposeFilter
PushLabelsComposeFilter	lookahead-filter.h	/^class PushLabelsComposeFilter {$/;"	c	namespace:fst
PushPrefix	replace.h	/^  PrefixId PushPrefix(StackPrefix prefix, Label fst_id, StateId nextstate) {$/;"	f	class:fst::ReplaceFstImpl
PushWeightsComposeFilter	lookahead-filter.h	/^  PushWeightsComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::PushWeightsComposeFilter
PushWeightsComposeFilter	lookahead-filter.h	/^  PushWeightsComposeFilter(const PushWeightsComposeFilter<F, M1, M2, MT>$/;"	f	class:fst::PushWeightsComposeFilter
PushWeightsComposeFilter	lookahead-filter.h	/^class PushWeightsComposeFilter {$/;"	c	namespace:fst
PushedLabelFilterArc	lookahead-filter.h	/^  FilterState PushedLabelFilterArc(Arc *arca, Arc *arcb,$/;"	f	class:fst::PushLabelsComposeFilter
Quantize	expectation-weight.h	/^  PairWeight<X1, X2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::ExpectationWeight
Quantize	float-weight.h	/^  LogWeightTpl<T> Quantize(float delta = kDelta) const {$/;"	f	class:fst::LogWeightTpl
Quantize	float-weight.h	/^  MinMaxWeightTpl<T> Quantize(float delta = kDelta) const {$/;"	f	class:fst::MinMaxWeightTpl
Quantize	float-weight.h	/^  TropicalWeightTpl<T> Quantize(float delta = kDelta) const {$/;"	f	class:fst::TropicalWeightTpl
Quantize	lexicographic-weight.h	/^  LexicographicWeight<W1, W2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::LexicographicWeight
Quantize	pair-weight.h	/^  PairWeight<W1, W2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::PairWeight
Quantize	power-weight.h	/^  PowerWeight<W, n> Quantize(float delta = kDelta) const {$/;"	f	class:fst::PowerWeight
Quantize	product-weight.h	/^  ProductWeight<W1, W2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::ProductWeight
Quantize	signed-log-weight.h	/^  ProductWeight<X1, X2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::SignedLogWeightTpl
Quantize	sparse-power-weight.h	/^  SparsePowerWeight<W, K> Quantize(float delta = kDelta) const {$/;"	f	class:fst::SparsePowerWeight
Quantize	sparse-tuple-weight.h	/^  SparseTupleWeight<W, K> Quantize(float delta = kDelta) const {$/;"	f	class:fst::SparseTupleWeight
Quantize	string-weight.h	/^  StringWeight<L, S> Quantize(float delta = kDelta) const {$/;"	f	class:fst::StringWeight
Quantize	tuple-weight.h	/^  TupleWeight<W, n> Quantize(float delta = kDelta) const {$/;"	f	class:fst::TupleWeight
QuantizeMapper	arc-map.h	/^  QuantizeMapper() : delta_(kDelta) {}$/;"	f	struct:fst::QuantizeMapper
QuantizeMapper	arc-map.h	/^  explicit QuantizeMapper(float d) : delta_(d) {}$/;"	f	struct:fst::QuantizeMapper
QuantizeMapper	arc-map.h	/^struct QuantizeMapper {$/;"	s	namespace:fst
Queue	queue.h	/^  typedef Q Queue;$/;"	t	class:fst::SccQueue
QueueBase	queue.h	/^  QueueBase(QueueType type) : queue_type_(type), error_(false) {}$/;"	f	class:fst::QueueBase
QueueBase	queue.h	/^class QueueBase {$/;"	c	namespace:fst
QueueType	queue.h	/^enum QueueType {$/;"	g	namespace:fst
READ_POD_TYPE	util.h	69;"	d
READ_STL_ASSOC_TYPE	util.h	147;"	d
READ_STL_SEQ_TYPE	util.h	128;"	d
REGISTER_FST	register.h	112;"	d
REVERSE_STRING_TYPE	string-weight.h	44;"	d
REWEIGHT_TO_FINAL	reweight.h	/^enum ReweightType { REWEIGHT_TO_INITIAL, REWEIGHT_TO_FINAL };$/;"	e	enum:fst::ReweightType
REWEIGHT_TO_INITIAL	reweight.h	/^enum ReweightType { REWEIGHT_TO_INITIAL, REWEIGHT_TO_FINAL };$/;"	e	enum:fst::ReweightType
RandEquivalent	randequivalent.h	/^bool RandEquivalent(const Fst<Arc> &fst1, const Fst<Arc> &fst2,$/;"	f	namespace:fst
RandGen	randgen.h	/^void RandGen(const Fst<IArc> &ifst, MutableFst<OArc> *ofst) {$/;"	f	namespace:fst
RandGen	randgen.h	/^void RandGen(const Fst<IArc> &ifst, MutableFst<OArc> *ofst,$/;"	f	namespace:fst
RandGenFst	randgen.h	/^  RandGenFst(const Fst<A> &fst, const RandGenFstOptions<S> &opts)$/;"	f	class:fst::RandGenFst
RandGenFst	randgen.h	/^ RandGenFst(const RandGenFst<A, B, S> &fst, bool safe = false)$/;"	f	class:fst::RandGenFst
RandGenFst	randgen.h	/^class RandGenFst : public ImplToFst< RandGenFstImpl<A, B, S> > {$/;"	c	namespace:fst
RandGenFstImpl	randgen.h	/^  RandGenFstImpl(const Fst<A> &fst, const RandGenFstOptions<S> &opts)$/;"	f	class:fst::RandGenFstImpl
RandGenFstImpl	randgen.h	/^  RandGenFstImpl(const RandGenFstImpl &impl)$/;"	f	class:fst::RandGenFstImpl
RandGenFstImpl	randgen.h	/^class RandGenFstImpl : public CacheImpl<B> {$/;"	c	namespace:fst
RandGenFstOptions	randgen.h	/^  RandGenFstOptions(const CacheOptions &copts, S *samp,$/;"	f	struct:fst::RandGenFstOptions
RandGenFstOptions	randgen.h	/^struct RandGenFstOptions : public CacheOptions {$/;"	s	namespace:fst
RandGenOptions	randgen.h	/^  RandGenOptions(const S &sel, int len = INT_MAX, size_t n = 1,$/;"	f	struct:fst::RandGenOptions
RandGenOptions	randgen.h	/^struct RandGenOptions {$/;"	s	namespace:fst
RandGenVisitor	randgen.h	/^  RandGenVisitor(MutableFst<OArc> *ofst) : ofst_(ofst) {}$/;"	f	class:fst::RandGenVisitor
RandGenVisitor	randgen.h	/^class RandGenVisitor {$/;"	c	namespace:fst
RandState	randgen.h	/^  RandState()$/;"	f	struct:fst::RandState
RandState	randgen.h	/^  RandState(StateId s, size_t n, size_t l, size_t k, const RandState<A> *p)$/;"	f	struct:fst::RandState
RandState	randgen.h	/^struct RandState {$/;"	s	namespace:fst
RationalFst	rational.h	/^  RationalFst()$/;"	f	class:fst::RationalFst
RationalFst	rational.h	/^  RationalFst(const RationalFst<A> &fst , bool safe = false)$/;"	f	class:fst::RationalFst
RationalFst	rational.h	/^  explicit RationalFst(const RationalFstOptions &opts)$/;"	f	class:fst::RationalFst
RationalFst	rational.h	/^class RationalFst : public ImplToFst< RationalFstImpl<A> > {$/;"	c	namespace:fst
RationalFstImpl	rational.h	/^  RationalFstImpl(const RationalFstImpl<A> &impl)$/;"	f	class:fst::RationalFstImpl
RationalFstImpl	rational.h	/^  explicit RationalFstImpl(const RationalFstOptions &opts)$/;"	f	class:fst::RationalFstImpl
RationalFstImpl	rational.h	/^class RationalFstImpl : public FstImpl<A> {$/;"	c	namespace:fst
RationalFstOptions	rational.h	/^typedef CacheOptions RationalFstOptions;$/;"	t	namespace:fst
Reach	label-reachable.h	/^  bool Reach(Iterator *aiter, ssize_t aiter_begin,$/;"	f	class:fst::LabelReachable
Reach	label-reachable.h	/^  bool Reach(Label label) {$/;"	f	class:fst::LabelReachable
Reach	state-reachable.h	/^  bool Reach(StateId s) {$/;"	f	class:fst::StateReachable
ReachBegin	label-reachable.h	/^  ssize_t ReachBegin() const { return reach_begin_;  }$/;"	f	class:fst::LabelReachable
ReachEnd	label-reachable.h	/^  ssize_t ReachEnd() const { return reach_end_; }$/;"	f	class:fst::LabelReachable
ReachFinal	label-reachable.h	/^  bool ReachFinal() {$/;"	f	class:fst::LabelReachable
ReachInit	label-reachable.h	/^  void ReachInit(const F &fst, bool copy = false) {$/;"	f	class:fst::LabelReachable
ReachInput	label-reachable.h	/^  bool ReachInput() const { return reach_input_; }$/;"	f	class:fst::LabelReachableData
ReachWeight	label-reachable.h	/^  Weight ReachWeight() const { return reach_weight_; }$/;"	f	class:fst::LabelReachable
Read	add-on.h	/^  static AddOnImpl<F, T> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::AddOnImpl
Read	add-on.h	/^  static AddOnPair<A1, A2> *Read(istream &istrm) {$/;"	f	class:fst::AddOnPair
Read	add-on.h	/^  static NullAddOn *Read(istream &istrm) {$/;"	f	class:fst::NullAddOn
Read	compact-fst.h	/^  static AcceptorCompactor *Read(istream &strm) {$/;"	f	class:fst::AcceptorCompactor
Read	compact-fst.h	/^  static CompactFst<A, C, U> *Read(const string &filename) {$/;"	f	class:fst::CompactFst
Read	compact-fst.h	/^  static CompactFst<A, C, U> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::CompactFst
Read	compact-fst.h	/^  static CompactFstImpl<A, C, U> *Read(istream &strm,$/;"	f	class:fst::CompactFstImpl
Read	compact-fst.h	/^  static StringCompactor *Read(istream &strm) {$/;"	f	class:fst::StringCompactor
Read	compact-fst.h	/^  static UnweightedAcceptorCompactor *Read(istream &istrm) {$/;"	f	class:fst::UnweightedAcceptorCompactor
Read	compact-fst.h	/^  static UnweightedCompactor *Read(istream &strm) {$/;"	f	class:fst::UnweightedCompactor
Read	compact-fst.h	/^  static WeightedStringCompactor *Read(istream &strm) {$/;"	f	class:fst::WeightedStringCompactor
Read	compact-fst.h	/^CompactFstData<E, U> *CompactFstData<E, U>::Read($/;"	f	class:fst::CompactFstData
Read	const-fst.h	/^  static ConstFst<A, U> *Read(const string &filename) {$/;"	f	class:fst::ConstFst
Read	const-fst.h	/^  static ConstFst<A, U> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::ConstFst
Read	const-fst.h	/^ConstFstImpl<A, U> *ConstFstImpl<A, U>::Read(istream &strm,$/;"	f	class:fst::ConstFstImpl
Read	edit-fst.h	/^  Read(istream &strm,$/;"	f	class:fst::EditFst
Read	edit-fst.h	/^  static EditFst<A, WrappedFstT, MutableFstT> *Read(const string &filename) {$/;"	f	class:fst::EditFst
Read	edit-fst.h	/^EditFstData<A, WrappedFstT, MutableFstT>::Read(istream &strm,$/;"	f	class:fst::EditFstData
Read	edit-fst.h	/^EditFstImpl<A, WrappedFstT, MutableFstT>::Read(istream &strm,$/;"	f	class:fst::EditFstImpl
Read	encode.h	/^  static EncodeMapper<A> *Read(const string& filename,$/;"	f	class:fst::EncodeMapper
Read	encode.h	/^  static EncodeMapper<A> *Read(istream &strm,$/;"	f	class:fst::EncodeMapper
Read	encode.h	/^EncodeTable<A> *EncodeTable<A>::Read(istream &strm, const string &source) {$/;"	f	class:fst::EncodeTable
Read	expanded-fst.h	/^  static ExpandedFst<A> *Read(const string &filename) {$/;"	f	class:fst::ExpandedFst
Read	expanded-fst.h	/^  static ExpandedFst<A> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::ExpandedFst
Read	expanded-fst.h	/^  static I *Read(const string &filename) {$/;"	f	class:fst::ImplToExpandedFst
Read	float-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::FloatWeightTpl
Read	fst.h	/^  static Fst<A> *Read(const string &filename) {$/;"	f	class:fst::Fst
Read	fst.h	/^  static Fst<A> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::Fst
Read	interval-set.h	/^    istream &Read(istream &strm) {$/;"	f	struct:fst::IntervalSet::Interval
Read	interval-set.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::IntervalSet
Read	label-reachable.h	/^  static LabelReachableData<L> *Read(istream &istrm) {$/;"	f	class:fst::LabelReachableData
Read	matcher-fst.h	/^  static MatcherFst<F, M, N, I> *Read(const string &filename) {$/;"	f	class:fst::MatcherFst
Read	matcher-fst.h	/^  static MatcherFst<F, M, N, I> *Read(istream &strm,$/;"	f	class:fst::MatcherFst
Read	mutable-fst.h	/^  static MutableFst<A> *Read(const string &filename, bool convert = false,$/;"	f	class:fst::MutableFst
Read	mutable-fst.h	/^  static MutableFst<A> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::MutableFst
Read	pair-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::PairWeight
Read	sparse-tuple-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::SparseTupleWeight
Read	string-weight.h	/^inline istream &StringWeight<L, S>::Read(istream &strm) {$/;"	f	class:fst::StringWeight
Read	symbol-table.h	/^  static SymbolTable* Read(const string& filename) {$/;"	f	class:fst::SymbolTable
Read	symbol-table.h	/^  static SymbolTable* Read(istream &strm, const string& source) {$/;"	f	class:fst::SymbolTable
Read	symbol-table.h	/^  static SymbolTable* Read(istream &strm,$/;"	f	class:fst::SymbolTable
Read	tuple-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::TupleWeight
Read	vector-fst.h	/^  static VectorFst<A> *Read(const string &filename) {$/;"	f	class:fst::VectorFst
Read	vector-fst.h	/^  static VectorFst<A> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::VectorFst
Read	vector-fst.h	/^VectorFstImpl<A> *VectorFstImpl<A>::Read(istream &strm,$/;"	f	class:fst::VectorFstImpl
ReadHeader	fst.h	/^bool FstImpl<A>::ReadHeader(istream &strm, const FstReadOptions& opts,$/;"	f	class:fst::FstImpl
ReadLabelPairs	util.h	/^bool ReadLabelPairs(const string& filename,$/;"	f	namespace:fst
ReadNoParen	pair-weight.h	/^  inline static istream &ReadNoParen($/;"	f	class:fst::PairWeight
ReadNoParen	sparse-tuple-weight.h	/^inline istream& SparseTupleWeight<W, K>::ReadNoParen($/;"	f	class:fst::SparseTupleWeight
ReadNoParen	tuple-weight.h	/^  inline static istream &ReadNoParen(istream &strm,$/;"	f	class:fst::TupleWeight
ReadText	symbol-table.h	/^  static SymbolTable* ReadText(const string& filename,$/;"	f	class:fst::SymbolTable
ReadText	symbol-table.h	/^  static SymbolTable* ReadText(istream &strm,$/;"	f	class:fst::SymbolTable
ReadType	util.h	/^inline istream &ReadType(istream &strm, T *t) {$/;"	f	namespace:fst
ReadType	util.h	/^inline istream &ReadType(istream &strm, pair<S, T> *p) {$/;"	f	namespace:fst
ReadType	util.h	/^inline istream &ReadType(istream &strm, pair<const S, T> *p) {$/;"	f	namespace:fst
ReadType	util.h	/^inline istream &ReadType(istream &strm, string *s) {$/;"	f	namespace:fst
ReadWithParen	pair-weight.h	/^  inline static istream &ReadWithParen($/;"	f	class:fst::PairWeight
ReadWithParen	sparse-tuple-weight.h	/^inline istream& SparseTupleWeight<W, K>::ReadWithParen($/;"	f	class:fst::SparseTupleWeight
ReadWithParen	tuple-weight.h	/^  inline static istream &ReadWithParen(istream &strm,$/;"	f	class:fst::TupleWeight
Reader	register.h	/^  typedef Fst<A> *(*Reader)(istream &strm, const FstReadOptions &opts);$/;"	t	struct:fst::FstRegisterEntry
Reader	register.h	/^  typedef typename FstRegister<Arc>::Reader Reader;$/;"	t	class:fst::FstRegisterer
Reader	register.h	/^  typedef typename FstRegisterEntry<A>::Reader Reader;$/;"	t	class:fst::FstRegister
ReaderMutexLock	lock.h	/^  ReaderMutexLock(Mutex *) {}$/;"	f	class:fst::ReaderMutexLock
ReaderMutexLock	lock.h	/^class ReaderMutexLock {$/;"	c	namespace:fst
RefCount	accumulator.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::CacheLogAccumulatorData
RefCount	accumulator.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::FastLogAccumulatorData
RefCount	accumulator.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::ReplaceAccumulatorData
RefCount	add-on.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::AddOnPair
RefCount	add-on.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::NullAddOn
RefCount	compact-fst.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::CompactFstData
RefCount	edit-fst.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::EditFstData
RefCount	encode.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::EncodeTable
RefCount	fst.h	/^  int RefCount() const {$/;"	f	class:fst::FstImpl
RefCount	label-reachable.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::LabelReachableData
RefCount	symbol-table.h	/^  int RefCount() const {$/;"	f	class:fst::SymbolTableImpl
RefCounter	lock.h	/^  RefCounter() : count_(1) {}$/;"	f	class:fst::RefCounter
RefCounter	lock.h	/^class RefCounter {$/;"	c	namespace:fst
Refine	minimize.h	/^  void Refine(const Fst<A>& fst) {$/;"	f	class:fst::AcyclicMinimizer
RegisterMapType	generic-register.h	/^  typedef map<KeyType, EntryType> RegisterMapType;$/;"	t	class:fst::GenericRegister
Relabel	label-reachable.h	/^  Label Relabel(Label label) {$/;"	f	class:fst::LabelReachable
Relabel	label-reachable.h	/^  void Relabel(MutableFst<Arc> *fst, bool relabel_input) {$/;"	f	class:fst::LabelReachable
Relabel	lookahead-matcher.h	/^  static void Relabel(MutableFst<A> *fst, const L &mfst,$/;"	f	class:fst::LabelLookAheadRelabeler
Relabel	relabel.h	/^void Relabel($/;"	f	namespace:fst
Relabel	relabel.h	/^void Relabel(MutableFst<A> *fst,$/;"	f	namespace:fst
RelabelFst	relabel.h	/^  RelabelFst(const Fst<A>& fst,$/;"	f	class:fst::RelabelFst
RelabelFst	relabel.h	/^  RelabelFst(const RelabelFst<A> &fst, bool safe = false)$/;"	f	class:fst::RelabelFst
RelabelFst	relabel.h	/^class RelabelFst : public ImplToFst< RelabelFstImpl<A> > {$/;"	c	namespace:fst
RelabelFstImpl	relabel.h	/^  RelabelFstImpl(const Fst<A>& fst,$/;"	f	class:fst::RelabelFstImpl
RelabelFstImpl	relabel.h	/^  RelabelFstImpl(const RelabelFstImpl<A>& impl)$/;"	f	class:fst::RelabelFstImpl
RelabelFstImpl	relabel.h	/^class RelabelFstImpl : public CacheImpl<A> {$/;"	c	namespace:fst
RelabelFstOptions	relabel.h	/^typedef CacheOptions RelabelFstOptions;$/;"	t	namespace:fst
RelabelPairs	label-reachable.h	/^  void RelabelPairs(vector<pair<Label, Label> > *pairs,$/;"	f	class:fst::LabelReachable
RelabelPairs	lookahead-matcher.h	/^  static void RelabelPairs(const L &mfst, vector<pair<Label, Label> > *pairs,$/;"	f	class:fst::LabelLookAheadRelabeler
RelabelSymbolTable	symbol-table.h	/^SymbolTable *RelabelSymbolTable(const SymbolTable *table,$/;"	f	namespace:fst
RemoveWeight	push.h	/^void RemoveWeight(MutableFst<Arc> *fst, typename Arc::Weight w, bool at_final) {$/;"	f	namespace:fst::internal
Replace	rational.h	/^  ReplaceFst<A> *Replace() const {$/;"	f	class:fst::RationalFstImpl
Replace	replace.h	/^void Replace(const vector<pair<typename Arc::Label,$/;"	f	namespace:fst
ReplaceAccumulator	accumulator.h	/^  ReplaceAccumulator()$/;"	f	class:fst::ReplaceAccumulator
ReplaceAccumulator	accumulator.h	/^  ReplaceAccumulator(const ReplaceAccumulator<Accumulator, T> &acc)$/;"	f	class:fst::ReplaceAccumulator
ReplaceAccumulator	accumulator.h	/^  ReplaceAccumulator(const vector<Accumulator*> &accumulators)$/;"	f	class:fst::ReplaceAccumulator
ReplaceAccumulator	accumulator.h	/^class ReplaceAccumulator {$/;"	c	namespace:fst
ReplaceAccumulatorData	accumulator.h	/^  ReplaceAccumulatorData() : state_table_(0) {}$/;"	f	class:fst::ReplaceAccumulatorData
ReplaceAccumulatorData	accumulator.h	/^  ReplaceAccumulatorData(const vector<Accumulator*> &accumulators)$/;"	f	class:fst::ReplaceAccumulatorData
ReplaceAccumulatorData	accumulator.h	/^class ReplaceAccumulatorData {$/;"	c	namespace:fst
ReplaceByInstances	replace-util.h	/^void ReplaceUtil<Arc>::ReplaceByInstances(size_t ninstances) {$/;"	f	class:fst::ReplaceUtil
ReplaceBySize	replace-util.h	/^void ReplaceUtil<Arc>::ReplaceBySize(size_t nstates, size_t narcs,$/;"	f	class:fst::ReplaceUtil
ReplaceFingerprint	replace.h	/^  ReplaceFingerprint(const vector<uint64> *size_array)$/;"	f	class:fst::ReplaceFingerprint
ReplaceFingerprint	replace.h	/^class ReplaceFingerprint {$/;"	c	namespace:fst
ReplaceFst	replace.h	/^  ReplaceFst(const ReplaceFst<A, T>& fst, bool safe = false)$/;"	f	class:fst::ReplaceFst
ReplaceFst	replace.h	/^  ReplaceFst(const vector<pair<Label, const Fst<A>* > >& fst_array,$/;"	f	class:fst::ReplaceFst
ReplaceFst	replace.h	/^class ReplaceFst : public ImplToFst< ReplaceFstImpl<A, T> > {$/;"	c	namespace:fst
ReplaceFstImpl	replace.h	/^  ReplaceFstImpl(const ReplaceFstImpl& impl)$/;"	f	class:fst::ReplaceFstImpl
ReplaceFstImpl	replace.h	/^  ReplaceFstImpl(const vector< pair<Label, const Fst<A>* > >& fst_tuples,$/;"	f	class:fst::ReplaceFstImpl
ReplaceFstImpl	replace.h	/^class ReplaceFstImpl : public CacheImpl<A> {$/;"	c	namespace:fst
ReplaceFstMatcher	replace.h	/^  ReplaceFstMatcher(const ReplaceFst<A, T> &fst, fst::MatchType match_type)$/;"	f	class:fst::ReplaceFstMatcher
ReplaceFstMatcher	replace.h	/^  ReplaceFstMatcher(const ReplaceFstMatcher<A, T> &matcher, bool safe = false)$/;"	f	class:fst::ReplaceFstMatcher
ReplaceFstMatcher	replace.h	/^class ReplaceFstMatcher : public MatcherBase<A> {$/;"	c	namespace:fst
ReplaceFstOptions	replace.h	/^  ReplaceFstOptions()$/;"	f	struct:fst::ReplaceFstOptions
ReplaceFstOptions	replace.h	/^  ReplaceFstOptions(const CacheOptions &opts, int64 r)$/;"	f	struct:fst::ReplaceFstOptions
ReplaceFstOptions	replace.h	/^  ReplaceFstOptions(int64 r, bool epsilon_replace_arc)$/;"	f	struct:fst::ReplaceFstOptions
ReplaceFstOptions	replace.h	/^  explicit ReplaceFstOptions(int64 r)$/;"	f	struct:fst::ReplaceFstOptions
ReplaceFstOptions	replace.h	/^struct ReplaceFstOptions : CacheOptions {$/;"	s	namespace:fst
ReplaceFstStateFingerprint	replace.h	/^class ReplaceFstStateFingerprint {$/;"	c	namespace:fst
ReplaceHash	replace.h	/^class ReplaceHash {$/;"	c	namespace:fst
ReplaceLabels	replace-util.h	/^void ReplaceUtil<Arc>::ReplaceLabels(const vector<Label> &labels) {$/;"	f	class:fst::ReplaceUtil
ReplaceRootSelector	replace.h	/^class ReplaceRootSelector {$/;"	c	namespace:fst
ReplaceStateTuple	replace.h	/^  ReplaceStateTuple()$/;"	f	struct:fst::ReplaceStateTuple
ReplaceStateTuple	replace.h	/^  ReplaceStateTuple(PrefixId p, StateId f, StateId s)$/;"	f	struct:fst::ReplaceStateTuple
ReplaceStateTuple	replace.h	/^struct ReplaceStateTuple {$/;"	s	namespace:fst
ReplaceStats	replace-util.h	/^    ReplaceStats()$/;"	f	struct:fst::ReplaceUtil::ReplaceStats
ReplaceStats	replace-util.h	/^  struct ReplaceStats {$/;"	s	class:fst::ReplaceUtil
ReplaceTrivial	replace-util.h	/^  void ReplaceTrivial() { ReplaceBySize(2, 1, 1); }$/;"	f	class:fst::ReplaceUtil
ReplaceUnique	replace-util.h	/^  void ReplaceUnique() { ReplaceByInstances(1); }$/;"	f	class:fst::ReplaceUtil
ReplaceUtil	replace-util.h	/^ReplaceUtil<Arc>::ReplaceUtil($/;"	f	class:fst::ReplaceUtil
ReplaceUtil	replace-util.h	/^class ReplaceUtil {$/;"	c	namespace:fst
ReserveArcs	cache.h	/^  void ReserveArcs(StateId s, size_t n) {$/;"	f	class:fst::CacheBaseImpl
ReserveArcs	edit-fst.h	/^  void ReserveArcs(StateId s, size_t n) {$/;"	f	class:fst::EditFstImpl
ReserveArcs	mutable-fst.h	/^  virtual void ReserveArcs(StateId s, size_t n) { }  \/\/ Optional, Best effort.$/;"	f	class:fst::MutableFst
ReserveArcs	mutable-fst.h	/^  virtual void ReserveArcs(StateId s, size_t n) {$/;"	f	class:fst::ImplToMutableFst
ReserveArcs	vector-fst.h	/^  void ReserveArcs(StateId s, size_t n) { states_[s]->arcs.reserve(n); }$/;"	f	class:fst::VectorFstBaseImpl
ReserveArcs	vector-fst.h	/^  void ReserveArcs(StateId s, size_t n) {$/;"	f	class:fst::VectorFst
ReserveStates	edit-fst.h	/^  void ReserveStates(StateId s) {$/;"	f	class:fst::EditFstImpl
ReserveStates	mutable-fst.h	/^  virtual void ReserveStates(StateId n) { }  \/\/ Optional, best effort only.$/;"	f	class:fst::MutableFst
ReserveStates	mutable-fst.h	/^  virtual void ReserveStates(StateId s) {$/;"	f	class:fst::ImplToMutableFst
ReserveStates	vector-fst.h	/^  void ReserveStates(StateId n) { states_.reserve(n); }$/;"	f	class:fst::VectorFstBaseImpl
ReserveStates	vector-fst.h	/^  void ReserveStates(StateId n) {$/;"	f	class:fst::VectorFst
Reset	arc-map.h	/^  void Reset() {$/;"	f	class:fst::StateIterator
Reset	cache.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::CacheArcIterator
Reset	cache.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::CacheMutableArcIterator
Reset	cache.h	/^  void Reset() { s_ = 0; }$/;"	f	class:fst::CacheStateIterator
Reset	cache.h	/^  void Reset() {$/;"	f	struct:fst::CacheState
Reset	compact-fst.h	/^  void Reset() { pos_ = 0;  }$/;"	f	class:fst::ArcIterator
Reset	compact-fst.h	/^  void Reset() { s_ = 0; }$/;"	f	class:fst::StateIterator
Reset	compat.h	/^  void Reset() {$/;"	f	class:fst::CheckSummer
Reset	complement.h	/^  void Reset() {$/;"	f	class:fst::ArcIterator
Reset	complement.h	/^  void Reset() {$/;"	f	class:fst::StateIterator
Reset	const-fst.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::ArcIterator
Reset	const-fst.h	/^  void Reset() { s_ = 0; }$/;"	f	class:fst::StateIterator
Reset	factor-weight.h	/^  void Reset() { done_ = weight_.Size() <= 1; }$/;"	f	class:fst::StringFactor
Reset	factor-weight.h	/^  void Reset() { done_ = weight_.Value1().Size() <= 1; }$/;"	f	class:fst::GallicFactor
Reset	factor-weight.h	/^  void Reset() {}$/;"	f	class:fst::IdentityFactor
Reset	fst.h	/^  void Reset() { Reset_(); }         \/\/ Return to initial condition$/;"	f	class:fst::ArcIteratorBase
Reset	fst.h	/^  void Reset() { Reset_(); }    \/\/ Return to initial condition$/;"	f	class:fst::StateIteratorBase
Reset	fst.h	/^  void Reset() {$/;"	f	class:fst::ArcIterator
Reset	fst.h	/^  void Reset() {$/;"	f	class:fst::StateIterator
Reset	mutable-fst.h	/^  void Reset() { data_.base->Reset(); }$/;"	f	class:fst::MutableArcIterator
Reset	partition.h	/^  void Reset() {$/;"	f	class:fst::PartitionIterator
Reset	randgen.h	/^  void Reset() { sample_iter_ = sample_map_.begin(); }$/;"	f	class:fst::ArcSampler
Reset	relabel.h	/^  void Reset() {$/;"	f	class:fst::StateIterator
Reset	replace.h	/^  void Reset() { pos_ = 0;  }$/;"	f	class:fst::ArcIterator
Reset	sparse-tuple-weight.h	/^  void Reset() {$/;"	f	class:fst::SparseTupleWeightIterator
Reset	string-weight.h	/^  void Reset() {$/;"	f	class:fst::StringWeightIterator
Reset	string-weight.h	/^  void Reset() {$/;"	f	class:fst::StringWeightReverseIterator
Reset	symbol-table.h	/^  void Reset(void) {$/;"	f	class:fst::SymbolTableIterator
Reset	vector-fst.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::ArcIterator
Reset	vector-fst.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::MutableArcIterator
Reset	vector-fst.h	/^  void Reset() { s_ = 0; }$/;"	f	class:fst::StateIterator
Reset_	arc-map.h	/^  void Reset_() { Reset(); }$/;"	f	class:fst::StateIterator
Reset_	cache.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::CacheMutableArcIterator
Reset_	cache.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::CacheStateIterator
Reset_	complement.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::ArcIterator
Reset_	complement.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::StateIterator
Reset_	relabel.h	/^  void Reset_() { Reset(); }$/;"	f	class:fst::StateIterator
Reset_	vector-fst.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::MutableArcIterator
RevA	minimize.h	/^  typedef ReverseArc<A> RevA;$/;"	t	class:fst::CyclicMinimizer
Reverse	expectation-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::ExpectationWeight
Reverse	float-weight.h	/^  LogWeightTpl<T> Reverse() const { return *this; }$/;"	f	class:fst::LogWeightTpl
Reverse	float-weight.h	/^  MinMaxWeightTpl<T> Reverse() const { return *this; }$/;"	f	class:fst::MinMaxWeightTpl
Reverse	float-weight.h	/^  TropicalWeightTpl<T> Reverse() const { return *this; }$/;"	f	class:fst::TropicalWeightTpl
Reverse	lexicographic-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::LexicographicWeight
Reverse	pair-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::PairWeight
Reverse	power-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::PowerWeight
Reverse	product-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::ProductWeight
Reverse	reverse.h	/^void Reverse(const Fst<Arc> &ifst, MutableFst<RevArc> *ofst) {$/;"	f	namespace:fst
Reverse	signed-log-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::SignedLogWeightTpl
Reverse	sparse-power-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::SparsePowerWeight
Reverse	sparse-tuple-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::SparseTupleWeight
Reverse	string-weight.h	/^StringWeight<L, S>::Reverse() const {$/;"	f	class:fst::StringWeight
Reverse	tuple-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::TupleWeight
ReverseArc	arc.h	/^  ReverseArc() {}$/;"	f	struct:fst::ReverseArc
ReverseArc	arc.h	/^  ReverseArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::ReverseArc
ReverseArc	arc.h	/^template <class A> struct ReverseArc {$/;"	s	namespace:fst
ReverseWeight	expectation-weight.h	/^                            typename X2::ReverseWeight> ReverseWeight;$/;"	t	class:fst::ExpectationWeight
ReverseWeight	float-weight.h	/^  typedef LogWeightTpl ReverseWeight;$/;"	t	class:fst::LogWeightTpl
ReverseWeight	float-weight.h	/^  typedef MinMaxWeightTpl<T> ReverseWeight;$/;"	t	class:fst::MinMaxWeightTpl
ReverseWeight	float-weight.h	/^  typedef TropicalWeightTpl<T> ReverseWeight;$/;"	t	class:fst::TropicalWeightTpl
ReverseWeight	lexicographic-weight.h	/^  ReverseWeight;$/;"	t	class:fst::LexicographicWeight
ReverseWeight	pair-weight.h	/^  ReverseWeight;$/;"	t	class:fst::PairWeight
ReverseWeight	power-weight.h	/^  typedef PowerWeight<typename W::ReverseWeight, n> ReverseWeight;$/;"	t	class:fst::PowerWeight
ReverseWeight	product-weight.h	/^  ReverseWeight;$/;"	t	class:fst::ProductWeight
ReverseWeight	signed-log-weight.h	/^  typedef SignedLogWeightTpl<T> ReverseWeight;$/;"	t	class:fst::SignedLogWeightTpl
ReverseWeight	sparse-power-weight.h	/^  typedef SparsePowerWeight<typename W::ReverseWeight, K> ReverseWeight;$/;"	t	class:fst::SparsePowerWeight
ReverseWeight	sparse-tuple-weight.h	/^  typedef SparseTupleWeight<typename W::ReverseWeight, K> ReverseWeight;$/;"	t	class:fst::SparseTupleWeight
ReverseWeight	string-weight.h	/^  ReverseWeight;$/;"	t	struct:fst::GallicWeight
ReverseWeight	string-weight.h	/^  typedef StringWeight<L, REVERSE_STRING_TYPE(S)> ReverseWeight;$/;"	t	class:fst::StringWeight
ReverseWeight	tuple-weight.h	/^  typedef TupleWeight<typename W::ReverseWeight, n> ReverseWeight;$/;"	t	class:fst::TupleWeight
ReverseWeightMapper	arc-map.h	/^struct ReverseWeightMapper {$/;"	s	namespace:fst
Reweight	reweight.h	/^void Reweight(MutableFst<Arc> *fst,$/;"	f	namespace:fst
ReweightType	reweight.h	/^enum ReweightType { REWEIGHT_TO_INITIAL, REWEIGHT_TO_FINAL };$/;"	g	namespace:fst
RhoMatcher	matcher.h	/^  RhoMatcher(const FST &fst,$/;"	f	class:fst::RhoMatcher
RhoMatcher	matcher.h	/^  RhoMatcher(const RhoMatcher<M> &matcher, bool safe = false)$/;"	f	class:fst::RhoMatcher
RhoMatcher	matcher.h	/^class RhoMatcher : public MatcherBase<typename M::Arc> {$/;"	c	namespace:fst
Right	heap.h	/^  int Right(int i) {$/;"	f	class:fst::Heap
RmEpsilon	rmepsilon.h	/^void RmEpsilon(MutableFst<Arc> *fst,$/;"	f	namespace:fst
RmEpsilonFst	rmepsilon.h	/^  RmEpsilonFst(const Fst<A> &fst)$/;"	f	class:fst::RmEpsilonFst
RmEpsilonFst	rmepsilon.h	/^  RmEpsilonFst(const Fst<A> &fst, const RmEpsilonFstOptions &opts)$/;"	f	class:fst::RmEpsilonFst
RmEpsilonFst	rmepsilon.h	/^  RmEpsilonFst(const RmEpsilonFst<A> &fst, bool safe = false)$/;"	f	class:fst::RmEpsilonFst
RmEpsilonFst	rmepsilon.h	/^class RmEpsilonFst : public ImplToFst< RmEpsilonFstImpl<A> > {$/;"	c	namespace:fst
RmEpsilonFstImpl	rmepsilon.h	/^  RmEpsilonFstImpl(const Fst<A>& fst, const RmEpsilonFstOptions &opts)$/;"	f	class:fst::RmEpsilonFstImpl
RmEpsilonFstImpl	rmepsilon.h	/^  RmEpsilonFstImpl(const RmEpsilonFstImpl &impl)$/;"	f	class:fst::RmEpsilonFstImpl
RmEpsilonFstImpl	rmepsilon.h	/^class RmEpsilonFstImpl : public CacheImpl<A> {$/;"	c	namespace:fst
RmEpsilonFstOptions	rmepsilon.h	/^  RmEpsilonFstOptions(const CacheOptions &opts, float delta = kDelta)$/;"	f	struct:fst::RmEpsilonFstOptions
RmEpsilonFstOptions	rmepsilon.h	/^  explicit RmEpsilonFstOptions(float delta = kDelta) : delta(delta) {}$/;"	f	struct:fst::RmEpsilonFstOptions
RmEpsilonFstOptions	rmepsilon.h	/^struct RmEpsilonFstOptions : CacheOptions {$/;"	s	namespace:fst
RmEpsilonOptions	rmepsilon.h	/^  explicit RmEpsilonOptions(Queue *q, float d = kDelta, bool c = true,$/;"	f	class:fst::RmEpsilonOptions
RmEpsilonOptions	rmepsilon.h	/^class RmEpsilonOptions$/;"	c	namespace:fst
RmEpsilonState	rmepsilon.h	/^  RmEpsilonState(const Fst<Arc> &fst,$/;"	f	class:fst::RmEpsilonState
RmEpsilonState	rmepsilon.h	/^class RmEpsilonState {$/;"	c	namespace:fst
RmFinalEpsilon	rmfinalepsilon.h	/^void RmFinalEpsilon(MutableFst<A>* fst) {$/;"	f	namespace:fst
RmWeightMapper	arc-map.h	/^struct RmWeightMapper {$/;"	s	namespace:fst
S	randgen.h	/^  typedef FastLogProbArcSelector<A> S;$/;"	t	class:fst::ArcSampler
SCC_QUEUE	queue.h	/^  SCC_QUEUE = 6,             \/\/ Component graph top-ordered meta-queue$/;"	e	enum:fst::QueueType
SEQUENCE_FILTER	compose.h	/^enum ComposeFilter { AUTO_FILTER, SEQUENCE_FILTER, ALT_SEQUENCE_FILTER,$/;"	e	enum:fst::ComposeFilter
SET_FLAGS	flags.h	232;"	d
SF	lookahead-filter.h	/^  typedef AltSequenceComposeFilter<M> SF;$/;"	t	class:fst::DefaultLookAhead
SF	lookahead-filter.h	/^  typedef SequenceComposeFilter<M> SF;$/;"	t	class:fst::DefaultLookAhead
SHORTEST_FIRST_QUEUE	queue.h	/^  SHORTEST_FIRST_QUEUE = 3,  \/\/ Shortest-first queue$/;"	e	enum:fst::QueueType
STATE_ORDER_QUEUE	queue.h	/^  STATE_ORDER_QUEUE = 5,     \/\/ State-ID ordered queue$/;"	e	enum:fst::QueueType
STRING_LEFT	string-weight.h	/^enum StringType { STRING_LEFT = 0, STRING_RIGHT = 1 ,$/;"	e	enum:fst::StringType
STRING_LEFT_RESTRICT	string-weight.h	/^                  STRING_LEFT_RESTRICT = 2, STRING_RIGHT_RESTRICT };$/;"	e	enum:fst::StringType
STRING_RIGHT	string-weight.h	/^enum StringType { STRING_LEFT = 0, STRING_RIGHT = 1 ,$/;"	e	enum:fst::StringType
STRING_RIGHT_RESTRICT	string-weight.h	/^                  STRING_LEFT_RESTRICT = 2, STRING_RIGHT_RESTRICT };$/;"	e	enum:fst::StringType
SW	arc-map.h	/^  typedef StringWeight<Label, S> SW;$/;"	t	struct:fst::FromGallicMapper
SW	arc-map.h	/^  typedef StringWeight<Label, S> SW;$/;"	t	struct:fst::GallicToNewSymbolsMapper
SW	arc-map.h	/^  typedef StringWeight<typename A::Label, S> SW;$/;"	t	struct:fst::ToGallicMapper
SYMBOL	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringCompiler::TokenType
SYMBOL	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringPrinter::TokenType
Sample	randgen.h	/^  bool Sample(const RandState<A> &rstate) {$/;"	f	class:fst::ArcSampler
Sampler	randgen.h	/^  typedef S Sampler;$/;"	t	class:fst::RandGenFst
SccQueue	queue.h	/^  SccQueue(const vector<StateId> &scc, vector<Queue*> *queue)$/;"	f	class:fst::SccQueue
SccQueue	queue.h	/^class SccQueue : public QueueBase<S> {$/;"	c	namespace:fst
SccQueueType	queue.h	/^void AutoQueue<StateId>::SccQueueType(const Fst<A> &fst,$/;"	f	class:fst::AutoQueue
SccVisitor	connect.h	/^  SccVisitor(uint64 *props)$/;"	f	class:fst::SccVisitor
SccVisitor	connect.h	/^  SccVisitor(vector<StateId> *scc, vector<bool> *access,$/;"	f	class:fst::SccVisitor
SccVisitor	connect.h	/^class SccVisitor {$/;"	c	namespace:fst
Second	add-on.h	/^  A2 *Second() const { return a2_; }$/;"	f	class:fst::AddOnPair
Seed	randgen.h	/^  int Seed() const { return seed_; }$/;"	f	class:fst::FastLogProbArcSelector
Seek	cache.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::CacheArcIterator
Seek	cache.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::CacheMutableArcIterator
Seek	compact-fst.h	/^  void Seek(size_t pos) { pos_ = pos; }$/;"	f	class:fst::ArcIterator
Seek	complement.h	/^  void Seek(size_t a) {$/;"	f	class:fst::ArcIterator
Seek	const-fst.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::ArcIterator
Seek	fst.h	/^  void Seek(size_t a) { Seek_(a); }  \/\/ Random arc access by position$/;"	f	class:fst::ArcIteratorBase
Seek	fst.h	/^  void Seek(size_t a) {$/;"	f	class:fst::ArcIterator
Seek	mutable-fst.h	/^  void Seek(size_t a) { data_.base->Seek(a); }$/;"	f	class:fst::MutableArcIterator
Seek	replace.h	/^  void Seek(size_t pos) { pos_ = pos; }$/;"	f	class:fst::ArcIterator
Seek	vector-fst.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::ArcIterator
Seek	vector-fst.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::MutableArcIterator
Seek_	cache.h	/^  virtual void Seek_(size_t a) { Seek(a); }$/;"	f	class:fst::CacheMutableArcIterator
Seek_	complement.h	/^  virtual void Seek_(size_t a) { Seek(a); }$/;"	f	class:fst::ArcIterator
Seek_	vector-fst.h	/^  virtual void Seek_(size_t a) { Seek(a); }$/;"	f	class:fst::MutableArcIterator
Selector	bi-table.h	/^  const S &Selector() const { return *selector_; }$/;"	f	class:fst::VectorHashBiTable
Selector	lookahead-filter.h	/^  &Selector() const {$/;"	f	class:fst::PushLabelsComposeFilter
Selector	lookahead-filter.h	/^  const LookAheadSelector<Matcher1, Matcher2, MT> &Selector() const {$/;"	f	class:fst::LookAheadComposeFilter
Selector	lookahead-filter.h	/^  const LookAheadSelector<Matcher1, Matcher2, MT> &Selector() const {$/;"	f	class:fst::PushWeightsComposeFilter
SequenceComposeFilter	compose-filter.h	/^  SequenceComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::SequenceComposeFilter
SequenceComposeFilter	compose-filter.h	/^  SequenceComposeFilter(const SequenceComposeFilter<M1, M2> &filter,$/;"	f	class:fst::SequenceComposeFilter
SequenceComposeFilter	compose-filter.h	/^class SequenceComposeFilter {$/;"	c	namespace:fst
SetAddOn	add-on.h	/^  void SetAddOn(T *t) {$/;"	f	class:fst::AddOnImpl
SetArcType	fst.h	/^  void SetArcType(const string& type) { arctype_ = type; }$/;"	f	class:fst::FstHeader
SetArcs	cache.h	/^  void SetArcs(StateId s) {$/;"	f	class:fst::CacheBaseImpl
SetCompactElements	compact-fst.h	/^  void SetCompactElements(const Iterator &b, const Iterator &e) {$/;"	f	class:fst::CompactFst
SetCompactElements	compact-fst.h	/^  void SetCompactElements(const Iterator &b, const Iterator &e) {$/;"	f	class:fst::CompactFstImpl
SetDefaultValue	sparse-tuple-weight.h	/^  void SetDefaultValue(const W& val) { default_ = val; }$/;"	f	class:fst::SparseTupleWeight
SetDescription	flags.h	/^  void SetDescription(const string &name,$/;"	f	class:FlagRegister
SetEditedProperties	edit-fst.h	/^  void SetEditedProperties(uint64 props, uint64 mask) {$/;"	f	class:fst::EditFstData
SetEmptyAndDeleteKeysForInternalMaps	edit-fst.h	/^  void SetEmptyAndDeleteKeysForInternalMaps() {$/;"	f	class:fst::EditFstData
SetEntry	generic-register.h	/^  void SetEntry(const KeyType &key,$/;"	f	class:fst::GenericRegister
SetError	queue.h	/^  void SetError(bool error) { error_ = error; }$/;"	f	class:fst::QueueBase
SetFinal	cache.h	/^  void SetFinal(StateId s, Weight w) {$/;"	f	class:fst::CacheBaseImpl
SetFinal	edit-fst.h	/^  Weight SetFinal(StateId s, Weight w, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
SetFinal	edit-fst.h	/^  void SetFinal(StateId s, Weight w) {$/;"	f	class:fst::EditFstImpl
SetFinal	mutable-fst.h	/^  virtual void SetFinal(StateId s, Weight w) {$/;"	f	class:fst::ImplToMutableFst
SetFinal	vector-fst.h	/^  void SetFinal(StateId s, Weight w) { states_[s]->final = w; }$/;"	f	class:fst::VectorFstBaseImpl
SetFinal	vector-fst.h	/^  void SetFinal(StateId s, Weight w) {$/;"	f	class:fst::VectorFstImpl
SetFinalProperties	properties.h	/^uint64 SetFinalProperties(uint64 inprops, Weight old_weight,$/;"	f	namespace:fst
SetFlag	flags.h	/^  bool SetFlag(const string &arg, const string &val) const {$/;"	f	class:FlagRegister
SetFlag	flags.h	/^  bool SetFlag(const string &val, bool *address) const {$/;"	f	class:FlagRegister
SetFlag	flags.h	/^  bool SetFlag(const string &val, double *address) const {$/;"	f	class:FlagRegister
SetFlag	flags.h	/^  bool SetFlag(const string &val, int32 *address) const {$/;"	f	class:FlagRegister
SetFlag	flags.h	/^  bool SetFlag(const string &val, int64 *address) const {$/;"	f	class:FlagRegister
SetFlag	flags.h	/^  bool SetFlag(const string &val, string *address) const {$/;"	f	class:FlagRegister
SetFlags	cache.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::CacheMutableArcIterator
SetFlags	cache.h	/^  void SetFlags(uint32 flags, uint32 mask) {}$/;"	f	class:fst::CacheArcIterator
SetFlags	compact-fst.h	/^  void SetFlags(uint32 f, uint32 m) {$/;"	f	class:fst::ArcIterator
SetFlags	complement.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::ArcIterator
SetFlags	const-fst.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::ArcIterator
SetFlags	fst.h	/^  void SetFlags(int32 flags) { flags_ = flags; }$/;"	f	class:fst::FstHeader
SetFlags	fst.h	/^  void SetFlags(uint32 flags, uint32 mask) {  \/\/ Set behavorial flags$/;"	f	class:fst::ArcIteratorBase
SetFlags	fst.h	/^  void SetFlags(uint32 flags, uint32 mask) {$/;"	f	class:fst::ArcIterator
SetFlags	mutable-fst.h	/^  void SetFlags(uint32 f, uint32 m) {$/;"	f	class:fst::MutableArcIterator
SetFlags	replace.h	/^  void SetFlags(uint32 f, uint32 mask) {$/;"	f	class:fst::ArcIterator
SetFlags	vector-fst.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::ArcIterator
SetFlags	vector-fst.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::MutableArcIterator
SetFlags_	cache.h	/^  void SetFlags_(uint32 f, uint32 m) { SetFlags(f, m); }$/;"	f	class:fst::CacheMutableArcIterator
SetFlags_	complement.h	/^  void SetFlags_(uint32 f, uint32 m) { SetFlags(f, m); }$/;"	f	class:fst::ArcIterator
SetFlags_	vector-fst.h	/^  void SetFlags_(uint32 f, uint32 m) { SetFlags(f, m); }$/;"	f	class:fst::MutableArcIterator
SetFstType	fst.h	/^  void SetFstType(const string& type) { fsttype_ = type; }$/;"	f	class:fst::FstHeader
SetImpl	compact-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = false) {$/;"	f	class:fst::CompactFst
SetImpl	const-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = true) {$/;"	f	class:fst::ConstFst
SetImpl	edit-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = true) {$/;"	f	class:fst::EditFst
SetImpl	fst.h	/^  void SetImpl(I *impl, bool own_impl = true) {$/;"	f	class:fst::ImplToFst
SetImpl	matcher-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = true) {$/;"	f	class:fst::MatcherFst
SetImpl	vector-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = true) {$/;"	f	class:fst::VectorFst
SetInputSymbols	encode.h	/^  void SetInputSymbols(const SymbolTable* syms) {$/;"	f	class:fst::EncodeMapper
SetInputSymbols	encode.h	/^  void SetInputSymbols(const SymbolTable* syms) {$/;"	f	class:fst::EncodeTable
SetInputSymbols	fst.h	/^  void SetInputSymbols(const SymbolTable* isyms) {$/;"	f	class:fst::FstImpl
SetInputSymbols	mutable-fst.h	/^  virtual void SetInputSymbols(const SymbolTable* isyms) {$/;"	f	class:fst::ImplToMutableFst
SetLookAheadPrefix	lookahead-matcher.h	/^  void SetLookAheadPrefix(const Arc &arc) { prefix_arc_ = arc; }$/;"	f	class:fst::LookAheadMatcherBase
SetLookAheadWeight	lookahead-matcher.h	/^  void SetLookAheadWeight(const Weight &w) { weight_ = w; }$/;"	f	class:fst::LookAheadMatcherBase
SetNumArcs	fst.h	/^  void SetNumArcs(int64 numarcs) { numarcs_ = numarcs; }$/;"	f	class:fst::FstHeader
SetNumStates	fst.h	/^  void SetNumStates(int64 numstates) { numstates_ = numstates; }$/;"	f	class:fst::FstHeader
SetOutputSymbols	encode.h	/^  void SetOutputSymbols(const SymbolTable* syms) {$/;"	f	class:fst::EncodeMapper
SetOutputSymbols	encode.h	/^  void SetOutputSymbols(const SymbolTable* syms) {$/;"	f	class:fst::EncodeTable
SetOutputSymbols	fst.h	/^  void SetOutputSymbols(const SymbolTable* osyms) {$/;"	f	class:fst::FstImpl
SetOutputSymbols	mutable-fst.h	/^  virtual void SetOutputSymbols(const SymbolTable* osyms) {$/;"	f	class:fst::ImplToMutableFst
SetProperties	fst.h	/^  void SetProperties(uint64 properties) { properties_ = properties; }$/;"	f	class:fst::FstHeader
SetProperties	fst.h	/^  void SetProperties(uint64 props) {$/;"	f	class:fst::FstImpl
SetProperties	fst.h	/^  void SetProperties(uint64 props, uint64 mask) const {$/;"	f	class:fst::FstImpl
SetProperties	fst.h	/^  void SetProperties(uint64 props, uint64 mask) {$/;"	f	class:fst::FstImpl
SetProperties	mutable-fst.h	/^  virtual void SetProperties(uint64 props, uint64 mask) {$/;"	f	class:fst::ImplToMutableFst
SetStart	cache.h	/^  void SetStart(StateId s) {$/;"	f	class:fst::CacheBaseImpl
SetStart	edit-fst.h	/^  void SetStart(StateId s) {$/;"	f	class:fst::EditFstData
SetStart	edit-fst.h	/^  void SetStart(StateId s) {$/;"	f	class:fst::EditFstImpl
SetStart	fst.h	/^  void SetStart(int64 start) { start_ = start; }$/;"	f	class:fst::FstHeader
SetStart	mutable-fst.h	/^  virtual void SetStart(StateId s) {$/;"	f	class:fst::ImplToMutableFst
SetStart	vector-fst.h	/^  void SetStart(StateId s) { start_ = s; }$/;"	f	class:fst::VectorFstBaseImpl
SetStart	vector-fst.h	/^  void SetStart(StateId s) {$/;"	f	class:fst::VectorFstImpl
SetStartProperties	properties.h	/^uint64 SetStartProperties(uint64 inprops) {$/;"	f	namespace:fst
SetState	accumulator.h	/^  void SetState(StateId s) {$/;"	f	class:fst::FastLogAccumulator
SetState	accumulator.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ReplaceAccumulator
SetState	accumulator.h	/^  void SetState(StateId s, int depth = 0) {$/;"	f	class:fst::CacheLogAccumulator
SetState	accumulator.h	/^  void SetState(StateId) {}$/;"	f	class:fst::DefaultAccumulator
SetState	accumulator.h	/^  void SetState(StateId) {}$/;"	f	class:fst::LogAccumulator
SetState	arcsort.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ArcSortMapper
SetState	compose-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::AltSequenceComposeFilter
SetState	compose-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::MatchComposeFilter
SetState	compose-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::MultiEpsFilter
SetState	compose-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::SequenceComposeFilter
SetState	compose-filter.h	/^  void SetState(T state) { state_ = state; }$/;"	f	class:fst::IntegerFilterState
SetState	compose-filter.h	/^  void SetState(const F1 &f1, const F2 &f2) {$/;"	f	class:fst::PairFilterState
SetState	label-reachable.h	/^  void SetState(StateId s, StateId aiter_s = kNoStateId) {$/;"	f	class:fst::LabelReachable
SetState	lookahead-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::LookAheadComposeFilter
SetState	lookahead-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::PushLabelsComposeFilter
SetState	lookahead-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::PushWeightsComposeFilter
SetState	lookahead-matcher.h	/^  void SetState(StateId s) { base_->SetState(s); }$/;"	f	class:fst::LookAheadMatcher
SetState	lookahead-matcher.h	/^  void SetState(StateId s) { return matcher_.SetState(s); }$/;"	f	class:fst::TrivialLookAheadMatcher
SetState	lookahead-matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ArcLookAheadMatcher
SetState	lookahead-matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::LabelLookAheadMatcher
SetState	matcher-fst.h	/^  void SetState(StateId s) { matcher_->SetState(s); }$/;"	f	class:fst::LookAheadMatcher
SetState	matcher-fst.h	/^  void SetState(StateId s) { matcher_->SetState(s); }$/;"	f	class:fst::Matcher
SetState	matcher.h	/^  void SetState(StateId s) { SetState_(s); }$/;"	f	class:fst::MatcherBase
SetState	matcher.h	/^  void SetState(StateId s) { base_->SetState(s); }$/;"	f	class:fst::Matcher
SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::MultiEpsMatcher
SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::PhiMatcher
SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::RhoMatcher
SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::SigmaMatcher
SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::SortedMatcher
SetState	state-map.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ArcSumMapper
SetState	state-map.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ArcUniqueMapper
SetState	state-map.h	/^  void SetState(StateId s) {$/;"	f	class:fst::IdentityStateMapper
SetState	state-reachable.h	/^  void SetState(StateId s) { s_ = s; }$/;"	f	class:fst::StateReachable
SetState	vector-fst.h	/^  void SetState(StateId s, State *state) { states_[s] = state; }$/;"	f	class:fst::VectorFstBaseImpl
SetState_	lookahead-matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::ArcLookAheadMatcher
SetState_	lookahead-matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::LabelLookAheadMatcher
SetState_	lookahead-matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::TrivialLookAheadMatcher
SetState_	matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::PhiMatcher
SetState_	matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::RhoMatcher
SetState_	matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::SigmaMatcher
SetState_	matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::SortedMatcher
SetState_	replace.h	/^  virtual void SetState_(StateId s) {$/;"	f	class:fst::ReplaceFstMatcher
SetType	fst.h	/^  void SetType(const string &type) { type_ = type; }$/;"	f	class:fst::FstImpl
SetValue	cache.h	/^  void SetValue(const Arc& arc) {$/;"	f	class:fst::CacheMutableArcIterator
SetValue	float-weight.h	/^  void SetValue(const T &f) { value_ = f; }$/;"	f	class:fst::FloatWeightTpl
SetValue	mutable-fst.h	/^  void SetValue(const A &arc) { SetValue_(arc); }  \/\/ Set current arc's content$/;"	f	class:fst::MutableArcIteratorBase
SetValue	mutable-fst.h	/^  void SetValue(const Arc &a) { data_.base->SetValue(a); }$/;"	f	class:fst::MutableArcIterator
SetValue	tuple-weight.h	/^  void SetValue(size_t i, const W &w) { values_[i] = w; }$/;"	f	class:fst::TupleWeight
SetValue	vector-fst.h	/^  void SetValue(const A &arc) {$/;"	f	class:fst::MutableArcIterator
SetValue1	pair-weight.h	/^  void SetValue1(const W1 &w) { value1_ = w; }$/;"	f	class:fst::PairWeight
SetValue2	pair-weight.h	/^  void SetValue2(const W2 &w) { value2_ = w; }$/;"	f	class:fst::PairWeight
SetValue_	cache.h	/^  virtual void SetValue_(const Arc &a) { SetValue(a); }$/;"	f	class:fst::CacheMutableArcIterator
SetValue_	vector-fst.h	/^  virtual void SetValue_(const A &a) { SetValue(a); }$/;"	f	class:fst::MutableArcIterator
SetVersion	fst.h	/^  void SetVersion(int32 version) { version_ = version; }$/;"	f	class:fst::FstHeader
SetWeight	compose-filter.h	/^  void SetWeight(W w) { weight_ = w; }$/;"	f	class:fst::WeightFilterState
ShortFilterState	compose-filter.h	/^typedef IntegerFilterState<short> ShortFilterState;$/;"	t	namespace:fst
ShortFilterState	fst-decl.h	/^typedef IntegerFilterState<short> ShortFilterState;$/;"	t	namespace:fst
ShortestDistance	shortest-distance.h	/^typename Arc::Weight ShortestDistance(const Fst<Arc> &fst, float delta = kDelta) {$/;"	f	namespace:fst
ShortestDistance	shortest-distance.h	/^void ShortestDistance($/;"	f	namespace:fst
ShortestDistance	shortest-distance.h	/^void ShortestDistance(const Fst<Arc> &fst,$/;"	f	namespace:fst
ShortestDistance	shortest-distance.h	/^void ShortestDistanceState<Arc, Queue, ArcFilter>::ShortestDistance($/;"	f	class:fst::ShortestDistanceState
ShortestDistanceOptions	shortest-distance.h	/^  ShortestDistanceOptions(Queue *q, ArcFilter filt, StateId src = kNoStateId,$/;"	f	struct:fst::ShortestDistanceOptions
ShortestDistanceOptions	shortest-distance.h	/^struct ShortestDistanceOptions {$/;"	s	namespace:fst
ShortestDistanceState	shortest-distance.h	/^  ShortestDistanceState($/;"	f	class:fst::ShortestDistanceState
ShortestDistanceState	shortest-distance.h	/^class ShortestDistanceState {$/;"	c	namespace:fst
ShortestFirstQueue	queue.h	/^  ShortestFirstQueue(C comp)$/;"	f	class:fst::ShortestFirstQueue
ShortestFirstQueue	queue.h	/^class ShortestFirstQueue : public QueueBase<S> {$/;"	c	namespace:fst
ShortestPath	shortest-path.h	/^void ShortestPath(const Fst<Arc> &ifst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
ShortestPathCompare	shortest-path.h	/^  ShortestPathCompare(const vector<Pair>& pairs,$/;"	f	class:fst::ShortestPathCompare
ShortestPathCompare	shortest-path.h	/^class ShortestPathCompare {$/;"	c	namespace:fst
ShortestPathOptions	shortest-path.h	/^  ShortestPathOptions(Queue *q, ArcFilter filt, size_t n = 1, bool u = false,$/;"	f	struct:fst::ShortestPathOptions
ShortestPathOptions	shortest-path.h	/^struct ShortestPathOptions$/;"	s	namespace:fst
SigmaMatcher	matcher.h	/^  SigmaMatcher(const FST &fst,$/;"	f	class:fst::SigmaMatcher
SigmaMatcher	matcher.h	/^  SigmaMatcher(const SigmaMatcher<M> &matcher, bool safe = false)$/;"	f	class:fst::SigmaMatcher
SigmaMatcher	matcher.h	/^class SigmaMatcher : public MatcherBase<typename M::Arc> {$/;"	c	namespace:fst
SignedLog64Arc	arc.h	/^typedef ArcTpl<SignedLog64Weight> SignedLog64Arc;$/;"	t	namespace:fst
SignedLog64Weight	signed-log-weight.h	/^typedef SignedLogWeightTpl<double> SignedLog64Weight;$/;"	t	namespace:fst
SignedLogArc	arc.h	/^typedef ArcTpl<SignedLogWeight> SignedLogArc;$/;"	t	namespace:fst
SignedLogConvertCheck	signed-log-weight.h	/^bool SignedLogConvertCheck(W1 w) {$/;"	f	namespace:fst
SignedLogWeight	signed-log-weight.h	/^typedef SignedLogWeightTpl<float> SignedLogWeight;$/;"	t	namespace:fst
SignedLogWeightGenerator	random-weight.h	/^typedef SignedLogWeightGenerator_<float> SignedLogWeightGenerator;$/;"	t	namespace:fst
SignedLogWeightGenerator_	random-weight.h	/^  SignedLogWeightGenerator_(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::SignedLogWeightGenerator_
SignedLogWeightGenerator_	random-weight.h	/^class SignedLogWeightGenerator_ {$/;"	c	namespace:fst
SignedLogWeightTpl	signed-log-weight.h	/^  SignedLogWeightTpl() : PairWeight<X1, X2>() {}$/;"	f	class:fst::SignedLogWeightTpl
SignedLogWeightTpl	signed-log-weight.h	/^  SignedLogWeightTpl(const PairWeight<X1, X2>& w)$/;"	f	class:fst::SignedLogWeightTpl
SignedLogWeightTpl	signed-log-weight.h	/^  SignedLogWeightTpl(const SignedLogWeightTpl<T>& w)$/;"	f	class:fst::SignedLogWeightTpl
SignedLogWeightTpl	signed-log-weight.h	/^  SignedLogWeightTpl(const X1& x1, const X2& x2)$/;"	f	class:fst::SignedLogWeightTpl
SignedLogWeightTpl	signed-log-weight.h	/^class SignedLogWeightTpl$/;"	c	namespace:fst
SingleShortestPath	shortest-path.h	/^void SingleShortestPath(const Fst<Arc> &ifst,$/;"	f	namespace:fst
Singleton	interval-set.h	/^  bool Singleton() const {$/;"	f	class:fst::IntervalSet
Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::CompactHashBiTable
Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::ErasableBiTable
Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::HashBiTable
Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::VectorBiTable
Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::VectorHashBiTable
Size	compact-fst.h	/^  ssize_t Size() const { return -1; }$/;"	f	class:fst::UnweightedCompactor
Size	compact-fst.h	/^  ssize_t Size() const { return -1;}$/;"	f	class:fst::AcceptorCompactor
Size	compact-fst.h	/^  ssize_t Size() const { return -1;}$/;"	f	class:fst::UnweightedAcceptorCompactor
Size	compact-fst.h	/^  ssize_t Size() const { return 1; }$/;"	f	class:fst::StringCompactor
Size	compact-fst.h	/^  ssize_t Size() const { return 1;}$/;"	f	class:fst::WeightedStringCompactor
Size	encode.h	/^  size_t Size() const { return encode_tuples_.size(); }$/;"	f	class:fst::EncodeTable
Size	interval-set.h	/^  const T Size() const { return intervals_.size(); }$/;"	f	class:fst::IntervalSet
Size	sparse-tuple-weight.h	/^  size_t Size() const {$/;"	f	class:fst::SparseTupleWeight
Size	string-weight.h	/^  size_t Size() const { return first_ ? rest_.size() + 1 : 0; }$/;"	f	class:fst::StringWeight
SortedMatcher	matcher.h	/^  SortedMatcher(const F &fst, MatchType match_type,$/;"	f	class:fst::SortedMatcher
SortedMatcher	matcher.h	/^  SortedMatcher(const SortedMatcher<F> &matcher, bool safe = false)$/;"	f	class:fst::SortedMatcher
SortedMatcher	matcher.h	/^class SortedMatcher : public MatcherBase<typename F::Arc> {$/;"	c	namespace:fst
SparsePowerArc	arc.h	/^  SparsePowerArc() {}$/;"	f	struct:fst::SparsePowerArc
SparsePowerArc	arc.h	/^  SparsePowerArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::SparsePowerArc
SparsePowerArc	arc.h	/^struct SparsePowerArc {$/;"	s	namespace:fst
SparsePowerWeight	sparse-power-weight.h	/^  SparsePowerWeight() {}$/;"	f	class:fst::SparsePowerWeight
SparsePowerWeight	sparse-power-weight.h	/^  SparsePowerWeight(Iterator begin, Iterator end) :$/;"	f	class:fst::SparsePowerWeight
SparsePowerWeight	sparse-power-weight.h	/^  SparsePowerWeight(const K &key, const W &w) :$/;"	f	class:fst::SparsePowerWeight
SparsePowerWeight	sparse-power-weight.h	/^  SparsePowerWeight(const SparseTupleWeight<W, K> &w) :$/;"	f	class:fst::SparsePowerWeight
SparsePowerWeight	sparse-power-weight.h	/^class SparsePowerWeight : public SparseTupleWeight<W, K> {$/;"	c	namespace:fst
SparsePowerWeightGenerator	random-weight.h	/^  SparsePowerWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::SparsePowerWeightGenerator
SparsePowerWeightGenerator	random-weight.h	/^class SparsePowerWeightGenerator {$/;"	c	namespace:fst
SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight() {$/;"	f	class:fst::SparseTupleWeight
SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight(Iterator begin, Iterator end) {$/;"	f	class:fst::SparseTupleWeight
SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight(const K& key, const W &w) {$/;"	f	class:fst::SparseTupleWeight
SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight(const SparseTupleWeight<W, K> &w) {$/;"	f	class:fst::SparseTupleWeight
SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight(const W &w) {$/;"	f	class:fst::SparseTupleWeight
SparseTupleWeight	sparse-tuple-weight.h	/^class SparseTupleWeight {$/;"	c	namespace:fst
SparseTupleWeightApproxMapper	sparse-power-weight.h	/^  SparseTupleWeightApproxMapper(float delta) { delta_ = delta; }$/;"	f	struct:fst::SparseTupleWeightApproxMapper
SparseTupleWeightApproxMapper	sparse-power-weight.h	/^struct SparseTupleWeightApproxMapper {$/;"	s	namespace:fst
SparseTupleWeightDivideMapper	sparse-power-weight.h	/^  SparseTupleWeightDivideMapper(DivideType divide_type) {$/;"	f	struct:fst::SparseTupleWeightDivideMapper
SparseTupleWeightDivideMapper	sparse-power-weight.h	/^struct SparseTupleWeightDivideMapper {$/;"	s	namespace:fst
SparseTupleWeightIterator	sparse-tuple-weight.h	/^  explicit SparseTupleWeightIterator(const SparseTupleWeight<W, K>& w)$/;"	f	class:fst::SparseTupleWeightIterator
SparseTupleWeightIterator	sparse-tuple-weight.h	/^class SparseTupleWeightIterator {$/;"	c	namespace:fst
SparseTupleWeightMap	sparse-tuple-weight.h	/^inline void SparseTupleWeightMap($/;"	f	namespace:fst
SparseTupleWeightPlusMapper	sparse-power-weight.h	/^struct SparseTupleWeightPlusMapper {$/;"	s	namespace:fst
SparseTupleWeightTimesMapper	sparse-power-weight.h	/^struct SparseTupleWeightTimesMapper {$/;"	s	namespace:fst
Split	minimize.h	/^  void Split(ClassId C) {$/;"	f	class:fst::CyclicMinimizer
SplitOn	partition.h	/^  void SplitOn(T element_id) {$/;"	f	class:fst::Partition
SplitRefine	partition.h	/^  T SplitRefine(T class_id) {$/;"	f	class:fst::Partition
StackPrefix	replace.h	/^    StackPrefix() {}$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
StackPrefix	replace.h	/^    StackPrefix(const StackPrefix& x) :$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
StackPrefix	replace.h	/^  class StackPrefix {$/;"	c	class:fst::ReplaceFstImpl
StackPrefixEqual	replace.h	/^  class StackPrefixEqual {$/;"	c	class:fst::ReplaceFstImpl
StackPrefixHash	replace.h	/^  StackPrefixHash;$/;"	t	class:fst::ReplaceFstImpl
StackPrefixKey	replace.h	/^  class StackPrefixKey {$/;"	c	class:fst::ReplaceFstImpl
Start	add-on.h	/^  StateId Start() const { return fst_.Start(); }$/;"	f	class:fst::AddOnImpl
Start	arc-map.h	/^  StateId Start() {$/;"	f	class:fst::ArcMapFstImpl
Start	arcsort.h	/^  StateId Start() { return fst_.Start(); }$/;"	f	class:fst::ArcSortMapper
Start	compact-fst.h	/^  StateId Start() {$/;"	f	class:fst::CompactFstImpl
Start	compact-fst.h	/^  ssize_t Start() const { return start_; }$/;"	f	class:fst::CompactFstData
Start	complement.h	/^  StateId Start() const {$/;"	f	class:fst::ComplementFstImpl
Start	compose-filter.h	/^  FilterState Start() const { return FilterState(0); }$/;"	f	class:fst::AltSequenceComposeFilter
Start	compose-filter.h	/^  FilterState Start() const { return FilterState(0); }$/;"	f	class:fst::MatchComposeFilter
Start	compose-filter.h	/^  FilterState Start() const { return FilterState(0); }$/;"	f	class:fst::SequenceComposeFilter
Start	compose-filter.h	/^  FilterState Start() const { return filter_.Start(); }$/;"	f	class:fst::MultiEpsFilter
Start	compose.h	/^  StateId Start() {$/;"	f	class:fst::ComposeFstImplBase
Start	const-fst.h	/^  StateId Start() const { return start_; }$/;"	f	class:fst::ConstFstImpl
Start	determinize.h	/^  StateId Start() {$/;"	f	class:fst::DeterminizeFstImplBase
Start	edit-fst.h	/^  StateId Start() const {$/;"	f	class:fst::EditFstImpl
Start	factor-weight.h	/^  StateId Start() {$/;"	f	class:fst::FactorWeightFstImpl
Start	fst.h	/^  int64 Start() const { return start_; }$/;"	f	class:fst::FstHeader
Start	fst.h	/^  virtual StateId Start() const { return impl_->Start(); }$/;"	f	class:fst::ImplToFst
Start	lookahead-filter.h	/^  FilterState Start() const {$/;"	f	class:fst::LookAheadComposeFilter
Start	lookahead-filter.h	/^  FilterState Start() const {$/;"	f	class:fst::PushLabelsComposeFilter
Start	lookahead-filter.h	/^  FilterState Start() const {$/;"	f	class:fst::PushWeightsComposeFilter
Start	randgen.h	/^  StateId Start() {$/;"	f	class:fst::RandGenFstImpl
Start	rational.h	/^  StateId Start() { return Replace()->Start(); }$/;"	f	class:fst::RationalFstImpl
Start	relabel.h	/^  StateId Start() {$/;"	f	class:fst::RelabelFstImpl
Start	replace.h	/^  StateId Start() {$/;"	f	class:fst::ReplaceFstImpl
Start	rmepsilon.h	/^  StateId Start() {$/;"	f	class:fst::RmEpsilonFstImpl
Start	state-map.h	/^  StateId Start() const { return fst_.Start(); }$/;"	f	class:fst::ArcSumMapper
Start	state-map.h	/^  StateId Start() const { return fst_.Start(); }$/;"	f	class:fst::ArcUniqueMapper
Start	state-map.h	/^  StateId Start() const { return fst_.Start(); }$/;"	f	class:fst::IdentityStateMapper
Start	state-map.h	/^  StateId Start() {$/;"	f	class:fst::StateMapFstImpl
Start	synchronize.h	/^  StateId Start() {$/;"	f	class:fst::SynchronizeFstImpl
Start	vector-fst.h	/^  StateId Start() const { return start_; }$/;"	f	class:fst::VectorFstBaseImpl
State	arc-map.h	/^  typedef CacheState<B> State;$/;"	t	class:fst::ArcMapFst
State	cache.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::CacheImpl
State	cache.h	/^  typedef S State;$/;"	t	class:fst::CacheBaseImpl
State	cache.h	/^  typedef typename F::State State;$/;"	t	class:fst::CacheArcIterator
State	cache.h	/^  typedef typename F::State State;$/;"	t	class:fst::CacheMutableArcIterator
State	cache.h	/^  typedef typename F::State State;$/;"	t	class:fst::CacheStateIterator
State	compact-fst.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::CompactFst
State	compose.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::ComposeFst
State	compose.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::ComposeFstImplBase
State	const-fst.h	/^    State() : final(Weight::Zero()), niepsilons(0), noepsilons(0) {}$/;"	f	struct:fst::ConstFstImpl::State
State	const-fst.h	/^  struct State {$/;"	s	class:fst::ConstFstImpl
State	determinize.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::DeterminizeFst
State	determinize.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::DeterminizeFstImplBase
State	factor-weight.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::FactorWeightFst
State	map.h	/^  typedef CacheState<B> State;$/;"	t	class:fst::MapFst
State	randgen.h	/^  typedef CacheState<B> State;$/;"	t	class:fst::RandGenFst
State	relabel.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::RelabelFst
State	relabel.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::RelabelFstImpl
State	replace.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::ReplaceFst
State	replace.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::ReplaceFstImpl
State	rmepsilon.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::RmEpsilonFst
State	rmepsilon.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::RmEpsilonFstImpl
State	state-map.h	/^  typedef CacheState<B> State;$/;"	t	class:fst::StateMapFst
State	synchronize.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::SynchronizeFst
State2Index	state-reachable.h	/^  vector<I> &State2Index() { return state2index_; }$/;"	f	class:fst::StateReachable
StateComparator	minimize.h	/^  StateComparator(const Fst<A>& fst,$/;"	f	class:fst::StateComparator
StateComparator	minimize.h	/^class StateComparator {$/;"	c	namespace:fst
StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CacheLogAccumulator
StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CacheLogAccumulatorData
StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DefaultAccumulator
StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FastLogAccumulator
StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::LogAccumulator
StateId	accumulator.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ReplaceAccumulator
StateId	accumulator.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ReplaceAccumulatorData
StateId	add-on.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::AddOnImpl
StateId	arc-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	arc-map.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::GallicToNewSymbolsMapper
StateId	arc-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::ArcMapFst
StateId	arc-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::ArcMapFstImpl
StateId	arc-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::StateIterator
StateId	arc.h	/^  typedef int StateId;$/;"	t	class:fst::ArcTpl
StateId	arc.h	/^  typedef int StateId;$/;"	t	class:fst::StringArc
StateId	arc.h	/^  typedef int StateId;$/;"	t	struct:fst::LexicographicArc
StateId	arc.h	/^  typedef int StateId;$/;"	t	struct:fst::ProductArc
StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::ExpectationArc
StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::GallicArc
StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::PowerArc
StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::ReverseArc
StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::SparsePowerArc
StateId	arcsort.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ArcSortMapper
StateId	cache.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::CacheState
StateId	cache.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheArcIterator
StateId	cache.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheBaseImpl
StateId	cache.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheMutableArcIterator
StateId	cache.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheStateIterator
StateId	cache.h	/^  typedef typename S::Arc::StateId StateId;$/;"	t	struct:fst::DefaultCacheStateAllocator
StateId	closure.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::AcceptorCompactor
StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CompactFst
StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CompactFstImpl
StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StringCompactor
StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::UnweightedAcceptorCompactor
StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::UnweightedCompactor
StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::WeightedStringCompactor
StateId	complement.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	complement.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ComplementFst
StateId	complement.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ComplementFstImpl
StateId	complement.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
StateId	compose-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::AltSequenceComposeFilter
StateId	compose-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MatchComposeFilter
StateId	compose-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MultiEpsFilter
StateId	compose-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::SequenceComposeFilter
StateId	compose.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	compose.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ComposeFst
StateId	compose.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ComposeFstImplBase
StateId	compose.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ComposeFstImpl
StateId	concat.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	concat.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ConcatFst
StateId	connect.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CcVisitor
StateId	connect.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::SccVisitor
StateId	const-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	const-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ConstFst
StateId	const-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ConstFstImpl
StateId	const-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DeterminizeFsaImpl
StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DeterminizeFst
StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DeterminizeFstImpl
StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DeterminizeFstImplBase
StateId	determinize.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::DeterminizeOptions
StateId	dfs-visit.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::DfsState
StateId	difference.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	difference.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DifferenceFst
StateId	edit-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::EditFst
StateId	edit-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::EditFstData
StateId	edit-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::EditFstImpl
StateId	equivalent.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::EquivalenceUtil
StateId	expanded-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ExpandedFst
StateId	expanded-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ImplToExpandedFst
StateId	factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FactorWeightFst
StateId	factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FactorWeightFstImpl
StateId	fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIteratorBase
StateId	fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::Fst
StateId	fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FstImpl
StateId	fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIteratorBase
StateId	fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ImplToFst
StateId	fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::StateIterator
StateId	intersect.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	intersect.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::IntersectFst
StateId	label-reachable.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::LabelReachable
StateId	lookahead-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LookAheadComposeFilter
StateId	lookahead-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::PushLabelsComposeFilter
StateId	lookahead-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::PushWeightsComposeFilter
StateId	lookahead-matcher.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::LookAheadMatcherBase
StateId	lookahead-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ArcLookAheadMatcher
StateId	lookahead-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LabelLookAheadMatcher
StateId	lookahead-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LookAheadMatcher
StateId	lookahead-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::TrivialLookAheadMatcher
StateId	map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::MapFst
StateId	matcher-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LookAheadMatcher
StateId	matcher-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::Matcher
StateId	matcher-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MatcherFst
StateId	matcher.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::MatcherBase
StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::Matcher
StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MultiEpsMatcher
StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::PhiMatcher
StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::RhoMatcher
StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::SigmaMatcher
StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::SortedMatcher
StateId	minimize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::AcyclicMinimizer
StateId	minimize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CyclicMinimizer
StateId	minimize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateComparator
StateId	mutable-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::MutableFst
StateId	mutable-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ImplToMutableFst
StateId	mutable-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MutableArcIterator
StateId	prune.h	/^  typedef S StateId;$/;"	t	class:fst::PruneCompare
StateId	prune.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::PruneOptions
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::AStarWeightCompare
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::AutoQueue
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::FifoQueue
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::LifoQueue
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::QueueBase
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::SccQueue
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::ShortestFirstQueue
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::StateOrderQueue
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::StateWeightCompare
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::TopOrderQueue
StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::TrivialQueue
StateId	queue.h	/^  typedef typename Q::StateId StateId;$/;"	t	class:fst::NaturalPruneQueue
StateId	queue.h	/^  typedef typename Q::StateId StateId;$/;"	t	class:fst::PruneQueue
StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcSampler
StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FastLogProbArcSelector
StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::LogProbArcSelector
StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RandGenFst
StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RandGenFstImpl
StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::RandState
StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::UniformArcSelector
StateId	randgen.h	/^  typedef typename IArc::StateId StateId;$/;"	t	class:fst::RandGenVisitor
StateId	rational.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	rational.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RationalFst
StateId	rational.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RationalFstImpl
StateId	relabel.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	relabel.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RelabelFst
StateId	relabel.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RelabelFstImpl
StateId	relabel.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
StateId	replace-util.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ReplaceUtil
StateId	replace.h	/^  typedef S StateId;$/;"	t	struct:fst::ReplaceStateTuple
StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DefaultReplaceStateTable
StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ReplaceFst
StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ReplaceFstImpl
StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ReplaceFstMatcher
StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::VectorHashReplaceStateTable
StateId	rmepsilon.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	rmepsilon.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RmEpsilonFst
StateId	rmepsilon.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RmEpsilonFstImpl
StateId	rmepsilon.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::RmEpsilonOptions
StateId	rmepsilon.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::RmEpsilonState
StateId	shortest-distance.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ShortestDistanceState
StateId	shortest-distance.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::ShortestDistanceOptions
StateId	shortest-path.h	/^  typedef S StateId;$/;"	t	class:fst::ShortestPathCompare
StateId	shortest-path.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::ShortestPathOptions
StateId	state-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	state-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcSumMapper
StateId	state-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcUniqueMapper
StateId	state-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::IdentityStateMapper
StateId	state-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::StateMapFst
StateId	state-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::StateMapFstImpl
StateId	state-reachable.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::IntervalReachVisitor
StateId	state-reachable.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateReachable
StateId	state-table.h	/^  typedef S StateId;$/;"	t	class:fst::ComposeFingerprint
StateId	state-table.h	/^  typedef S StateId;$/;"	t	class:fst::ComposeState1Fingerprint
StateId	state-table.h	/^  typedef S StateId;$/;"	t	class:fst::ComposeState2Fingerprint
StateId	state-table.h	/^  typedef S StateId;$/;"	t	struct:fst::ComposeStateTuple
StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DetStringComposeStateTable
StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ErasableComposeStateTable
StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::GenericComposeStateTable
StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ProductComposeStateTable
StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StringDetComposeStateTable
StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::CompactHashStateTable
StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::ErasableStateTable
StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::HashStateTable
StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::VectorHashStateTable
StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::VectorStateTable
StateId	string.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StringPrinter
StateId	synchronize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	synchronize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::SynchronizeFst
StateId	synchronize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::SynchronizeFstImpl
StateId	topsort.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::TopOrderVisitor
StateId	union.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	union.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::UnionFst
StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::MutableArcIterator
StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::VectorFst
StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::VectorFstImpl
StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::VectorState
StateId	vector-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::VectorFstBaseImpl
StateId	visit.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CopyVisitor
StateId	visit.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::PartialVisitor
StateIterator	arc-map.h	/^  explicit StateIterator(const ArcMapFst<A, B, C> &fst)$/;"	f	class:fst::StateIterator
StateIterator	arc-map.h	/^class StateIterator< ArcMapFst<A, B, C> > : public StateIteratorBase<B> {$/;"	c	namespace:fst
StateIterator	arcsort.h	/^  explicit StateIterator(const ArcSortFst<A, C> &fst)$/;"	f	class:fst::StateIterator
StateIterator	arcsort.h	/^class StateIterator< ArcSortFst<A, C> >$/;"	c	namespace:fst
StateIterator	closure.h	/^  explicit StateIterator(const ClosureFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	closure.h	/^class StateIterator< ClosureFst<A> > : public StateIterator< RationalFst<A> > {$/;"	c	namespace:fst
StateIterator	compact-fst.h	/^  explicit StateIterator(const CompactFst<A, C, U> &fst)$/;"	f	class:fst::StateIterator
StateIterator	compact-fst.h	/^class StateIterator< CompactFst<A, C, U> > {$/;"	c	namespace:fst
StateIterator	complement.h	/^  explicit StateIterator(const ComplementFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	complement.h	/^class StateIterator< ComplementFst<A> > : public StateIteratorBase<A> {$/;"	c	namespace:fst
StateIterator	compose.h	/^  explicit StateIterator(const ComposeFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	compose.h	/^class StateIterator< ComposeFst<A> >$/;"	c	namespace:fst
StateIterator	concat.h	/^  explicit StateIterator(const ConcatFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	concat.h	/^class StateIterator< ConcatFst<A> > : public StateIterator< RationalFst<A> > {$/;"	c	namespace:fst
StateIterator	const-fst.h	/^  explicit StateIterator(const ConstFst<A, U> &fst)$/;"	f	class:fst::StateIterator
StateIterator	const-fst.h	/^class StateIterator< ConstFst<A, U> > {$/;"	c	namespace:fst
StateIterator	determinize.h	/^  explicit StateIterator(const DeterminizeFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	determinize.h	/^class StateIterator< DeterminizeFst<A> >$/;"	c	namespace:fst
StateIterator	difference.h	/^  explicit StateIterator(const DifferenceFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	difference.h	/^class StateIterator< DifferenceFst<A> >$/;"	c	namespace:fst
StateIterator	encode.h	/^  explicit StateIterator(const DecodeFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	encode.h	/^  explicit StateIterator(const EncodeFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	encode.h	/^class StateIterator< DecodeFst<A> >$/;"	c	namespace:fst
StateIterator	encode.h	/^class StateIterator< EncodeFst<A> >$/;"	c	namespace:fst
StateIterator	factor-weight.h	/^  explicit StateIterator(const FactorWeightFst<A, F> &fst)$/;"	f	class:fst::StateIterator
StateIterator	factor-weight.h	/^class StateIterator< FactorWeightFst<A, F> >$/;"	c	namespace:fst
StateIterator	fst.h	/^  explicit StateIterator(const F &fst) : s_(0) {$/;"	f	class:fst::StateIterator
StateIterator	fst.h	/^class StateIterator {$/;"	c	namespace:fst
StateIterator	intersect.h	/^  explicit StateIterator(const IntersectFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	intersect.h	/^class StateIterator< IntersectFst<A> >$/;"	c	namespace:fst
StateIterator	invert.h	/^  explicit StateIterator(const InvertFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	invert.h	/^class StateIterator< InvertFst<A> >$/;"	c	namespace:fst
StateIterator	map.h	/^  explicit StateIterator(const ArcMapFst<A, B, C> &fst)$/;"	f	class:fst::StateIterator
StateIterator	map.h	/^class StateIterator< MapFst<A, B, C> >$/;"	c	namespace:fst
StateIterator	matcher-fst.h	/^  explicit StateIterator(const MatcherFst<F, M, N, I> &fst) :$/;"	f	class:fst::StateIterator
StateIterator	matcher-fst.h	/^class StateIterator< MatcherFst<F, M, N, I> > : public StateIterator<F> {$/;"	c	namespace:fst
StateIterator	project.h	/^  explicit StateIterator(const ProjectFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	project.h	/^class StateIterator< ProjectFst<A> >$/;"	c	namespace:fst
StateIterator	randgen.h	/^  explicit StateIterator(const RandGenFst<A, B, S> &fst)$/;"	f	class:fst::StateIterator
StateIterator	randgen.h	/^class StateIterator< RandGenFst<A, B, S> >$/;"	c	namespace:fst
StateIterator	rational.h	/^  explicit StateIterator(const RationalFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	rational.h	/^class StateIterator< RationalFst<A> >$/;"	c	namespace:fst
StateIterator	relabel.h	/^  explicit StateIterator(const RelabelFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	relabel.h	/^class StateIterator< RelabelFst<A> > : public StateIteratorBase<A> {$/;"	c	namespace:fst
StateIterator	replace.h	/^  explicit StateIterator(const ReplaceFst<A, T> &fst)$/;"	f	class:fst::StateIterator
StateIterator	replace.h	/^class StateIterator< ReplaceFst<A, T> >$/;"	c	namespace:fst
StateIterator	rmepsilon.h	/^  explicit StateIterator(const RmEpsilonFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	rmepsilon.h	/^class StateIterator< RmEpsilonFst<A> >$/;"	c	namespace:fst
StateIterator	synchronize.h	/^  explicit StateIterator(const SynchronizeFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	synchronize.h	/^class StateIterator< SynchronizeFst<A> >$/;"	c	namespace:fst
StateIterator	union.h	/^  explicit StateIterator(const UnionFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	union.h	/^class StateIterator< UnionFst<A> > : public StateIterator< RationalFst<A> > {$/;"	c	namespace:fst
StateIterator	vector-fst.h	/^  explicit StateIterator(const VectorFst<A> &fst)$/;"	f	class:fst::StateIterator
StateIterator	vector-fst.h	/^class StateIterator< VectorFst<A> > {$/;"	c	namespace:fst
StateIteratorBase	fst.h	/^class StateIteratorBase {$/;"	c	namespace:fst
StateIteratorData	fst.h	/^template <class A> struct StateIteratorData {$/;"	s	namespace:fst
StateMap	state-map.h	/^void StateMap(MutableFst<A> *fst, C mapper) {$/;"	f	namespace:fst
StateMap	state-map.h	/^void StateMap(MutableFst<A> *fst, C* mapper) {$/;"	f	namespace:fst
StateMap	state-map.h	/^void StateMap(const Fst<A> &ifst, MutableFst<B> *ofst, C mapper) {$/;"	f	namespace:fst
StateMap	state-map.h	/^void StateMap(const Fst<A> &ifst, MutableFst<B> *ofst, C* mapper) {$/;"	f	namespace:fst
StateMapFst	state-map.h	/^  StateMapFst(const Fst<A> &fst, C* mapper)$/;"	f	class:fst::StateMapFst
StateMapFst	state-map.h	/^  StateMapFst(const Fst<A> &fst, C* mapper, const StateMapFstOptions& opts)$/;"	f	class:fst::StateMapFst
StateMapFst	state-map.h	/^  StateMapFst(const Fst<A> &fst, const C &mapper)$/;"	f	class:fst::StateMapFst
StateMapFst	state-map.h	/^  StateMapFst(const Fst<A> &fst, const C &mapper,$/;"	f	class:fst::StateMapFst
StateMapFst	state-map.h	/^  StateMapFst(const StateMapFst<A, B, C> &fst, bool safe = false)$/;"	f	class:fst::StateMapFst
StateMapFst	state-map.h	/^class StateMapFst : public ImplToFst< StateMapFstImpl<A, B, C> > {$/;"	c	namespace:fst
StateMapFstImpl	state-map.h	/^  StateMapFstImpl(const Fst<A> &fst, C *mapper,$/;"	f	class:fst::StateMapFstImpl
StateMapFstImpl	state-map.h	/^  StateMapFstImpl(const Fst<A> &fst, const C &mapper,$/;"	f	class:fst::StateMapFstImpl
StateMapFstImpl	state-map.h	/^  StateMapFstImpl(const StateMapFstImpl<A, B, C> &impl)$/;"	f	class:fst::StateMapFstImpl
StateMapFstImpl	state-map.h	/^class StateMapFstImpl : public CacheImpl<B> {$/;"	c	namespace:fst
StateMapFstOptions	state-map.h	/^typedef CacheOptions StateMapFstOptions;$/;"	t	namespace:fst
StateOrderQueue	queue.h	/^  StateOrderQueue()$/;"	f	class:fst::StateOrderQueue
StateOrderQueue	queue.h	/^class StateOrderQueue : public QueueBase<S> {$/;"	c	namespace:fst
StateReachable	state-reachable.h	/^  StateReachable(const Fst<A> &fst)$/;"	f	class:fst::StateReachable
StateReachable	state-reachable.h	/^  StateReachable(const StateReachable<A> &reachable) {$/;"	f	class:fst::StateReachable
StateReachable	state-reachable.h	/^class StateReachable {$/;"	c	namespace:fst
StateSort	statesort.h	/^void StateSort(MutableFst<Arc> *fst,$/;"	f	namespace:fst
StateTable	accumulator.h	/^  typedef T StateTable;$/;"	t	class:fst::ReplaceAccumulator
StateTable	accumulator.h	/^  typedef T StateTable;$/;"	t	class:fst::ReplaceAccumulatorData
StateTable	replace.h	/^                                ReplaceHash<StateId, PrefixId> > StateTable;$/;"	t	class:fst::DefaultReplaceStateTable
StateTable	replace.h	/^                               ReplaceFingerprint<StateId, P> > StateTable;$/;"	t	class:fst::VectorHashReplaceStateTable
StateTable	replace.h	/^  typedef T StateTable;$/;"	t	class:fst::ReplaceFstImpl
StateTuple	accumulator.h	/^  typedef typename T::StateTuple StateTuple;$/;"	t	class:fst::ReplaceAccumulator
StateTuple	accumulator.h	/^  typedef typename T::StateTuple StateTuple;$/;"	t	class:fst::ReplaceAccumulatorData
StateTuple	compose.h	/^  typedef ComposeStateTuple<StateId, FilterState> StateTuple;$/;"	t	class:fst::ComposeFstImpl
StateTuple	replace.h	/^  typedef ReplaceStateTuple<StateId, P> StateTuple;$/;"	t	class:fst::DefaultReplaceStateTable
StateTuple	replace.h	/^  typedef ReplaceStateTuple<StateId, P> StateTuple;$/;"	t	class:fst::VectorHashReplaceStateTable
StateTuple	replace.h	/^  typedef ReplaceStateTuple<StateId, PrefixId> StateTuple;$/;"	t	class:fst::ReplaceFstImpl
StateTuple	state-table.h	/^  typedef ComposeStateTuple<S, F> StateTuple;$/;"	t	class:fst::ComposeFingerprint
StateTuple	state-table.h	/^  typedef ComposeStateTuple<S, F> StateTuple;$/;"	t	class:fst::ComposeState1Fingerprint
StateTuple	state-table.h	/^  typedef ComposeStateTuple<S, F> StateTuple;$/;"	t	class:fst::ComposeState2Fingerprint
StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::DetStringComposeStateTable
StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::ErasableComposeStateTable
StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::GenericComposeStateTable
StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::ProductComposeStateTable
StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::StringDetComposeStateTable
StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::CompactHashStateTable
StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::ErasableStateTable
StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::HashStateTable
StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::VectorHashStateTable
StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::VectorStateTable
StateWeightCompare	queue.h	/^  StateWeightCompare(const vector<Weight>& weights, const L &less)$/;"	f	class:fst::StateWeightCompare
StateWeightCompare	queue.h	/^class StateWeightCompare {$/;"	c	namespace:fst
States	compact-fst.h	/^  Unsigned States(ssize_t i) const { return states_[i]; }$/;"	f	class:fst::CompactFstData
StdArc	arc.h	/^typedef ArcTpl<TropicalWeight> StdArc;$/;"	t	namespace:fst
StdArc	fst-decl.h	/^typedef ArcTpl<TropicalWeight> StdArc;$/;"	t	namespace:fst
StdArcLookAheadFst	matcher-fst.h	/^                   arc_lookahead_fst_type> StdArcLookAheadFst;$/;"	t	namespace:fst
StdArcSelector	randgen.h	/^typedef LogProbArcSelector<StdArc> StdArcSelector;$/;"	t	namespace:fst
StdArcSortFst	arcsort.h	/^template<class C> class StdArcSortFst : public ArcSortFst<StdArc, C> {$/;"	c	namespace:fst
StdClosureFst	closure.h	/^typedef ClosureFst<StdArc> StdClosureFst;$/;"	t	namespace:fst
StdClosureFst	fst-decl.h	/^typedef ClosureFst<StdArc> StdClosureFst;$/;"	t	namespace:fst
StdCompactAcceptorFst	compact-fst.h	/^StdCompactAcceptorFst;$/;"	t	namespace:fst
StdCompactAcceptorFst	fst-decl.h	/^StdCompactAcceptorFst;$/;"	t	namespace:fst
StdCompactStringFst	compact-fst.h	/^StdCompactStringFst;$/;"	t	namespace:fst
StdCompactStringFst	fst-decl.h	/^StdCompactStringFst;$/;"	t	namespace:fst
StdCompactUnweightedAcceptorFst	compact-fst.h	/^StdCompactUnweightedAcceptorFst;$/;"	t	namespace:fst
StdCompactUnweightedAcceptorFst	fst-decl.h	/^StdCompactUnweightedAcceptorFst;$/;"	t	namespace:fst
StdCompactUnweightedFst	compact-fst.h	/^StdCompactUnweightedFst;$/;"	t	namespace:fst
StdCompactUnweightedFst	fst-decl.h	/^StdCompactUnweightedFst;$/;"	t	namespace:fst
StdCompactWeightedStringFst	compact-fst.h	/^StdCompactWeightedStringFst;$/;"	t	namespace:fst
StdCompactWeightedStringFst	fst-decl.h	/^StdCompactWeightedStringFst;$/;"	t	namespace:fst
StdComplementFst	complement.h	/^typedef ComplementFst<StdArc> StdComplementFst;$/;"	t	namespace:fst
StdComposeFst	compose.h	/^typedef ComposeFst<StdArc> StdComposeFst;$/;"	t	namespace:fst
StdComposeFst	fst-decl.h	/^typedef ComposeFst<StdArc> StdComposeFst;$/;"	t	namespace:fst
StdConcatFst	concat.h	/^typedef ConcatFst<StdArc> StdConcatFst;$/;"	t	namespace:fst
StdConcatFst	fst-decl.h	/^typedef ConcatFst<StdArc> StdConcatFst;$/;"	t	namespace:fst
StdConstFst	const-fst.h	/^typedef ConstFst<StdArc> StdConstFst;$/;"	t	namespace:fst
StdConstFst	fst-decl.h	/^typedef ConstFst<StdArc> StdConstFst;$/;"	t	namespace:fst
StdDecodeFst	encode.h	/^typedef DecodeFst<StdArc> StdDecodeFst;$/;"	t	namespace:fst
StdDeterminizeFst	determinize.h	/^typedef DeterminizeFst<StdArc> StdDeterminizeFst;$/;"	t	namespace:fst
StdDeterminizeFst	fst-decl.h	/^typedef DeterminizeFst<StdArc> StdDeterminizeFst;$/;"	t	namespace:fst
StdDifferenceFst	difference.h	/^typedef DifferenceFst<StdArc> StdDifferenceFst;$/;"	t	namespace:fst
StdDifferenceFst	fst-decl.h	/^typedef DifferenceFst<StdArc> StdDifferenceFst;$/;"	t	namespace:fst
StdEncodeFst	encode.h	/^typedef EncodeFst<StdArc> StdEncodeFst;$/;"	t	namespace:fst
StdExpandedFst	expanded-fst.h	/^typedef ExpandedFst<StdArc> StdExpandedFst;$/;"	t	namespace:fst
StdExpandedFst	fst-decl.h	/^typedef ExpandedFst<StdArc> StdExpandedFst;$/;"	t	namespace:fst
StdFst	fst-decl.h	/^typedef Fst<StdArc> StdFst;$/;"	t	namespace:fst
StdFst	fst.h	/^typedef Fst<StdArc> StdFst;$/;"	t	namespace:fst
StdILabelCompare	arcsort.h	/^typedef ILabelCompare<StdArc> StdILabelCompare;$/;"	t	namespace:fst
StdILabelLookAheadFst	matcher-fst.h	/^                   LabelLookAheadRelabeler<StdArc> > StdILabelLookAheadFst;$/;"	t	namespace:fst
StdIntersectFst	fst-decl.h	/^typedef IntersectFst<StdArc> StdIntersectFst;$/;"	t	namespace:fst
StdIntersectFst	intersect.h	/^typedef IntersectFst<StdArc> StdIntersectFst;$/;"	t	namespace:fst
StdInvertFst	fst-decl.h	/^typedef InvertFst<StdArc> StdInvertFst;$/;"	t	namespace:fst
StdInvertFst	invert.h	/^typedef InvertFst<StdArc> StdInvertFst;$/;"	t	namespace:fst
StdMutableFst	fst-decl.h	/^typedef MutableFst<StdArc> StdMutableFst;$/;"	t	namespace:fst
StdMutableFst	mutable-fst.h	/^typedef MutableFst<StdArc> StdMutableFst;$/;"	t	namespace:fst
StdOLabelCompare	arcsort.h	/^typedef OLabelCompare<StdArc> StdOLabelCompare;$/;"	t	namespace:fst
StdOLabelLookAheadFst	matcher-fst.h	/^                   LabelLookAheadRelabeler<StdArc> > StdOLabelLookAheadFst;$/;"	t	namespace:fst
StdProjectFst	fst-decl.h	/^typedef ProjectFst<StdArc> StdProjectFst;$/;"	t	namespace:fst
StdProjectFst	project.h	/^typedef ProjectFst<StdArc> StdProjectFst;$/;"	t	namespace:fst
StdRelabelFst	fst-decl.h	/^typedef RelabelFst<StdArc> StdRelabelFst;$/;"	t	namespace:fst
StdRelabelFst	relabel.h	/^typedef RelabelFst<StdArc> StdRelabelFst;$/;"	t	namespace:fst
StdReplaceFst	fst-decl.h	/^StdReplaceFst;$/;"	t	namespace:fst
StdReplaceFst	replace.h	/^typedef ReplaceFst<StdArc> StdReplaceFst;$/;"	t	namespace:fst
StdRmEpsilonFst	fst-decl.h	/^typedef RmEpsilonFst<StdArc> StdRmEpsilonFst;$/;"	t	namespace:fst
StdRmEpsilonFst	rmepsilon.h	/^typedef RmEpsilonFst<StdArc> StdRmEpsilonFst;$/;"	t	namespace:fst
StdToLog64Mapper	arc-map.h	/^typedef WeightConvertMapper<StdArc, Log64Arc> StdToLog64Mapper;$/;"	t	namespace:fst
StdToLogMapper	arc-map.h	/^typedef WeightConvertMapper<StdArc, LogArc> StdToLogMapper;$/;"	t	namespace:fst
StdUnionFst	fst-decl.h	/^typedef UnionFst<StdArc> StdUnionFst;$/;"	t	namespace:fst
StdUnionFst	union.h	/^typedef UnionFst<StdArc> StdUnionFst;$/;"	t	namespace:fst
StdVectorFst	fst-decl.h	/^typedef VectorFst<StdArc> StdVectorFst;$/;"	t	namespace:fst
StdVectorFst	vector-fst.h	/^typedef VectorFst<StdArc> StdVectorFst;$/;"	t	namespace:fst
StlReserve	util.h	/^void StlReserve(C *c, int64 n) {}$/;"	f	namespace:fst
StlReserve	util.h	/^void StlReserve(vector<S, T> *c, int64 n) {$/;"	f	namespace:fst
StrCmp	symbol-table.h	/^  struct StrCmp {$/;"	s	class:fst::SymbolTableImpl
StrToWeight	util.h	/^Weight StrToWeight(const string &s, const string &src, size_t nline) {$/;"	f	namespace:fst
StrictlyOverlaps	interval-set.h	/^bool IntervalSet<T>::StrictlyOverlaps(const IntervalSet<T> &iset) const {$/;"	f	class:fst::IntervalSet
String	synchronize.h	/^  typedef basic_string<Label> String;$/;"	t	class:fst::SynchronizeFstImpl
StringArc	arc.h	/^  StringArc() {}$/;"	f	class:fst::StringArc
StringArc	arc.h	/^  StringArc(Label i, Label o, Weight w, StateId s)$/;"	f	class:fst::StringArc
StringArc	arc.h	/^class StringArc {$/;"	c	namespace:fst
StringCompactor	compact-fst.h	/^class StringCompactor {$/;"	c	namespace:fst
StringCompiler	string.h	/^  StringCompiler(TokenType type, const SymbolTable *syms = 0,$/;"	f	class:fst::StringCompiler
StringCompiler	string.h	/^class StringCompiler {$/;"	c	namespace:fst
StringDetComposeStateTable	state-table.h	/^  StringDetComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2)$/;"	f	class:fst::StringDetComposeStateTable
StringDetComposeStateTable	state-table.h	/^  StringDetComposeStateTable(const StringDetComposeStateTable<A, F> &table)$/;"	f	class:fst::StringDetComposeStateTable
StringDetComposeStateTable	state-table.h	/^class StringDetComposeStateTable : public$/;"	c	namespace:fst
StringEqual	synchronize.h	/^  class StringEqual {$/;"	c	class:fst::SynchronizeFstImpl
StringFactor	factor-weight.h	/^  StringFactor(const StringWeight<L, S> &w)$/;"	f	class:fst::StringFactor
StringFactor	factor-weight.h	/^class StringFactor {$/;"	c	namespace:fst
StringKey	arc-map.h	/^  class StringKey {$/;"	c	struct:fst::GallicToNewSymbolsMapper
StringKey	synchronize.h	/^  class StringKey{$/;"	c	class:fst::SynchronizeFstImpl
StringPrinter	string.h	/^  StringPrinter(TokenType token_type,$/;"	f	class:fst::StringPrinter
StringPrinter	string.h	/^class StringPrinter {$/;"	c	namespace:fst
StringSet	synchronize.h	/^  typedef unordered_set<const String*, StringKey, StringEqual> StringSet;$/;"	t	class:fst::SynchronizeFstImpl
StringToFst	fst.h	/^Fst<A> *StringToFst(const string &s) {$/;"	f	namespace:fst
StringToSymbolTable	symbol-table.h	/^inline SymbolTable *StringToSymbolTable(const string &s) {$/;"	f	namespace:fst
StringType	string-weight.h	/^enum StringType { STRING_LEFT = 0, STRING_RIGHT = 1 ,$/;"	g	namespace:fst
StringWeight	string-weight.h	/^  StringWeight() { Init(); }$/;"	f	class:fst::StringWeight
StringWeight	string-weight.h	/^  StringWeight(const Iter &begin, const Iter &end) {$/;"	f	class:fst::StringWeight
StringWeight	string-weight.h	/^  explicit StringWeight(L l) { Init(); PushBack(l); }$/;"	f	class:fst::StringWeight
StringWeight	string-weight.h	/^class StringWeight {$/;"	c	namespace:fst
StringWeightGenerator	random-weight.h	/^  StringWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::StringWeightGenerator
StringWeightGenerator	random-weight.h	/^class StringWeightGenerator {$/;"	c	namespace:fst
StringWeightIterator	string-weight.h	/^  explicit StringWeightIterator(const StringWeight<L, S>& w)$/;"	f	class:fst::StringWeightIterator
StringWeightIterator	string-weight.h	/^class StringWeightIterator {$/;"	c	namespace:fst
StringWeightReverseIterator	string-weight.h	/^  explicit StringWeightReverseIterator(const StringWeight<L, S>& w)$/;"	f	class:fst::StringWeightReverseIterator
StringWeightReverseIterator	string-weight.h	/^class StringWeightReverseIterator {$/;"	c	namespace:fst
Subset	determinize.h	/^  typedef slist<Element> Subset;$/;"	t	class:fst::DeterminizeFsaImpl
SubsetEqual	determinize.h	/^    explicit SubsetEqual(vector<Element *> *elements)$/;"	f	class:fst::DeterminizeFsaImpl::SubsetEqual
SubsetEqual	determinize.h	/^  class SubsetEqual {$/;"	c	class:fst::DeterminizeFsaImpl
SubsetHash	determinize.h	/^  SubsetHash;$/;"	t	class:fst::DeterminizeFsaImpl
SubsetKey	determinize.h	/^  class SubsetKey {$/;"	c	class:fst::DeterminizeFsaImpl
Sum	accumulator.h	/^  Weight Sum(Weight w, ArcIterator *aiter, ssize_t begin,$/;"	f	class:fst::DefaultAccumulator
Sum	accumulator.h	/^  Weight Sum(Weight w, ArcIterator *aiter, ssize_t begin,$/;"	f	class:fst::FastLogAccumulator
Sum	accumulator.h	/^  Weight Sum(Weight w, ArcIterator *aiter, ssize_t begin,$/;"	f	class:fst::LogAccumulator
Sum	accumulator.h	/^  Weight Sum(Weight w, ArcIterator *aiter, ssize_t begin,$/;"	f	class:fst::ReplaceAccumulator
Sum	accumulator.h	/^  Weight Sum(Weight w, Iterator *aiter, ssize_t begin,$/;"	f	class:fst::CacheLogAccumulator
Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::CacheLogAccumulator
Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::DefaultAccumulator
Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::FastLogAccumulator
Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::LogAccumulator
Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::ReplaceAccumulator
SuperFinalMapper	arc-map.h	/^struct SuperFinalMapper {$/;"	s	namespace:fst
Swap	heap.h	/^  void Swap(int j, int k) {$/;"	f	class:fst::Heap
Symbol	symbol-table.h	/^  string Symbol(void) {$/;"	f	class:fst::SymbolTableIterator
SymbolTable	symbol-table.h	/^  SymbolTable() : impl_(new SymbolTableImpl("<unspecified>")) {}$/;"	f	class:fst::SymbolTable
SymbolTable	symbol-table.h	/^  SymbolTable(const SymbolTable& table) : impl_(table.impl_) {$/;"	f	class:fst::SymbolTable
SymbolTable	symbol-table.h	/^  SymbolTable(const string& name) : impl_(new SymbolTableImpl(name)) {}$/;"	f	class:fst::SymbolTable
SymbolTable	symbol-table.h	/^  explicit SymbolTable(SymbolTableImpl* impl) : impl_(impl) {}$/;"	f	class:fst::SymbolTable
SymbolTable	symbol-table.h	/^class SymbolTable {$/;"	c	namespace:fst
SymbolTableImpl	symbol-table.h	/^  SymbolTableImpl(const string &name)$/;"	f	class:fst::SymbolTableImpl
SymbolTableImpl	symbol-table.h	/^  explicit SymbolTableImpl(const SymbolTableImpl& impl)$/;"	f	class:fst::SymbolTableImpl
SymbolTableImpl	symbol-table.h	/^class SymbolTableImpl {$/;"	c	namespace:fst
SymbolTableIterator	symbol-table.h	/^  SymbolTableIterator(const SymbolTable& table)$/;"	f	class:fst::SymbolTableIterator
SymbolTableIterator	symbol-table.h	/^class SymbolTableIterator {$/;"	c	namespace:fst
SymbolTableReadOptions	symbol-table.h	/^  SymbolTableReadOptions() { }$/;"	f	struct:fst::SymbolTableReadOptions
SymbolTableReadOptions	symbol-table.h	/^  SymbolTableReadOptions(vector<pair<int64, int64> > string_hash_ranges_,$/;"	f	struct:fst::SymbolTableReadOptions
SymbolTableReadOptions	symbol-table.h	/^struct SymbolTableReadOptions {$/;"	s	namespace:fst
SymbolTableToString	symbol-table.h	/^inline void SymbolTableToString(const SymbolTable *table, string *result) {$/;"	f	namespace:fst
Synchronize	synchronize.h	/^void Synchronize(const Fst<Arc> &ifst, MutableFst<Arc> *ofst) {$/;"	f	namespace:fst
SynchronizeFst	synchronize.h	/^  SynchronizeFst(const Fst<A> &fst)$/;"	f	class:fst::SynchronizeFst
SynchronizeFst	synchronize.h	/^  SynchronizeFst(const Fst<A> &fst,  const SynchronizeFstOptions &opts)$/;"	f	class:fst::SynchronizeFst
SynchronizeFst	synchronize.h	/^  SynchronizeFst(const SynchronizeFst<A> &fst, bool safe = false)$/;"	f	class:fst::SynchronizeFst
SynchronizeFst	synchronize.h	/^class SynchronizeFst : public ImplToFst< SynchronizeFstImpl<A> > {$/;"	c	namespace:fst
SynchronizeFstImpl	synchronize.h	/^  SynchronizeFstImpl(const Fst<A> &fst, const SynchronizeFstOptions &opts)$/;"	f	class:fst::SynchronizeFstImpl
SynchronizeFstImpl	synchronize.h	/^  SynchronizeFstImpl(const SynchronizeFstImpl &impl)$/;"	f	class:fst::SynchronizeFstImpl
SynchronizeFstImpl	synchronize.h	/^class SynchronizeFstImpl$/;"	c	namespace:fst
SynchronizeFstOptions	synchronize.h	/^typedef CacheOptions SynchronizeFstOptions;$/;"	t	namespace:fst
TOP_ORDER_QUEUE	queue.h	/^  TOP_ORDER_QUEUE = 4,       \/\/ Topologically-ordered queue$/;"	e	enum:fst::QueueType
TRIVIAL_QUEUE	queue.h	/^  TRIVIAL_QUEUE = 0,         \/\/ Single state queue$/;"	e	enum:fst::QueueType
TestProperties	test-properties.h	/^uint64 TestProperties(const Fst<Arc> &fst, uint64 mask, uint64 *known) {$/;"	f	namespace:fst
Times	expectation-weight.h	/^inline ExpectationWeight<X1, X2> Times(const ExpectationWeight<X1, X2> &w,$/;"	f	namespace:fst
Times	float-weight.h	/^inline LogWeightTpl<T> Times(const LogWeightTpl<T> &w1,$/;"	f	namespace:fst
Times	float-weight.h	/^inline LogWeightTpl<double> Times(const LogWeightTpl<double> &w1,$/;"	f	namespace:fst
Times	float-weight.h	/^inline LogWeightTpl<float> Times(const LogWeightTpl<float> &w1,$/;"	f	namespace:fst
Times	float-weight.h	/^inline MinMaxWeightTpl<T> Times($/;"	f	namespace:fst
Times	float-weight.h	/^inline MinMaxWeightTpl<double> Times($/;"	f	namespace:fst
Times	float-weight.h	/^inline MinMaxWeightTpl<float> Times($/;"	f	namespace:fst
Times	float-weight.h	/^inline TropicalWeightTpl<T> Times(const TropicalWeightTpl<T> &w1,$/;"	f	namespace:fst
Times	float-weight.h	/^inline TropicalWeightTpl<double> Times(const TropicalWeightTpl<double> &w1,$/;"	f	namespace:fst
Times	float-weight.h	/^inline TropicalWeightTpl<float> Times(const TropicalWeightTpl<float> &w1,$/;"	f	namespace:fst
Times	lexicographic-weight.h	/^inline LexicographicWeight<W1, W2> Times(const LexicographicWeight<W1, W2> &w,$/;"	f	namespace:fst
Times	power-weight.h	/^inline PowerWeight<W, n> Times(const PowerWeight<W, n> &w, const W &s) {$/;"	f	namespace:fst
Times	power-weight.h	/^inline PowerWeight<W, n> Times(const PowerWeight<W, n> &w1,$/;"	f	namespace:fst
Times	power-weight.h	/^inline PowerWeight<W, n> Times(const W &s, const PowerWeight<W, n> &w) {$/;"	f	namespace:fst
Times	product-weight.h	/^inline ProductWeight<W1, W2> Times(const ProductWeight<W1, W2> &w,$/;"	f	namespace:fst
Times	signed-log-weight.h	/^inline SignedLogWeightTpl<T> Times(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
Times	sparse-power-weight.h	/^inline SparsePowerWeight<W, K> Times(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
Times	sparse-power-weight.h	/^inline SparsePowerWeight<W, K> Times(const W &k,$/;"	f	namespace:fst
Times	string-weight.h	/^inline StringWeight<L, S> Times(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
TimesMapper	arc-map.h	/^  explicit TimesMapper(Weight w) : weight_(w) {}$/;"	f	struct:fst::TimesMapper
TimesMapper	arc-map.h	/^struct TimesMapper {$/;"	s	namespace:fst
ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::FromGallicMapper
ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::GallicToNewSymbolsMapper
ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::IdentityArcMapper
ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::InvertWeightMapper
ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::PlusMapper
ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::SuperFinalMapper
ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::TimesMapper
ToArc	arc-map.h	/^  typedef B ToArc;$/;"	t	class:fst::WeightConvertMapper
ToArc	arc-map.h	/^  typedef B ToArc;$/;"	t	struct:fst::QuantizeMapper
ToArc	arc-map.h	/^  typedef B ToArc;$/;"	t	struct:fst::ReverseWeightMapper
ToArc	arc-map.h	/^  typedef B ToArc;$/;"	t	struct:fst::RmWeightMapper
ToArc	arc-map.h	/^  typedef GallicArc<A, S> ToArc;$/;"	t	struct:fst::ToGallicMapper
ToArc	arcsort.h	/^  typedef Arc ToArc;$/;"	t	class:fst::ArcSortMapper
ToArc	determinize.h	/^  typedef typename ToMapper::ToArc ToArc;$/;"	t	class:fst::DeterminizeFstImpl
ToArc	map.h	/^  typedef A ToArc;$/;"	t	struct:fst::IdentityMapper
ToArc	state-map.h	/^  typedef A ToArc;$/;"	t	class:fst::ArcSumMapper
ToArc	state-map.h	/^  typedef A ToArc;$/;"	t	class:fst::ArcUniqueMapper
ToArc	state-map.h	/^  typedef A ToArc;$/;"	t	class:fst::IdentityStateMapper
ToFst	determinize.h	/^  typedef ArcMapFst<A, ToArc, ToMapper> ToFst;$/;"	t	class:fst::DeterminizeFstImpl
ToGallicMapper	arc-map.h	/^struct ToGallicMapper {$/;"	s	namespace:fst
ToMapper	determinize.h	/^  typedef ToGallicMapper<A, S> ToMapper;$/;"	t	class:fst::DeterminizeFstImpl
ToWeight	arc-map.h	/^  typedef typename ToArc::Weight ToWeight;$/;"	t	class:fst::WeightConvertMapper
ToWeight	arc-map.h	/^  typedef typename ToArc::Weight ToWeight;$/;"	t	struct:fst::QuantizeMapper
ToWeight	arc-map.h	/^  typedef typename ToArc::Weight ToWeight;$/;"	t	struct:fst::RmWeightMapper
TokenType	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	g	class:fst::StringCompiler
TokenType	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	g	class:fst::StringPrinter
Top	heap.h	/^  T Top() const {$/;"	f	class:fst::Heap
Top	replace.h	/^    const PrefixTuple& Top() const {$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
TopOrderQueue	queue.h	/^  TopOrderQueue(const Fst<Arc> &fst, ArcFilter filter)$/;"	f	class:fst::TopOrderQueue
TopOrderQueue	queue.h	/^  TopOrderQueue(const vector<StateId> &order)$/;"	f	class:fst::TopOrderQueue
TopOrderQueue	queue.h	/^class TopOrderQueue : public QueueBase<S> {$/;"	c	namespace:fst
TopOrderVisitor	topsort.h	/^  TopOrderVisitor(vector<StateId> *order, bool *acyclic)$/;"	f	class:fst::TopOrderVisitor
TopOrderVisitor	topsort.h	/^class TopOrderVisitor {$/;"	c	namespace:fst
TopSort	topsort.h	/^bool TopSort(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
Tr_	minimize.h	/^  VectorFst<RevA> Tr_;$/;"	m	class:fst::CyclicMinimizer
TransformFst	label-reachable.h	/^  void TransformFst() {$/;"	f	class:fst::LabelReachable
TreeArc	connect.h	/^  bool TreeArc(StateId s, const A &arc) { return true; }$/;"	f	class:fst::SccVisitor
TreeArc	minimize.h	/^    bool TreeArc(StateId s, const A& arc) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
TreeArc	randgen.h	/^  bool TreeArc(StateId s, const IArc &arc) {$/;"	f	class:fst::RandGenVisitor
TreeArc	state-reachable.h	/^  bool TreeArc(StateId s, const A &arc) {$/;"	f	class:fst::IntervalReachVisitor
TreeArc	topsort.h	/^  bool TreeArc(StateId s, const A &arc) { return true; }$/;"	f	class:fst::TopOrderVisitor
TrivialAStarEstimate	queue.h	/^struct TrivialAStarEstimate {$/;"	s	namespace:fst
TrivialLookAheadMatcher	lookahead-matcher.h	/^  TrivialLookAheadMatcher(const FST &fst, MatchType match_type)$/;"	f	class:fst::TrivialLookAheadMatcher
TrivialLookAheadMatcher	lookahead-matcher.h	/^  TrivialLookAheadMatcher(const TrivialLookAheadMatcher<M> &lmatcher,$/;"	f	class:fst::TrivialLookAheadMatcher
TrivialLookAheadMatcher	lookahead-matcher.h	/^class TrivialLookAheadMatcher$/;"	c	namespace:fst
TrivialQueue	queue.h	/^  TrivialQueue() : QueueBase<S>(TRIVIAL_QUEUE), front_(kNoStateId) {}$/;"	f	class:fst::TrivialQueue
TrivialQueue	queue.h	/^class TrivialQueue : public QueueBase<S> {$/;"	c	namespace:fst
TrivialStateEquivClass	queue.h	/^struct TrivialStateEquivClass {$/;"	s	namespace:fst
TropicalWeight	float-weight.h	/^typedef TropicalWeightTpl<float> TropicalWeight;$/;"	t	namespace:fst
TropicalWeight	fst-decl.h	/^typedef TropicalWeightTpl<float> TropicalWeight;$/;"	t	namespace:fst
TropicalWeightGenerator	random-weight.h	/^typedef TropicalWeightGenerator_<float> TropicalWeightGenerator;$/;"	t	namespace:fst
TropicalWeightGenerator_	random-weight.h	/^  TropicalWeightGenerator_(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::TropicalWeightGenerator_
TropicalWeightGenerator_	random-weight.h	/^class TropicalWeightGenerator_ {$/;"	c	namespace:fst
TropicalWeightTpl	float-weight.h	/^  TropicalWeightTpl() : FloatWeightTpl<T>() {}$/;"	f	class:fst::TropicalWeightTpl
TropicalWeightTpl	float-weight.h	/^  TropicalWeightTpl(T f) : FloatWeightTpl<T>(f) {}$/;"	f	class:fst::TropicalWeightTpl
TropicalWeightTpl	float-weight.h	/^  TropicalWeightTpl(const TropicalWeightTpl<T> &w) : FloatWeightTpl<T>(w) {}$/;"	f	class:fst::TropicalWeightTpl
TropicalWeightTpl	float-weight.h	/^class TropicalWeightTpl : public FloatWeightTpl<T> {$/;"	c	namespace:fst
Tuple	encode.h	/^    Tuple() {}$/;"	f	struct:fst::EncodeTable::Tuple
Tuple	encode.h	/^    Tuple(Label ilabel_, Label olabel_, Weight weight_)$/;"	f	struct:fst::EncodeTable::Tuple
Tuple	encode.h	/^    Tuple(const Tuple& tuple)$/;"	f	struct:fst::EncodeTable::Tuple
Tuple	encode.h	/^  struct Tuple {$/;"	s	class:fst::EncodeTable
Tuple	replace.h	/^  const StateTuple &Tuple(StateId id) const {$/;"	f	class:fst::VectorHashReplaceStateTable
Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::CompactHashStateTable
Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::ErasableStateTable
Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::HashStateTable
Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::VectorHashStateTable
Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::VectorStateTable
TupleEqual	encode.h	/^  class TupleEqual {$/;"	c	class:fst::EncodeTable
TupleKey	encode.h	/^    TupleKey()$/;"	f	class:fst::EncodeTable::TupleKey
TupleKey	encode.h	/^    TupleKey(const TupleKey& key)$/;"	f	class:fst::EncodeTable::TupleKey
TupleKey	encode.h	/^    explicit TupleKey(uint32 encode_flags)$/;"	f	class:fst::EncodeTable::TupleKey
TupleKey	encode.h	/^  class TupleKey {$/;"	c	class:fst::EncodeTable
TupleWeight	tuple-weight.h	/^  TupleWeight() {}$/;"	f	class:fst::TupleWeight
TupleWeight	tuple-weight.h	/^  TupleWeight(Iterator begin, Iterator end) {$/;"	f	class:fst::TupleWeight
TupleWeight	tuple-weight.h	/^  TupleWeight(const TupleWeight &w) {$/;"	f	class:fst::TupleWeight
TupleWeight	tuple-weight.h	/^  TupleWeight(const W &w) {$/;"	f	class:fst::TupleWeight
TupleWeight	tuple-weight.h	/^class TupleWeight {$/;"	c	namespace:fst
Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	class:fst::StringArc
Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::ExpectationArc
Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::GallicArc
Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::LexicographicArc
Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::PowerArc
Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::ProductArc
Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::ReverseArc
Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::SparsePowerArc
Type	arc.h	/^  static const string &Type(void) {$/;"	f	class:fst::ArcTpl
Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::AcceptorCompactor
Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::StringCompactor
Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::UnweightedAcceptorCompactor
Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::UnweightedCompactor
Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::WeightedStringCompactor
Type	expectation-weight.h	/^  static const string &Type() {$/;"	f	class:fst::ExpectationWeight
Type	float-weight.h	/^  static const string &Type() {$/;"	f	class:fst::LogWeightTpl
Type	float-weight.h	/^  static const string &Type() {$/;"	f	class:fst::MinMaxWeightTpl
Type	float-weight.h	/^  static const string &Type() {$/;"	f	class:fst::TropicalWeightTpl
Type	fst.h	/^  const string& Type() const { return type_; }$/;"	f	class:fst::FstImpl
Type	fst.h	/^  virtual const string& Type() const { return impl_->Type(); }$/;"	f	class:fst::ImplToFst
Type	lexicographic-weight.h	/^  static const string &Type() {$/;"	f	class:fst::LexicographicWeight
Type	lookahead-matcher.h	/^  MatchType Type(bool test) const { return base_->Type(test); }$/;"	f	class:fst::LookAheadMatcher
Type	lookahead-matcher.h	/^  MatchType Type(bool test) const { return matcher_.Type(test); }$/;"	f	class:fst::ArcLookAheadMatcher
Type	lookahead-matcher.h	/^  MatchType Type(bool test) const { return matcher_.Type(test); }$/;"	f	class:fst::LabelLookAheadMatcher
Type	lookahead-matcher.h	/^  MatchType Type(bool test) const { return matcher_.Type(test); }$/;"	f	class:fst::TrivialLookAheadMatcher
Type	matcher-fst.h	/^  MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::LookAheadMatcher
Type	matcher-fst.h	/^  MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::Matcher
Type	matcher.h	/^  MatchType Type(bool test) const { return base_->Type(test); }$/;"	f	class:fst::Matcher
Type	matcher.h	/^  MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::MultiEpsMatcher
Type	matcher.h	/^  virtual MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::PhiMatcher
Type	matcher.h	/^  virtual MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::RhoMatcher
Type	matcher.h	/^  virtual MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::SigmaMatcher
Type	matcher.h	/^  virtual MatchType Type(bool test) const {$/;"	f	class:fst::SortedMatcher
Type	power-weight.h	/^  static const string &Type() {$/;"	f	class:fst::PowerWeight
Type	product-weight.h	/^  static const string &Type() {$/;"	f	class:fst::ProductWeight
Type	queue.h	/^  QueueType Type() { return queue_type_; }$/;"	f	class:fst::QueueBase
Type	replace.h	/^  virtual MatchType Type(bool test) const {$/;"	f	class:fst::ReplaceFstMatcher
Type	signed-log-weight.h	/^  static const string &Type() {$/;"	f	class:fst::SignedLogWeightTpl
Type	sparse-power-weight.h	/^  static const string &Type() {$/;"	f	class:fst::SparsePowerWeight
Type	string-weight.h	/^  static const string &Type() {$/;"	f	class:fst::StringWeight
UTF8	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringCompiler::TokenType
UTF8	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringPrinter::TokenType
UTF8StringToLabels	icu.h	/^bool UTF8StringToLabels(const string &str, vector<Label> *labels) {$/;"	f	namespace:fst
UnMapState	equivalent.h	/^  static StateId UnMapState(MappedId id) {$/;"	f	struct:fst::EquivalenceUtil
UniformArcSelector	randgen.h	/^  UniformArcSelector(int seed = time(0)) { srand(seed); }$/;"	f	struct:fst::UniformArcSelector
UniformArcSelector	randgen.h	/^struct UniformArcSelector {$/;"	s	namespace:fst
Union	interval-set.h	/^  void Union(const IntervalSet<T> &iset) {$/;"	f	class:fst::IntervalSet
Union	union-find.h	/^  void Union(T x, T y) {$/;"	f	class:fst::UnionFind
Union	union.h	/^void Union(MutableFst<Arc> *fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
Union	union.h	/^void Union(RationalFst<Arc> *fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
UnionFind	union-find.h	/^  UnionFind(T max, T fail)$/;"	f	class:fst::UnionFind
UnionFind	union-find.h	/^class UnionFind {$/;"	c	namespace:fst
UnionFst	union.h	/^  UnionFst(const Fst<A> &fst1, const Fst<A> &fst2) {$/;"	f	class:fst::UnionFst
UnionFst	union.h	/^  UnionFst(const Fst<A> &fst1, const Fst<A> &fst2, const UnionFstOptions &opts)$/;"	f	class:fst::UnionFst
UnionFst	union.h	/^  UnionFst(const UnionFst<A> &fst, bool safe = false)$/;"	f	class:fst::UnionFst
UnionFst	union.h	/^class UnionFst : public RationalFst<A> {$/;"	c	namespace:fst
UnionFstOptions	union.h	/^typedef RationalFstOptions UnionFstOptions;$/;"	t	namespace:fst
Unsigned	compact-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::CompactFst
Unsigned	compact-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::CompactFstData
Unsigned	compact-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::CompactFstImpl
Unsigned	const-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::ConstFst
Unsigned	const-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::ConstFstImpl
UnweightedAcceptorCompactor	compact-fst.h	/^class UnweightedAcceptorCompactor {$/;"	c	namespace:fst
UnweightedCompactor	compact-fst.h	/^class UnweightedCompactor {$/;"	c	namespace:fst
Update	compat.h	/^  void Update(string const &data) {$/;"	f	class:fst::CheckSummer
Update	compat.h	/^  void Update(void const *data, int size) {$/;"	f	class:fst::CheckSummer
Update	heap.h	/^  void Update(int key, const T& val) {$/;"	f	class:fst::Heap
Update	queue.h	/^  void Update(StateId s) { Update_(s); }$/;"	f	class:fst::QueueBase
Update	queue.h	/^  void Update(StateId s) { queue_->Update(s); }$/;"	f	class:fst::AutoQueue
Update	queue.h	/^  void Update(StateId s) {$/;"	f	class:fst::PruneQueue
Update	queue.h	/^  void Update(StateId s) {$/;"	f	class:fst::SccQueue
Update	queue.h	/^  void Update(StateId s) {$/;"	f	class:fst::ShortestFirstQueue
Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::FifoQueue
Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::LifoQueue
Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::StateOrderQueue
Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::TopOrderQueue
Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::TrivialQueue
UpdateFstHeader	fst.h	/^  static bool UpdateFstHeader(const Fst<A> &fst, ostream &strm,$/;"	f	class:fst::FstImpl
UpdateNumKnownStates	cache.h	/^  void UpdateNumKnownStates(StateId s) {$/;"	f	class:fst::CacheBaseImpl
UpdateStats	replace-util.h	/^void ReplaceUtil<Arc>::UpdateStats(Label j) {$/;"	f	class:fst::ReplaceUtil
Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::AutoQueue
Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::FifoQueue
Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::LifoQueue
Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::PruneQueue
Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::SccQueue
Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::ShortestFirstQueue
Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::StateOrderQueue
Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::TopOrderQueue
Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::TrivialQueue
VLOG	log.h	51;"	d
Value	arc-map.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
Value	arcsort.h	/^  const Arc &Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcSortMapper
Value	cache.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::CacheStateIterator
Value	cache.h	/^  const Arc& Value() const { return state_->arcs[i_]; }$/;"	f	class:fst::CacheArcIterator
Value	cache.h	/^  const Arc& Value() const { return state_->arcs[i_]; }$/;"	f	class:fst::CacheMutableArcIterator
Value	compact-fst.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
Value	compact-fst.h	/^  const A& Value() const {$/;"	f	class:fst::ArcIterator
Value	complement.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
Value	complement.h	/^  const A& Value() const {$/;"	f	class:fst::ArcIterator
Value	const-fst.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
Value	const-fst.h	/^  const A& Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcIterator
Value	factor-weight.h	/^  pair< GallicWeight<L, W, S>, GallicWeight<L, W, S> > Value() const {$/;"	f	class:fst::GallicFactor
Value	factor-weight.h	/^  pair< StringWeight<L, S>, StringWeight<L, S> > Value() const {$/;"	f	class:fst::StringFactor
Value	factor-weight.h	/^  pair<W, W> Value() const { return make_pair(W::One(), W::One()); } \/\/ unused$/;"	f	class:fst::IdentityFactor
Value	float-weight.h	/^  const T &Value() const { return value_; }$/;"	f	class:fst::FloatWeightTpl
Value	fst.h	/^  StateId Value() const { return Value_(); }  \/\/ Current state (when !Done)$/;"	f	class:fst::StateIteratorBase
Value	fst.h	/^  StateId Value() const { return data_.base ? data_.base->Value() : s_; }$/;"	f	class:fst::StateIterator
Value	fst.h	/^  const A& Value() const { return Value_(); }      \/\/ Current arc (when !Done)$/;"	f	class:fst::ArcIteratorBase
Value	fst.h	/^  const Arc& Value() const {$/;"	f	class:fst::ArcIterator
Value	lookahead-matcher.h	/^  const Arc& Value() const { return base_->Value(); }$/;"	f	class:fst::LookAheadMatcher
Value	lookahead-matcher.h	/^  const Arc& Value() const { return matcher_.Value(); }$/;"	f	class:fst::ArcLookAheadMatcher
Value	lookahead-matcher.h	/^  const Arc& Value() const { return matcher_.Value(); }$/;"	f	class:fst::LabelLookAheadMatcher
Value	lookahead-matcher.h	/^  const Arc& Value() const { return matcher_.Value(); }$/;"	f	class:fst::TrivialLookAheadMatcher
Value	matcher-fst.h	/^  const Arc& Value() const { return matcher_->Value(); }$/;"	f	class:fst::LookAheadMatcher
Value	matcher-fst.h	/^  const Arc& Value() const { return matcher_->Value(); }$/;"	f	class:fst::Matcher
Value	matcher.h	/^  const A& Value() const { return Value_(); }$/;"	f	class:fst::MatcherBase
Value	matcher.h	/^  const Arc& Value() const { return base_->Value(); }$/;"	f	class:fst::Matcher
Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::MultiEpsMatcher
Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::PhiMatcher
Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::RhoMatcher
Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::SigmaMatcher
Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::SortedMatcher
Value	mutable-fst.h	/^  const Arc& Value() const { return data_.base->Value(); }$/;"	f	class:fst::MutableArcIterator
Value	partition.h	/^  const T Value() {$/;"	f	class:fst::PartitionIterator
Value	randgen.h	/^  pair<size_t, size_t> Value() const { return *sample_iter_; }$/;"	f	class:fst::ArcSampler
Value	relabel.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
Value	replace.h	/^  const A& Value() const {$/;"	f	class:fst::ArcIterator
Value	sparse-tuple-weight.h	/^  const Pair& Value() const { return init_ ? first_ : *iter_; }$/;"	f	class:fst::SparseTupleWeightIterator
Value	state-map.h	/^  const A &Value() const { return aiter_->Value(); }$/;"	f	class:fst::IdentityStateMapper
Value	state-map.h	/^  const A &Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcSumMapper
Value	state-map.h	/^  const A &Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcUniqueMapper
Value	string-weight.h	/^  const L& Value() const { return init_ ? first_ : *iter_; }$/;"	f	class:fst::StringWeightIterator
Value	string-weight.h	/^  const L& Value() const { return iter_ == rest_.rend() ? first_ : *iter_; }$/;"	f	class:fst::StringWeightReverseIterator
Value	symbol-table.h	/^  int64 Value(void) {$/;"	f	class:fst::SymbolTableIterator
Value	tuple-weight.h	/^  const W& Value(size_t i) const { return values_[i]; }$/;"	f	class:fst::TupleWeight
Value	vector-fst.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
Value	vector-fst.h	/^  const A& Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcIterator
Value	vector-fst.h	/^  const A& Value() const { return state_->arcs[i_]; }$/;"	f	class:fst::MutableArcIterator
Value1	pair-weight.h	/^  const W1& Value1() const { return value1_; }$/;"	f	class:fst::PairWeight
Value2	pair-weight.h	/^  const W2& Value2() const { return value2_; }$/;"	f	class:fst::PairWeight
Value_	arc-map.h	/^  StateId Value_() const { return Value(); }$/;"	f	class:fst::StateIterator
Value_	cache.h	/^  virtual StateId Value_() const { return Value(); }$/;"	f	class:fst::CacheStateIterator
Value_	cache.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::CacheMutableArcIterator
Value_	complement.h	/^  virtual StateId Value_() const { return Value(); }$/;"	f	class:fst::StateIterator
Value_	complement.h	/^  virtual const A& Value_() const { return Value(); }$/;"	f	class:fst::ArcIterator
Value_	lookahead-matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::ArcLookAheadMatcher
Value_	lookahead-matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::LabelLookAheadMatcher
Value_	lookahead-matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::TrivialLookAheadMatcher
Value_	matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::PhiMatcher
Value_	matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::RhoMatcher
Value_	matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::SigmaMatcher
Value_	matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::SortedMatcher
Value_	relabel.h	/^  StateId Value_() const { return Value(); }$/;"	f	class:fst::StateIterator
Value_	replace.h	/^  virtual const Arc& Value_() const {$/;"	f	class:fst::ReplaceFstMatcher
Value_	vector-fst.h	/^  virtual const A& Value_() const { return Value(); }$/;"	f	class:fst::MutableArcIterator
VectorBiTable	bi-table.h	/^  explicit VectorBiTable(FP *fp = 0) : fp_(fp ? fp : new FP()) {}$/;"	f	class:fst::VectorBiTable
VectorBiTable	bi-table.h	/^class VectorBiTable {$/;"	c	namespace:fst
VectorFst	vector-fst.h	/^  VectorFst() : ImplToMutableFst<Impl>(new Impl) {}$/;"	f	class:fst::VectorFst
VectorFst	vector-fst.h	/^  VectorFst(const VectorFst<A> &fst) : ImplToMutableFst<Impl>(fst) {}$/;"	f	class:fst::VectorFst
VectorFst	vector-fst.h	/^  explicit VectorFst(Impl *impl) : ImplToMutableFst<Impl>(impl) {}$/;"	f	class:fst::VectorFst
VectorFst	vector-fst.h	/^  explicit VectorFst(const Fst<A> &fst)$/;"	f	class:fst::VectorFst
VectorFst	vector-fst.h	/^class VectorFst : public ImplToMutableFst< VectorFstImpl<A> > {$/;"	c	namespace:fst
VectorFstBaseImpl	vector-fst.h	/^  VectorFstBaseImpl() : start_(kNoStateId) {}$/;"	f	class:fst::VectorFstBaseImpl
VectorFstBaseImpl	vector-fst.h	/^class VectorFstBaseImpl : public FstImpl<typename State::Arc> {$/;"	c	namespace:fst
VectorFstImpl	vector-fst.h	/^  VectorFstImpl() {$/;"	f	class:fst::VectorFstImpl
VectorFstImpl	vector-fst.h	/^VectorFstImpl<A>::VectorFstImpl(const Fst<A> &fst) {$/;"	f	class:fst::VectorFstImpl
VectorFstImpl	vector-fst.h	/^class VectorFstImpl : public VectorFstBaseImpl< VectorState<A> > {$/;"	c	namespace:fst
VectorHashBiTable	bi-table.h	/^  VectorHashBiTable(S *s, FP *fp, H *h,$/;"	f	class:fst::VectorHashBiTable
VectorHashBiTable	bi-table.h	/^class VectorHashBiTable {$/;"	c	namespace:fst
VectorHashReplaceStateTable	replace.h	/^  VectorHashReplaceStateTable($/;"	f	class:fst::VectorHashReplaceStateTable
VectorHashReplaceStateTable	replace.h	/^  VectorHashReplaceStateTable(const VectorHashReplaceStateTable<A, P> &table)$/;"	f	class:fst::VectorHashReplaceStateTable
VectorHashReplaceStateTable	replace.h	/^class VectorHashReplaceStateTable {$/;"	c	namespace:fst
VectorHashStateTable	state-table.h	/^  VectorHashStateTable(S *s, FP *fp, H *h,$/;"	f	class:fst::VectorHashStateTable
VectorHashStateTable	state-table.h	/^class VectorHashStateTable$/;"	c	namespace:fst
VectorState	vector-fst.h	/^  VectorState() : final(Weight::Zero()), niepsilons(0), noepsilons(0) {}$/;"	f	struct:fst::VectorState
VectorState	vector-fst.h	/^struct VectorState {$/;"	s	namespace:fst
VectorStateTable	state-table.h	/^  explicit VectorStateTable(FP *fp = 0) : VectorBiTable<StateId, T, FP>(fp) {}$/;"	f	class:fst::VectorStateTable
VectorStateTable	state-table.h	/^class VectorStateTable$/;"	c	namespace:fst
Verify	verify.h	/^bool Verify(const Fst<Arc> &fst, bool allow_negative_labels = false) {$/;"	f	namespace:fst
Version	fst.h	/^  int32 Version() const { return version_; }$/;"	f	class:fst::FstHeader
Visit	visit.h	/^inline void Visit(const Fst<Arc> &fst, V *visitor, Q* queue) {$/;"	f	namespace:fst
Visit	visit.h	/^void Visit(const Fst<Arc> &fst, V *visitor, Q *queue, ArcFilter filter) {$/;"	f	namespace:fst
W	random-weight.h	/^  typedef typename G::Weight W;$/;"	t	class:fst::GallicWeightGenerator
W	random-weight.h	/^  typedef typename G::Weight W;$/;"	t	class:fst::PowerWeightGenerator
W	random-weight.h	/^  typedef typename G::Weight W;$/;"	t	class:fst::SparsePowerWeightGenerator
W1	expectation-weight.h	/^  typedef X1 W1;$/;"	t	class:fst::ExpectationWeight
W1	random-weight.h	/^  typedef typename G1::Weight W1;$/;"	t	class:fst::LexicographicWeightGenerator
W1	random-weight.h	/^  typedef typename G1::Weight W1;$/;"	t	class:fst::ProductWeightGenerator
W2	expectation-weight.h	/^  typedef X2 W2;$/;"	t	class:fst::ExpectationWeight
W2	random-weight.h	/^  typedef typename G2::Weight W2;$/;"	t	class:fst::LexicographicWeightGenerator
W2	random-weight.h	/^  typedef typename G2::Weight W2;$/;"	t	class:fst::ProductWeightGenerator
WF	lookahead-filter.h	/^  typedef PushWeightsComposeFilter<LF, M> WF;$/;"	t	class:fst::DefaultLookAhead
WRITE_POD_TYPE	util.h	176;"	d
WRITE_STL_ASSOC_TYPE	util.h	227;"	d
WRITE_STL_SEQ_TYPE	util.h	212;"	d
Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::CacheLogAccumulator
Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::CacheLogAccumulatorData
Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DefaultAccumulator
Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FastLogAccumulator
Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::LogAccumulator
Weight	accumulator.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ReplaceAccumulator
Weight	add-on.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::AddOnImpl
Weight	arc-map.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::InvertWeightMapper
Weight	arc-map.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::PlusMapper
Weight	arc-map.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::TimesMapper
Weight	arc-map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::ArcMapFst
Weight	arc-map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::ArcMapFstImpl
Weight	arc.h	/^  typedef ExpectationWeight<X1, X2> Weight;$/;"	t	struct:fst::ExpectationArc
Weight	arc.h	/^  typedef GallicWeight<Label, typename A::Weight, S> Weight;$/;"	t	struct:fst::GallicArc
Weight	arc.h	/^  typedef LexicographicWeight<W1, W2> Weight;$/;"	t	struct:fst::LexicographicArc
Weight	arc.h	/^  typedef PowerWeight<typename A::Weight, n> Weight;$/;"	t	struct:fst::PowerArc
Weight	arc.h	/^  typedef ProductWeight<W1, W2> Weight;$/;"	t	struct:fst::ProductArc
Weight	arc.h	/^  typedef SparsePowerWeight<typename A::Weight, K> Weight;$/;"	t	struct:fst::SparsePowerArc
Weight	arc.h	/^  typedef StringWeight<int, S> Weight;$/;"	t	class:fst::StringArc
Weight	arc.h	/^  typedef W Weight;$/;"	t	class:fst::ArcTpl
Weight	arc.h	/^  typedef typename AWeight::ReverseWeight Weight;$/;"	t	struct:fst::ReverseArc
Weight	arcsort.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ArcSortMapper
Weight	cache.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::CacheState
Weight	cache.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::CacheBaseImpl
Weight	cache.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::CacheMutableArcIterator
Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::AcceptorCompactor
Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::CompactFstImpl
Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StringCompactor
Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::UnweightedAcceptorCompactor
Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::UnweightedCompactor
Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::WeightedStringCompactor
Weight	complement.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ArcIterator
Weight	complement.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ComplementFstImpl
Weight	compose-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::AltSequenceComposeFilter
Weight	compose-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::MatchComposeFilter
Weight	compose-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::MultiEpsFilter
Weight	compose-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::SequenceComposeFilter
Weight	compose.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ComposeFst
Weight	compose.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ComposeFstImplBase
Weight	compose.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ComposeFstImpl
Weight	concat.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ConcatFst
Weight	connect.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::SccVisitor
Weight	connect.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::CcVisitor
Weight	const-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ConstFstImpl
Weight	determinize.h	/^  typedef GallicWeight<L, W, S> Weight;$/;"	t	class:fst::GallicCommonDivisor
Weight	determinize.h	/^  typedef StringWeight<L, S> Weight;$/;"	t	class:fst::LabelCommonDivisor
Weight	determinize.h	/^  typedef W Weight;$/;"	t	class:fst::DefaultCommonDivisor
Weight	determinize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DeterminizeFsaImpl
Weight	determinize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DeterminizeFst
Weight	determinize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DeterminizeFstImpl
Weight	determinize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DeterminizeFstImplBase
Weight	determinize.h	/^  typedef typename Arc::Weight Weight;$/;"	t	struct:fst::DeterminizeOptions
Weight	difference.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DifferenceFst
Weight	edit-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::EditFstData
Weight	edit-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::EditFstImpl
Weight	encode.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::EncodeMapper
Weight	encode.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::EncodeTable
Weight	equivalent.h	/^  typedef typename Arc::Weight Weight;$/;"	t	struct:fst::EquivalenceUtil
Weight	expanded-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ImplToExpandedFst
Weight	factor-weight.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FactorWeightFst
Weight	factor-weight.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FactorWeightFstImpl
Weight	fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::Fst
Weight	fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FstImpl
Weight	fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ImplToFst
Weight	intersect.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::IntersectFst
Weight	label-reachable.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::LabelReachable
Weight	lookahead-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LookAheadComposeFilter
Weight	lookahead-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::PushLabelsComposeFilter
Weight	lookahead-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::PushWeightsComposeFilter
Weight	lookahead-matcher.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::LookAheadMatcherBase
Weight	lookahead-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ArcLookAheadMatcher
Weight	lookahead-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LabelLookAheadMatcher
Weight	lookahead-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LookAheadMatcher
Weight	lookahead-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::TrivialLookAheadMatcher
Weight	map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::MapFst
Weight	matcher-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LookAheadMatcher
Weight	matcher.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::MatcherBase
Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::Matcher
Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::MultiEpsMatcher
Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::PhiMatcher
Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::RhoMatcher
Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::SigmaMatcher
Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::SortedMatcher
Weight	minimize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::AcyclicMinimizer
Weight	minimize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::CyclicMinimizer
Weight	minimize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StateComparator
Weight	mutable-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::MutableFst
Weight	mutable-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ImplToMutableFst
Weight	prune.h	/^  typedef W Weight;$/;"	t	class:fst::PruneCompare
Weight	prune.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::PruneOptions
Weight	queue.h	/^  typedef W Weight;$/;"	t	class:fst::NaturalPruneQueue
Weight	queue.h	/^  typedef typename L::Weight Weight;$/;"	t	class:fst::AStarWeightCompare
Weight	queue.h	/^  typedef typename L::Weight Weight;$/;"	t	class:fst::PruneQueue
Weight	queue.h	/^  typedef typename L::Weight Weight;$/;"	t	class:fst::StateWeightCompare
Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ArcSampler
Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FastLogProbArcSelector
Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::LogProbArcSelector
Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::RandGenFst
Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::RandGenFstImpl
Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::UniformArcSelector
Weight	randgen.h	/^  typedef typename IArc::Weight Weight;$/;"	t	class:fst::RandGenVisitor
Weight	random-weight.h	/^  typedef GallicWeight<L, W, S> Weight;$/;"	t	class:fst::GallicWeightGenerator
Weight	random-weight.h	/^  typedef LexicographicWeight<W1, W2> Weight;$/;"	t	class:fst::LexicographicWeightGenerator
Weight	random-weight.h	/^  typedef LogWeightTpl<T> Weight;$/;"	t	class:fst::LogWeightGenerator_
Weight	random-weight.h	/^  typedef MinMaxWeightTpl<T> Weight;$/;"	t	class:fst::MinMaxWeightGenerator_
Weight	random-weight.h	/^  typedef PowerWeight<W, n> Weight;$/;"	t	class:fst::PowerWeightGenerator
Weight	random-weight.h	/^  typedef SignedLogWeightTpl<T> Weight;$/;"	t	class:fst::SignedLogWeightGenerator_
Weight	random-weight.h	/^  typedef SparsePowerWeight<W, K> Weight;$/;"	t	class:fst::SparsePowerWeightGenerator
Weight	random-weight.h	/^  typedef StringWeight<L, S> Weight;$/;"	t	class:fst::StringWeightGenerator
Weight	random-weight.h	/^  typedef TropicalWeightTpl<T> Weight;$/;"	t	class:fst::TropicalWeightGenerator_
Weight	random-weight.h	/^  typedef W Weight;$/;"	t	class:fst::ProductWeightGenerator
Weight	rational.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::RationalFstImpl
Weight	relabel.h	/^  typedef typename A::Weight  Weight;$/;"	t	class:fst::RelabelFst
Weight	relabel.h	/^  typedef typename A::Weight  Weight;$/;"	t	class:fst::RelabelFstImpl
Weight	replace-util.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ReplaceUtil
Weight	replace.h	/^  typedef typename A::Weight  Weight;$/;"	t	class:fst::ReplaceFst
Weight	replace.h	/^  typedef typename A::Weight  Weight;$/;"	t	class:fst::ReplaceFstImpl
Weight	rmepsilon.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::RmEpsilonFstImpl
Weight	rmepsilon.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::RmEpsilonOptions
Weight	rmepsilon.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::RmEpsilonState
Weight	shortest-distance.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ShortestDistanceState
Weight	shortest-path.h	/^  typedef W Weight;$/;"	t	class:fst::ShortestPathCompare
Weight	shortest-path.h	/^  typedef typename Arc::Weight Weight;$/;"	t	struct:fst::ShortestPathOptions
Weight	state-map.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ArcSumMapper
Weight	state-map.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ArcUniqueMapper
Weight	state-map.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::IdentityStateMapper
Weight	state-map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::StateMapFst
Weight	state-map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::StateMapFstImpl
Weight	state-reachable.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::IntervalReachVisitor
Weight	state-reachable.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StateReachable
Weight	string.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StringCompiler
Weight	string.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StringPrinter
Weight	synchronize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::SynchronizeFst
Weight	synchronize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::SynchronizeFstImpl
Weight	union.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::UnionFst
Weight	vector-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::MutableArcIterator
Weight	vector-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::VectorFstImpl
Weight	vector-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::VectorState
Weight	vector-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::VectorFstBaseImpl
Weight	weight.h	/^  typedef W Weight;$/;"	t	class:fst::NaturalLess
WeightConvert	float-weight.h	/^struct WeightConvert<Log64Weight, LogWeight> {$/;"	s	namespace:fst
WeightConvert	float-weight.h	/^struct WeightConvert<Log64Weight, TropicalWeight> {$/;"	s	namespace:fst
WeightConvert	float-weight.h	/^struct WeightConvert<LogWeight, Log64Weight> {$/;"	s	namespace:fst
WeightConvert	float-weight.h	/^struct WeightConvert<LogWeight, TropicalWeight> {$/;"	s	namespace:fst
WeightConvert	float-weight.h	/^struct WeightConvert<TropicalWeight, Log64Weight> {$/;"	s	namespace:fst
WeightConvert	float-weight.h	/^struct WeightConvert<TropicalWeight, LogWeight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<Log64Weight, SignedLog64Weight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<Log64Weight, SignedLogWeight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<LogWeight, SignedLog64Weight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<LogWeight, SignedLogWeight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLog64Weight, Log64Weight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLog64Weight, LogWeight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLog64Weight, SignedLogWeight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLog64Weight, TropicalWeight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLogWeight, Log64Weight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLogWeight, LogWeight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLogWeight, SignedLog64Weight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLogWeight, TropicalWeight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<TropicalWeight, SignedLog64Weight> {$/;"	s	namespace:fst
WeightConvert	signed-log-weight.h	/^struct WeightConvert<TropicalWeight, SignedLogWeight> {$/;"	s	namespace:fst
WeightConvert	weight.h	/^struct WeightConvert {$/;"	s	namespace:fst
WeightConvert	weight.h	/^struct WeightConvert<W, W> {$/;"	s	namespace:fst
WeightConvertMapper	arc-map.h	/^class WeightConvertMapper {$/;"	c	namespace:fst
WeightEnd	accumulator.h	/^  double *WeightEnd() { return &(weights_[weights_.size() - 1]); };$/;"	f	class:fst::FastLogAccumulatorData
WeightFilterState	compose-filter.h	/^  WeightFilterState() : weight_(W::Zero()) {}$/;"	f	class:fst::WeightFilterState
WeightFilterState	compose-filter.h	/^  explicit WeightFilterState(W w) : weight_(w) {}$/;"	f	class:fst::WeightFilterState
WeightFilterState	compose-filter.h	/^class WeightFilterState {$/;"	c	namespace:fst
WeightFromString	vector-fst.h	/^template <class W> class WeightFromString {$/;"	c	namespace:fst
WeightPositions	accumulator.h	/^  vector<ssize_t> *WeightPositions() { return &weight_positions_; }$/;"	f	class:fst::FastLogAccumulatorData
WeightToStr	util.h	/^void WeightToStr(Weight w, string *s) {$/;"	f	namespace:fst
WeightedStringCompactor	compact-fst.h	/^class WeightedStringCompactor {$/;"	c	namespace:fst
Weights	accumulator.h	/^  vector<double> *Weights() { return &weights_; }$/;"	f	class:fst::FastLogAccumulatorData
WhiteArc	connect.h	/^  bool WhiteArc(StateId s, const A &arc) {$/;"	f	class:fst::CcVisitor
WhiteArc	visit.h	/^  bool WhiteArc(StateId s, const Arc &arc) { return true; }$/;"	f	class:fst::PartialVisitor
WhiteArc	visit.h	/^  bool WhiteArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CopyVisitor
Write	add-on.h	/^  bool Write(ostream &ostrm) const { return true; }$/;"	f	class:fst::NullAddOn
Write	add-on.h	/^  bool Write(ostream &ostrm) const {$/;"	f	class:fst::AddOnPair
Write	add-on.h	/^  bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::AddOnImpl
Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::AcceptorCompactor
Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::StringCompactor
Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::UnweightedAcceptorCompactor
Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::UnweightedCompactor
Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::WeightedStringCompactor
Write	compact-fst.h	/^  bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::CompactFstImpl
Write	compact-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::CompactFst
Write	compact-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::CompactFst
Write	compact-fst.h	/^bool CompactFstData<E, U>::Write(ostream &strm,$/;"	f	class:fst::CompactFstData
Write	const-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::ConstFst
Write	const-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::ConstFst
Write	edit-fst.h	/^  bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::EditFstData
Write	edit-fst.h	/^  bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::EditFstImpl
Write	edit-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::EditFst
Write	edit-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::EditFst
Write	encode.h	/^  bool Write(const string& filename) {$/;"	f	class:fst::EncodeMapper
Write	encode.h	/^  bool Write(ostream &strm, const string& source) {$/;"	f	class:fst::EncodeMapper
Write	encode.h	/^bool EncodeTable<A>::Write(ostream &strm, const string &source) const {$/;"	f	class:fst::EncodeTable
Write	float-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::FloatWeightTpl
Write	fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::Fst
Write	fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::Fst
Write	interval-set.h	/^    ostream &Write(ostream &strm) const {$/;"	f	struct:fst::IntervalSet::Interval
Write	interval-set.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::IntervalSet
Write	label-reachable.h	/^  bool Write(ostream &ostrm) {$/;"	f	class:fst::LabelReachableData
Write	matcher-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::MatcherFst
Write	matcher-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::MatcherFst
Write	pair-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::PairWeight
Write	sparse-tuple-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::SparseTupleWeight
Write	string-weight.h	/^inline ostream &StringWeight<L, S>::Write(ostream &strm) const {$/;"	f	class:fst::StringWeight
Write	symbol-table.h	/^  bool Write(const string& filename) const {$/;"	f	class:fst::SymbolTable
Write	symbol-table.h	/^  virtual bool Write(ostream &strm) const {$/;"	f	class:fst::SymbolTable
Write	tuple-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::TupleWeight
Write	vector-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::VectorFst
Write	vector-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::VectorFst
WriteFile	fst.h	/^  bool WriteFile(const string &filename) const {$/;"	f	class:fst::Fst
WriteFst	const-fst.h	/^bool ConstFst<A, U>::WriteFst(const F &fst, ostream &strm,$/;"	f	class:fst::ConstFst
WriteFst	vector-fst.h	/^bool VectorFst<A>::WriteFst(const F &fst, ostream &strm,$/;"	f	class:fst::VectorFst
WriteFstHeader	fst.h	/^  static void WriteFstHeader(const Fst<A> &fst, ostream &strm,$/;"	f	class:fst::FstImpl
WriteHeader	fst.h	/^  void WriteHeader(ostream &strm, const FstWriteOptions& opts,$/;"	f	class:fst::FstImpl
WriteLabelPairs	util.h	/^bool WriteLabelPairs(const string& filename,$/;"	f	namespace:fst
WriteText	symbol-table.h	/^  bool WriteText(const string& filename) const {$/;"	f	class:fst::SymbolTable
WriteType	util.h	/^inline ostream &WriteType(ostream &strm, const T t) {$/;"	f	namespace:fst
WriteType	util.h	/^inline ostream &WriteType(ostream &strm, const pair<S, T> &p) {$/;"	f	namespace:fst
WriteType	util.h	/^inline ostream &WriteType(ostream &strm, const string &s) {$/;"	f	namespace:fst
X1	arc.h	/^  typedef typename A::Weight X1;$/;"	t	struct:fst::ExpectationArc
X1	signed-log-weight.h	/^  typedef TropicalWeight X1;$/;"	t	class:fst::SignedLogWeightTpl
X2	signed-log-weight.h	/^  typedef LogWeightTpl<T> X2;$/;"	t	class:fst::SignedLogWeightTpl
Zero	expectation-weight.h	/^  static const ExpectationWeight<X1, X2> &Zero() {$/;"	f	class:fst::ExpectationWeight
Zero	float-weight.h	/^  static const LogWeightTpl<T> Zero() {$/;"	f	class:fst::LogWeightTpl
Zero	float-weight.h	/^  static const MinMaxWeightTpl<T> Zero() {$/;"	f	class:fst::MinMaxWeightTpl
Zero	float-weight.h	/^  static const TropicalWeightTpl<T> Zero() {$/;"	f	class:fst::TropicalWeightTpl
Zero	lexicographic-weight.h	/^  static const LexicographicWeight<W1, W2> &Zero() {$/;"	f	class:fst::LexicographicWeight
Zero	pair-weight.h	/^  static const PairWeight<W1, W2> &Zero() {$/;"	f	class:fst::PairWeight
Zero	power-weight.h	/^  static const PowerWeight<W, n> &Zero() {$/;"	f	class:fst::PowerWeight
Zero	product-weight.h	/^  static const ProductWeight<W1, W2> &Zero() {$/;"	f	class:fst::ProductWeight
Zero	signed-log-weight.h	/^  static const SignedLogWeightTpl<T> &Zero() {$/;"	f	class:fst::SignedLogWeightTpl
Zero	sparse-power-weight.h	/^  static const SparsePowerWeight<W, K> &Zero() {$/;"	f	class:fst::SparsePowerWeight
Zero	sparse-tuple-weight.h	/^  static const SparseTupleWeight<W, K> &Zero() {$/;"	f	class:fst::SparseTupleWeight
Zero	string-weight.h	/^  static const StringWeight<L, S> &Zero() {$/;"	f	class:fst::StringWeight
Zero	tuple-weight.h	/^  static const TupleWeight<W, n> &Zero() {$/;"	f	class:fst::TupleWeight
__fst_union_find_inl_h__	union-find.h	22;"	d
a1_	add-on.h	/^  A1 *a1_;$/;"	m	class:fst::AddOnPair
a2_	add-on.h	/^  A2 *a2_;$/;"	m	class:fst::AddOnPair
access_	connect.h	/^  vector<bool> *access_;        \/\/ State's accessibility$/;"	m	class:fst::SccVisitor
accumulator_	label-reachable.h	/^  S *accumulator_;                        \/\/ Sums arc weights$/;"	m	class:fst::LabelReachable
accumulator_	randgen.h	/^  C *accumulator_;$/;"	m	class:fst::ArcSampler
accumulators_	accumulator.h	/^  vector<Accumulator*> accumulators_;$/;"	m	class:fst::ReplaceAccumulatorData
acyclic_	topsort.h	/^  bool *acyclic_;$/;"	m	class:fst::TopOrderVisitor
address	flags.h	/^  T *address;$/;"	m	struct:FlagDescription
aiter_	complement.h	/^  ArcIterator< Fst<A> > *aiter_;$/;"	m	class:fst::ArcIterator
aiter_	matcher.h	/^  ArcIterator<F> *aiter_;         \/\/ Iterator for current state$/;"	m	class:fst::SortedMatcher
aiter_	state-map.h	/^  ArcIterator< Fst<A> > *aiter_;$/;"	m	class:fst::IdentityStateMapper
aiter_queue_	minimize.h	/^  ArcIterQueue* aiter_queue_;$/;"	m	class:fst::CyclicMinimizer
align	fst.h	/^  bool align;                    \/\/ Write data aligned where appropriate;$/;"	m	struct:fst::FstWriteOptions
alleps1_	compose-filter.h	/^  bool alleps1_, alleps2_;  \/\/ Only epsilons (and non-final) leaving s1, s2?$/;"	m	class:fst::MatchComposeFilter
alleps1_	compose-filter.h	/^  bool alleps1_;   \/\/ Only epsilons (and non-final) leaving s1_?$/;"	m	class:fst::SequenceComposeFilter
alleps2_	compose-filter.h	/^  bool alleps1_, alleps2_;  \/\/ Only epsilons (and non-final) leaving s1, s2?$/;"	m	class:fst::MatchComposeFilter
alleps2_	compose-filter.h	/^  bool alleps2_;   \/\/ Only epsilons (and non-final) leaving s2_?$/;"	m	class:fst::AltSequenceComposeFilter
allocator_	cache.h	/^  C *allocator_;                             \/\/ used to allocate new states$/;"	m	class:fst::CacheBaseImpl
allow_negative_	string.h	/^  bool allow_negative_;      \/\/ Negative labels allowed?$/;"	m	class:fst::StringCompiler
allow_repeated_split_	partition.h	/^  bool allow_repeated_split_;$/;"	m	class:fst::Partition
allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero divisors$/;"	m	class:fst::LogWeightGenerator_
allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero divisors$/;"	m	class:fst::MinMaxWeightGenerator_
allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero divisors$/;"	m	class:fst::SignedLogWeightGenerator_
allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero divisors$/;"	m	class:fst::TropicalWeightGenerator_
allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero$/;"	m	class:fst::StringWeightGenerator
allow_zero_	random-weight.h	/^  bool allow_zero_;$/;"	m	class:fst::LexicographicWeightGenerator
always_cache_	replace.h	/^  bool always_cache_;  \/\/ Optionally caching arc iterator disabled when true$/;"	m	class:fst::ReplaceFstImpl
arc_	compact-fst.h	/^  mutable A arc_;$/;"	m	class:fst::ArcIterator
arc_	complement.h	/^  mutable A arc_;$/;"	m	class:fst::ArcIterator
arc_	replace.h	/^  mutable Arc arc_;         \/\/ Memory to temporarily store computed arcs$/;"	m	class:fst::ArcIterator
arc_	replace.h	/^  mutable Arc arc_;$/;"	m	class:fst::ReplaceFstMatcher
arc_filter	shortest-distance.h	/^  ArcFilter arc_filter;  \/\/ Arc filter (e.g., limit to only epsilon graph)$/;"	m	struct:fst::ShortestDistanceOptions
arc_filter_	shortest-distance.h	/^  ArcFilter arc_filter_;$/;"	m	class:fst::ShortestDistanceState
arc_iter	dfs-visit.h	/^  ArcIterator< Fst<Arc> > arc_iter;  \/\/ and its corresponding arcs$/;"	m	struct:fst::DfsState
arc_limit_	accumulator.h	/^  ssize_t arc_limit_;                    \/\/ Minimum # of arcs to cache a state$/;"	m	class:fst::CacheLogAccumulator
arc_limit_	accumulator.h	/^  ssize_t arc_limit_;     \/\/ Minimum # of arcs to pre-compute state$/;"	m	class:fst::FastLogAccumulator
arc_period_	accumulator.h	/^  ssize_t arc_period_;    \/\/ Save cumulative weights per 'arc_period_'.$/;"	m	class:fst::FastLogAccumulator
arc_sampler	randgen.h	/^  S *arc_sampler;            \/\/ How to sample transitions at a state$/;"	m	struct:fst::RandGenFstOptions
arc_sampler_	randgen.h	/^  S *arc_sampler_;$/;"	m	class:fst::RandGenFstImpl
arc_selector	randgen.h	/^  const S &arc_selector;     \/\/ How an arc is selected at a state$/;"	m	struct:fst::RandGenOptions
arc_selector_	randgen.h	/^  const S &arc_selector_;$/;"	m	class:fst::ArcSampler
arcs	cache.h	/^  vector<A> arcs;            \/\/ Arcs represenation$/;"	m	struct:fst::CacheState
arcs	fst.h	/^  const A *arcs;             \/\/ O.w. arcs pointer$/;"	m	struct:fst::ArcIteratorData
arcs	vector-fst.h	/^  vector<A> arcs;            \/\/ Arcs represenation$/;"	m	struct:fst::VectorState
arcs_	arcsort.h	/^  vector<Arc> arcs_;$/;"	m	class:fst::ArcSortMapper
arcs_	const-fst.h	/^  A *arcs_;                      \/\/ Arcs representation$/;"	m	class:fst::ConstFstImpl
arcs_	const-fst.h	/^  const A *arcs_;$/;"	m	class:fst::ArcIterator
arcs_	replace.h	/^  mutable const A* arcs_;       \/\/ Array of arcs$/;"	m	class:fst::ArcIterator
arcs_	rmepsilon.h	/^  vector<Arc> arcs_;              \/\/ Arcs of state being expanded$/;"	m	class:fst::RmEpsilonState
arcs_	state-map.h	/^  vector<A> arcs_;$/;"	m	class:fst::ArcSumMapper
arcs_	state-map.h	/^  vector<A> arcs_;$/;"	m	class:fst::ArcUniqueMapper
arcs_	vector-fst.h	/^  const vector<A>& arcs_;$/;"	m	class:fst::ArcIterator
arctype_	fst.h	/^  string arctype_;                   \/\/ E.g. "standard"$/;"	m	class:fst::FstHeader
available_key_	symbol-table.h	/^  int64 available_key_;$/;"	m	class:fst::SymbolTableImpl
back_	queue.h	/^  StateId back_;$/;"	m	class:fst::SccQueue
back_	queue.h	/^  StateId back_;$/;"	m	class:fst::StateOrderQueue
back_	queue.h	/^  StateId back_;$/;"	m	class:fst::TopOrderQueue
base	fst.h	/^  ArcIteratorBase<A> *base;  \/\/ Specialized iterator if non-zero$/;"	m	struct:fst::ArcIteratorData
base	fst.h	/^  StateIteratorBase<A> *base;   \/\/ Specialized iterator if non-zero$/;"	m	struct:fst::StateIteratorData
base	mutable-fst.h	/^  MutableArcIteratorBase<A> *base;  \/\/ Specific iterator$/;"	m	struct:fst::MutableArcIteratorData
base_	lookahead-matcher.h	/^  MatcherBase<Arc> *base_;$/;"	m	class:fst::LookAheadMatcher
base_	matcher.h	/^  MatcherBase<Arc> *base_;$/;"	m	class:fst::Matcher
begin	interval-set.h	/^    T begin;$/;"	m	struct:fst::IntervalSet::Interval
binary_label_	matcher.h	/^  Label binary_label_;            \/\/ Least label for binary search$/;"	m	class:fst::SortedMatcher
bit_cast	compat.h	/^inline Dest bit_cast(const Source& source) {$/;"	f	namespace:fst
cache_	accumulator.h	/^  unordered_map<StateId, CacheState> cache_;  \/\/ Cache$/;"	m	class:fst::CacheLogAccumulatorData
cache_data_	replace.h	/^  mutable ArcIteratorData<Arc> cache_data_;  \/\/ Arc iterator data in cache$/;"	m	class:fst::ArcIterator
cache_first_state_	cache.h	/^  S *cache_first_state_;                     \/\/ First cached state$/;"	m	class:fst::CacheBaseImpl
cache_first_state_id_	cache.h	/^  StateId cache_first_state_id_;             \/\/ First cached state id$/;"	m	class:fst::CacheBaseImpl
cache_gc_	accumulator.h	/^  bool cache_gc_;                        \/\/ Enable garbage collection$/;"	m	class:fst::CacheLogAccumulatorData
cache_gc_	cache.h	/^  bool cache_gc_;                            \/\/ enable GC$/;"	m	class:fst::CacheBaseImpl
cache_limit_	accumulator.h	/^  size_t cache_limit_;                   \/\/ # of bytes cached$/;"	m	class:fst::CacheLogAccumulatorData
cache_limit_	cache.h	/^  size_t cache_limit_;                       \/\/ # of bytes allowed before GC$/;"	m	class:fst::CacheBaseImpl
cache_size_	accumulator.h	/^  size_t cache_size_;                    \/\/ # of bytes allowed before GC$/;"	m	class:fst::CacheLogAccumulatorData
cache_size_	cache.h	/^  size_t cache_size_;                        \/\/ # of bytes cached$/;"	m	class:fst::CacheBaseImpl
cache_start_	cache.h	/^  mutable bool cache_start_;                 \/\/ Is the start state cached?$/;"	m	class:fst::CacheBaseImpl
cache_states_	cache.h	/^  list<StateId> cache_states_;               \/\/ list of currently cached states$/;"	m	class:fst::CacheBaseImpl
cc_	connect.h	/^  vector<StateId> *cc_;         \/\/ State's cc number$/;"	m	class:fst::CcVisitor
check_sum_	compat.h	/^  string check_sum_;$/;"	m	class:fst::CheckSummer
check_sum_finalized_	symbol-table.h	/^  mutable bool check_sum_finalized_;$/;"	m	class:fst::SymbolTableImpl
check_sum_mutex_	symbol-table.h	/^  mutable Mutex check_sum_mutex_;$/;"	m	class:fst::SymbolTableImpl
check_sum_string_	symbol-table.h	/^  mutable string check_sum_string_;$/;"	m	class:fst::SymbolTableImpl
class_distance_	queue.h	/^  vector<Weight> class_distance_;          \/\/ shortest distance to class$/;"	m	class:fst::PruneQueue
class_func_	queue.h	/^  const C &class_func_;                    \/\/ eqv. class function object$/;"	m	class:fst::PruneQueue
class_id	partition.h	/^  const T class_id(T element_id) const {$/;"	f	class:fst::Partition
class_id_	partition.h	/^  T class_id_;$/;"	m	class:fst::PartitionIterator
class_index_	partition.h	/^  vector<T> class_index_;$/;"	m	class:fst::Partition
class_size	partition.h	/^  const size_t class_size(T class_id)  const {$/;"	f	class:fst::Partition
class_size_	partition.h	/^  vector<T> class_size_;$/;"	m	class:fst::Partition
class_sizes	partition.h	/^  const vector<T>& class_sizes() const {$/;"	f	class:fst::Partition
class_split_	partition.h	/^  vector<Element*> class_split_;$/;"	m	class:fst::Partition
classes_	partition.h	/^  vector<Element*> classes_;$/;"	m	class:fst::Partition
coaccess_	connect.h	/^  vector<bool> *coaccess_;      \/\/ State's coaccessibility$/;"	m	class:fst::SccVisitor
coaccess_internal_	connect.h	/^  bool coaccess_internal_;$/;"	m	class:fst::SccVisitor
common_divisor_	determinize.h	/^  D common_divisor_;$/;"	m	class:fst::DeterminizeFsaImpl
comp_	arcsort.h	/^  const Compare &comp_;$/;"	m	class:fst::ArcSortMapper
comp_	heap.h	/^  Compare comp_;$/;"	m	class:fst::Heap
comp_	state-map.h	/^  Compare comp_;$/;"	m	class:fst::ArcSumMapper
comp_	state-map.h	/^  Compare comp_;$/;"	m	class:fst::ArcUniqueMapper
compactor_	compact-fst.h	/^  C *compactor_;$/;"	m	class:fst::ArcIterator
compactor_	compact-fst.h	/^  C *compactor_;$/;"	m	class:fst::CompactFstImpl
compacts_	compact-fst.h	/^  CompactElement *compacts_;$/;"	m	class:fst::CompactFstData
compacts_	compact-fst.h	/^  const CompactElement *compacts_;$/;"	m	class:fst::ArcIterator
comps_	connect.h	/^  UnionFind<StateId> *comps_;   \/\/ Components$/;"	m	class:fst::CcVisitor
connect	compose.h	/^  bool connect;  \/\/ Connect output$/;"	m	struct:fst::ComposeOptions
connect	rmepsilon.h	/^  bool connect;              \/\/ Connect output$/;"	m	class:fst::RmEpsilonOptions
const_iterator	sparse-tuple-weight.h	/^  typedef typename list<Pair>::const_iterator const_iterator;$/;"	t	class:fst::SparseTupleWeightIterator
const_iterator	util.h	/^  typedef typename set<Key>::const_iterator const_iterator;$/;"	t	class:fst::CompactSet
convert_weight_	arc-map.h	/^  WeightConvert<FromWeight, ToWeight> convert_weight_;$/;"	m	class:fst::WeightConvertMapper
converter	register.h	/^  Converter converter;$/;"	m	struct:fst::FstRegisterEntry
count	lock.h	/^  int count() const { return count_; }$/;"	f	class:fst::RefCounter
count_	compat.h	/^  int count_;$/;"	m	class:fst::CheckSummer
count_	interval-set.h	/^  T count_;$/;"	m	class:fst::IntervalSet
count_	lock.h	/^  mutable int count_;$/;"	m	class:fst::RefCounter
cumulative_size_array_	replace.h	/^  const vector<uint64> *cumulative_size_array_;$/;"	m	class:fst::ReplaceFingerprint
cumulative_size_array_	replace.h	/^  vector<uint64> cumulative_size_array_;$/;"	m	class:fst::VectorHashReplaceStateTable
current_entry_	bi-table.h	/^  const T *current_entry_;$/;"	m	class:fst::CompactHashBiTable
current_entry_	bi-table.h	/^  const T *current_entry_;$/;"	m	class:fst::VectorHashBiTable
current_loop_	matcher.h	/^  bool current_loop_;             \/\/ Current arc is the implicit loop$/;"	m	class:fst::SortedMatcher
current_loop_	matcher.h	/^  bool current_loop_;            \/\/ Current arc is the implicit loop$/;"	m	class:fst::MultiEpsMatcher
current_loop_	replace.h	/^  mutable bool current_loop_;        \/\/ Current arc is the implicit loop$/;"	m	class:fst::ReplaceFstMatcher
current_matcher_	replace.h	/^  LocalMatcher* current_matcher_;$/;"	m	class:fst::ReplaceFstMatcher
data_	accumulator.h	/^  CacheLogAccumulatorData<A> *data_;     \/\/ Cache data$/;"	m	class:fst::CacheLogAccumulator
data_	accumulator.h	/^  FastLogAccumulatorData *data_;$/;"	m	class:fst::FastLogAccumulator
data_	accumulator.h	/^  ReplaceAccumulatorData<Accumulator, T> *data_;$/;"	m	class:fst::ReplaceAccumulator
data_	compact-fst.h	/^  CompactFstData<CompactElement, U> *data_;$/;"	m	class:fst::CompactFstImpl
data_	edit-fst.h	/^  EditFstData<A, WrappedFstT, MutableFstT> *data_;$/;"	m	class:fst::EditFstImpl
data_	fst.h	/^  ArcIteratorData<Arc> data_;$/;"	m	class:fst::ArcIterator
data_	fst.h	/^  StateIteratorData<Arc> data_;$/;"	m	class:fst::StateIterator
data_	label-reachable.h	/^  LabelReachableData<Label> *data_;       \/\/ Shareable data between copies$/;"	m	class:fst::LabelReachable
data_	mutable-fst.h	/^  MutableArcIteratorData<Arc> data_;$/;"	m	class:fst::MutableArcIterator
data_flags_	replace.h	/^  mutable uint32 data_flags_;   \/\/ Arc value flags valid for data in arcs_$/;"	m	class:fst::ArcIterator
default_	sparse-tuple-weight.h	/^  W default_;$/;"	m	class:fst::SparseTupleWeight
default_value	flags.h	/^  const T default_value;$/;"	m	struct:FlagDescription
delta	determinize.h	/^  float delta;                \/\/ Quantization delta for subset weights$/;"	m	struct:fst::DeterminizeFstOptions
delta	determinize.h	/^  float delta;                \/\/ Quantization delta for subset weights.$/;"	m	struct:fst::DeterminizeOptions
delta	factor-weight.h	/^  float delta;$/;"	m	struct:fst::FactorWeightOptions
delta	prune.h	/^  float delta;$/;"	m	class:fst::PruneOptions
delta	rmepsilon.h	/^  float delta;$/;"	m	struct:fst::RmEpsilonFstOptions
delta	shortest-distance.h	/^  float delta;           \/\/ Determines the degree of convergence required$/;"	m	struct:fst::ShortestDistanceOptions
delta_	arc-map.h	/^  float delta_;$/;"	m	struct:fst::QuantizeMapper
delta_	determinize.h	/^  float delta_;                    \/\/ Quantization delta for subset weights$/;"	m	class:fst::DeterminizeFsaImpl
delta_	determinize.h	/^  float delta_;$/;"	m	class:fst::DeterminizeFstImpl
delta_	factor-weight.h	/^  float delta_;$/;"	m	class:fst::FactorWeightFstImpl
delta_	rmepsilon.h	/^  float delta_;$/;"	m	class:fst::RmEpsilonFstImpl
delta_	shortest-distance.h	/^  float delta_;$/;"	m	class:fst::ShortestDistanceState
delta_	shortest-path.h	/^  float delta_;$/;"	m	class:fst::ShortestPathCompare
delta_	sparse-power-weight.h	/^  float delta_;$/;"	m	struct:fst::SparseTupleWeightApproxMapper
dense_key_limit_	symbol-table.h	/^  int64 dense_key_limit_;$/;"	m	class:fst::SymbolTableImpl
depaccess_	replace-util.h	/^  mutable vector<bool> depaccess_;                \/\/ Fst ID accessibility$/;"	m	class:fst::ReplaceUtil
depfst_	replace-util.h	/^  mutable VectorFst<Arc> depfst_;                 \/\/ Fst ID dependencies$/;"	m	class:fst::ReplaceUtil
depprops_	replace-util.h	/^  mutable uint64 depprops_;                       \/\/ dependency Fst props$/;"	m	class:fst::ReplaceUtil
dfnumber_	connect.h	/^  vector<StateId> *dfnumber_;   \/\/ state discovery times$/;"	m	class:fst::SccVisitor
distance	prune.h	/^  const vector<Weight> *distance;$/;"	m	class:fst::PruneOptions
distance_	queue.h	/^  const vector<Weight> &distance_;         \/\/ shortest distance to state$/;"	m	class:fst::PruneQueue
distance_	rmepsilon.h	/^  vector<Weight> *distance_;$/;"	m	class:fst::RmEpsilonState
distance_	rmepsilon.h	/^  vector<Weight> distance_;$/;"	m	class:fst::RmEpsilonFstImpl
distance_	shortest-distance.h	/^  vector<Weight> *distance_;$/;"	m	class:fst::ShortestDistanceState
distance_	shortest-path.h	/^  const vector<Weight> &distance_;$/;"	m	class:fst::ShortestPathCompare
divide_type_	sparse-power-weight.h	/^  DivideType divide_type_;$/;"	m	struct:fst::SparseTupleWeightDivideMapper
doc_string	flags.h	/^  const char *doc_string;$/;"	m	struct:FlagDescription
done_	factor-weight.h	/^  bool done_;$/;"	m	class:fst::GallicFactor
done_	factor-weight.h	/^  bool done_;$/;"	m	class:fst::StringFactor
done_	matcher.h	/^  bool done_;                    \/\/ Matching done$/;"	m	class:fst::MultiEpsMatcher
done_	replace.h	/^  mutable bool done_;$/;"	m	class:fst::ReplaceFstMatcher
down_cast	compat.h	/^inline To down_cast(From* f) {$/;"	f	namespace:fst
edited_final_weights_	edit-fst.h	/^  unordered_map<StateId, Weight> edited_final_weights_;$/;"	m	class:fst::EditFstData
edits_	edit-fst.h	/^  MutableFstT edits_;$/;"	m	class:fst::EditFstData
element_	partition.h	/^  const Element* element_;$/;"	m	class:fst::PartitionIterator
element_map_	factor-weight.h	/^  ElementMap element_map_;    \/\/ mapping Elements to Fst state$/;"	m	class:fst::FactorWeightFstImpl
element_map_	rmepsilon.h	/^  ElementMap element_map_;$/;"	m	class:fst::RmEpsilonState
element_map_	synchronize.h	/^  ElementMap element_map_;    \/\/ mapping Elements to Fst state$/;"	m	class:fst::SynchronizeFstImpl
elements_	determinize.h	/^    vector<Element *> *elements_;$/;"	m	class:fst::DeterminizeFsaImpl::SubsetEqual
elements_	determinize.h	/^  vector<Element *> elements_;$/;"	m	class:fst::DeterminizeFsaImpl
elements_	factor-weight.h	/^  vector<Element> elements_;  \/\/ mapping Fst state to Elements$/;"	m	class:fst::FactorWeightFstImpl
elements_	partition.h	/^  vector<Element*> elements_;$/;"	m	class:fst::Partition
elements_	synchronize.h	/^  vector<Element> elements_;  \/\/ mapping Fst state to Elements$/;"	m	class:fst::SynchronizeFstImpl
empty_entry_	bi-table.h	/^  const T empty_entry_;$/;"	m	class:fst::CompactHashBiTable
empty_entry_	bi-table.h	/^  const T empty_entry_;$/;"	m	class:fst::ErasableBiTable
empty_entry_	bi-table.h	/^  const T empty_entry_;$/;"	m	class:fst::VectorHashBiTable
encode_flags_	encode.h	/^    int32 encode_flags_;$/;"	m	class:fst::EncodeTable::TupleKey
encode_hash_	encode.h	/^  EncodeHash encode_hash_;$/;"	m	class:fst::EncodeTable
encode_tuples_	encode.h	/^  vector<Tuple*> encode_tuples_;$/;"	m	class:fst::EncodeTable
end	interval-set.h	/^    T end;$/;"	m	struct:fst::IntervalSet::Interval
enqueued_	queue.h	/^  vector<bool> enqueued_;$/;"	m	class:fst::StateOrderQueue
enqueued_	shortest-distance.h	/^  vector<bool> enqueued_;     \/\/ Is state enqueued?$/;"	m	class:fst::ShortestDistanceState
entry2id_	bi-table.h	/^  unordered_map<T, I, F> entry2id_;$/;"	m	class:fst::ErasableBiTable
entry2id_	bi-table.h	/^  unordered_map<T, I, H> entry2id_;$/;"	m	class:fst::HashBiTable
eps_filter_	rmepsilon.h	/^  EpsilonArcFilter<Arc> eps_filter_;$/;"	m	class:fst::RmEpsilonState
eps_queue_	rmepsilon.h	/^  stack<StateId> eps_queue_;      \/\/ Queue used to visit the epsilon-closure$/;"	m	class:fst::RmEpsilonState
epsilon_on_replace	replace.h	/^  bool  epsilon_on_replace;$/;"	m	struct:fst::ReplaceFstOptions
epsilon_on_replace_	replace-util.h	/^  bool epsilon_on_replace_;                       \/\/ see Replace()$/;"	m	class:fst::ReplaceUtil
epsilon_on_replace_	replace.h	/^  bool epsilon_on_replace_;$/;"	m	class:fst::ReplaceFstImpl
equal_	state-map.h	/^  Equal equal_;$/;"	m	class:fst::ArcSumMapper
equal_	state-map.h	/^  Equal equal_;$/;"	m	class:fst::ArcUniqueMapper
error_	accumulator.h	/^  bool error_;$/;"	m	class:fst::CacheLogAccumulator
error_	accumulator.h	/^  bool error_;$/;"	m	class:fst::FastLogAccumulator
error_	accumulator.h	/^  bool error_;$/;"	m	class:fst::ReplaceAccumulator
error_	arc-map.h	/^  mutable bool error_;$/;"	m	struct:fst::FromGallicMapper
error_	arc-map.h	/^  mutable bool error_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
error_	compact-fst.h	/^  bool error_;$/;"	m	class:fst::CompactFstData
error_	encode.h	/^  bool error_;$/;"	m	class:fst::EncodeMapper
error_	label-reachable.h	/^  bool error_;$/;"	m	class:fst::LabelReachable
error_	lookahead-matcher.h	/^  bool error_;$/;"	m	class:fst::LabelLookAheadMatcher
error_	matcher.h	/^  bool error_;                    \/\/ Error encountered$/;"	m	class:fst::SortedMatcher
error_	matcher.h	/^  bool error_;             \/\/ Error encountered$/;"	m	class:fst::PhiMatcher
error_	matcher.h	/^  bool error_;             \/\/ Error encountered$/;"	m	class:fst::SigmaMatcher
error_	matcher.h	/^  bool error_;            \/\/ Error encountered$/;"	m	class:fst::RhoMatcher
error_	queue.h	/^  bool error_;$/;"	m	class:fst::QueueBase
error_	shortest-distance.h	/^  bool error_;$/;"	m	class:fst::ShortestDistanceState
error_	state-reachable.h	/^  bool error_;$/;"	m	class:fst::IntervalReachVisitor
error_	state-reachable.h	/^  bool error_;$/;"	m	class:fst::StateReachable
error_	state-table.h	/^  bool error_;$/;"	m	class:fst::DetStringComposeStateTable
error_	state-table.h	/^  bool error_;$/;"	m	class:fst::StringDetComposeStateTable
estimate_	queue.h	/^  const E &estimate_;$/;"	m	class:fst::AStarWeightCompare
exec_stack_	union-find.h	/^  stack<T*> exec_stack_;  \/\/ Used for path compression.$/;"	m	class:fst::UnionFind
expand_id_	rmepsilon.h	/^  StateId expand_id_;             \/\/ Unique ID for each call to Expand$/;"	m	class:fst::RmEpsilonState
expanded_states_	cache.h	/^  vector<bool> expanded_states_;             \/\/ states that have been expanded$/;"	m	class:fst::CacheBaseImpl
external_to_internal_ids_	edit-fst.h	/^  unordered_map<StateId, StateId> external_to_internal_ids_;$/;"	m	class:fst::EditFstData
f1_	compose-filter.h	/^  F1 f1_;$/;"	m	class:fst::PairFilterState
f2_	compose-filter.h	/^  F2 f2_;$/;"	m	class:fst::PairFilterState
f_	compose-filter.h	/^  FilterState f_;           \/\/ Current filter state ID$/;"	m	class:fst::MatchComposeFilter
f_	compose-filter.h	/^  FilterState f_;  \/\/ Current filter state$/;"	m	class:fst::AltSequenceComposeFilter
f_	compose-filter.h	/^  FilterState f_;  \/\/ Current filter state$/;"	m	class:fst::SequenceComposeFilter
f_	lookahead-filter.h	/^  FilterState f_ ;            \/\/ Current filter state$/;"	m	class:fst::PushLabelsComposeFilter
f_	lookahead-filter.h	/^  FilterState f_;                  \/\/ Current filter state$/;"	m	class:fst::PushWeightsComposeFilter
fail_	union-find.h	/^  T fail_;                \/\/ Value indicating lookup failure.$/;"	m	class:fst::UnionFind
fatal_	log.h	/^  bool fatal_;$/;"	m	class:LogMessage
fdistance_	prune.h	/^  const vector<Weight> &fdistance_;$/;"	m	class:fst::PruneCompare
file_name	flags.h	/^  const char *file_name;$/;"	m	struct:FlagDescription
filter	compose.h	/^  F *filter;        \/\/ Composition filter (see compose-filter.h)$/;"	m	struct:fst::ComposeFstImplOptions
filter	compose.h	/^  F *filter;        \/\/ Composition filter (see compose-filter.h)$/;"	m	struct:fst::ComposeFstOptions
filter	prune.h	/^  ArcFilter filter;$/;"	m	class:fst::PruneOptions
filter_	compose-filter.h	/^  F filter_;$/;"	m	class:fst::MultiEpsFilter
filter_	compose.h	/^  F *filter_;$/;"	m	class:fst::ComposeFstImpl
filter_	lookahead-filter.h	/^  F filter_;                       \/\/ Underlying filter$/;"	m	class:fst::PushWeightsComposeFilter
filter_	lookahead-filter.h	/^  F filter_;                    \/\/ Underlying filter$/;"	m	class:fst::LookAheadComposeFilter
filter_	lookahead-filter.h	/^  F filter_;                  \/\/ Underlying filter$/;"	m	class:fst::PushLabelsComposeFilter
filter_state	state-table.h	/^  FilterState filter_state;  \/\/ State of composition filter$/;"	m	struct:fst::ComposeStateTuple
filter_type	compose.h	/^  ComposeFilter filter_type;  \/\/ Which pre-defined filter to use$/;"	m	struct:fst::ComposeOptions
fin_	string-weight.h	/^  bool fin_;   \/\/ in the final state?$/;"	m	class:fst::StringWeightReverseIterator
final	cache.h	/^  Weight final;              \/\/ Final weight$/;"	m	struct:fst::CacheState
final	const-fst.h	/^    Weight final;                \/\/ Final weight$/;"	m	struct:fst::ConstFstImpl::State
final	vector-fst.h	/^  Weight final;              \/\/ Final weight$/;"	m	struct:fst::VectorState
final_	rmepsilon.h	/^  Weight final_;                  \/\/ Final weight of state being expanded$/;"	m	class:fst::RmEpsilonState
final_action_	arc-map.h	/^  MapFinalAction final_action_;$/;"	m	class:fst::ArcMapFstImpl
final_arc_	replace.h	/^  mutable Arc final_arc_;       \/\/ Final arc (when required)$/;"	m	class:fst::ArcIterator
final_arc_	replace.h	/^  mutable bool final_arc_;           \/\/ Current arc for exiting recursion$/;"	m	class:fst::ReplaceFstMatcher
final_flags_	replace.h	/^  mutable uint32 final_flags_;  \/\/ Arc value flags valid for final_arc_$/;"	m	class:fst::ArcIterator
final_ilabel	factor-weight.h	/^  Label final_ilabel;  \/\/ input label of arc created when factoring final w's$/;"	m	struct:fst::FactorWeightOptions
final_ilabel_	factor-weight.h	/^  Label final_ilabel_;        \/\/ ilabel of arc created when factoring final w's$/;"	m	class:fst::FactorWeightFstImpl
final_label_	label-reachable.h	/^  Label final_label_;                 \/\/ Final label$/;"	m	class:fst::LabelReachableData
final_olabel	factor-weight.h	/^  Label final_olabel;  \/\/ output label of arc created when factoring final w's$/;"	m	struct:fst::FactorWeightOptions
final_olabel_	factor-weight.h	/^  Label final_olabel_;        \/\/ olabel of arc created when factoring final w's$/;"	m	class:fst::FactorWeightFstImpl
finish_	topsort.h	/^  vector<StateId> *finish_;  \/\/ states in finishing-time order$/;"	m	class:fst::TopOrderVisitor
first_	bi-table.h	/^  I first_;        \/\/ I of first element in the deque;$/;"	m	class:fst::ErasableBiTable
first_	sparse-tuple-weight.h	/^  Pair first_;$/;"	m	class:fst::SparseTupleWeight
first_	sparse-tuple-weight.h	/^  const Pair &first_;$/;"	m	class:fst::SparseTupleWeightIterator
first_	string-weight.h	/^  L first_;         \/\/ first label in string (0 if empty)$/;"	m	class:fst::StringWeight
first_	string-weight.h	/^  const L &first_;$/;"	m	class:fst::StringWeightIterator
first_	string-weight.h	/^  const L &first_;$/;"	m	class:fst::StringWeightReverseIterator
first_path	shortest-distance.h	/^  bool first_path;       \/\/ For a semiring with the path property (o.w.$/;"	m	struct:fst::ShortestDistanceOptions
first_path	shortest-path.h	/^  bool first_path;    \/\/ Single shortest path stops after finding the first$/;"	m	struct:fst::ShortestPathOptions
first_path_	shortest-distance.h	/^  bool first_path_;$/;"	m	class:fst::ShortestDistanceState
flag_table_	flags.h	/^  std::map< string, FlagDescription<T> > flag_table_;$/;"	m	class:FlagRegister
flags	cache.h	/^  mutable uint32 flags;$/;"	m	struct:fst::CacheState
flags	encode.h	/^  const uint32 flags() const { return flags_ & kEncodeFlags; }$/;"	f	class:fst::EncodeTable
flags	encode.h	/^  const uint32 flags() const { return flags_; }$/;"	f	class:fst::EncodeMapper
flags_	compact-fst.h	/^  uint32 flags_;$/;"	m	class:fst::ArcIterator
flags_	encode.h	/^  uint32 flags_;$/;"	m	class:fst::EncodeMapper
flags_	encode.h	/^  uint32 flags_;$/;"	m	class:fst::EncodeTable
flags_	fst.h	/^  int32 flags_;                      \/\/ File format bits$/;"	m	class:fst::FstHeader
flags_	lookahead-filter.h	/^  uint32 flags_;                \/\/ Lookahead flags$/;"	m	class:fst::LookAheadComposeFilter
flags_	matcher.h	/^  uint32 flags_;$/;"	m	class:fst::MultiEpsMatcher
flags_	minimize.h	/^  const uint32 flags_;$/;"	m	class:fst::StateComparator
flags_	replace.h	/^  uint32 flags_;            \/\/ Behavorial flags for the arc iterator$/;"	m	class:fst::ArcIterator
fp2id_	bi-table.h	/^  vector<I> fp2id_;        \/\/ Maps entry fingerprints to IDs$/;"	m	class:fst::VectorHashBiTable
fp2id_	bi-table.h	/^  vector<I> fp2id_;$/;"	m	class:fst::VectorBiTable
fp_	bi-table.h	/^  FP *fp_;       \/\/ Fingerprint used when hashing entry into vector$/;"	m	class:fst::VectorHashBiTable
fp_	bi-table.h	/^  FP *fp_;$/;"	m	class:fst::VectorBiTable
from_fst_	determinize.h	/^  FromFst *from_fst_;$/;"	m	class:fst::DeterminizeFstImpl
front_	queue.h	/^  StateId front_;$/;"	m	class:fst::StateOrderQueue
front_	queue.h	/^  StateId front_;$/;"	m	class:fst::TopOrderQueue
front_	queue.h	/^  StateId front_;$/;"	m	class:fst::TrivialQueue
front_	queue.h	/^  mutable StateId front_;$/;"	m	class:fst::SccQueue
fst	accumulator.h	/^namespace fst {$/;"	n
fst	add-on.h	/^namespace fst {$/;"	n
fst	arc-map.h	/^namespace fst {$/;"	n
fst	arc.h	/^namespace fst {$/;"	n
fst	arcfilter.h	/^namespace fst {$/;"	n
fst	arcsort.h	/^namespace fst {$/;"	n
fst	bi-table.h	/^namespace fst {$/;"	n
fst	cache.h	/^namespace fst {$/;"	n
fst	closure.h	/^namespace fst {$/;"	n
fst	compact-fst.h	/^namespace fst {$/;"	n
fst	compat.h	/^namespace fst {$/;"	n
fst	complement.h	/^namespace fst {$/;"	n
fst	compose-filter.h	/^namespace fst {$/;"	n
fst	compose.h	/^namespace fst {$/;"	n
fst	concat.h	/^namespace fst {$/;"	n
fst	connect.h	/^namespace fst {$/;"	n
fst	const-fst.h	/^namespace fst {$/;"	n
fst	determinize.h	/^namespace fst {$/;"	n
fst	dfs-visit.h	/^namespace fst {$/;"	n
fst	difference.h	/^namespace fst {$/;"	n
fst	edit-fst.h	/^namespace fst {$/;"	n
fst	encode.h	/^namespace fst {$/;"	n
fst	epsnormalize.h	/^namespace fst {$/;"	n
fst	equal.h	/^namespace fst {$/;"	n
fst	equivalent.h	/^namespace fst {$/;"	n
fst	expanded-fst.h	/^namespace fst {$/;"	n
fst	expectation-weight.h	/^namespace fst {$/;"	n
fst	factor-weight.h	/^namespace fst {$/;"	n
fst	float-weight.h	/^namespace fst {$/;"	n
fst	fst-decl.h	/^namespace fst {$/;"	n
fst	fst.h	/^namespace fst {$/;"	n
fst	generic-register.h	/^namespace fst {$/;"	n
fst	heap.h	/^namespace fst {$/;"	n
fst	icu.h	/^namespace fst {$/;"	n
fst	intersect.h	/^namespace fst {$/;"	n
fst	interval-set.h	/^namespace fst {$/;"	n
fst	invert.h	/^namespace fst {$/;"	n
fst	label-reachable.h	/^namespace fst {$/;"	n
fst	lexicographic-weight.h	/^namespace fst {$/;"	n
fst	lock.h	/^namespace fst {$/;"	n
fst	lookahead-filter.h	/^namespace fst {$/;"	n
fst	lookahead-matcher.h	/^namespace fst {$/;"	n
fst	map.h	/^namespace fst {$/;"	n
fst	matcher-fst.h	/^namespace fst {$/;"	n
fst	matcher.h	/^namespace fst {$/;"	n
fst	minimize.h	/^namespace fst {$/;"	n
fst	mutable-fst.h	/^namespace fst {$/;"	n
fst	pair-weight.h	/^namespace fst {$/;"	n
fst	partition.h	/^namespace fst {$/;"	n
fst	power-weight.h	/^namespace fst {$/;"	n
fst	product-weight.h	/^namespace fst {$/;"	n
fst	project.h	/^namespace fst {$/;"	n
fst	properties.h	/^namespace fst {$/;"	n
fst	prune.h	/^namespace fst {$/;"	n
fst	push.h	/^namespace fst {$/;"	n
fst	queue.h	/^namespace fst {$/;"	n
fst	randequivalent.h	/^namespace fst {$/;"	n
fst	randgen.h	/^namespace fst {$/;"	n
fst	random-weight.h	/^namespace fst {$/;"	n
fst	rational.h	/^namespace fst {$/;"	n
fst	register.h	/^namespace fst {$/;"	n
fst	relabel.h	/^namespace fst {$/;"	n
fst	replace-util.h	/^namespace fst {$/;"	n
fst	replace.h	/^namespace fst {$/;"	n
fst	reverse.h	/^namespace fst {$/;"	n
fst	reweight.h	/^namespace fst {$/;"	n
fst	rmepsilon.h	/^namespace fst {$/;"	n
fst	rmfinalepsilon.h	/^namespace fst {$/;"	n
fst	shortest-distance.h	/^namespace fst {$/;"	n
fst	shortest-path.h	/^namespace fst {$/;"	n
fst	signed-log-weight.h	/^namespace fst {$/;"	n
fst	slist.h	/^namespace fst {$/;"	n
fst	sparse-power-weight.h	/^namespace fst {$/;"	n
fst	sparse-tuple-weight.h	/^namespace fst {$/;"	n
fst	state-map.h	/^namespace fst {$/;"	n
fst	state-reachable.h	/^namespace fst {$/;"	n
fst	state-table.h	/^namespace fst {$/;"	n
fst	statesort.h	/^namespace fst {$/;"	n
fst	string-weight.h	/^namespace fst {$/;"	n
fst	string.h	/^namespace fst {$/;"	n
fst	symbol-table-ops.h	/^namespace fst {$/;"	n
fst	symbol-table.h	/^namespace fst {$/;"	n
fst	synchronize.h	/^namespace fst {$/;"	n
fst	test-properties.h	/^namespace fst {$/;"	n
fst	topsort.h	/^namespace fst {$/;"	n
fst	tuple-weight.h	/^namespace fst {$/;"	n
fst	union-find.h	/^namespace fst {$/;"	n
fst	union.h	/^namespace fst {$/;"	n
fst	util.h	/^namespace fst {$/;"	n
fst	vector-fst.h	/^namespace fst {$/;"	n
fst	verify.h	/^namespace fst {$/;"	n
fst	visit.h	/^namespace fst {$/;"	n
fst	weight.h	/^namespace fst {$/;"	n
fst1_	compose-filter.h	/^  const FST1 &fst1_;$/;"	m	class:fst::MatchComposeFilter
fst1_	compose-filter.h	/^  const FST1 &fst1_;$/;"	m	class:fst::SequenceComposeFilter
fst1_	compose.h	/^  const FST1 &fst1_;$/;"	m	class:fst::ComposeFstImpl
fst1_	lookahead-filter.h	/^  const FST1 &fst1_;$/;"	m	class:fst::PushLabelsComposeFilter
fst2_	compose-filter.h	/^  const FST2 &fst2_;$/;"	m	class:fst::AltSequenceComposeFilter
fst2_	compose-filter.h	/^  const FST2 &fst2_;$/;"	m	class:fst::MatchComposeFilter
fst2_	compose.h	/^  const FST2 &fst2_;$/;"	m	class:fst::ComposeFstImpl
fst2_	lookahead-filter.h	/^  const FST2 &fst2_;$/;"	m	class:fst::PushLabelsComposeFilter
fst::ALT_SEQUENCE_FILTER	compose.h	/^enum ComposeFilter { AUTO_FILTER, SEQUENCE_FILTER, ALT_SEQUENCE_FILTER,$/;"	e	enum:fst::ComposeFilter
fst::AStarWeightCompare	queue.h	/^class AStarWeightCompare {$/;"	c	namespace:fst
fst::AStarWeightCompare::AStarWeightCompare	queue.h	/^  AStarWeightCompare(const vector<Weight>& weights, const L &less,$/;"	f	class:fst::AStarWeightCompare
fst::AStarWeightCompare::Less	queue.h	/^  typedef L Less;$/;"	t	class:fst::AStarWeightCompare
fst::AStarWeightCompare::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::AStarWeightCompare
fst::AStarWeightCompare::Weight	queue.h	/^  typedef typename L::Weight Weight;$/;"	t	class:fst::AStarWeightCompare
fst::AStarWeightCompare::estimate_	queue.h	/^  const E &estimate_;$/;"	m	class:fst::AStarWeightCompare
fst::AStarWeightCompare::less_	queue.h	/^  L less_;$/;"	m	class:fst::AStarWeightCompare
fst::AStarWeightCompare::operator ()	queue.h	/^  bool operator()(const S x, const S y) const {$/;"	f	class:fst::AStarWeightCompare
fst::AStarWeightCompare::weights_	queue.h	/^  const vector<Weight>& weights_;$/;"	m	class:fst::AStarWeightCompare
fst::AUTO_FILTER	compose.h	/^enum ComposeFilter { AUTO_FILTER, SEQUENCE_FILTER, ALT_SEQUENCE_FILTER,$/;"	e	enum:fst::ComposeFilter
fst::AUTO_QUEUE	queue.h	/^  AUTO_QUEUE = 7,            \/\/ Auto-selected queue$/;"	e	enum:fst::QueueType
fst::AcceptorCompactor	compact-fst.h	/^class AcceptorCompactor {$/;"	c	namespace:fst
fst::AcceptorCompactor::Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const {$/;"	f	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Element	compact-fst.h	/^  typedef pair< pair<Label, Weight>, StateId > Element;$/;"	t	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Read	compact-fst.h	/^  static AcceptorCompactor *Read(istream &strm) {$/;"	f	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Size	compact-fst.h	/^  ssize_t Size() const { return -1;}$/;"	f	class:fst::AcceptorCompactor
fst::AcceptorCompactor::StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::AcceptorCompactor
fst::AcceptorCompactor::Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::AcceptorCompactor
fst::AcceptorMinimize	minimize.h	/^void AcceptorMinimize(MutableFst<A>* fst) {$/;"	f	namespace:fst
fst::AcyclicMinimizer	minimize.h	/^class AcyclicMinimizer {$/;"	c	namespace:fst
fst::AcyclicMinimizer::AcyclicMinimizer	minimize.h	/^  AcyclicMinimizer(const ExpandedFst<A>& fst):$/;"	f	class:fst::AcyclicMinimizer
fst::AcyclicMinimizer::ClassId	minimize.h	/^  typedef typename A::StateId ClassId;$/;"	t	class:fst::AcyclicMinimizer
fst::AcyclicMinimizer::HeightVisitor	minimize.h	/^  class HeightVisitor {$/;"	c	class:fst::AcyclicMinimizer
fst::AcyclicMinimizer::HeightVisitor::BackArc	minimize.h	/^    bool BackArc(StateId s, const A& arc) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::FinishState	minimize.h	/^    void FinishState(StateId s, StateId parent, const A* parent_arc) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::FinishVisit	minimize.h	/^    void FinishVisit() {}$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::ForwardOrCrossArc	minimize.h	/^    bool ForwardOrCrossArc(StateId s, const A& arc) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::HeightVisitor	minimize.h	/^    HeightVisitor() : max_height_(0), num_states_(0) { }$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::InitState	minimize.h	/^    bool InitState(StateId s, StateId root) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::InitVisit	minimize.h	/^    void InitVisit(const Fst<A>& fst) {}$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::TreeArc	minimize.h	/^    bool TreeArc(StateId s, const A& arc) {$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::height	minimize.h	/^    const vector<StateId>& height() const { return height_; }$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::height_	minimize.h	/^    vector<StateId> height_;$/;"	m	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::max_height	minimize.h	/^    size_t max_height() const { return max_height_; }$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::max_height_	minimize.h	/^    size_t max_height_;$/;"	m	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::num_states	minimize.h	/^    const size_t num_states() const { return num_states_; }$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::HeightVisitor::num_states_	minimize.h	/^    size_t num_states_;$/;"	m	class:fst::AcyclicMinimizer::HeightVisitor
fst::AcyclicMinimizer::Initialize	minimize.h	/^  void Initialize(const Fst<A>& fst) {$/;"	f	class:fst::AcyclicMinimizer
fst::AcyclicMinimizer::Label	minimize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::AcyclicMinimizer
fst::AcyclicMinimizer::Refine	minimize.h	/^  void Refine(const Fst<A>& fst) {$/;"	f	class:fst::AcyclicMinimizer
fst::AcyclicMinimizer::StateId	minimize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::AcyclicMinimizer
fst::AcyclicMinimizer::Weight	minimize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::AcyclicMinimizer
fst::AcyclicMinimizer::partition	minimize.h	/^  const Partition<StateId>& partition() {$/;"	f	class:fst::AcyclicMinimizer
fst::AcyclicMinimizer::partition_	minimize.h	/^  Partition<StateId> partition_;$/;"	m	class:fst::AcyclicMinimizer
fst::AddArcProperties	properties.h	/^uint64 AddArcProperties(uint64 inprops, typename A::StateId s,$/;"	f	namespace:fst
fst::AddOnImpl	add-on.h	/^class AddOnImpl : public FstImpl<typename F::Arc> {$/;"	c	namespace:fst
fst::AddOnImpl::AddOnImpl	add-on.h	/^  AddOnImpl(const AddOnImpl<F, T> &impl)$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::AddOnImpl	add-on.h	/^  AddOnImpl(const F &fst, const string &type, T *t = 0)$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::AddOnImpl	add-on.h	/^  AddOnImpl(const Fst<Arc> &fst, const string &type, T *t = 0)$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::AddOnImpl	add-on.h	/^  explicit AddOnImpl(const string &type) : t_(0) {$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::Arc	add-on.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::AddOnImpl
fst::AddOnImpl::Final	add-on.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::GetAddOn	add-on.h	/^  T *GetAddOn() const { return t_; }$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::GetFst	add-on.h	/^  F &GetFst() { return fst_; }$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::GetFst	add-on.h	/^  const F &GetFst() const { return fst_; }$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::InitArcIterator	add-on.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::InitStateIterator	add-on.h	/^  void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::Label	add-on.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::AddOnImpl
fst::AddOnImpl::NumArcs	add-on.h	/^  size_t NumArcs(StateId s) const { return fst_.NumArcs(s); }$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::NumInputEpsilons	add-on.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::NumOutputEpsilons	add-on.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::NumStates	add-on.h	/^  size_t NumStates() const { return fst_.NumStates(); }$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::Read	add-on.h	/^  static AddOnImpl<F, T> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::SetAddOn	add-on.h	/^  void SetAddOn(T *t) {$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::Start	add-on.h	/^  StateId Start() const { return fst_.Start(); }$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::StateId	add-on.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::AddOnImpl
fst::AddOnImpl::Weight	add-on.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::AddOnImpl
fst::AddOnImpl::Write	add-on.h	/^  bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::AddOnImpl
fst::AddOnImpl::fst_	add-on.h	/^  F fst_;$/;"	m	class:fst::AddOnImpl
fst::AddOnImpl::kFileVersion	add-on.h	/^  static const int kFileVersion = 1;$/;"	m	class:fst::AddOnImpl
fst::AddOnImpl::kFileVersion	add-on.h	/^template <class F, class T> const int AddOnImpl<F, T>::kFileVersion;$/;"	m	class:fst::AddOnImpl
fst::AddOnImpl::kMinFileVersion	add-on.h	/^  static const int kMinFileVersion = 1;$/;"	m	class:fst::AddOnImpl
fst::AddOnImpl::kMinFileVersion	add-on.h	/^template <class F, class T> const int AddOnImpl<F, T>::kMinFileVersion;$/;"	m	class:fst::AddOnImpl
fst::AddOnImpl::t_	add-on.h	/^  T *t_;$/;"	m	class:fst::AddOnImpl
fst::AddOnImpl::~AddOnImpl	add-on.h	/^  ~AddOnImpl() {$/;"	f	class:fst::AddOnImpl
fst::AddOnPair	add-on.h	/^class AddOnPair {$/;"	c	namespace:fst
fst::AddOnPair::AddOnPair	add-on.h	/^  AddOnPair(A1 *a1, A2 *a2)$/;"	f	class:fst::AddOnPair
fst::AddOnPair::DecrRefCount	add-on.h	/^  int DecrRefCount() {$/;"	f	class:fst::AddOnPair
fst::AddOnPair::First	add-on.h	/^  A1 *First() const { return a1_; }$/;"	f	class:fst::AddOnPair
fst::AddOnPair::IncrRefCount	add-on.h	/^  int IncrRefCount() {$/;"	f	class:fst::AddOnPair
fst::AddOnPair::Read	add-on.h	/^  static AddOnPair<A1, A2> *Read(istream &istrm) {$/;"	f	class:fst::AddOnPair
fst::AddOnPair::RefCount	add-on.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::AddOnPair
fst::AddOnPair::Second	add-on.h	/^  A2 *Second() const { return a2_; }$/;"	f	class:fst::AddOnPair
fst::AddOnPair::Write	add-on.h	/^  bool Write(ostream &ostrm) const {$/;"	f	class:fst::AddOnPair
fst::AddOnPair::a1_	add-on.h	/^  A1 *a1_;$/;"	m	class:fst::AddOnPair
fst::AddOnPair::a2_	add-on.h	/^  A2 *a2_;$/;"	m	class:fst::AddOnPair
fst::AddOnPair::ref_count_	add-on.h	/^  RefCounter ref_count_;$/;"	m	class:fst::AddOnPair
fst::AddOnPair::~AddOnPair	add-on.h	/^  ~AddOnPair() {$/;"	f	class:fst::AddOnPair
fst::AddStateProperties	properties.h	/^uint64 AddStateProperties(uint64 inprops) {$/;"	f	namespace:fst
fst::AltSequenceComposeFilter	compose-filter.h	/^class AltSequenceComposeFilter {$/;"	c	namespace:fst
fst::AltSequenceComposeFilter::AltSequenceComposeFilter	compose-filter.h	/^  AltSequenceComposeFilter(const AltSequenceComposeFilter<M1, M2> &filter,$/;"	f	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::AltSequenceComposeFilter	compose-filter.h	/^  AltSequenceComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::Arc	compose-filter.h	/^  typedef typename FST1::Arc Arc;$/;"	t	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::FST1	compose-filter.h	/^  typedef typename M1::FST FST1;$/;"	t	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::FST2	compose-filter.h	/^  typedef typename M2::FST FST2;$/;"	t	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::FilterArc	compose-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::FilterFinal	compose-filter.h	/^  void FilterFinal(Weight *, Weight *) const {}$/;"	f	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::FilterState	compose-filter.h	/^  typedef CharFilterState FilterState;$/;"	t	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::GetMatcher1	compose-filter.h	/^  Matcher1 *GetMatcher1() { return matcher1_; }$/;"	f	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::GetMatcher2	compose-filter.h	/^  Matcher2 *GetMatcher2() { return matcher2_; }$/;"	f	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::Label	compose-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::Matcher1	compose-filter.h	/^  typedef M1 Matcher1;$/;"	t	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::Matcher2	compose-filter.h	/^  typedef M2 Matcher2;$/;"	t	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::Properties	compose-filter.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::SetState	compose-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::Start	compose-filter.h	/^  FilterState Start() const { return FilterState(0); }$/;"	f	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::StateId	compose-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::Weight	compose-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::alleps2_	compose-filter.h	/^  bool alleps2_;   \/\/ Only epsilons (and non-final) leaving s2_?$/;"	m	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::f_	compose-filter.h	/^  FilterState f_;  \/\/ Current filter state$/;"	m	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::fst2_	compose-filter.h	/^  const FST2 &fst2_;$/;"	m	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::matcher1_	compose-filter.h	/^  Matcher1 *matcher1_;$/;"	m	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::matcher2_	compose-filter.h	/^  Matcher2 *matcher2_;$/;"	m	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::noeps2_	compose-filter.h	/^  bool noeps2_;    \/\/ No epsilons leaving s2_?$/;"	m	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::s1_	compose-filter.h	/^  StateId s1_;     \/\/ Current fst1_ state;$/;"	m	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::s2_	compose-filter.h	/^  StateId s2_;     \/\/ Current fst2_ state;$/;"	m	class:fst::AltSequenceComposeFilter
fst::AltSequenceComposeFilter::~AltSequenceComposeFilter	compose-filter.h	/^  ~AltSequenceComposeFilter() {$/;"	f	class:fst::AltSequenceComposeFilter
fst::AnyArcFilter	arcfilter.h	/^class AnyArcFilter {$/;"	c	namespace:fst
fst::AnyArcFilter::operator ()	arcfilter.h	/^  bool operator()(const A &arc) const { return true; }$/;"	f	class:fst::AnyArcFilter
fst::ApproxEqual	float-weight.h	/^inline bool ApproxEqual(const FloatWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::ApproxEqual	pair-weight.h	/^inline bool ApproxEqual(const PairWeight<W1, W2> &w1,$/;"	f	namespace:fst
fst::ApproxEqual	signed-log-weight.h	/^inline bool ApproxEqual(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::ApproxEqual	sparse-power-weight.h	/^inline bool ApproxEqual(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
fst::ApproxEqual	string-weight.h	/^inline bool ApproxEqual(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
fst::ApproxEqual	tuple-weight.h	/^inline bool ApproxEqual(const TupleWeight<W, n> &w1,$/;"	f	namespace:fst
fst::ArcIterator	arc-map.h	/^class ArcIterator< ArcMapFst<A, B, C> >$/;"	c	namespace:fst
fst::ArcIterator	arcsort.h	/^class ArcIterator< ArcSortFst<A, C> >$/;"	c	namespace:fst
fst::ArcIterator	closure.h	/^class ArcIterator< ClosureFst<A> > : public ArcIterator< RationalFst<A> > {$/;"	c	namespace:fst
fst::ArcIterator	compact-fst.h	/^class ArcIterator< CompactFst<A, C, U> > {$/;"	c	namespace:fst
fst::ArcIterator	complement.h	/^class ArcIterator< ComplementFst<A> > : public ArcIteratorBase<A> {$/;"	c	namespace:fst
fst::ArcIterator	compose.h	/^class ArcIterator< ComposeFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	concat.h	/^class ArcIterator< ConcatFst<A> > : public ArcIterator< RationalFst<A> > {$/;"	c	namespace:fst
fst::ArcIterator	const-fst.h	/^class ArcIterator< ConstFst<A, U> > {$/;"	c	namespace:fst
fst::ArcIterator	determinize.h	/^class ArcIterator< DeterminizeFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	difference.h	/^class ArcIterator< DifferenceFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	encode.h	/^class ArcIterator< DecodeFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	encode.h	/^class ArcIterator< EncodeFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	factor-weight.h	/^class ArcIterator< FactorWeightFst<A, F> >$/;"	c	namespace:fst
fst::ArcIterator	fst.h	/^class ArcIterator {$/;"	c	namespace:fst
fst::ArcIterator	intersect.h	/^class ArcIterator< IntersectFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	invert.h	/^class ArcIterator< InvertFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	map.h	/^class ArcIterator< MapFst<A, B, C> >$/;"	c	namespace:fst
fst::ArcIterator	matcher-fst.h	/^class ArcIterator< MatcherFst<F, M, N, I> > : public ArcIterator<F> {$/;"	c	namespace:fst
fst::ArcIterator	project.h	/^class ArcIterator< ProjectFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	randgen.h	/^class ArcIterator< RandGenFst<A, B, S> >$/;"	c	namespace:fst
fst::ArcIterator	rational.h	/^class ArcIterator< RationalFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	relabel.h	/^class ArcIterator< RelabelFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	replace.h	/^class ArcIterator< ReplaceFst<A, T> > {$/;"	c	namespace:fst
fst::ArcIterator	rmepsilon.h	/^class ArcIterator< RmEpsilonFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	state-map.h	/^class ArcIterator< StateMapFst<A, B, C> >$/;"	c	namespace:fst
fst::ArcIterator	synchronize.h	/^class ArcIterator< SynchronizeFst<A> >$/;"	c	namespace:fst
fst::ArcIterator	union.h	/^class ArcIterator< UnionFst<A> > : public ArcIterator< RationalFst<A> > {$/;"	c	namespace:fst
fst::ArcIterator	vector-fst.h	/^class ArcIterator< VectorFst<A> > {$/;"	c	namespace:fst
fst::ArcIterator::Arc	fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	arc-map.h	/^  ArcIterator(const ArcMapFst<A, B, C> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	arcsort.h	/^  ArcIterator(const ArcSortFst<A, C> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	closure.h	/^  ArcIterator(const ClosureFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	compact-fst.h	/^  ArcIterator(const CompactFst<A, C, U> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	complement.h	/^  ArcIterator(const ComplementFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	compose.h	/^  ArcIterator(const ComposeFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	concat.h	/^  ArcIterator(const ConcatFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	const-fst.h	/^  ArcIterator(const ConstFst<A, U> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	determinize.h	/^  ArcIterator(const DeterminizeFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	difference.h	/^  ArcIterator(const DifferenceFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	encode.h	/^  ArcIterator(const DecodeFst<A> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	encode.h	/^  ArcIterator(const EncodeFst<A> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	factor-weight.h	/^  ArcIterator(const FactorWeightFst<A, F> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	fst.h	/^  ArcIterator(const F &fst, StateId s) : i_(0) {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	fst.h	/^  explicit ArcIterator(const ArcIteratorData<Arc> &data) : data_(data), i_(0) {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	intersect.h	/^  ArcIterator(const IntersectFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	invert.h	/^  ArcIterator(const InvertFst<A> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	map.h	/^  ArcIterator(const ArcMapFst<A, B, C> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	matcher-fst.h	/^  ArcIterator(const MatcherFst<F, M, N, I> &fst, typename F::Arc::StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	project.h	/^  ArcIterator(const ProjectFst<A> &fst, typename A::StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	randgen.h	/^  ArcIterator(const RandGenFst<A, B, S> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	rational.h	/^  ArcIterator(const RationalFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	relabel.h	/^  ArcIterator(const RelabelFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	replace.h	/^  ArcIterator(const ReplaceFst<A, T> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	rmepsilon.h	/^  ArcIterator(const RmEpsilonFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	state-map.h	/^  ArcIterator(const StateMapFst<A, B, C> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	synchronize.h	/^  ArcIterator(const SynchronizeFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	union.h	/^  ArcIterator(const UnionFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ArcIterator	vector-fst.h	/^  ArcIterator(const VectorFst<A> &fst, StateId s)$/;"	f	class:fst::ArcIterator
fst::ArcIterator::CompactElement	compact-fst.h	/^  typedef typename C::Element CompactElement;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::Done	compact-fst.h	/^  bool Done() const { return pos_ >= num_arcs_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Done	complement.h	/^  bool Done() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Done	const-fst.h	/^  bool Done() const { return i_ >= narcs_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Done	fst.h	/^  bool Done() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Done	replace.h	/^  bool Done() const { return pos_ >= num_arcs_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Done	vector-fst.h	/^  bool Done() const { return i_ >= arcs_.size(); }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Done_	complement.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::ExpandAndCache	replace.h	/^  void ExpandAndCache() const   {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::FST	fst.h	/^  typedef F FST;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::Flags	compact-fst.h	/^  uint32 Flags() const { return flags_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Flags	complement.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Flags	const-fst.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Flags	fst.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Flags	replace.h	/^  uint32 Flags() const { return flags_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Flags	vector-fst.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Flags_	complement.h	/^  uint32 Flags_() const { return Flags(); }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Init	replace.h	/^  void Init() {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Label	complement.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::Next	compact-fst.h	/^  void Next() { ++pos_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Next	complement.h	/^  void Next() {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Next	const-fst.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Next	fst.h	/^  void Next() {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Next	replace.h	/^  void Next() { ++pos_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Next	vector-fst.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Next_	complement.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Position	compact-fst.h	/^  size_t Position() const { return pos_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Position	complement.h	/^  size_t Position() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Position	const-fst.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Position	fst.h	/^  size_t Position() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Position	replace.h	/^  size_t Position() const { return pos_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Position	vector-fst.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Position_	complement.h	/^  virtual size_t Position_() const { return Position(); }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Reset	compact-fst.h	/^  void Reset() { pos_ = 0;  }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Reset	complement.h	/^  void Reset() {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Reset	const-fst.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Reset	fst.h	/^  void Reset() {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Reset	replace.h	/^  void Reset() { pos_ = 0;  }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Reset	vector-fst.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Reset_	complement.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Seek	compact-fst.h	/^  void Seek(size_t pos) { pos_ = pos; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Seek	complement.h	/^  void Seek(size_t a) {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Seek	const-fst.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Seek	fst.h	/^  void Seek(size_t a) {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Seek	replace.h	/^  void Seek(size_t pos) { pos_ = pos; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Seek	vector-fst.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Seek_	complement.h	/^  virtual void Seek_(size_t a) { Seek(a); }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::SetFlags	compact-fst.h	/^  void SetFlags(uint32 f, uint32 m) {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::SetFlags	complement.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::ArcIterator
fst::ArcIterator::SetFlags	const-fst.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::ArcIterator
fst::ArcIterator::SetFlags	fst.h	/^  void SetFlags(uint32 flags, uint32 mask) {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::SetFlags	replace.h	/^  void SetFlags(uint32 f, uint32 mask) {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::SetFlags	vector-fst.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::ArcIterator
fst::ArcIterator::SetFlags_	complement.h	/^  void SetFlags_(uint32 f, uint32 m) { SetFlags(f, m); }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::StateId	arc-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	closure.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	complement.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	compose.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	concat.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	const-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	difference.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	intersect.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	rational.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	relabel.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	rmepsilon.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	state-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	synchronize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	union.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::Value	compact-fst.h	/^  const A& Value() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Value	complement.h	/^  const A& Value() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Value	const-fst.h	/^  const A& Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Value	fst.h	/^  const Arc& Value() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Value	replace.h	/^  const A& Value() const {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Value	vector-fst.h	/^  const A& Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Value_	complement.h	/^  virtual const A& Value_() const { return Value(); }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::Weight	complement.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ArcIterator
fst::ArcIterator::aiter_	complement.h	/^  ArcIterator< Fst<A> > *aiter_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::arc_	compact-fst.h	/^  mutable A arc_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::arc_	complement.h	/^  mutable A arc_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::arc_	replace.h	/^  mutable Arc arc_;         \/\/ Memory to temporarily store computed arcs$/;"	m	class:fst::ArcIterator
fst::ArcIterator::arcs_	const-fst.h	/^  const A *arcs_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::arcs_	replace.h	/^  mutable const A* arcs_;       \/\/ Array of arcs$/;"	m	class:fst::ArcIterator
fst::ArcIterator::arcs_	vector-fst.h	/^  const vector<A>& arcs_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::cache_data_	replace.h	/^  mutable ArcIteratorData<Arc> cache_data_;  \/\/ Arc iterator data in cache$/;"	m	class:fst::ArcIterator
fst::ArcIterator::compactor_	compact-fst.h	/^  C *compactor_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::compacts_	compact-fst.h	/^  const CompactElement *compacts_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::data_	fst.h	/^  ArcIteratorData<Arc> data_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::data_flags_	replace.h	/^  mutable uint32 data_flags_;   \/\/ Arc value flags valid for data in arcs_$/;"	m	class:fst::ArcIterator
fst::ArcIterator::final_arc_	replace.h	/^  mutable Arc final_arc_;       \/\/ Final arc (when required)$/;"	m	class:fst::ArcIterator
fst::ArcIterator::final_flags_	replace.h	/^  mutable uint32 final_flags_;  \/\/ Arc value flags valid for final_arc_$/;"	m	class:fst::ArcIterator
fst::ArcIterator::flags_	compact-fst.h	/^  uint32 flags_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::flags_	replace.h	/^  uint32 flags_;            \/\/ Behavorial flags for the arc iterator$/;"	m	class:fst::ArcIterator
fst::ArcIterator::fst_	replace.h	/^  const ReplaceFst<A, T> &fst_;           \/\/ Reference to the FST$/;"	m	class:fst::ArcIterator
fst::ArcIterator::i_	const-fst.h	/^  size_t i_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::i_	fst.h	/^  size_t i_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::i_	vector-fst.h	/^  size_t i_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::local_data_	replace.h	/^  mutable ArcIteratorData<Arc> local_data_;  \/\/ Arc iterator data in local fst$/;"	m	class:fst::ArcIterator
fst::ArcIterator::narcs_	const-fst.h	/^  size_t narcs_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::num_arcs_	compact-fst.h	/^  size_t num_arcs_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::num_arcs_	replace.h	/^  ssize_t num_arcs_;        \/\/ Number of arcs at state_$/;"	m	class:fst::ArcIterator
fst::ArcIterator::offset_	replace.h	/^  mutable ssize_t offset_;  \/\/ Offset between position in iterator and in arcs_$/;"	m	class:fst::ArcIterator
fst::ArcIterator::pos_	compact-fst.h	/^  size_t pos_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::pos_	complement.h	/^  size_t pos_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::pos_	replace.h	/^  ssize_t pos_;             \/\/ Current position$/;"	m	class:fst::ArcIterator
fst::ArcIterator::s_	complement.h	/^  StateId s_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::state_	compact-fst.h	/^  StateId state_;$/;"	m	class:fst::ArcIterator
fst::ArcIterator::state_	replace.h	/^  StateId state_;                         \/\/ State in the FST$/;"	m	class:fst::ArcIterator
fst::ArcIterator::tuple_	replace.h	/^  mutable typename T::StateTuple tuple_;  \/\/ Tuple corresponding to state_$/;"	m	class:fst::ArcIterator
fst::ArcIterator::~ArcIterator	compact-fst.h	/^  ~ArcIterator() {}$/;"	f	class:fst::ArcIterator
fst::ArcIterator::~ArcIterator	complement.h	/^  virtual ~ArcIterator() { delete aiter_; }$/;"	f	class:fst::ArcIterator
fst::ArcIterator::~ArcIterator	fst.h	/^  ~ArcIterator() {$/;"	f	class:fst::ArcIterator
fst::ArcIterator::~ArcIterator	replace.h	/^  ~ArcIterator() {$/;"	f	class:fst::ArcIterator
fst::ArcIteratorBase	fst.h	/^class ArcIteratorBase {$/;"	c	namespace:fst
fst::ArcIteratorBase::Arc	fst.h	/^  typedef A Arc;$/;"	t	class:fst::ArcIteratorBase
fst::ArcIteratorBase::Done	fst.h	/^  bool Done() const { return Done_(); }            \/\/ End of iterator?$/;"	f	class:fst::ArcIteratorBase
fst::ArcIteratorBase::Flags	fst.h	/^  uint32 Flags() const { return Flags_(); }  \/\/ Return current behavorial flags$/;"	f	class:fst::ArcIteratorBase
fst::ArcIteratorBase::Next	fst.h	/^  void Next() { Next_(); }           \/\/ Advance to next arc (when !Done)$/;"	f	class:fst::ArcIteratorBase
fst::ArcIteratorBase::Position	fst.h	/^  size_t Position() const { return Position_(); }  \/\/ Return current position$/;"	f	class:fst::ArcIteratorBase
fst::ArcIteratorBase::Reset	fst.h	/^  void Reset() { Reset_(); }         \/\/ Return to initial condition$/;"	f	class:fst::ArcIteratorBase
fst::ArcIteratorBase::Seek	fst.h	/^  void Seek(size_t a) { Seek_(a); }  \/\/ Random arc access by position$/;"	f	class:fst::ArcIteratorBase
fst::ArcIteratorBase::SetFlags	fst.h	/^  void SetFlags(uint32 flags, uint32 mask) {  \/\/ Set behavorial flags$/;"	f	class:fst::ArcIteratorBase
fst::ArcIteratorBase::StateId	fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcIteratorBase
fst::ArcIteratorBase::Value	fst.h	/^  const A& Value() const { return Value_(); }      \/\/ Current arc (when !Done)$/;"	f	class:fst::ArcIteratorBase
fst::ArcIteratorBase::~ArcIteratorBase	fst.h	/^  virtual ~ArcIteratorBase() {}$/;"	f	class:fst::ArcIteratorBase
fst::ArcIteratorData	fst.h	/^template <class A> struct ArcIteratorData {$/;"	s	namespace:fst
fst::ArcIteratorData::arcs	fst.h	/^  const A *arcs;             \/\/ O.w. arcs pointer$/;"	m	struct:fst::ArcIteratorData
fst::ArcIteratorData::base	fst.h	/^  ArcIteratorBase<A> *base;  \/\/ Specialized iterator if non-zero$/;"	m	struct:fst::ArcIteratorData
fst::ArcIteratorData::narcs	fst.h	/^  size_t narcs;              \/\/ ... and arc count$/;"	m	struct:fst::ArcIteratorData
fst::ArcIteratorData::ref_count	fst.h	/^  int *ref_count;            \/\/ ... and reference count if non-zero$/;"	m	struct:fst::ArcIteratorData
fst::ArcLookAheadMatcher	lookahead-matcher.h	/^class ArcLookAheadMatcher$/;"	c	namespace:fst
fst::ArcLookAheadMatcher::Arc	lookahead-matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::ArcLookAheadMatcher	lookahead-matcher.h	/^  ArcLookAheadMatcher(const ArcLookAheadMatcher<M, F> &lmatcher,$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::ArcLookAheadMatcher	lookahead-matcher.h	/^  ArcLookAheadMatcher(const FST &fst, MatchType match_type,$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Copy	lookahead-matcher.h	/^  ArcLookAheadMatcher<M, F> *Copy(bool safe = false) const {$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Done	lookahead-matcher.h	/^  bool Done() const { return matcher_.Done(); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Done_	lookahead-matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::FST	lookahead-matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Find	lookahead-matcher.h	/^  bool Find(Label label) { return matcher_.Find(label); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Find_	lookahead-matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Flags	lookahead-matcher.h	/^  uint32 Flags() const {$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::GetData	lookahead-matcher.h	/^  MatcherData *GetData() const { return 0; }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::GetFst	lookahead-matcher.h	/^  const FST &GetFst() const { return fst_; }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Label	lookahead-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::LookAheadFst	lookahead-matcher.h	/^bool ArcLookAheadMatcher<M, F>::LookAheadFst(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::LookAheadFst_	lookahead-matcher.h	/^  bool LookAheadFst_(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const { return matcher_.Find(label); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::LookAheadLabel_	lookahead-matcher.h	/^  bool LookAheadLabel_(Label l) const { return LookAheadLabel(l); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::MatcherData	lookahead-matcher.h	/^  typedef NullAddOn MatcherData;$/;"	t	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Next	lookahead-matcher.h	/^  void Next() { matcher_.Next(); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Next_	lookahead-matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Properties	lookahead-matcher.h	/^  uint64 Properties(uint64 props) const { return matcher_.Properties(props); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::SetState	lookahead-matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::SetState_	lookahead-matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::StateId	lookahead-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Type	lookahead-matcher.h	/^  MatchType Type(bool test) const { return matcher_.Type(test); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Value	lookahead-matcher.h	/^  const Arc& Value() const { return matcher_.Value(); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Value_	lookahead-matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::Weight	lookahead-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::fst_	lookahead-matcher.h	/^  const FST &fst_;         \/\/ Matcher FST$/;"	m	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::lfst_	lookahead-matcher.h	/^  const Fst<Arc> *lfst_;   \/\/ Look-ahead FST$/;"	m	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::matcher_	lookahead-matcher.h	/^  mutable M matcher_;$/;"	m	class:fst::ArcLookAheadMatcher
fst::ArcLookAheadMatcher::s_	lookahead-matcher.h	/^  StateId s_;              \/\/ Matcher state$/;"	m	class:fst::ArcLookAheadMatcher
fst::ArcMap	arc-map.h	/^void ArcMap(MutableFst<A> *fst, C mapper) {$/;"	f	namespace:fst
fst::ArcMap	arc-map.h	/^void ArcMap(MutableFst<A> *fst, C* mapper) {$/;"	f	namespace:fst
fst::ArcMap	arc-map.h	/^void ArcMap(const Fst<A> &ifst, MutableFst<B> *ofst, C mapper) {$/;"	f	namespace:fst
fst::ArcMap	arc-map.h	/^void ArcMap(const Fst<A> &ifst, MutableFst<B> *ofst, C* mapper) {$/;"	f	namespace:fst
fst::ArcMapFst	arc-map.h	/^class ArcMapFst : public ImplToFst< ArcMapFstImpl<A, B, C> > {$/;"	c	namespace:fst
fst::ArcMapFst::Arc	arc-map.h	/^  typedef B Arc;$/;"	t	class:fst::ArcMapFst
fst::ArcMapFst::ArcMapFst	arc-map.h	/^  ArcMapFst(const ArcMapFst<A, B, C> &fst, bool safe = false)$/;"	f	class:fst::ArcMapFst
fst::ArcMapFst::ArcMapFst	arc-map.h	/^  ArcMapFst(const Fst<A> &fst, C* mapper)$/;"	f	class:fst::ArcMapFst
fst::ArcMapFst::ArcMapFst	arc-map.h	/^  ArcMapFst(const Fst<A> &fst, C* mapper, const ArcMapFstOptions& opts)$/;"	f	class:fst::ArcMapFst
fst::ArcMapFst::ArcMapFst	arc-map.h	/^  ArcMapFst(const Fst<A> &fst, const C &mapper)$/;"	f	class:fst::ArcMapFst
fst::ArcMapFst::ArcMapFst	arc-map.h	/^  ArcMapFst(const Fst<A> &fst, const C &mapper, const ArcMapFstOptions& opts)$/;"	f	class:fst::ArcMapFst
fst::ArcMapFst::Copy	arc-map.h	/^  virtual ArcMapFst<A, B, C> *Copy(bool safe = false) const {$/;"	f	class:fst::ArcMapFst
fst::ArcMapFst::GetImpl	arc-map.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::ArcMapFst
fst::ArcMapFst::Impl	arc-map.h	/^  typedef ArcMapFstImpl<A, B, C> Impl;$/;"	t	class:fst::ArcMapFst
fst::ArcMapFst::InitArcIterator	arc-map.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<B> *data) const {$/;"	f	class:fst::ArcMapFst
fst::ArcMapFst::InitStateIterator	arc-map.h	/^void ArcMapFst<A, B, C>::InitStateIterator(StateIteratorData<B> *data)$/;"	f	class:fst::ArcMapFst
fst::ArcMapFst::State	arc-map.h	/^  typedef CacheState<B> State;$/;"	t	class:fst::ArcMapFst
fst::ArcMapFst::StateId	arc-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::ArcMapFst
fst::ArcMapFst::Weight	arc-map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::ArcMapFst
fst::ArcMapFstImpl	arc-map.h	/^class ArcMapFstImpl : public CacheImpl<B> {$/;"	c	namespace:fst
fst::ArcMapFstImpl::Arc	arc-map.h	/^  typedef B Arc;$/;"	t	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::ArcMapFstImpl	arc-map.h	/^  ArcMapFstImpl(const ArcMapFstImpl<A, B, C> &impl)$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::ArcMapFstImpl	arc-map.h	/^  ArcMapFstImpl(const Fst<A> &fst, C *mapper,$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::ArcMapFstImpl	arc-map.h	/^  ArcMapFstImpl(const Fst<A> &fst, const C &mapper,$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::Expand	arc-map.h	/^  void Expand(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::Final	arc-map.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::FindIState	arc-map.h	/^  StateId FindIState(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::FindOState	arc-map.h	/^  StateId FindOState(StateId is) {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::Init	arc-map.h	/^  void Init() {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::InitArcIterator	arc-map.h	/^  void InitArcIterator(StateId s, ArcIteratorData<B> *data) {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::NumArcs	arc-map.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::NumInputEpsilons	arc-map.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::NumOutputEpsilons	arc-map.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::Properties	arc-map.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::Properties	arc-map.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::Start	arc-map.h	/^  StateId Start() {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::StateId	arc-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::Weight	arc-map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::final_action_	arc-map.h	/^  MapFinalAction final_action_;$/;"	m	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::fst_	arc-map.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::mapper_	arc-map.h	/^  C*   mapper_;$/;"	m	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::nstates_	arc-map.h	/^  StateId nstates_;$/;"	m	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::own_mapper_	arc-map.h	/^  bool own_mapper_;$/;"	m	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::superfinal_	arc-map.h	/^  StateId superfinal_;$/;"	m	class:fst::ArcMapFstImpl
fst::ArcMapFstImpl::~ArcMapFstImpl	arc-map.h	/^  ~ArcMapFstImpl() {$/;"	f	class:fst::ArcMapFstImpl
fst::ArcMapFstOptions	arc-map.h	/^struct ArcMapFstOptions : public CacheOptions {$/;"	s	namespace:fst
fst::ArcMapFstOptions::ArcMapFstOptions	arc-map.h	/^  ArcMapFstOptions() : CacheOptions(true, 0) {}$/;"	f	struct:fst::ArcMapFstOptions
fst::ArcMapFstOptions::ArcMapFstOptions	arc-map.h	/^  ArcMapFstOptions(const CacheOptions& opts) : CacheOptions(opts) {}$/;"	f	struct:fst::ArcMapFstOptions
fst::ArcSampler	randgen.h	/^class ArcSampler {$/;"	c	namespace:fst
fst::ArcSampler	randgen.h	/^class ArcSampler<A, FastLogProbArcSelector<A> > {$/;"	c	namespace:fst
fst::ArcSampler::ArcSampler	randgen.h	/^  ArcSampler(const ArcSampler<A, S> &sampler, const Fst<A> *fst = 0)$/;"	f	class:fst::ArcSampler
fst::ArcSampler::ArcSampler	randgen.h	/^  ArcSampler(const Fst<A> &fst, const S &arc_selector, int max_length = INT_MAX)$/;"	f	class:fst::ArcSampler
fst::ArcSampler::ArcSampler	randgen.h	/^  ArcSampler(const Fst<A> &fst, const S &arc_selector,$/;"	f	class:fst::ArcSampler
fst::ArcSampler::C	randgen.h	/^  typedef CacheLogAccumulator<A> C;$/;"	t	class:fst::ArcSampler
fst::ArcSampler::Done	randgen.h	/^  bool Done() const { return sample_iter_ == sample_map_.end(); }$/;"	f	class:fst::ArcSampler
fst::ArcSampler::Error	randgen.h	/^  bool Error() const { return accumulator_->Error(); }$/;"	f	class:fst::ArcSampler
fst::ArcSampler::Error	randgen.h	/^  bool Error() const { return false; }$/;"	f	class:fst::ArcSampler
fst::ArcSampler::Next	randgen.h	/^  void Next() { ++sample_iter_; }$/;"	f	class:fst::ArcSampler
fst::ArcSampler::Reset	randgen.h	/^  void Reset() { sample_iter_ = sample_map_.begin(); }$/;"	f	class:fst::ArcSampler
fst::ArcSampler::S	randgen.h	/^  typedef FastLogProbArcSelector<A> S;$/;"	t	class:fst::ArcSampler
fst::ArcSampler::Sample	randgen.h	/^  bool Sample(const RandState<A> &rstate) {$/;"	f	class:fst::ArcSampler
fst::ArcSampler::StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcSampler
fst::ArcSampler::Value	randgen.h	/^  pair<size_t, size_t> Value() const { return *sample_iter_; }$/;"	f	class:fst::ArcSampler
fst::ArcSampler::Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ArcSampler
fst::ArcSampler::accumulator_	randgen.h	/^  C *accumulator_;$/;"	m	class:fst::ArcSampler
fst::ArcSampler::arc_selector_	randgen.h	/^  const S &arc_selector_;$/;"	m	class:fst::ArcSampler
fst::ArcSampler::fst_	randgen.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::ArcSampler
fst::ArcSampler::max_length_	randgen.h	/^  int max_length_;$/;"	m	class:fst::ArcSampler
fst::ArcSampler::sample_iter_	randgen.h	/^  map<size_t, size_t>::const_iterator sample_iter_;$/;"	m	class:fst::ArcSampler
fst::ArcSampler::sample_map_	randgen.h	/^  map<size_t, size_t> sample_map_;$/;"	m	class:fst::ArcSampler
fst::ArcSampler::~ArcSampler	randgen.h	/^  ~ArcSampler() {$/;"	f	class:fst::ArcSampler
fst::ArcSort	arcsort.h	/^void ArcSort(MutableFst<Arc> *fst, Compare comp) {$/;"	f	namespace:fst
fst::ArcSortFst	arcsort.h	/^class ArcSortFst : public StateMapFst<A, A, ArcSortMapper<A, C> > {$/;"	c	namespace:fst
fst::ArcSortFst::Arc	arcsort.h	/^  typedef A Arc;$/;"	t	class:fst::ArcSortFst
fst::ArcSortFst::ArcSortFst	arcsort.h	/^  ArcSortFst(const ArcSortFst<A, C> &fst, bool safe = false)$/;"	f	class:fst::ArcSortFst
fst::ArcSortFst::ArcSortFst	arcsort.h	/^  ArcSortFst(const Fst<A> &fst, const C &comp)$/;"	f	class:fst::ArcSortFst
fst::ArcSortFst::ArcSortFst	arcsort.h	/^  ArcSortFst(const Fst<A> &fst, const C &comp, const ArcSortFstOptions &opts)$/;"	f	class:fst::ArcSortFst
fst::ArcSortFst::Copy	arcsort.h	/^  virtual ArcSortFst<A, C> *Copy(bool safe = false) const {$/;"	f	class:fst::ArcSortFst
fst::ArcSortFst::M	arcsort.h	/^ typedef ArcSortMapper<A, C> M;$/;"	t	class:fst::ArcSortFst
fst::ArcSortFstOptions	arcsort.h	/^typedef CacheOptions ArcSortFstOptions;$/;"	t	namespace:fst
fst::ArcSortMapper	arcsort.h	/^class ArcSortMapper {$/;"	c	namespace:fst
fst::ArcSortMapper::ArcSortMapper	arcsort.h	/^  ArcSortMapper(const ArcSortMapper<Arc, Compare> &mapper,$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::ArcSortMapper	arcsort.h	/^  ArcSortMapper(const Fst<Arc> &fst, const Compare &comp)$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::Done	arcsort.h	/^  bool Done() const { return i_ >= arcs_.size(); }$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::Final	arcsort.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::FromArc	arcsort.h	/^  typedef Arc FromArc;$/;"	t	class:fst::ArcSortMapper
fst::ArcSortMapper::InputSymbolsAction	arcsort.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::Next	arcsort.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::OutputSymbolsAction	arcsort.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::Properties	arcsort.h	/^  uint64 Properties(uint64 props) const { return comp_.Properties(props); }$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::SetState	arcsort.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::Start	arcsort.h	/^  StateId Start() { return fst_.Start(); }$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::StateId	arcsort.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ArcSortMapper
fst::ArcSortMapper::ToArc	arcsort.h	/^  typedef Arc ToArc;$/;"	t	class:fst::ArcSortMapper
fst::ArcSortMapper::Value	arcsort.h	/^  const Arc &Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcSortMapper
fst::ArcSortMapper::Weight	arcsort.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ArcSortMapper
fst::ArcSortMapper::arcs_	arcsort.h	/^  vector<Arc> arcs_;$/;"	m	class:fst::ArcSortMapper
fst::ArcSortMapper::comp_	arcsort.h	/^  const Compare &comp_;$/;"	m	class:fst::ArcSortMapper
fst::ArcSortMapper::fst_	arcsort.h	/^  const Fst<Arc> &fst_;$/;"	m	class:fst::ArcSortMapper
fst::ArcSortMapper::i_	arcsort.h	/^  ssize_t i_;               \/\/ current arc position$/;"	m	class:fst::ArcSortMapper
fst::ArcSumMapper	state-map.h	/^class ArcSumMapper {$/;"	c	namespace:fst
fst::ArcSumMapper::ArcSumMapper	state-map.h	/^  ArcSumMapper(const ArcSumMapper<A> &mapper,$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::ArcSumMapper	state-map.h	/^  explicit ArcSumMapper(const Fst<A> &fst) : fst_(fst), i_(0) {}$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::Compare	state-map.h	/^  struct Compare {$/;"	s	class:fst::ArcSumMapper
fst::ArcSumMapper::Compare::operator ()	state-map.h	/^    bool operator()(const A& x, const A& y) {$/;"	f	struct:fst::ArcSumMapper::Compare
fst::ArcSumMapper::Done	state-map.h	/^  bool Done() const { return i_ >= arcs_.size(); }$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::Equal	state-map.h	/^  struct Equal {$/;"	s	class:fst::ArcSumMapper
fst::ArcSumMapper::Equal::operator ()	state-map.h	/^    bool operator()(const A& x, const A& y) {$/;"	f	struct:fst::ArcSumMapper::Equal
fst::ArcSumMapper::Final	state-map.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::FromArc	state-map.h	/^  typedef A FromArc;$/;"	t	class:fst::ArcSumMapper
fst::ArcSumMapper::InputSymbolsAction	state-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::Next	state-map.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::OutputSymbolsAction	state-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::Properties	state-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::SetState	state-map.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::Start	state-map.h	/^  StateId Start() const { return fst_.Start(); }$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::StateId	state-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcSumMapper
fst::ArcSumMapper::ToArc	state-map.h	/^  typedef A ToArc;$/;"	t	class:fst::ArcSumMapper
fst::ArcSumMapper::Value	state-map.h	/^  const A &Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcSumMapper
fst::ArcSumMapper::Weight	state-map.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ArcSumMapper
fst::ArcSumMapper::arcs_	state-map.h	/^  vector<A> arcs_;$/;"	m	class:fst::ArcSumMapper
fst::ArcSumMapper::comp_	state-map.h	/^  Compare comp_;$/;"	m	class:fst::ArcSumMapper
fst::ArcSumMapper::equal_	state-map.h	/^  Equal equal_;$/;"	m	class:fst::ArcSumMapper
fst::ArcSumMapper::fst_	state-map.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::ArcSumMapper
fst::ArcSumMapper::i_	state-map.h	/^  ssize_t i_;               \/\/ current arc position$/;"	m	class:fst::ArcSumMapper
fst::ArcTpl	arc.h	/^class ArcTpl {$/;"	c	namespace:fst
fst::ArcTpl::ArcTpl	arc.h	/^  ArcTpl() {}$/;"	f	class:fst::ArcTpl
fst::ArcTpl::ArcTpl	arc.h	/^  ArcTpl(Label i, Label o, const Weight& w, StateId s)$/;"	f	class:fst::ArcTpl
fst::ArcTpl::Label	arc.h	/^  typedef int Label;$/;"	t	class:fst::ArcTpl
fst::ArcTpl::StateId	arc.h	/^  typedef int StateId;$/;"	t	class:fst::ArcTpl
fst::ArcTpl::Type	arc.h	/^  static const string &Type(void) {$/;"	f	class:fst::ArcTpl
fst::ArcTpl::Weight	arc.h	/^  typedef W Weight;$/;"	t	class:fst::ArcTpl
fst::ArcTpl::ilabel	arc.h	/^  Label ilabel;$/;"	m	class:fst::ArcTpl
fst::ArcTpl::nextstate	arc.h	/^  StateId nextstate;$/;"	m	class:fst::ArcTpl
fst::ArcTpl::olabel	arc.h	/^  Label olabel;$/;"	m	class:fst::ArcTpl
fst::ArcTpl::weight	arc.h	/^  Weight weight;$/;"	m	class:fst::ArcTpl
fst::ArcUniqueMapper	state-map.h	/^class ArcUniqueMapper {$/;"	c	namespace:fst
fst::ArcUniqueMapper::ArcUniqueMapper	state-map.h	/^  ArcUniqueMapper(const ArcSumMapper<A> &mapper,$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::ArcUniqueMapper	state-map.h	/^  explicit ArcUniqueMapper(const Fst<A> &fst) : fst_(fst), i_(0) {}$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::Compare	state-map.h	/^  struct Compare {$/;"	s	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::Compare::operator ()	state-map.h	/^    bool operator()(const A& x, const A& y) {$/;"	f	struct:fst::ArcUniqueMapper::Compare
fst::ArcUniqueMapper::Done	state-map.h	/^  bool Done() const { return i_ >= arcs_.size(); }$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::Equal	state-map.h	/^  struct Equal {$/;"	s	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::Equal::operator ()	state-map.h	/^    bool operator()(const A& x, const A& y) {$/;"	f	struct:fst::ArcUniqueMapper::Equal
fst::ArcUniqueMapper::Final	state-map.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::FromArc	state-map.h	/^  typedef A FromArc;$/;"	t	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::InputSymbolsAction	state-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::Next	state-map.h	/^  void Next() { ++i_; }$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::OutputSymbolsAction	state-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::Properties	state-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::SetState	state-map.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::Start	state-map.h	/^  StateId Start() const { return fst_.Start(); }$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::StateId	state-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::ToArc	state-map.h	/^  typedef A ToArc;$/;"	t	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::Value	state-map.h	/^  const A &Value() const { return arcs_[i_]; }$/;"	f	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::Weight	state-map.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::arcs_	state-map.h	/^  vector<A> arcs_;$/;"	m	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::comp_	state-map.h	/^  Compare comp_;$/;"	m	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::equal_	state-map.h	/^  Equal equal_;$/;"	m	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::fst_	state-map.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::ArcUniqueMapper
fst::ArcUniqueMapper::i_	state-map.h	/^  ssize_t i_;               \/\/ current arc position$/;"	m	class:fst::ArcUniqueMapper
fst::AutoQueue	queue.h	/^class AutoQueue : public QueueBase<S> {$/;"	c	namespace:fst
fst::AutoQueue::AutoQueue	queue.h	/^  AutoQueue(const Fst<Arc> &fst, const vector<typename Arc::Weight> *distance,$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Clear	queue.h	/^  void Clear() { queue_->Clear(); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Dequeue	queue.h	/^  void Dequeue() { queue_->Dequeue(); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Empty	queue.h	/^  bool Empty() const { return queue_->Empty(); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Enqueue	queue.h	/^  void Enqueue(StateId s) { queue_->Enqueue(s); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Head	queue.h	/^  StateId Head() const { return queue_->Head(); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::SccQueueType	queue.h	/^void AutoQueue<StateId>::SccQueueType(const Fst<A> &fst,$/;"	f	class:fst::AutoQueue
fst::AutoQueue::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::AutoQueue
fst::AutoQueue::Update	queue.h	/^  void Update(StateId s) { queue_->Update(s); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::AutoQueue
fst::AutoQueue::queue_	queue.h	/^  QueueBase<StateId> *queue_;$/;"	m	class:fst::AutoQueue
fst::AutoQueue::queues_	queue.h	/^  vector< QueueBase<StateId>* > queues_;$/;"	m	class:fst::AutoQueue
fst::AutoQueue::scc_	queue.h	/^  vector<StateId> scc_;$/;"	m	class:fst::AutoQueue
fst::AutoQueue::~AutoQueue	queue.h	/^  ~AutoQueue() {$/;"	f	class:fst::AutoQueue
fst::CLOSURE_PLUS	rational.h	/^                   CLOSURE_PLUS = 1 };  \/\/ T+ -> don't add the empty string$/;"	e	enum:fst::ClosureType
fst::CLOSURE_STAR	rational.h	/^enum ClosureType { CLOSURE_STAR = 0,    \/\/ T* -> add the empty string$/;"	e	enum:fst::ClosureType
fst::CacheArcIterator	cache.h	/^class CacheArcIterator {$/;"	c	namespace:fst
fst::CacheArcIterator::Arc	cache.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::CacheArcIterator
fst::CacheArcIterator::CacheArcIterator	cache.h	/^  CacheArcIterator(Impl *impl, StateId s) : i_(0) {$/;"	f	class:fst::CacheArcIterator
fst::CacheArcIterator::Done	cache.h	/^  bool Done() const { return i_ >= state_->arcs.size(); }$/;"	f	class:fst::CacheArcIterator
fst::CacheArcIterator::Flags	cache.h	/^  uint32 Flags() const {$/;"	f	class:fst::CacheArcIterator
fst::CacheArcIterator::Impl	cache.h	/^  typedef CacheBaseImpl<State, C> Impl;$/;"	t	class:fst::CacheArcIterator
fst::CacheArcIterator::Next	cache.h	/^  void Next() { ++i_; }$/;"	f	class:fst::CacheArcIterator
fst::CacheArcIterator::Position	cache.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::CacheArcIterator
fst::CacheArcIterator::Reset	cache.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::CacheArcIterator
fst::CacheArcIterator::Seek	cache.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::CacheArcIterator
fst::CacheArcIterator::SetFlags	cache.h	/^  void SetFlags(uint32 flags, uint32 mask) {}$/;"	f	class:fst::CacheArcIterator
fst::CacheArcIterator::State	cache.h	/^  typedef typename F::State State;$/;"	t	class:fst::CacheArcIterator
fst::CacheArcIterator::StateId	cache.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheArcIterator
fst::CacheArcIterator::Value	cache.h	/^  const Arc& Value() const { return state_->arcs[i_]; }$/;"	f	class:fst::CacheArcIterator
fst::CacheArcIterator::i_	cache.h	/^  size_t i_;$/;"	m	class:fst::CacheArcIterator
fst::CacheArcIterator::state_	cache.h	/^  const State *state_;$/;"	m	class:fst::CacheArcIterator
fst::CacheArcIterator::~CacheArcIterator	cache.h	/^  ~CacheArcIterator() { --state_->ref_count;  }$/;"	f	class:fst::CacheArcIterator
fst::CacheBaseImpl	cache.h	/^class CacheBaseImpl : public VectorFstBaseImpl<S> {$/;"	c	namespace:fst
fst::CacheBaseImpl::AddArc	cache.h	/^  void AddArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::Allocator	cache.h	/^  typedef C Allocator;$/;"	t	class:fst::CacheBaseImpl
fst::CacheBaseImpl::Arc	cache.h	/^  typedef typename State::Arc Arc;$/;"	t	class:fst::CacheBaseImpl
fst::CacheBaseImpl::CacheBaseImpl	cache.h	/^  CacheBaseImpl(const CacheBaseImpl &impl)$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::CacheBaseImpl	cache.h	/^  explicit CacheBaseImpl(C *allocator = 0)$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::CacheBaseImpl	cache.h	/^  explicit CacheBaseImpl(const CacheOptions &opts, C *allocator = 0)$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::CheckState	cache.h	/^  const S *CheckState(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::DeleteArcs	cache.h	/^  void DeleteArcs(StateId s) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::DeleteArcs	cache.h	/^  void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::ExpandedState	cache.h	/^  void ExpandedState(StateId s) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::ExtendState	cache.h	/^  S *ExtendState(StateId s) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::Final	cache.h	/^  Weight Final(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::GC	cache.h	/^  void GC(StateId current, bool free_recent) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::GetCacheGc	cache.h	/^  bool GetCacheGc() const { return cache_gc_; }$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::GetCacheLimit	cache.h	/^  size_t GetCacheLimit() const { return cache_limit_; }$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::GetCacheSize	cache.h	/^  size_t GetCacheSize() const { return cache_size_; }$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::GetState	cache.h	/^  S *GetState(StateId s) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::GetState	cache.h	/^  const S *GetState(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::HasArcs	cache.h	/^  bool HasArcs(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::HasFinal	cache.h	/^  bool HasFinal(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::HasStart	cache.h	/^  bool HasStart() const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::InitArcIterator	cache.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::MinUnexpandedState	cache.h	/^  StateId MinUnexpandedState() const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::NumArcs	cache.h	/^  size_t NumArcs(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::NumInputEpsilons	cache.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::NumKnownStates	cache.h	/^  StateId NumKnownStates() const { return nknown_states_; }$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::NumOutputEpsilons	cache.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::PushArc	cache.h	/^  void PushArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::ReserveArcs	cache.h	/^  void ReserveArcs(StateId s, size_t n) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::SetArcs	cache.h	/^  void SetArcs(StateId s) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::SetFinal	cache.h	/^  void SetFinal(StateId s, Weight w) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::SetStart	cache.h	/^  void SetStart(StateId s) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::State	cache.h	/^  typedef S State;$/;"	t	class:fst::CacheBaseImpl
fst::CacheBaseImpl::StateId	cache.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheBaseImpl
fst::CacheBaseImpl::UpdateNumKnownStates	cache.h	/^  void UpdateNumKnownStates(StateId s) {$/;"	f	class:fst::CacheBaseImpl
fst::CacheBaseImpl::Weight	cache.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::CacheBaseImpl
fst::CacheBaseImpl::allocator_	cache.h	/^  C *allocator_;                             \/\/ used to allocate new states$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::cache_first_state_	cache.h	/^  S *cache_first_state_;                     \/\/ First cached state$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::cache_first_state_id_	cache.h	/^  StateId cache_first_state_id_;             \/\/ First cached state id$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::cache_gc_	cache.h	/^  bool cache_gc_;                            \/\/ enable GC$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::cache_limit_	cache.h	/^  size_t cache_limit_;                       \/\/ # of bytes allowed before GC$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::cache_size_	cache.h	/^  size_t cache_size_;                        \/\/ # of bytes cached$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::cache_start_	cache.h	/^  mutable bool cache_start_;                 \/\/ Is the start state cached?$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::cache_states_	cache.h	/^  list<StateId> cache_states_;               \/\/ list of currently cached states$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::expanded_states_	cache.h	/^  vector<bool> expanded_states_;             \/\/ states that have been expanded$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kCacheArcs	cache.h	/^  static const uint32 kCacheArcs =   0x0002;  \/\/ Arcs have been cached$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kCacheArcs	cache.h	/^template <class S, class C> const uint32 CacheBaseImpl<S, C>::kCacheArcs;$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kCacheFinal	cache.h	/^  static const uint32 kCacheFinal =  0x0001;  \/\/ Final weight has been cached$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kCacheFinal	cache.h	/^template <class S, class C> const uint32 CacheBaseImpl<S, C>::kCacheFinal;$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kCacheFlags	cache.h	/^  static const uint32 kCacheFlags = kCacheFinal | kCacheArcs | kCacheRecent$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kCacheModified	cache.h	/^  static const uint32 kCacheModified = 0x0008;  \/\/ Mark state as modified$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kCacheModified	cache.h	/^template <class S, class C> const uint32 CacheBaseImpl<S, C>::kCacheModified;$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kCacheRecent	cache.h	/^  static const uint32 kCacheRecent = 0x0004;  \/\/ Mark as visited since GC$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kCacheRecent	cache.h	/^template <class S, class C> const uint32 CacheBaseImpl<S, C>::kCacheRecent;$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kMinCacheLimit	cache.h	/^  static const size_t kMinCacheLimit = 8096;  \/\/ Minimum (non-zero) cache limit$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::kMinCacheLimit	cache.h	/^template <class S, class C> const size_t CacheBaseImpl<S, C>::kMinCacheLimit;$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::min_unexpanded_state_id_	cache.h	/^  mutable StateId min_unexpanded_state_id_;  \/\/ minimum never-expanded state Id$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::nknown_states_	cache.h	/^  StateId nknown_states_;                    \/\/ # of known states$/;"	m	class:fst::CacheBaseImpl
fst::CacheBaseImpl::~CacheBaseImpl	cache.h	/^  ~CacheBaseImpl() {$/;"	f	class:fst::CacheBaseImpl
fst::CacheImpl	cache.h	/^class CacheImpl : public CacheBaseImpl< CacheState<A> > {$/;"	c	namespace:fst
fst::CacheImpl::CacheImpl	cache.h	/^  CacheImpl() {}$/;"	f	class:fst::CacheImpl
fst::CacheImpl::CacheImpl	cache.h	/^  CacheImpl(const CacheImpl<State> &impl) : CacheBaseImpl<State>(impl) {}$/;"	f	class:fst::CacheImpl
fst::CacheImpl::CacheImpl	cache.h	/^  explicit CacheImpl(const CacheOptions &opts)$/;"	f	class:fst::CacheImpl
fst::CacheImpl::State	cache.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::CacheImpl
fst::CacheLogAccumulator	accumulator.h	/^class CacheLogAccumulator {$/;"	c	namespace:fst
fst::CacheLogAccumulator::Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::CacheLogAccumulator	accumulator.h	/^  CacheLogAccumulator(const CacheLogAccumulator<A> &acc)$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::CacheLogAccumulator	accumulator.h	/^  explicit CacheLogAccumulator(ssize_t arc_limit = 10, bool gc = false,$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::Error	accumulator.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::Init	accumulator.h	/^  void Init(const Fst<A> &fst, bool copy = false) {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::LogMinus	accumulator.h	/^  Weight LogMinus(double f1, double f2) {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::LogMinusExp	accumulator.h	/^  double LogMinusExp(double x) {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::LogPlus	accumulator.h	/^  Weight LogPlus(Weight w, Weight v) {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::LogPlus	accumulator.h	/^  double LogPlus(double f1, Weight v) {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::LogPosExp	accumulator.h	/^  double LogPosExp(double x) {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::LowerBound	accumulator.h	/^  size_t LowerBound(double w, Iterator *aiter) {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::SetState	accumulator.h	/^  void SetState(StateId s, int depth = 0) {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, Iterator *aiter, ssize_t begin,$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::arc_limit_	accumulator.h	/^  ssize_t arc_limit_;                    \/\/ Minimum # of arcs to cache a state$/;"	m	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::data_	accumulator.h	/^  CacheLogAccumulatorData<A> *data_;     \/\/ Cache data$/;"	m	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::error_	accumulator.h	/^  bool error_;$/;"	m	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::fst_	accumulator.h	/^  const Fst<A>* fst_;                    \/\/ Input fst$/;"	m	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::s_	accumulator.h	/^  StateId s_;                            \/\/ Current state$/;"	m	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::to_log_weight_	accumulator.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::to_weight_	accumulator.h	/^  WeightConvert<Log64Weight, Weight> to_weight_;$/;"	m	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::weights_	accumulator.h	/^  vector<double> *weights_;              \/\/ Accumulated weights for cur. state$/;"	m	class:fst::CacheLogAccumulator
fst::CacheLogAccumulator::~CacheLogAccumulator	accumulator.h	/^  ~CacheLogAccumulator() {$/;"	f	class:fst::CacheLogAccumulator
fst::CacheLogAccumulatorData	accumulator.h	/^class CacheLogAccumulatorData {$/;"	c	namespace:fst
fst::CacheLogAccumulatorData::AddWeights	accumulator.h	/^  void AddWeights(StateId s, vector<double> *weights) {$/;"	f	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::CacheDisabled	accumulator.h	/^  bool CacheDisabled() const { return cache_gc_ && cache_limit_ == 0; }$/;"	f	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::CacheLogAccumulatorData	accumulator.h	/^  CacheLogAccumulatorData(bool gc, size_t gc_limit)$/;"	f	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::CacheState	accumulator.h	/^  struct CacheState {$/;"	s	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::CacheState::CacheState	accumulator.h	/^    CacheState(vector<double> *w, bool r) : weights(w), recent(r) {}$/;"	f	struct:fst::CacheLogAccumulatorData::CacheState
fst::CacheLogAccumulatorData::CacheState::recent	accumulator.h	/^    bool recent;              \/\/ Has this state been accessed since last GC?$/;"	m	struct:fst::CacheLogAccumulatorData::CacheState
fst::CacheLogAccumulatorData::CacheState::weights	accumulator.h	/^    vector<double>* weights;  \/\/ Accumulated weights for this state.$/;"	m	struct:fst::CacheLogAccumulatorData::CacheState
fst::CacheLogAccumulatorData::DecrRefCount	accumulator.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::GC	accumulator.h	/^  void GC(bool free_recent) {$/;"	f	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::GetWeights	accumulator.h	/^  vector<double> *GetWeights(StateId s) {$/;"	f	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::IncrRefCount	accumulator.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::RefCount	accumulator.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::cache_	accumulator.h	/^  unordered_map<StateId, CacheState> cache_;  \/\/ Cache$/;"	m	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::cache_gc_	accumulator.h	/^  bool cache_gc_;                        \/\/ Enable garbage collection$/;"	m	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::cache_limit_	accumulator.h	/^  size_t cache_limit_;                   \/\/ # of bytes cached$/;"	m	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::cache_size_	accumulator.h	/^  size_t cache_size_;                    \/\/ # of bytes allowed before GC$/;"	m	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::ref_count_	accumulator.h	/^  RefCounter ref_count_;$/;"	m	class:fst::CacheLogAccumulatorData
fst::CacheLogAccumulatorData::~CacheLogAccumulatorData	accumulator.h	/^  ~CacheLogAccumulatorData() {$/;"	f	class:fst::CacheLogAccumulatorData
fst::CacheMutableArcIterator	cache.h	/^class CacheMutableArcIterator$/;"	c	namespace:fst
fst::CacheMutableArcIterator::Arc	cache.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::CacheMutableArcIterator	cache.h	/^  CacheMutableArcIterator(Impl *impl, StateId s) : i_(0), s_(s), impl_(impl) {$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Done	cache.h	/^  bool Done() const { return i_ >= state_->arcs.size(); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Done_	cache.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Flags	cache.h	/^  uint32 Flags() const {$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Flags_	cache.h	/^  uint32 Flags_() const { return Flags(); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Impl	cache.h	/^  typedef CacheBaseImpl<State, C> Impl;$/;"	t	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Next	cache.h	/^  void Next() { ++i_; }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Next_	cache.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Position	cache.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Position_	cache.h	/^  virtual size_t Position_() const { return Position(); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Reset	cache.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Reset_	cache.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Seek	cache.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Seek_	cache.h	/^  virtual void Seek_(size_t a) { Seek(a); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::SetFlags	cache.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::SetFlags_	cache.h	/^  void SetFlags_(uint32 f, uint32 m) { SetFlags(f, m); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::SetValue	cache.h	/^  void SetValue(const Arc& arc) {$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::SetValue_	cache.h	/^  virtual void SetValue_(const Arc &a) { SetValue(a); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::State	cache.h	/^  typedef typename F::State State;$/;"	t	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::StateId	cache.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Value	cache.h	/^  const Arc& Value() const { return state_->arcs[i_]; }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Value_	cache.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::Weight	cache.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::i_	cache.h	/^  size_t i_;$/;"	m	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::impl_	cache.h	/^  Impl *impl_;$/;"	m	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::s_	cache.h	/^  StateId s_;$/;"	m	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::state_	cache.h	/^  State *state_;$/;"	m	class:fst::CacheMutableArcIterator
fst::CacheMutableArcIterator::~CacheMutableArcIterator	cache.h	/^  ~CacheMutableArcIterator() {$/;"	f	class:fst::CacheMutableArcIterator
fst::CacheOptions	cache.h	/^struct CacheOptions {$/;"	s	namespace:fst
fst::CacheOptions::CacheOptions	cache.h	/^  CacheOptions()$/;"	f	struct:fst::CacheOptions
fst::CacheOptions::CacheOptions	cache.h	/^  CacheOptions(bool g, size_t l) : gc(g), gc_limit(l) {}$/;"	f	struct:fst::CacheOptions
fst::CacheOptions::gc	cache.h	/^  bool gc;          \/\/ enable GC$/;"	m	struct:fst::CacheOptions
fst::CacheOptions::gc_limit	cache.h	/^  size_t gc_limit;  \/\/ # of bytes allowed before GC$/;"	m	struct:fst::CacheOptions
fst::CacheState	cache.h	/^struct CacheState {$/;"	s	namespace:fst
fst::CacheState::Arc	cache.h	/^  typedef A Arc;$/;"	t	struct:fst::CacheState
fst::CacheState::CacheState	cache.h	/^  CacheState() :  final(Weight::Zero()), flags(0), ref_count(0) {}$/;"	f	struct:fst::CacheState
fst::CacheState::Reset	cache.h	/^  void Reset() {$/;"	f	struct:fst::CacheState
fst::CacheState::StateId	cache.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::CacheState
fst::CacheState::Weight	cache.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::CacheState
fst::CacheState::arcs	cache.h	/^  vector<A> arcs;            \/\/ Arcs represenation$/;"	m	struct:fst::CacheState
fst::CacheState::final	cache.h	/^  Weight final;              \/\/ Final weight$/;"	m	struct:fst::CacheState
fst::CacheState::flags	cache.h	/^  mutable uint32 flags;$/;"	m	struct:fst::CacheState
fst::CacheState::niepsilons	cache.h	/^  size_t niepsilons;         \/\/ # of input epsilons$/;"	m	struct:fst::CacheState
fst::CacheState::noepsilons	cache.h	/^  size_t noepsilons;         \/\/ # of output epsilons$/;"	m	struct:fst::CacheState
fst::CacheState::ref_count	cache.h	/^  mutable int ref_count;$/;"	m	struct:fst::CacheState
fst::CacheStateIterator	cache.h	/^class CacheStateIterator : public StateIteratorBase<typename F::Arc> {$/;"	c	namespace:fst
fst::CacheStateIterator::Arc	cache.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::CacheStateIterator
fst::CacheStateIterator::CacheStateIterator	cache.h	/^  CacheStateIterator(const F &fst, Impl *impl)$/;"	f	class:fst::CacheStateIterator
fst::CacheStateIterator::Done	cache.h	/^  bool Done() const {$/;"	f	class:fst::CacheStateIterator
fst::CacheStateIterator::Done_	cache.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::CacheStateIterator
fst::CacheStateIterator::Impl	cache.h	/^  typedef CacheBaseImpl<State> Impl;$/;"	t	class:fst::CacheStateIterator
fst::CacheStateIterator::Next	cache.h	/^  void Next() { ++s_; }$/;"	f	class:fst::CacheStateIterator
fst::CacheStateIterator::Next_	cache.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::CacheStateIterator
fst::CacheStateIterator::Reset	cache.h	/^  void Reset() { s_ = 0; }$/;"	f	class:fst::CacheStateIterator
fst::CacheStateIterator::Reset_	cache.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::CacheStateIterator
fst::CacheStateIterator::State	cache.h	/^  typedef typename F::State State;$/;"	t	class:fst::CacheStateIterator
fst::CacheStateIterator::StateId	cache.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::CacheStateIterator
fst::CacheStateIterator::Value	cache.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::CacheStateIterator
fst::CacheStateIterator::Value_	cache.h	/^  virtual StateId Value_() const { return Value(); }$/;"	f	class:fst::CacheStateIterator
fst::CacheStateIterator::fst_	cache.h	/^  const F &fst_;$/;"	m	class:fst::CacheStateIterator
fst::CacheStateIterator::impl_	cache.h	/^  Impl *impl_;$/;"	m	class:fst::CacheStateIterator
fst::CacheStateIterator::s_	cache.h	/^  StateId s_;$/;"	m	class:fst::CacheStateIterator
fst::Cast	fst.h	/^template<class F, class G> void Cast(const F &ifst, G *ofst) {$/;"	f	namespace:fst
fst::CcVisitor	connect.h	/^class CcVisitor {$/;"	c	namespace:fst
fst::CcVisitor::Arc	connect.h	/^  typedef A Arc;$/;"	t	class:fst::CcVisitor
fst::CcVisitor::BlackArc	connect.h	/^  bool BlackArc(StateId s, const A &arc) {$/;"	f	class:fst::CcVisitor
fst::CcVisitor::CcVisitor	connect.h	/^  CcVisitor(UnionFind<StateId> *comps)$/;"	f	class:fst::CcVisitor
fst::CcVisitor::CcVisitor	connect.h	/^  CcVisitor(vector<StateId> *cc)$/;"	f	class:fst::CcVisitor
fst::CcVisitor::FinishState	connect.h	/^  void FinishState(StateId s) { }$/;"	f	class:fst::CcVisitor
fst::CcVisitor::FinishVisit	connect.h	/^  void FinishVisit() {$/;"	f	class:fst::CcVisitor
fst::CcVisitor::GetCcVector	connect.h	/^  int GetCcVector(vector<StateId> *cc) {$/;"	f	class:fst::CcVisitor
fst::CcVisitor::GreyArc	connect.h	/^  bool GreyArc(StateId s, const A &arc) {$/;"	f	class:fst::CcVisitor
fst::CcVisitor::InitState	connect.h	/^  bool InitState(StateId s, StateId root) {$/;"	f	class:fst::CcVisitor
fst::CcVisitor::InitVisit	connect.h	/^  void InitVisit(const Fst<A> &fst) { }$/;"	f	class:fst::CcVisitor
fst::CcVisitor::StateId	connect.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CcVisitor
fst::CcVisitor::Weight	connect.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::CcVisitor
fst::CcVisitor::WhiteArc	connect.h	/^  bool WhiteArc(StateId s, const A &arc) {$/;"	f	class:fst::CcVisitor
fst::CcVisitor::cc_	connect.h	/^  vector<StateId> *cc_;         \/\/ State's cc number$/;"	m	class:fst::CcVisitor
fst::CcVisitor::comps_	connect.h	/^  UnionFind<StateId> *comps_;   \/\/ Components$/;"	m	class:fst::CcVisitor
fst::CcVisitor::nstates_	connect.h	/^  StateId nstates_;             \/\/ State count$/;"	m	class:fst::CcVisitor
fst::CcVisitor::~CcVisitor	connect.h	/^  ~CcVisitor() {$/;"	f	class:fst::CcVisitor
fst::CharFilterState	compose-filter.h	/^typedef IntegerFilterState<signed char> CharFilterState;$/;"	t	namespace:fst
fst::CharFilterState	fst-decl.h	/^typedef IntegerFilterState<signed char> CharFilterState;$/;"	t	namespace:fst
fst::CheckSummer	compat.h	/^class CheckSummer {$/;"	c	namespace:fst
fst::CheckSummer::CheckSummer	compat.h	/^  CheckSummer() : count_(0) {$/;"	f	class:fst::CheckSummer
fst::CheckSummer::Digest	compat.h	/^  string Digest() {$/;"	f	class:fst::CheckSummer
fst::CheckSummer::Reset	compat.h	/^  void Reset() {$/;"	f	class:fst::CheckSummer
fst::CheckSummer::Update	compat.h	/^  void Update(string const &data) {$/;"	f	class:fst::CheckSummer
fst::CheckSummer::Update	compat.h	/^  void Update(void const *data, int size) {$/;"	f	class:fst::CheckSummer
fst::CheckSummer::check_sum_	compat.h	/^  string check_sum_;$/;"	m	class:fst::CheckSummer
fst::CheckSummer::count_	compat.h	/^  int count_;$/;"	m	class:fst::CheckSummer
fst::CheckSummer::kCheckSumLength	compat.h	/^  static const int kCheckSumLength = 32;$/;"	m	class:fst::CheckSummer
fst::Closure	closure.h	/^void Closure(MutableFst<Arc> *fst, ClosureType closure_type) {$/;"	f	namespace:fst
fst::Closure	closure.h	/^void Closure(RationalFst<Arc> *fst, ClosureType closure_type) {$/;"	f	namespace:fst
fst::ClosureFst	closure.h	/^class ClosureFst : public RationalFst<A> {$/;"	c	namespace:fst
fst::ClosureFst::Arc	closure.h	/^  typedef A Arc;$/;"	t	class:fst::ClosureFst
fst::ClosureFst::ClosureFst	closure.h	/^  ClosureFst(const ClosureFst<A> &fst, bool safe = false)$/;"	f	class:fst::ClosureFst
fst::ClosureFst::ClosureFst	closure.h	/^  ClosureFst(const Fst<A> &fst, ClosureType closure_type) {$/;"	f	class:fst::ClosureFst
fst::ClosureFst::ClosureFst	closure.h	/^  ClosureFst(const Fst<A> &fst, const ClosureFstOptions &opts)$/;"	f	class:fst::ClosureFst
fst::ClosureFst::Copy	closure.h	/^  virtual ClosureFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ClosureFst
fst::ClosureFstOptions	closure.h	/^struct ClosureFstOptions : RationalFstOptions {$/;"	s	namespace:fst
fst::ClosureFstOptions::ClosureFstOptions	closure.h	/^  ClosureFstOptions() : type(CLOSURE_STAR) {}$/;"	f	struct:fst::ClosureFstOptions
fst::ClosureFstOptions::ClosureFstOptions	closure.h	/^  ClosureFstOptions(const RationalFstOptions &opts, ClosureType t)$/;"	f	struct:fst::ClosureFstOptions
fst::ClosureFstOptions::ClosureFstOptions	closure.h	/^  explicit ClosureFstOptions(ClosureType t) : type(t) {}$/;"	f	struct:fst::ClosureFstOptions
fst::ClosureFstOptions::type	closure.h	/^  ClosureType type;$/;"	m	struct:fst::ClosureFstOptions
fst::ClosureType	rational.h	/^enum ClosureType { CLOSURE_STAR = 0,    \/\/ T* -> add the empty string$/;"	g	namespace:fst
fst::CompactFst	compact-fst.h	/^class CompactFst : public ImplToExpandedFst< CompactFstImpl<A, C, U> > {$/;"	c	namespace:fst
fst::CompactFst::Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::CompactFst
fst::CompactFst::CompactFst	compact-fst.h	/^  CompactFst() : ImplToExpandedFst<Impl>(new Impl()) {}$/;"	f	class:fst::CompactFst
fst::CompactFst::CompactFst	compact-fst.h	/^  CompactFst(Impl *impl) : ImplToExpandedFst<Impl>(impl) {}$/;"	f	class:fst::CompactFst
fst::CompactFst::CompactFst	compact-fst.h	/^  CompactFst(const CompactFst<A, C, U> &fst, bool safe = false)$/;"	f	class:fst::CompactFst
fst::CompactFst::CompactFst	compact-fst.h	/^  CompactFst(const Fst<A> &fst, C *compactor,$/;"	f	class:fst::CompactFst
fst::CompactFst::CompactFst	compact-fst.h	/^  CompactFst(const Iterator &begin, const Iterator &end,$/;"	f	class:fst::CompactFst
fst::CompactFst::CompactFst	compact-fst.h	/^  explicit CompactFst(const Fst<A> &fst, const C &compactor = C(),$/;"	f	class:fst::CompactFst
fst::CompactFst::CompactFst	compact-fst.h	/^  explicit CompactFst(const Iterator &begin, const Iterator &end,$/;"	f	class:fst::CompactFst
fst::CompactFst::Copy	compact-fst.h	/^  virtual CompactFst<A, C, U> *Copy(bool safe = false) const {$/;"	f	class:fst::CompactFst
fst::CompactFst::GetImpl	compact-fst.h	/^  Impl *GetImpl() const { return ImplToFst<Impl, ExpandedFst<A> >::GetImpl(); }$/;"	f	class:fst::CompactFst
fst::CompactFst::Impl	compact-fst.h	/^  typedef CompactFstImpl<A, C, U> Impl;$/;"	t	class:fst::CompactFst
fst::CompactFst::InitArcIterator	compact-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::CompactFst
fst::CompactFst::InitMatcher	compact-fst.h	/^  virtual MatcherBase<A> *InitMatcher(MatchType match_type) const {$/;"	f	class:fst::CompactFst
fst::CompactFst::InitStateIterator	compact-fst.h	/^  virtual void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::CompactFst
fst::CompactFst::Read	compact-fst.h	/^  static CompactFst<A, C, U> *Read(const string &filename) {$/;"	f	class:fst::CompactFst
fst::CompactFst::Read	compact-fst.h	/^  static CompactFst<A, C, U> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::CompactFst
fst::CompactFst::SetCompactElements	compact-fst.h	/^  void SetCompactElements(const Iterator &b, const Iterator &e) {$/;"	f	class:fst::CompactFst
fst::CompactFst::SetImpl	compact-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = false) {$/;"	f	class:fst::CompactFst
fst::CompactFst::State	compact-fst.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::CompactFst
fst::CompactFst::StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CompactFst
fst::CompactFst::Unsigned	compact-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::CompactFst
fst::CompactFst::Write	compact-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::CompactFst
fst::CompactFst::Write	compact-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::CompactFst
fst::CompactFstData	compact-fst.h	/^class CompactFstData {$/;"	c	namespace:fst
fst::CompactFstData::CompactElement	compact-fst.h	/^  typedef E CompactElement;$/;"	t	class:fst::CompactFstData
fst::CompactFstData::CompactFstData	compact-fst.h	/^  CompactFstData()$/;"	f	class:fst::CompactFstData
fst::CompactFstData::CompactFstData	compact-fst.h	/^CompactFstData<E, U>::CompactFstData(const Fst<A> &fst, const C &compactor)$/;"	f	class:fst::CompactFstData
fst::CompactFstData::CompactFstData	compact-fst.h	/^CompactFstData<E, U>::CompactFstData(const Iterator &begin,$/;"	f	class:fst::CompactFstData
fst::CompactFstData::Compacts	compact-fst.h	/^  const CompactElement &Compacts(size_t i) const { return compacts_[i]; }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::DecrRefCount	compact-fst.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::Error	compact-fst.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::IncrRefCount	compact-fst.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::NumArcs	compact-fst.h	/^  size_t NumArcs() const { return narcs_; }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::NumCompacts	compact-fst.h	/^  size_t NumCompacts() const { return ncompacts_; }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::NumStates	compact-fst.h	/^  size_t NumStates() const { return nstates_; }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::Read	compact-fst.h	/^CompactFstData<E, U> *CompactFstData<E, U>::Read($/;"	f	class:fst::CompactFstData
fst::CompactFstData::RefCount	compact-fst.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::Start	compact-fst.h	/^  ssize_t Start() const { return start_; }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::States	compact-fst.h	/^  Unsigned States(ssize_t i) const { return states_[i]; }$/;"	f	class:fst::CompactFstData
fst::CompactFstData::Unsigned	compact-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::CompactFstData
fst::CompactFstData::Write	compact-fst.h	/^bool CompactFstData<E, U>::Write(ostream &strm,$/;"	f	class:fst::CompactFstData
fst::CompactFstData::compacts_	compact-fst.h	/^  CompactElement *compacts_;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::error_	compact-fst.h	/^  bool error_;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::kFileAlign	compact-fst.h	/^  static const int kFileAlign = 16;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::kFileAlign	compact-fst.h	/^const int CompactFstData<E, U>::kFileAlign;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::narcs_	compact-fst.h	/^  size_t narcs_;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::ncompacts_	compact-fst.h	/^  size_t ncompacts_;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::nstates_	compact-fst.h	/^  size_t nstates_;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::ref_count_	compact-fst.h	/^  RefCounter ref_count_;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::start_	compact-fst.h	/^  ssize_t start_;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::states_	compact-fst.h	/^  Unsigned *states_;$/;"	m	class:fst::CompactFstData
fst::CompactFstData::~CompactFstData	compact-fst.h	/^  ~CompactFstData() {$/;"	f	class:fst::CompactFstData
fst::CompactFstImpl	compact-fst.h	/^class CompactFstImpl : public CacheImpl<A> {$/;"	c	namespace:fst
fst::CompactFstImpl::Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::CompactFstImpl
fst::CompactFstImpl::CompactElement	compact-fst.h	/^  typedef typename C::Element CompactElement;$/;"	t	class:fst::CompactFstImpl
fst::CompactFstImpl::CompactFstImpl	compact-fst.h	/^  CompactFstImpl()$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const CompactFstImpl<A, C, U> &impl)$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const Fst<Arc> &fst, C *compactor,$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const Fst<Arc> &fst, const C &compactor,$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const Iterator &b, const Iterator &e, C *compactor,$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::CompactFstImpl	compact-fst.h	/^  CompactFstImpl(const Iterator &b, const Iterator &e, const C &compactor,$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::CompactFstImpl	compact-fst.h	/^  explicit CompactFstImpl(const CompactFstImpl<B, D, U> &impl)$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::Compactor	compact-fst.h	/^  typedef C Compactor;$/;"	t	class:fst::CompactFstImpl
fst::CompactFstImpl::ComputeArc	compact-fst.h	/^  Arc ComputeArc(StateId s, Unsigned i, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::CountEpsilons	compact-fst.h	/^  size_t CountEpsilons(StateId s, bool output_epsilons) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::Data	compact-fst.h	/^  CompactFstData<CompactElement, U> *Data() const { return data_; }$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::Expand	compact-fst.h	/^  void Expand(StateId s) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::Final	compact-fst.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::GetCompactor	compact-fst.h	/^  C *GetCompactor() const { return compactor_; }$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::Init	compact-fst.h	/^  void Init(const Fst<Arc> &fst) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::Init	compact-fst.h	/^  void Init(const Iterator &b, const Iterator &e) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::InitArcIterator	compact-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::InitStateIterator	compact-fst.h	/^  void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::NumArcs	compact-fst.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::NumInputEpsilons	compact-fst.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::NumOutputEpsilons	compact-fst.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::NumStates	compact-fst.h	/^  StateId NumStates() const {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::Read	compact-fst.h	/^  static CompactFstImpl<A, C, U> *Read(istream &strm,$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::SetCompactElements	compact-fst.h	/^  void SetCompactElements(const Iterator &b, const Iterator &e) {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::Start	compact-fst.h	/^  StateId Start() {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CompactFstImpl
fst::CompactFstImpl::Unsigned	compact-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::CompactFstImpl
fst::CompactFstImpl::Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::CompactFstImpl
fst::CompactFstImpl::Write	compact-fst.h	/^  bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::CompactFstImpl
fst::CompactFstImpl::compactor_	compact-fst.h	/^  C *compactor_;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::data_	compact-fst.h	/^  CompactFstData<CompactElement, U> *data_;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::kAlignedFileVersion	compact-fst.h	/^  static const int kAlignedFileVersion = 1;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::kAlignedFileVersion	compact-fst.h	/^const int CompactFstImpl<A, C, U>::kAlignedFileVersion;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::kFileVersion	compact-fst.h	/^  static const int kFileVersion = 2;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::kFileVersion	compact-fst.h	/^const int CompactFstImpl<A, C, U>::kFileVersion;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::kMinFileVersion	compact-fst.h	/^  static const int kMinFileVersion = 1;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::kMinFileVersion	compact-fst.h	/^const int CompactFstImpl<A, C, U>::kMinFileVersion;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::kStaticProperties	compact-fst.h	/^  static const uint64 kStaticProperties = kExpanded;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::kStaticProperties	compact-fst.h	/^const uint64 CompactFstImpl<A, C, U>::kStaticProperties;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::own_compactor_	compact-fst.h	/^  bool own_compactor_;$/;"	m	class:fst::CompactFstImpl
fst::CompactFstImpl::~CompactFstImpl	compact-fst.h	/^  ~CompactFstImpl(){$/;"	f	class:fst::CompactFstImpl
fst::CompactFstOptions	compact-fst.h	/^struct CompactFstOptions : public CacheOptions {$/;"	s	namespace:fst
fst::CompactFstOptions::CompactFstOptions	compact-fst.h	/^  CompactFstOptions() : CacheOptions(true, 0) {}$/;"	f	struct:fst::CompactFstOptions
fst::CompactFstOptions::CompactFstOptions	compact-fst.h	/^  CompactFstOptions(const CacheOptions &opts) : CacheOptions(opts) {}$/;"	f	struct:fst::CompactFstOptions
fst::CompactHashBiTable	bi-table.h	/^class CompactHashBiTable {$/;"	c	namespace:fst
fst::CompactHashBiTable::CompactHashBiTable	bi-table.h	/^  CompactHashBiTable()$/;"	f	class:fst::CompactHashBiTable
fst::CompactHashBiTable::CompactHashBiTable	bi-table.h	/^  explicit CompactHashBiTable(size_t table_size)$/;"	f	class:fst::CompactHashBiTable
fst::CompactHashBiTable::FindEntry	bi-table.h	/^  const T &FindEntry(I s) const { return id2entry_[s]; }$/;"	f	class:fst::CompactHashBiTable
fst::CompactHashBiTable::FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::CompactHashBiTable
fst::CompactHashBiTable::HashEqual	bi-table.h	/^  class HashEqual {$/;"	c	class:fst::CompactHashBiTable
fst::CompactHashBiTable::HashEqual::HashEqual	bi-table.h	/^    HashEqual(const CompactHashBiTable &ht) : ht_(&ht) {}$/;"	f	class:fst::CompactHashBiTable::HashEqual
fst::CompactHashBiTable::HashEqual::ht_	bi-table.h	/^    const CompactHashBiTable *ht_;$/;"	m	class:fst::CompactHashBiTable::HashEqual
fst::CompactHashBiTable::HashEqual::operator ()	bi-table.h	/^    bool operator()(I k1, I k2) const {$/;"	f	class:fst::CompactHashBiTable::HashEqual
fst::CompactHashBiTable::HashFunc	bi-table.h	/^  class HashFunc {$/;"	c	class:fst::CompactHashBiTable
fst::CompactHashBiTable::HashFunc::HashFunc	bi-table.h	/^    HashFunc(const CompactHashBiTable &ht) : ht_(&ht) {}$/;"	f	class:fst::CompactHashBiTable::HashFunc
fst::CompactHashBiTable::HashFunc::hf	bi-table.h	/^    H hf;$/;"	m	class:fst::CompactHashBiTable::HashFunc
fst::CompactHashBiTable::HashFunc::ht_	bi-table.h	/^    const CompactHashBiTable *ht_;$/;"	m	class:fst::CompactHashBiTable::HashFunc
fst::CompactHashBiTable::HashFunc::operator ()	bi-table.h	/^    size_t operator()(I k) const { return hf(ht_->Key2T(k)); }$/;"	f	class:fst::CompactHashBiTable::HashFunc
fst::CompactHashBiTable::Key2T	bi-table.h	/^  const T &Key2T(I k) const {$/;"	f	class:fst::CompactHashBiTable
fst::CompactHashBiTable::KeyHashSet	bi-table.h	/^  typedef unordered_set<I, HashFunc, HashEqual> KeyHashSet;$/;"	t	class:fst::CompactHashBiTable
fst::CompactHashBiTable::Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::CompactHashBiTable
fst::CompactHashBiTable::current_entry_	bi-table.h	/^  const T *current_entry_;$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashBiTable::empty_entry_	bi-table.h	/^  const T empty_entry_;$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashBiTable::hash_equal_	bi-table.h	/^  HashEqual hash_equal_;$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashBiTable::hash_func_	bi-table.h	/^  HashFunc hash_func_;$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashBiTable::id2entry_	bi-table.h	/^  vector<T> id2entry_;$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashBiTable::kCurrentKey	bi-table.h	/^  static const I kCurrentKey;  \/\/ -2$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashBiTable::kCurrentKey	bi-table.h	/^const I CompactHashBiTable<I, T, H>::kCurrentKey = -2;$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashBiTable::kEmptyKey	bi-table.h	/^  static const I kEmptyKey;    \/\/ -1$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashBiTable::kEmptyKey	bi-table.h	/^const I CompactHashBiTable<I, T, H>::kEmptyKey = -1;$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashBiTable::keys_	bi-table.h	/^  KeyHashSet keys_;$/;"	m	class:fst::CompactHashBiTable
fst::CompactHashStateTable	state-table.h	/^class CompactHashStateTable$/;"	c	namespace:fst
fst::CompactHashStateTable::CompactHashStateTable	state-table.h	/^  CompactHashStateTable() : CompactHashBiTable<StateId, T, H>() {}$/;"	f	class:fst::CompactHashStateTable
fst::CompactHashStateTable::CompactHashStateTable	state-table.h	/^  explicit CompactHashStateTable(size_t table_size)$/;"	f	class:fst::CompactHashStateTable
fst::CompactHashStateTable::FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::CompactHashStateTable
fst::CompactHashStateTable::StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::CompactHashStateTable
fst::CompactHashStateTable::StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::CompactHashStateTable
fst::CompactHashStateTable::Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::CompactHashStateTable
fst::CompactSet	util.h	/^class CompactSet {$/;"	c	namespace:fst
fst::CompactSet::Begin	util.h	/^  const_iterator Begin() const { return set_.begin(); }$/;"	f	class:fst::CompactSet
fst::CompactSet::Clear	util.h	/^  void Clear() {$/;"	f	class:fst::CompactSet
fst::CompactSet::CompactSet	util.h	/^  CompactSet()$/;"	f	class:fst::CompactSet
fst::CompactSet::CompactSet	util.h	/^  CompactSet(const CompactSet<Key, NoKey> &compact_set)$/;"	f	class:fst::CompactSet
fst::CompactSet::End	util.h	/^  const_iterator End() const { return set_.end(); }$/;"	f	class:fst::CompactSet
fst::CompactSet::Find	util.h	/^  const_iterator Find(Key key) const {$/;"	f	class:fst::CompactSet
fst::CompactSet::Insert	util.h	/^  void Insert(Key key) {$/;"	f	class:fst::CompactSet
fst::CompactSet::const_iterator	util.h	/^  typedef typename set<Key>::const_iterator const_iterator;$/;"	t	class:fst::CompactSet
fst::CompactSet::max_key_	util.h	/^  Key max_key_;$/;"	m	class:fst::CompactSet
fst::CompactSet::min_key_	util.h	/^  Key min_key_;$/;"	m	class:fst::CompactSet
fst::CompactSet::set_	util.h	/^  set<Key> set_;$/;"	m	class:fst::CompactSet
fst::CompatProperties	test-properties.h	/^inline bool CompatProperties(uint64 props1, uint64 props2) {$/;"	f	namespace:fst
fst::CompatSymbols	symbol-table.h	/^inline bool CompatSymbols(const SymbolTable *syms1, const SymbolTable *syms2,$/;"	f	namespace:fst
fst::ComplementFst	complement.h	/^class ComplementFst : public ImplToFst< ComplementFstImpl<A> > {$/;"	c	namespace:fst
fst::ComplementFst::Arc	complement.h	/^  typedef A Arc;$/;"	t	class:fst::ComplementFst
fst::ComplementFst::ComplementFst	complement.h	/^  ComplementFst(const ComplementFst<A> &fst, bool safe = false)$/;"	f	class:fst::ComplementFst
fst::ComplementFst::ComplementFst	complement.h	/^  explicit ComplementFst(const Fst<A> &fst)$/;"	f	class:fst::ComplementFst
fst::ComplementFst::Copy	complement.h	/^  virtual ComplementFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ComplementFst
fst::ComplementFst::GetImpl	complement.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::ComplementFst
fst::ComplementFst::Impl	complement.h	/^  typedef ComplementFstImpl<A> Impl;$/;"	t	class:fst::ComplementFst
fst::ComplementFst::InitArcIterator	complement.h	/^ComplementFst<A>::InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::ComplementFst
fst::ComplementFst::InitStateIterator	complement.h	/^ComplementFst<A>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ComplementFst
fst::ComplementFst::Label	complement.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ComplementFst
fst::ComplementFst::StateId	complement.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ComplementFst
fst::ComplementFst::kRhoLabel	complement.h	/^  static const Label kRhoLabel = -2;$/;"	m	class:fst::ComplementFst
fst::ComplementFst::kRhoLabel	complement.h	/^template <class A> const typename A::Label ComplementFst<A>::kRhoLabel;$/;"	m	class:fst::ComplementFst
fst::ComplementFstImpl	complement.h	/^class ComplementFstImpl : public FstImpl<A> {$/;"	c	namespace:fst
fst::ComplementFstImpl::Arc	complement.h	/^  typedef A Arc;$/;"	t	class:fst::ComplementFstImpl
fst::ComplementFstImpl::ComplementFstImpl	complement.h	/^  ComplementFstImpl(const ComplementFstImpl<A> &impl)$/;"	f	class:fst::ComplementFstImpl
fst::ComplementFstImpl::ComplementFstImpl	complement.h	/^  explicit ComplementFstImpl(const Fst<A> &fst) : fst_(fst.Copy()) {$/;"	f	class:fst::ComplementFstImpl
fst::ComplementFstImpl::Final	complement.h	/^  Weight Final(StateId s) const {$/;"	f	class:fst::ComplementFstImpl
fst::ComplementFstImpl::Label	complement.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ComplementFstImpl
fst::ComplementFstImpl::NumArcs	complement.h	/^  size_t NumArcs(StateId s) const {$/;"	f	class:fst::ComplementFstImpl
fst::ComplementFstImpl::NumInputEpsilons	complement.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::ComplementFstImpl
fst::ComplementFstImpl::NumOutputEpsilons	complement.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::ComplementFstImpl
fst::ComplementFstImpl::Properties	complement.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::ComplementFstImpl
fst::ComplementFstImpl::Properties	complement.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::ComplementFstImpl
fst::ComplementFstImpl::Start	complement.h	/^  StateId Start() const {$/;"	f	class:fst::ComplementFstImpl
fst::ComplementFstImpl::StateId	complement.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ComplementFstImpl
fst::ComplementFstImpl::Weight	complement.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ComplementFstImpl
fst::ComplementFstImpl::fst_	complement.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::ComplementFstImpl
fst::ComplementFstImpl::~ComplementFstImpl	complement.h	/^  ~ComplementFstImpl() { delete fst_; }$/;"	f	class:fst::ComplementFstImpl
fst::Compose	compose.h	/^void Compose(const Fst<Arc> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
fst::ComposeFilter	compose.h	/^enum ComposeFilter { AUTO_FILTER, SEQUENCE_FILTER, ALT_SEQUENCE_FILTER,$/;"	g	namespace:fst
fst::ComposeFingerprint	state-table.h	/^class ComposeFingerprint {$/;"	c	namespace:fst
fst::ComposeFingerprint::ComposeFingerprint	state-table.h	/^  ComposeFingerprint() : mult1_(8192), mult2_(8192) {$/;"	f	class:fst::ComposeFingerprint
fst::ComposeFingerprint::ComposeFingerprint	state-table.h	/^  ComposeFingerprint(StateId nstates1, StateId nstates2)$/;"	f	class:fst::ComposeFingerprint
fst::ComposeFingerprint::FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ComposeFingerprint
fst::ComposeFingerprint::StateId	state-table.h	/^  typedef S StateId;$/;"	t	class:fst::ComposeFingerprint
fst::ComposeFingerprint::StateTuple	state-table.h	/^  typedef ComposeStateTuple<S, F> StateTuple;$/;"	t	class:fst::ComposeFingerprint
fst::ComposeFingerprint::mult1_	state-table.h	/^  ssize_t mult1_;$/;"	m	class:fst::ComposeFingerprint
fst::ComposeFingerprint::mult2_	state-table.h	/^  ssize_t mult2_;$/;"	m	class:fst::ComposeFingerprint
fst::ComposeFingerprint::operator ()	state-table.h	/^  size_t operator()(const StateTuple &tuple) {$/;"	f	class:fst::ComposeFingerprint
fst::ComposeFst	compose.h	/^class ComposeFst : public ImplToFst< ComposeFstImplBase<A> > {$/;"	c	namespace:fst
fst::ComposeFst::Arc	compose.h	/^  typedef A Arc;$/;"	t	class:fst::ComposeFst
fst::ComposeFst::ComposeFst	compose.h	/^  ComposeFst() {}$/;"	f	class:fst::ComposeFst
fst::ComposeFst::ComposeFst	compose.h	/^  ComposeFst(const ComposeFst<A> &fst, bool safe = false) {$/;"	f	class:fst::ComposeFst
fst::ComposeFst::ComposeFst	compose.h	/^  ComposeFst(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ComposeFst
fst::ComposeFst::ComposeFst	compose.h	/^  ComposeFst(const typename M1::FST &fst1, const typename M2::FST &fst2,$/;"	f	class:fst::ComposeFst
fst::ComposeFst::Copy	compose.h	/^  virtual ComposeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ComposeFst
fst::ComposeFst::CreateBase	compose.h	/^  static Impl *CreateBase(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ComposeFst
fst::ComposeFst::CreateBase1	compose.h	/^  static Impl *CreateBase1(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ComposeFst
fst::ComposeFst::CreateBase2	compose.h	/^  static Impl *CreateBase2($/;"	f	class:fst::ComposeFst
fst::ComposeFst::GetImpl	compose.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::ComposeFst
fst::ComposeFst::Impl	compose.h	/^  typedef ComposeFstImplBase<A> Impl;$/;"	t	class:fst::ComposeFst
fst::ComposeFst::InitArcIterator	compose.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::ComposeFst
fst::ComposeFst::InitStateIterator	compose.h	/^void ComposeFst<A>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ComposeFst
fst::ComposeFst::State	compose.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::ComposeFst
fst::ComposeFst::StateId	compose.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ComposeFst
fst::ComposeFst::Weight	compose.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ComposeFst
fst::ComposeFstImpl	compose.h	/^class ComposeFstImpl : public ComposeFstImplBase<typename M1::Arc> {$/;"	c	namespace:fst
fst::ComposeFstImpl::AddArc	compose.h	/^   void AddArc(StateId s, const Arc &arc1, const Arc &arc2,$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::Arc	compose.h	/^  typedef typename M1::Arc Arc;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::ComposeFstImpl	compose.h	/^  ComposeFstImpl(const ComposeFstImpl<M1, M2, F, T> &impl)$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::ComposeFstImpl	compose.h	/^ComposeFstImpl<M1, M2, F, T>::ComposeFstImpl($/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::ComputeFinal	compose.h	/^  Weight ComputeFinal(StateId s) {$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::ComputeStart	compose.h	/^  StateId ComputeStart() {$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::Copy	compose.h	/^  virtual ComposeFstImpl<M1, M2, F, T> *Copy() {$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::Expand	compose.h	/^  void Expand(StateId s) {$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::FST1	compose.h	/^  typedef typename M1::FST FST1;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::FST2	compose.h	/^  typedef typename M2::FST FST2;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::FilterState	compose.h	/^  typedef typename F::FilterState FilterState;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::Label	compose.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::MatchArc	compose.h	/^  void MatchArc(StateId s, Matcher *matchera,$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::Matcher1	compose.h	/^  typedef typename F::Matcher1 Matcher1;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::Matcher2	compose.h	/^  typedef typename F::Matcher2 Matcher2;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::OrderedExpand	compose.h	/^  void OrderedExpand(StateId s, const Fst<Arc> &, StateId sa,$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::Properties	compose.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::Properties	compose.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImpl::StateId	compose.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::StateTuple	compose.h	/^  typedef ComposeStateTuple<StateId, FilterState> StateTuple;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::Weight	compose.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ComposeFstImpl
fst::ComposeFstImpl::filter_	compose.h	/^  F *filter_;$/;"	m	class:fst::ComposeFstImpl
fst::ComposeFstImpl::fst1_	compose.h	/^  const FST1 &fst1_;$/;"	m	class:fst::ComposeFstImpl
fst::ComposeFstImpl::fst2_	compose.h	/^  const FST2 &fst2_;$/;"	m	class:fst::ComposeFstImpl
fst::ComposeFstImpl::match_type_	compose.h	/^  MatchType match_type_;$/;"	m	class:fst::ComposeFstImpl
fst::ComposeFstImpl::matcher1_	compose.h	/^  Matcher1 *matcher1_;$/;"	m	class:fst::ComposeFstImpl
fst::ComposeFstImpl::matcher2_	compose.h	/^  Matcher2 *matcher2_;$/;"	m	class:fst::ComposeFstImpl
fst::ComposeFstImpl::state_table_	compose.h	/^  T *state_table_;$/;"	m	class:fst::ComposeFstImpl
fst::ComposeFstImpl::~ComposeFstImpl	compose.h	/^  ~ComposeFstImpl() {$/;"	f	class:fst::ComposeFstImpl
fst::ComposeFstImplBase	compose.h	/^class ComposeFstImplBase : public CacheImpl<A> {$/;"	c	namespace:fst
fst::ComposeFstImplBase::ComposeFstImplBase	compose.h	/^  ComposeFstImplBase(const ComposeFstImplBase<A> &impl)$/;"	f	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::ComposeFstImplBase	compose.h	/^  ComposeFstImplBase(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::Final	compose.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::InitArcIterator	compose.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::Label	compose.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::NumArcs	compose.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::NumInputEpsilons	compose.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::NumOutputEpsilons	compose.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::Start	compose.h	/^  StateId Start() {$/;"	f	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::State	compose.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::StateId	compose.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::Weight	compose.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ComposeFstImplBase
fst::ComposeFstImplBase::~ComposeFstImplBase	compose.h	/^  virtual ~ComposeFstImplBase() {}$/;"	f	class:fst::ComposeFstImplBase
fst::ComposeFstImplOptions	compose.h	/^struct ComposeFstImplOptions : public CacheOptions {$/;"	s	namespace:fst
fst::ComposeFstImplOptions::ComposeFstImplOptions	compose.h	/^  ComposeFstImplOptions()$/;"	f	struct:fst::ComposeFstImplOptions
fst::ComposeFstImplOptions::ComposeFstImplOptions	compose.h	/^  explicit ComposeFstImplOptions(const CacheOptions &opts,$/;"	f	struct:fst::ComposeFstImplOptions
fst::ComposeFstImplOptions::filter	compose.h	/^  F *filter;        \/\/ Composition filter (see compose-filter.h)$/;"	m	struct:fst::ComposeFstImplOptions
fst::ComposeFstImplOptions::matcher1	compose.h	/^  M1 *matcher1;     \/\/ FST1 matcher (see matcher.h)$/;"	m	struct:fst::ComposeFstImplOptions
fst::ComposeFstImplOptions::matcher2	compose.h	/^  M2 *matcher2;     \/\/ FST2 matcher$/;"	m	struct:fst::ComposeFstImplOptions
fst::ComposeFstImplOptions::state_table	compose.h	/^  T *state_table;   \/\/ Composition state table (see compose-state-table.h)$/;"	m	struct:fst::ComposeFstImplOptions
fst::ComposeFstOptions	compose.h	/^struct ComposeFstOptions : public CacheOptions {$/;"	s	namespace:fst
fst::ComposeFstOptions::ComposeFstOptions	compose.h	/^  ComposeFstOptions() : matcher1(0), matcher2(0), filter(0), state_table(0) {}$/;"	f	struct:fst::ComposeFstOptions
fst::ComposeFstOptions::ComposeFstOptions	compose.h	/^  explicit ComposeFstOptions(const CacheOptions &opts,$/;"	f	struct:fst::ComposeFstOptions
fst::ComposeFstOptions::filter	compose.h	/^  F *filter;        \/\/ Composition filter (see compose-filter.h)$/;"	m	struct:fst::ComposeFstOptions
fst::ComposeFstOptions::matcher1	compose.h	/^  M *matcher1;      \/\/ FST1 matcher (see matcher.h)$/;"	m	struct:fst::ComposeFstOptions
fst::ComposeFstOptions::matcher2	compose.h	/^  M *matcher2;      \/\/ FST2 matcher$/;"	m	struct:fst::ComposeFstOptions
fst::ComposeFstOptions::state_table	compose.h	/^  T *state_table;   \/\/ Composition state table (see compose-state-table.h)$/;"	m	struct:fst::ComposeFstOptions
fst::ComposeHash	state-table.h	/^class ComposeHash {$/;"	c	namespace:fst
fst::ComposeHash::kPrime0	state-table.h	/^  static const size_t kPrime0;$/;"	m	class:fst::ComposeHash
fst::ComposeHash::kPrime0	state-table.h	/^const size_t ComposeHash<S, F>::kPrime0 = 7853;$/;"	m	class:fst::ComposeHash
fst::ComposeHash::kPrime1	state-table.h	/^  static const size_t kPrime1;$/;"	m	class:fst::ComposeHash
fst::ComposeHash::kPrime1	state-table.h	/^const size_t ComposeHash<S, F>::kPrime1 = 7867;$/;"	m	class:fst::ComposeHash
fst::ComposeHash::operator ()	state-table.h	/^  size_t operator()(const ComposeStateTuple<S, F>& t) const {$/;"	f	class:fst::ComposeHash
fst::ComposeOptions	compose.h	/^struct ComposeOptions {$/;"	s	namespace:fst
fst::ComposeOptions::ComposeOptions	compose.h	/^  ComposeOptions() : connect(true), filter_type(AUTO_FILTER) {}$/;"	f	struct:fst::ComposeOptions
fst::ComposeOptions::ComposeOptions	compose.h	/^  ComposeOptions(bool c, ComposeFilter ft = AUTO_FILTER)$/;"	f	struct:fst::ComposeOptions
fst::ComposeOptions::connect	compose.h	/^  bool connect;  \/\/ Connect output$/;"	m	struct:fst::ComposeOptions
fst::ComposeOptions::filter_type	compose.h	/^  ComposeFilter filter_type;  \/\/ Which pre-defined filter to use$/;"	m	struct:fst::ComposeOptions
fst::ComposeState1Fingerprint	state-table.h	/^class ComposeState1Fingerprint {$/;"	c	namespace:fst
fst::ComposeState1Fingerprint::FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ComposeState1Fingerprint
fst::ComposeState1Fingerprint::StateId	state-table.h	/^  typedef S StateId;$/;"	t	class:fst::ComposeState1Fingerprint
fst::ComposeState1Fingerprint::StateTuple	state-table.h	/^  typedef ComposeStateTuple<S, F> StateTuple;$/;"	t	class:fst::ComposeState1Fingerprint
fst::ComposeState1Fingerprint::operator ()	state-table.h	/^  size_t operator()(const StateTuple &tuple) { return tuple.state_id1; }$/;"	f	class:fst::ComposeState1Fingerprint
fst::ComposeState2Fingerprint	state-table.h	/^class ComposeState2Fingerprint {$/;"	c	namespace:fst
fst::ComposeState2Fingerprint::FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ComposeState2Fingerprint
fst::ComposeState2Fingerprint::StateId	state-table.h	/^  typedef S StateId;$/;"	t	class:fst::ComposeState2Fingerprint
fst::ComposeState2Fingerprint::StateTuple	state-table.h	/^  typedef ComposeStateTuple<S, F> StateTuple;$/;"	t	class:fst::ComposeState2Fingerprint
fst::ComposeState2Fingerprint::operator ()	state-table.h	/^  size_t operator()(const StateTuple &tuple) { return tuple.state_id2; }$/;"	f	class:fst::ComposeState2Fingerprint
fst::ComposeStateTuple	state-table.h	/^struct ComposeStateTuple {$/;"	s	namespace:fst
fst::ComposeStateTuple::ComposeStateTuple	state-table.h	/^  ComposeStateTuple()$/;"	f	struct:fst::ComposeStateTuple
fst::ComposeStateTuple::ComposeStateTuple	state-table.h	/^  ComposeStateTuple(StateId s1, StateId s2, const FilterState &f)$/;"	f	struct:fst::ComposeStateTuple
fst::ComposeStateTuple::FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	struct:fst::ComposeStateTuple
fst::ComposeStateTuple::StateId	state-table.h	/^  typedef S StateId;$/;"	t	struct:fst::ComposeStateTuple
fst::ComposeStateTuple::filter_state	state-table.h	/^  FilterState filter_state;  \/\/ State of composition filter$/;"	m	struct:fst::ComposeStateTuple
fst::ComposeStateTuple::state_id1	state-table.h	/^  StateId state_id1;         \/\/ State Id on fst1$/;"	m	struct:fst::ComposeStateTuple
fst::ComposeStateTuple::state_id2	state-table.h	/^  StateId state_id2;         \/\/ State Id on fst2$/;"	m	struct:fst::ComposeStateTuple
fst::ComputeProperties	test-properties.h	/^uint64 ComputeProperties(const Fst<Arc> &fst, uint64 mask, uint64 *known,$/;"	f	namespace:fst
fst::Concat	concat.h	/^void Concat(MutableFst<Arc> *fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
fst::Concat	concat.h	/^void Concat(RationalFst<Arc> *fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
fst::Concat	concat.h	/^void Concat(const Fst<Arc> &fst1, MutableFst<Arc> *fst2) {$/;"	f	namespace:fst
fst::Concat	concat.h	/^void Concat(const Fst<Arc> &fst1, RationalFst<Arc> *fst2) {$/;"	f	namespace:fst
fst::ConcatFst	concat.h	/^class ConcatFst : public RationalFst<A> {$/;"	c	namespace:fst
fst::ConcatFst::Arc	concat.h	/^  typedef A Arc;$/;"	t	class:fst::ConcatFst
fst::ConcatFst::ConcatFst	concat.h	/^  ConcatFst(const ConcatFst<A> &fst, bool safe = false)$/;"	f	class:fst::ConcatFst
fst::ConcatFst::ConcatFst	concat.h	/^  ConcatFst(const Fst<A> &fst1, const Fst<A> &fst2) {$/;"	f	class:fst::ConcatFst
fst::ConcatFst::ConcatFst	concat.h	/^  ConcatFst(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::ConcatFst
fst::ConcatFst::Copy	concat.h	/^  virtual ConcatFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ConcatFst
fst::ConcatFst::StateId	concat.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ConcatFst
fst::ConcatFst::Weight	concat.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ConcatFst
fst::ConcatFstOptions	concat.h	/^typedef RationalFstOptions ConcatFstOptions;$/;"	t	namespace:fst
fst::Connect	connect.h	/^void Connect(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
fst::ConstFst	const-fst.h	/^class ConstFst : public ImplToExpandedFst< ConstFstImpl<A, U> > {$/;"	c	namespace:fst
fst::ConstFst::Arc	const-fst.h	/^  typedef A Arc;$/;"	t	class:fst::ConstFst
fst::ConstFst::ConstFst	const-fst.h	/^  ConstFst() : ImplToExpandedFst<Impl>(new Impl()) {}$/;"	f	class:fst::ConstFst
fst::ConstFst::ConstFst	const-fst.h	/^  ConstFst(const ConstFst<A, U> &fst) : ImplToExpandedFst<Impl>(fst) {}$/;"	f	class:fst::ConstFst
fst::ConstFst::ConstFst	const-fst.h	/^  explicit ConstFst(Impl *impl) : ImplToExpandedFst<Impl>(impl) {}$/;"	f	class:fst::ConstFst
fst::ConstFst::ConstFst	const-fst.h	/^  explicit ConstFst(const Fst<A> &fst)$/;"	f	class:fst::ConstFst
fst::ConstFst::Copy	const-fst.h	/^  virtual ConstFst<A, U> *Copy(bool safe = false) const {$/;"	f	class:fst::ConstFst
fst::ConstFst::GetImpl	const-fst.h	/^  Impl *GetImpl() const { return ImplToFst<Impl, ExpandedFst<A> >::GetImpl(); }$/;"	f	class:fst::ConstFst
fst::ConstFst::Impl	const-fst.h	/^  typedef ConstFstImpl<A, U> Impl;$/;"	t	class:fst::ConstFst
fst::ConstFst::InitArcIterator	const-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::ConstFst
fst::ConstFst::InitStateIterator	const-fst.h	/^  virtual void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::ConstFst
fst::ConstFst::Read	const-fst.h	/^  static ConstFst<A, U> *Read(const string &filename) {$/;"	f	class:fst::ConstFst
fst::ConstFst::Read	const-fst.h	/^  static ConstFst<A, U> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::ConstFst
fst::ConstFst::SetImpl	const-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = true) {$/;"	f	class:fst::ConstFst
fst::ConstFst::StateId	const-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ConstFst
fst::ConstFst::Unsigned	const-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::ConstFst
fst::ConstFst::Write	const-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::ConstFst
fst::ConstFst::Write	const-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::ConstFst
fst::ConstFst::WriteFst	const-fst.h	/^bool ConstFst<A, U>::WriteFst(const F &fst, ostream &strm,$/;"	f	class:fst::ConstFst
fst::ConstFstImpl	const-fst.h	/^class ConstFstImpl : public FstImpl<A> {$/;"	c	namespace:fst
fst::ConstFstImpl::Arc	const-fst.h	/^  typedef A Arc;$/;"	t	class:fst::ConstFstImpl
fst::ConstFstImpl::Arcs	const-fst.h	/^  A *Arcs(StateId s) { return arcs_ + states_[s].pos; }$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::ConstFstImpl	const-fst.h	/^  ConstFstImpl()$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::ConstFstImpl	const-fst.h	/^ConstFstImpl<A, U>::ConstFstImpl(const Fst<A> &fst) : nstates_(0), narcs_(0) {$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::Final	const-fst.h	/^  Weight Final(StateId s) const { return states_[s].final; }$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::InitArcIterator	const-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::InitStateIterator	const-fst.h	/^  void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::NumArcs	const-fst.h	/^  size_t NumArcs(StateId s) const { return states_[s].narcs; }$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::NumInputEpsilons	const-fst.h	/^  size_t NumInputEpsilons(StateId s) const { return states_[s].niepsilons; }$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::NumOutputEpsilons	const-fst.h	/^  size_t NumOutputEpsilons(StateId s) const { return states_[s].noepsilons; }$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::NumStates	const-fst.h	/^  StateId NumStates() const { return nstates_; }$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::Read	const-fst.h	/^ConstFstImpl<A, U> *ConstFstImpl<A, U>::Read(istream &strm,$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::Start	const-fst.h	/^  StateId Start() const { return start_; }$/;"	f	class:fst::ConstFstImpl
fst::ConstFstImpl::State	const-fst.h	/^  struct State {$/;"	s	class:fst::ConstFstImpl
fst::ConstFstImpl::State::State	const-fst.h	/^    State() : final(Weight::Zero()), niepsilons(0), noepsilons(0) {}$/;"	f	struct:fst::ConstFstImpl::State
fst::ConstFstImpl::State::final	const-fst.h	/^    Weight final;                \/\/ Final weight$/;"	m	struct:fst::ConstFstImpl::State
fst::ConstFstImpl::State::narcs	const-fst.h	/^    Unsigned narcs;              \/\/ Number of arcs (per state)$/;"	m	struct:fst::ConstFstImpl::State
fst::ConstFstImpl::State::niepsilons	const-fst.h	/^    Unsigned niepsilons;         \/\/ # of input epsilons$/;"	m	struct:fst::ConstFstImpl::State
fst::ConstFstImpl::State::noepsilons	const-fst.h	/^    Unsigned noepsilons;         \/\/ # of output epsilons$/;"	m	struct:fst::ConstFstImpl::State
fst::ConstFstImpl::State::pos	const-fst.h	/^    Unsigned pos;                \/\/ Start of state's arcs in *arcs_$/;"	m	struct:fst::ConstFstImpl::State
fst::ConstFstImpl::StateId	const-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ConstFstImpl
fst::ConstFstImpl::Unsigned	const-fst.h	/^  typedef U Unsigned;$/;"	t	class:fst::ConstFstImpl
fst::ConstFstImpl::Weight	const-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::ConstFstImpl
fst::ConstFstImpl::arcs_	const-fst.h	/^  A *arcs_;                      \/\/ Arcs representation$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kAlignedFileVersion	const-fst.h	/^  static const int kAlignedFileVersion = 1;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kAlignedFileVersion	const-fst.h	/^const int ConstFstImpl<A, U>::kAlignedFileVersion;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kFileAlign	const-fst.h	/^  static const int kFileAlign = 16;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kFileAlign	const-fst.h	/^const int ConstFstImpl<A, U>::kFileAlign;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kFileVersion	const-fst.h	/^  static const int kFileVersion = 2;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kFileVersion	const-fst.h	/^const int ConstFstImpl<A, U>::kFileVersion;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kMinFileVersion	const-fst.h	/^  static const int kMinFileVersion = 1;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kMinFileVersion	const-fst.h	/^const int ConstFstImpl<A, U>::kMinFileVersion;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kStaticProperties	const-fst.h	/^  static const uint64 kStaticProperties = kExpanded;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::kStaticProperties	const-fst.h	/^const uint64 ConstFstImpl<A, U>::kStaticProperties;$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::narcs_	const-fst.h	/^  size_t narcs_;                 \/\/ Number of arcs (per FST)$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::nstates_	const-fst.h	/^  StateId nstates_;              \/\/ Number of states$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::start_	const-fst.h	/^  StateId start_;                \/\/ Initial state$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::states_	const-fst.h	/^  State *states_;                \/\/ States represenation$/;"	m	class:fst::ConstFstImpl
fst::ConstFstImpl::~ConstFstImpl	const-fst.h	/^  ~ConstFstImpl() {$/;"	f	class:fst::ConstFstImpl
fst::Convert	register.h	/^Fst<A> *Convert(const Fst<A> &fst, const string &ftype) {$/;"	f	namespace:fst
fst::CopyVisitor	visit.h	/^class CopyVisitor {$/;"	c	namespace:fst
fst::CopyVisitor::Arc	visit.h	/^  typedef A Arc;$/;"	t	class:fst::CopyVisitor
fst::CopyVisitor::BlackArc	visit.h	/^  bool BlackArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CopyVisitor
fst::CopyVisitor::CopyVisitor	visit.h	/^  CopyVisitor(MutableFst<Arc> *ofst) : ifst_(0), ofst_(ofst) {}$/;"	f	class:fst::CopyVisitor
fst::CopyVisitor::FinishState	visit.h	/^  void FinishState(StateId s) {$/;"	f	class:fst::CopyVisitor
fst::CopyVisitor::FinishVisit	visit.h	/^  void FinishVisit() {}$/;"	f	class:fst::CopyVisitor
fst::CopyVisitor::GreyArc	visit.h	/^  bool GreyArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CopyVisitor
fst::CopyVisitor::InitState	visit.h	/^  bool InitState(StateId s, StateId) {$/;"	f	class:fst::CopyVisitor
fst::CopyVisitor::InitVisit	visit.h	/^  void InitVisit(const Fst<A> &ifst) {$/;"	f	class:fst::CopyVisitor
fst::CopyVisitor::StateId	visit.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CopyVisitor
fst::CopyVisitor::WhiteArc	visit.h	/^  bool WhiteArc(StateId s, const Arc &arc) {$/;"	f	class:fst::CopyVisitor
fst::CopyVisitor::ifst_	visit.h	/^  const Fst<Arc> *ifst_;$/;"	m	class:fst::CopyVisitor
fst::CopyVisitor::ofst_	visit.h	/^  MutableFst<Arc> *ofst_;$/;"	m	class:fst::CopyVisitor
fst::CountStates	expanded-fst.h	/^typename Arc::StateId CountStates(const Fst<Arc> &fst) {$/;"	f	namespace:fst
fst::CyclicMinimizer	minimize.h	/^class CyclicMinimizer {$/;"	c	namespace:fst
fst::CyclicMinimizer::ArcIter	minimize.h	/^  typedef ArcIterator<Fst<RevA> > ArcIter;$/;"	t	class:fst::CyclicMinimizer
fst::CyclicMinimizer::ArcIterCompare	minimize.h	/^  class ArcIterCompare {$/;"	c	class:fst::CyclicMinimizer
fst::CyclicMinimizer::ArcIterCompare::ArcIterCompare	minimize.h	/^    ArcIterCompare(const ArcIterCompare& comp)$/;"	f	class:fst::CyclicMinimizer::ArcIterCompare
fst::CyclicMinimizer::ArcIterCompare::ArcIterCompare	minimize.h	/^    ArcIterCompare(const Partition<StateId>& partition)$/;"	f	class:fst::CyclicMinimizer::ArcIterCompare
fst::CyclicMinimizer::ArcIterCompare::operator ()	minimize.h	/^    bool operator()(const ArcIter* x, const ArcIter* y) const {$/;"	f	class:fst::CyclicMinimizer::ArcIterCompare
fst::CyclicMinimizer::ArcIterCompare::partition_	minimize.h	/^    const Partition<StateId>& partition_;$/;"	m	class:fst::CyclicMinimizer::ArcIterCompare
fst::CyclicMinimizer::ArcIterQueue	minimize.h	/^  ArcIterQueue;$/;"	t	class:fst::CyclicMinimizer
fst::CyclicMinimizer::ClassId	minimize.h	/^  typedef typename A::StateId ClassId;$/;"	t	class:fst::CyclicMinimizer
fst::CyclicMinimizer::Compute	minimize.h	/^  void Compute(const Fst<A>& fst) {$/;"	f	class:fst::CyclicMinimizer
fst::CyclicMinimizer::CyclicMinimizer	minimize.h	/^  CyclicMinimizer(const ExpandedFst<A>& fst):$/;"	f	class:fst::CyclicMinimizer
fst::CyclicMinimizer::Initialize	minimize.h	/^  void Initialize(const Fst<A>& fst) {$/;"	f	class:fst::CyclicMinimizer
fst::CyclicMinimizer::L_	minimize.h	/^  Queue L_;$/;"	m	class:fst::CyclicMinimizer
fst::CyclicMinimizer::Label	minimize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::CyclicMinimizer
fst::CyclicMinimizer::P_	minimize.h	/^  Partition<StateId> P_;$/;"	m	class:fst::CyclicMinimizer
fst::CyclicMinimizer::PrePartition	minimize.h	/^  void PrePartition(const Fst<A>& fst) {$/;"	f	class:fst::CyclicMinimizer
fst::CyclicMinimizer::RevA	minimize.h	/^  typedef ReverseArc<A> RevA;$/;"	t	class:fst::CyclicMinimizer
fst::CyclicMinimizer::Split	minimize.h	/^  void Split(ClassId C) {$/;"	f	class:fst::CyclicMinimizer
fst::CyclicMinimizer::StateId	minimize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::CyclicMinimizer
fst::CyclicMinimizer::Tr_	minimize.h	/^  VectorFst<RevA> Tr_;$/;"	m	class:fst::CyclicMinimizer
fst::CyclicMinimizer::Weight	minimize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::CyclicMinimizer
fst::CyclicMinimizer::aiter_queue_	minimize.h	/^  ArcIterQueue* aiter_queue_;$/;"	m	class:fst::CyclicMinimizer
fst::CyclicMinimizer::partition	minimize.h	/^  const Partition<StateId>& partition() const {$/;"	f	class:fst::CyclicMinimizer
fst::CyclicMinimizer::~CyclicMinimizer	minimize.h	/^  ~CyclicMinimizer() {$/;"	f	class:fst::CyclicMinimizer
fst::DECODE	encode.h	/^enum EncodeType { ENCODE = 1, DECODE = 2 };$/;"	e	enum:fst::EncodeType
fst::DIVIDE_ANY	weight.h	/^                  DIVIDE_ANY };  \/\/ division in a commutative semiring$/;"	e	enum:fst::DivideType
fst::DIVIDE_LEFT	weight.h	/^enum DivideType { DIVIDE_LEFT,   \/\/ left division$/;"	e	enum:fst::DivideType
fst::DIVIDE_RIGHT	weight.h	/^                  DIVIDE_RIGHT,  \/\/ right division$/;"	e	enum:fst::DivideType
fst::Decode	encode.h	/^void Decode(MutableFst<A>* fst, const EncodeMapper<A>& mapper) {$/;"	f	namespace:fst
fst::DecodeFst	encode.h	/^class DecodeFst : public ArcMapFst<A, A, EncodeMapper<A> > {$/;"	c	namespace:fst
fst::DecodeFst::Arc	encode.h	/^  typedef A Arc;$/;"	t	class:fst::DecodeFst
fst::DecodeFst::C	encode.h	/^  typedef EncodeMapper<A> C;$/;"	t	class:fst::DecodeFst
fst::DecodeFst::Copy	encode.h	/^  virtual DecodeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::DecodeFst
fst::DecodeFst::DecodeFst	encode.h	/^  DecodeFst(const DecodeFst<A> &fst, bool safe = false)$/;"	f	class:fst::DecodeFst
fst::DecodeFst::DecodeFst	encode.h	/^  DecodeFst(const Fst<A> &fst, const EncodeMapper<A>& encoder)$/;"	f	class:fst::DecodeFst
fst::DecodeFst::Impl	encode.h	/^  typedef ArcMapFstImpl< A, A, EncodeMapper<A> > Impl;$/;"	t	class:fst::DecodeFst
fst::DefaultAccumulator	accumulator.h	/^class DefaultAccumulator {$/;"	c	namespace:fst
fst::DefaultAccumulator::Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::DefaultAccumulator
fst::DefaultAccumulator::DefaultAccumulator	accumulator.h	/^  DefaultAccumulator() {}$/;"	f	class:fst::DefaultAccumulator
fst::DefaultAccumulator::DefaultAccumulator	accumulator.h	/^  DefaultAccumulator(const DefaultAccumulator<A> &acc) {}$/;"	f	class:fst::DefaultAccumulator
fst::DefaultAccumulator::Error	accumulator.h	/^  bool Error() const { return false; }$/;"	f	class:fst::DefaultAccumulator
fst::DefaultAccumulator::Init	accumulator.h	/^  void Init(const Fst<A>& fst, bool copy = false) {}$/;"	f	class:fst::DefaultAccumulator
fst::DefaultAccumulator::SetState	accumulator.h	/^  void SetState(StateId) {}$/;"	f	class:fst::DefaultAccumulator
fst::DefaultAccumulator::StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DefaultAccumulator
fst::DefaultAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, ArcIterator *aiter, ssize_t begin,$/;"	f	class:fst::DefaultAccumulator
fst::DefaultAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::DefaultAccumulator
fst::DefaultAccumulator::Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DefaultAccumulator
fst::DefaultCacheStateAllocator	cache.h	/^struct DefaultCacheStateAllocator {$/;"	s	namespace:fst
fst::DefaultCacheStateAllocator::Allocate	cache.h	/^  S *Allocate(StateId s) {$/;"	f	struct:fst::DefaultCacheStateAllocator
fst::DefaultCacheStateAllocator::DefaultCacheStateAllocator	cache.h	/^  DefaultCacheStateAllocator() : mru_(NULL) { }$/;"	f	struct:fst::DefaultCacheStateAllocator
fst::DefaultCacheStateAllocator::Free	cache.h	/^  void Free(S *state, StateId s) {$/;"	f	struct:fst::DefaultCacheStateAllocator
fst::DefaultCacheStateAllocator::StateId	cache.h	/^  typedef typename S::Arc::StateId StateId;$/;"	t	struct:fst::DefaultCacheStateAllocator
fst::DefaultCacheStateAllocator::mru_	cache.h	/^  S *mru_;$/;"	m	struct:fst::DefaultCacheStateAllocator
fst::DefaultCacheStateAllocator::~DefaultCacheStateAllocator	cache.h	/^  ~DefaultCacheStateAllocator() {$/;"	f	struct:fst::DefaultCacheStateAllocator
fst::DefaultCommonDivisor	determinize.h	/^class DefaultCommonDivisor {$/;"	c	namespace:fst
fst::DefaultCommonDivisor::Weight	determinize.h	/^  typedef W Weight;$/;"	t	class:fst::DefaultCommonDivisor
fst::DefaultCommonDivisor::operator ()	determinize.h	/^  W operator()(const W &w1, const W &w2) const { return Plus(w1, w2); }$/;"	f	class:fst::DefaultCommonDivisor
fst::DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead {$/;"	c	namespace:fst
fst::DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<A, MATCH_INPUT> {$/;"	c	namespace:fst
fst::DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<A, MATCH_OUTPUT> {$/;"	c	namespace:fst
fst::DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<LogArc, MATCH_INPUT> {$/;"	c	namespace:fst
fst::DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<LogArc, MATCH_OUTPUT> {$/;"	c	namespace:fst
fst::DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<StdArc, MATCH_INPUT> {$/;"	c	namespace:fst
fst::DefaultLookAhead	lookahead-filter.h	/^class DefaultLookAhead<StdArc, MATCH_OUTPUT> {$/;"	c	namespace:fst
fst::DefaultLookAhead::A	lookahead-filter.h	/^  typedef LogArc A;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::A	lookahead-filter.h	/^  typedef StdArc A;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::ComposeFilter	lookahead-filter.h	/^  typedef LookAheadComposeFilter<SF, M> ComposeFilter;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::ComposeFilter	lookahead-filter.h	/^  typedef PushLabelsComposeFilter<WF, M> ComposeFilter;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::ComposeFilter	lookahead-filter.h	/^  typedef SequenceComposeFilter<M> ComposeFilter;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::FstMatcher	lookahead-filter.h	/^  typedef M FstMatcher;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::LF	lookahead-filter.h	/^  typedef LookAheadComposeFilter<SF, M>  LF;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::LF	lookahead-filter.h	/^  typedef LookAheadComposeFilter<SF, M> LF;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::M	lookahead-filter.h	/^  typedef LookAheadMatcher< Fst<A> > M;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::M	lookahead-filter.h	/^  typedef Matcher< Fst<A> > M;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::SF	lookahead-filter.h	/^  typedef AltSequenceComposeFilter<M> SF;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::SF	lookahead-filter.h	/^  typedef SequenceComposeFilter<M> SF;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultLookAhead::WF	lookahead-filter.h	/^  typedef PushWeightsComposeFilter<LF, M> WF;$/;"	t	class:fst::DefaultLookAhead
fst::DefaultReplaceStateTable	replace.h	/^class DefaultReplaceStateTable : public CompactHashStateTable<$/;"	c	namespace:fst
fst::DefaultReplaceStateTable::Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::DefaultReplaceStateTable
fst::DefaultReplaceStateTable::DefaultReplaceStateTable	replace.h	/^  DefaultReplaceStateTable($/;"	f	class:fst::DefaultReplaceStateTable
fst::DefaultReplaceStateTable::DefaultReplaceStateTable	replace.h	/^  DefaultReplaceStateTable(const DefaultReplaceStateTable<A, P> &table)$/;"	f	class:fst::DefaultReplaceStateTable
fst::DefaultReplaceStateTable::Label	replace.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DefaultReplaceStateTable
fst::DefaultReplaceStateTable::PrefixId	replace.h	/^  typedef P PrefixId;$/;"	t	class:fst::DefaultReplaceStateTable
fst::DefaultReplaceStateTable::StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DefaultReplaceStateTable
fst::DefaultReplaceStateTable::StateTable	replace.h	/^                                ReplaceHash<StateId, PrefixId> > StateTable;$/;"	t	class:fst::DefaultReplaceStateTable
fst::DefaultReplaceStateTable::StateTuple	replace.h	/^  typedef ReplaceStateTuple<StateId, P> StateTuple;$/;"	t	class:fst::DefaultReplaceStateTable
fst::DeleteAllStatesProperties	properties.h	/^uint64 DeleteAllStatesProperties(uint64 inprops, uint64 staticprops) {$/;"	f	namespace:fst
fst::DeleteArcsProperties	properties.h	/^uint64 DeleteArcsProperties(uint64 inprops) {$/;"	f	namespace:fst
fst::DeleteStatesProperties	properties.h	/^uint64 DeleteStatesProperties(uint64 inprops) {$/;"	f	namespace:fst
fst::DetStringComposeStateTable	state-table.h	/^class DetStringComposeStateTable : public$/;"	c	namespace:fst
fst::DetStringComposeStateTable::Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::DetStringComposeStateTable
fst::DetStringComposeStateTable::DetStringComposeStateTable	state-table.h	/^  DetStringComposeStateTable(const DetStringComposeStateTable<A, F> &table)$/;"	f	class:fst::DetStringComposeStateTable
fst::DetStringComposeStateTable::DetStringComposeStateTable	state-table.h	/^  DetStringComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2)$/;"	f	class:fst::DetStringComposeStateTable
fst::DetStringComposeStateTable::Error	state-table.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::DetStringComposeStateTable
fst::DetStringComposeStateTable::FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::DetStringComposeStateTable
fst::DetStringComposeStateTable::StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DetStringComposeStateTable
fst::DetStringComposeStateTable::StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::DetStringComposeStateTable
fst::DetStringComposeStateTable::error_	state-table.h	/^  bool error_;$/;"	m	class:fst::DetStringComposeStateTable
fst::Determinize	determinize.h	/^void Determinize(const Fst<Arc> &ifst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
fst::DeterminizeFsaImpl	determinize.h	/^class DeterminizeFsaImpl : public DeterminizeFstImplBase<A> {$/;"	c	namespace:fst
fst::DeterminizeFsaImpl::AddArc	determinize.h	/^  void AddArc(StateId s, Label label, Subset *dest_subset) {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::ComputeDistance	determinize.h	/^  Weight ComputeDistance(const Subset *subset) {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::ComputeFinal	determinize.h	/^  virtual Weight ComputeFinal(StateId s) {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::ComputeStart	determinize.h	/^  virtual StateId ComputeStart() {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::Copy	determinize.h	/^  virtual DeterminizeFsaImpl<A, D> *Copy() {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::CreateState	determinize.h	/^  StateId CreateState(Subset *subset) {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::DeterminizeFsaImpl	determinize.h	/^  DeterminizeFsaImpl(const DeterminizeFsaImpl<A, D> &impl)$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::DeterminizeFsaImpl	determinize.h	/^  DeterminizeFsaImpl(const Fst<A> &fst, D common_divisor,$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::Element	determinize.h	/^  struct Element {$/;"	s	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::Element::Element	determinize.h	/^    Element() {}$/;"	f	struct:fst::DeterminizeFsaImpl::Element
fst::DeterminizeFsaImpl::Element::Element	determinize.h	/^    Element(StateId s, Weight w) : state_id(s), weight(w) {}$/;"	f	struct:fst::DeterminizeFsaImpl::Element
fst::DeterminizeFsaImpl::Element::state_id	determinize.h	/^    StateId state_id;  \/\/ Input state Id$/;"	m	struct:fst::DeterminizeFsaImpl::Element
fst::DeterminizeFsaImpl::Element::weight	determinize.h	/^    Weight weight;     \/\/ Residual weight$/;"	m	struct:fst::DeterminizeFsaImpl::Element
fst::DeterminizeFsaImpl::Expand	determinize.h	/^  virtual void Expand(StateId s) {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::FindState	determinize.h	/^  StateId FindState(Subset *subset) {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::Label	determinize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::LabelMap	determinize.h	/^  typedef map<Label, Subset*> LabelMap;$/;"	t	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::LabelSubsets	determinize.h	/^  void LabelSubsets(StateId s, LabelMap *label_map) {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::Properties	determinize.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::Properties	determinize.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::Subset	determinize.h	/^  typedef slist<Element> Subset;$/;"	t	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::SubsetEqual	determinize.h	/^  class SubsetEqual {$/;"	c	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::SubsetEqual::SubsetEqual	determinize.h	/^    explicit SubsetEqual(vector<Element *> *elements)$/;"	f	class:fst::DeterminizeFsaImpl::SubsetEqual
fst::DeterminizeFsaImpl::SubsetEqual::elements_	determinize.h	/^    vector<Element *> *elements_;$/;"	m	class:fst::DeterminizeFsaImpl::SubsetEqual
fst::DeterminizeFsaImpl::SubsetEqual::operator ()	determinize.h	/^    bool operator()(Subset* subset1, Subset* subset2) const {$/;"	f	class:fst::DeterminizeFsaImpl::SubsetEqual
fst::DeterminizeFsaImpl::SubsetHash	determinize.h	/^  SubsetHash;$/;"	t	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::SubsetKey	determinize.h	/^  class SubsetKey {$/;"	c	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::SubsetKey::operator ()	determinize.h	/^    size_t operator()(const Subset* subset) const {$/;"	f	class:fst::DeterminizeFsaImpl::SubsetKey
fst::DeterminizeFsaImpl::Weight	determinize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::common_divisor_	determinize.h	/^  D common_divisor_;$/;"	m	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::delta_	determinize.h	/^  float delta_;                    \/\/ Quantization delta for subset weights$/;"	m	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::elements_	determinize.h	/^  vector<Element *> elements_;$/;"	m	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::in_dist_	determinize.h	/^  const vector<Weight> *in_dist_;  \/\/ Distance to final NFA states$/;"	m	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::out_dist_	determinize.h	/^  vector<Weight> *out_dist_;       \/\/ Distance to final DFA states$/;"	m	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::subset_hash_	determinize.h	/^  SubsetHash subset_hash_;$/;"	m	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::subsets_	determinize.h	/^  vector<Subset *> subsets_;$/;"	m	class:fst::DeterminizeFsaImpl
fst::DeterminizeFsaImpl::~DeterminizeFsaImpl	determinize.h	/^  virtual ~DeterminizeFsaImpl() {$/;"	f	class:fst::DeterminizeFsaImpl
fst::DeterminizeFst	determinize.h	/^class DeterminizeFst : public ImplToFst< DeterminizeFstImplBase<A> >  {$/;"	c	namespace:fst
fst::DeterminizeFst::Arc	determinize.h	/^  typedef A Arc;$/;"	t	class:fst::DeterminizeFst
fst::DeterminizeFst::Copy	determinize.h	/^  virtual DeterminizeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::DeterminizeFst
fst::DeterminizeFst::DeterminizeFst	determinize.h	/^  DeterminizeFst($/;"	f	class:fst::DeterminizeFst
fst::DeterminizeFst::DeterminizeFst	determinize.h	/^  DeterminizeFst(const DeterminizeFst<A> &fst, bool safe = false) {$/;"	f	class:fst::DeterminizeFst
fst::DeterminizeFst::DeterminizeFst	determinize.h	/^  DeterminizeFst(const Fst<A> &fst, const D &common_div,$/;"	f	class:fst::DeterminizeFst
fst::DeterminizeFst::DeterminizeFst	determinize.h	/^  explicit DeterminizeFst($/;"	f	class:fst::DeterminizeFst
fst::DeterminizeFst::GetImpl	determinize.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::DeterminizeFst
fst::DeterminizeFst::Impl	determinize.h	/^  typedef DeterminizeFstImplBase<A> Impl;$/;"	t	class:fst::DeterminizeFst
fst::DeterminizeFst::InitArcIterator	determinize.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::DeterminizeFst
fst::DeterminizeFst::InitStateIterator	determinize.h	/^void DeterminizeFst<A>::InitStateIterator(StateIteratorData<A> *data) const$/;"	f	class:fst::DeterminizeFst
fst::DeterminizeFst::Label	determinize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DeterminizeFst
fst::DeterminizeFst::State	determinize.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::DeterminizeFst
fst::DeterminizeFst::StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DeterminizeFst
fst::DeterminizeFst::Weight	determinize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DeterminizeFst
fst::DeterminizeFstImpl	determinize.h	/^class DeterminizeFstImpl : public DeterminizeFstImplBase<A> {$/;"	c	namespace:fst
fst::DeterminizeFstImpl::CommonDivisor	determinize.h	/^  typedef GallicCommonDivisor<Label, Weight, S> CommonDivisor;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::ComputeFinal	determinize.h	/^  virtual Weight ComputeFinal(StateId s) { return from_fst_->Final(s); }$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::ComputeStart	determinize.h	/^  virtual StateId ComputeStart() { return from_fst_->Start(); }$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::Copy	determinize.h	/^  virtual DeterminizeFstImpl<A, S> *Copy() {$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::DeterminizeFstImpl	determinize.h	/^  DeterminizeFstImpl(const DeterminizeFstImpl<A, S> &impl)$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::DeterminizeFstImpl	determinize.h	/^  DeterminizeFstImpl(const Fst<A> &fst, const DeterminizeFstOptions<A> &opts)$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::Expand	determinize.h	/^  virtual void Expand(StateId s) {$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::FactorIterator	determinize.h	/^  typedef GallicFactor<Label, Weight, S> FactorIterator;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::FromFst	determinize.h	/^  typedef ArcMapFst<ToArc, A, FromMapper> FromFst;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::FromMapper	determinize.h	/^  typedef FromGallicMapper<A, S> FromMapper;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::Init	determinize.h	/^void DeterminizeFstImpl<A, S>::Init(const Fst<A> &fst) {$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::Label	determinize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::Properties	determinize.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::Properties	determinize.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::ToArc	determinize.h	/^  typedef typename ToMapper::ToArc ToArc;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::ToFst	determinize.h	/^  typedef ArcMapFst<A, ToArc, ToMapper> ToFst;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::ToMapper	determinize.h	/^  typedef ToGallicMapper<A, S> ToMapper;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::Weight	determinize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::delta_	determinize.h	/^  float delta_;$/;"	m	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::from_fst_	determinize.h	/^  FromFst *from_fst_;$/;"	m	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::subsequential_label_	determinize.h	/^  Label subsequential_label_;$/;"	m	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImpl::~DeterminizeFstImpl	determinize.h	/^  ~DeterminizeFstImpl() { delete from_fst_; }$/;"	f	class:fst::DeterminizeFstImpl
fst::DeterminizeFstImplBase	determinize.h	/^class DeterminizeFstImplBase : public CacheImpl<A> {$/;"	c	namespace:fst
fst::DeterminizeFstImplBase::DeterminizeFstImplBase	determinize.h	/^  DeterminizeFstImplBase(const DeterminizeFstImplBase<A> &impl)$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::DeterminizeFstImplBase	determinize.h	/^  DeterminizeFstImplBase(const Fst<A> &fst,$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::Final	determinize.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::GetFst	determinize.h	/^  const Fst<A> &GetFst() const { return *fst_; }$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::InitArcIterator	determinize.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::Label	determinize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::NumArcs	determinize.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::NumInputEpsilons	determinize.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::NumOutputEpsilons	determinize.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::Start	determinize.h	/^  StateId Start() {$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::State	determinize.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::StateId	determinize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::Weight	determinize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::fst_	determinize.h	/^  const Fst<A> *fst_;            \/\/ Input Fst$/;"	m	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstImplBase::~DeterminizeFstImplBase	determinize.h	/^  virtual ~DeterminizeFstImplBase() { delete fst_; }$/;"	f	class:fst::DeterminizeFstImplBase
fst::DeterminizeFstOptions	determinize.h	/^struct DeterminizeFstOptions : CacheOptions {$/;"	s	namespace:fst
fst::DeterminizeFstOptions::DeterminizeFstOptions	determinize.h	/^  explicit DeterminizeFstOptions(const CacheOptions &opts,$/;"	f	struct:fst::DeterminizeFstOptions
fst::DeterminizeFstOptions::DeterminizeFstOptions	determinize.h	/^  explicit DeterminizeFstOptions(float del = kDelta, Label lab = 0)$/;"	f	struct:fst::DeterminizeFstOptions
fst::DeterminizeFstOptions::Label	determinize.h	/^  typedef typename Arc::Label Label;$/;"	t	struct:fst::DeterminizeFstOptions
fst::DeterminizeFstOptions::delta	determinize.h	/^  float delta;                \/\/ Quantization delta for subset weights$/;"	m	struct:fst::DeterminizeFstOptions
fst::DeterminizeFstOptions::subsequential_label	determinize.h	/^  Label subsequential_label;  \/\/ Label used for residual final output$/;"	m	struct:fst::DeterminizeFstOptions
fst::DeterminizeOptions	determinize.h	/^struct DeterminizeOptions {$/;"	s	namespace:fst
fst::DeterminizeOptions::DeterminizeOptions	determinize.h	/^  explicit DeterminizeOptions(float d = kDelta, Weight w = Weight::Zero(),$/;"	f	struct:fst::DeterminizeOptions
fst::DeterminizeOptions::Label	determinize.h	/^  typedef typename Arc::Label Label;$/;"	t	struct:fst::DeterminizeOptions
fst::DeterminizeOptions::StateId	determinize.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::DeterminizeOptions
fst::DeterminizeOptions::Weight	determinize.h	/^  typedef typename Arc::Weight Weight;$/;"	t	struct:fst::DeterminizeOptions
fst::DeterminizeOptions::delta	determinize.h	/^  float delta;                \/\/ Quantization delta for subset weights.$/;"	m	struct:fst::DeterminizeOptions
fst::DeterminizeOptions::state_threshold	determinize.h	/^  StateId state_threshold;    \/\/ Pruning state threshold.$/;"	m	struct:fst::DeterminizeOptions
fst::DeterminizeOptions::subsequential_label	determinize.h	/^  Label subsequential_label;  \/\/ Label used for residual final output$/;"	m	struct:fst::DeterminizeOptions
fst::DeterminizeOptions::weight_threshold	determinize.h	/^  Weight weight_threshold;    \/\/ Pruning weight threshold.$/;"	m	struct:fst::DeterminizeOptions
fst::DfsState	dfs-visit.h	/^struct DfsState {$/;"	s	namespace:fst
fst::DfsState::DfsState	dfs-visit.h	/^  DfsState(const Fst<Arc> &fst, StateId s): state_id(s), arc_iter(fst, s) {}$/;"	f	struct:fst::DfsState
fst::DfsState::StateId	dfs-visit.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::DfsState
fst::DfsState::arc_iter	dfs-visit.h	/^  ArcIterator< Fst<Arc> > arc_iter;  \/\/ and its corresponding arcs$/;"	m	struct:fst::DfsState
fst::DfsState::state_id	dfs-visit.h	/^  StateId state_id;       \/\/ Fst state ...$/;"	m	struct:fst::DfsState
fst::DfsVisit	dfs-visit.h	/^void DfsVisit(const Fst<Arc> &fst, V *visitor) {$/;"	f	namespace:fst
fst::DfsVisit	dfs-visit.h	/^void DfsVisit(const Fst<Arc> &fst, V *visitor, ArcFilter filter) {$/;"	f	namespace:fst
fst::Difference	difference.h	/^void Difference(const Fst<Arc> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
fst::DifferenceFst	difference.h	/^class DifferenceFst : public ComposeFst<A> {$/;"	c	namespace:fst
fst::DifferenceFst::Arc	difference.h	/^  typedef A Arc;$/;"	t	class:fst::DifferenceFst
fst::DifferenceFst::Copy	difference.h	/^  virtual DifferenceFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::DifferenceFst
fst::DifferenceFst::DifferenceFst	difference.h	/^  DifferenceFst(const DifferenceFst<A> &fst, bool safe = false)$/;"	f	class:fst::DifferenceFst
fst::DifferenceFst::DifferenceFst	difference.h	/^  DifferenceFst(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::DifferenceFst
fst::DifferenceFst::StateId	difference.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::DifferenceFst
fst::DifferenceFst::Weight	difference.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::DifferenceFst
fst::DifferenceFstOptions	difference.h	/^struct DifferenceFstOptions : public ComposeFstOptions<A, M, F, T> {$/;"	s	namespace:fst
fst::DifferenceFstOptions::DifferenceFstOptions	difference.h	/^  DifferenceFstOptions() {}$/;"	f	struct:fst::DifferenceFstOptions
fst::DifferenceFstOptions::DifferenceFstOptions	difference.h	/^  explicit DifferenceFstOptions(const CacheOptions &opts,$/;"	f	struct:fst::DifferenceFstOptions
fst::DifferenceOptions	difference.h	/^typedef ComposeOptions DifferenceOptions;$/;"	t	namespace:fst
fst::Divide	expectation-weight.h	/^inline ExpectationWeight<X1, X2> Divide(const ExpectationWeight<X1, X2> &w,$/;"	f	namespace:fst
fst::Divide	float-weight.h	/^inline LogWeightTpl<T> Divide(const LogWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Divide	float-weight.h	/^inline LogWeightTpl<double> Divide(const LogWeightTpl<double> &w1,$/;"	f	namespace:fst
fst::Divide	float-weight.h	/^inline LogWeightTpl<float> Divide(const LogWeightTpl<float> &w1,$/;"	f	namespace:fst
fst::Divide	float-weight.h	/^inline MinMaxWeightTpl<T> Divide(const MinMaxWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Divide	float-weight.h	/^inline MinMaxWeightTpl<double> Divide(const MinMaxWeightTpl<double> &w1,$/;"	f	namespace:fst
fst::Divide	float-weight.h	/^inline MinMaxWeightTpl<float> Divide(const MinMaxWeightTpl<float> &w1,$/;"	f	namespace:fst
fst::Divide	float-weight.h	/^inline TropicalWeightTpl<T> Divide(const TropicalWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Divide	float-weight.h	/^inline TropicalWeightTpl<double> Divide(const TropicalWeightTpl<double> &w1,$/;"	f	namespace:fst
fst::Divide	float-weight.h	/^inline TropicalWeightTpl<float> Divide(const TropicalWeightTpl<float> &w1,$/;"	f	namespace:fst
fst::Divide	lexicographic-weight.h	/^inline LexicographicWeight<W1, W2> Divide(const LexicographicWeight<W1, W2> &w,$/;"	f	namespace:fst
fst::Divide	power-weight.h	/^inline PowerWeight<W, n> Divide(const PowerWeight<W, n> &w1,$/;"	f	namespace:fst
fst::Divide	product-weight.h	/^inline ProductWeight<W1, W2> Divide(const ProductWeight<W1, W2> &w,$/;"	f	namespace:fst
fst::Divide	signed-log-weight.h	/^inline SignedLogWeightTpl<T> Divide(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Divide	sparse-power-weight.h	/^inline SparsePowerWeight<W, K> Divide(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
fst::Divide	string-weight.h	/^Divide(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
fst::Divide	string-weight.h	/^Divide(const StringWeight<L, STRING_RIGHT> &w1,$/;"	f	namespace:fst
fst::Divide	string-weight.h	/^Divide(const StringWeight<L, STRING_RIGHT_RESTRICT> &w1,$/;"	f	namespace:fst
fst::DivideType	weight.h	/^enum DivideType { DIVIDE_LEFT,   \/\/ left division$/;"	g	namespace:fst
fst::DotProduct	power-weight.h	/^inline W DotProduct(const PowerWeight<W, n> &w1,$/;"	f	namespace:fst
fst::DotProduct	sparse-power-weight.h	/^inline const W& DotProduct(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
fst::ENCODE	encode.h	/^enum EncodeType { ENCODE = 1, DECODE = 2 };$/;"	e	enum:fst::EncodeType
fst::EPS_NORM_INPUT	epsnormalize.h	/^enum EpsNormalizeType {EPS_NORM_INPUT, EPS_NORM_OUTPUT};$/;"	e	enum:fst::EpsNormalizeType
fst::EPS_NORM_OUTPUT	epsnormalize.h	/^enum EpsNormalizeType {EPS_NORM_INPUT, EPS_NORM_OUTPUT};$/;"	e	enum:fst::EpsNormalizeType
fst::EditFst	edit-fst.h	/^class EditFst :$/;"	c	namespace:fst
fst::EditFst::Arc	edit-fst.h	/^  typedef A Arc;$/;"	t	class:fst::EditFst
fst::EditFst::Copy	edit-fst.h	/^  virtual EditFst<A, WrappedFstT, MutableFstT> *Copy(bool safe = false) const {$/;"	f	class:fst::EditFst
fst::EditFst::EditFst	edit-fst.h	/^  EditFst() : ImplToMutableFst<Impl>(new Impl()) {}$/;"	f	class:fst::EditFst
fst::EditFst::EditFst	edit-fst.h	/^  EditFst(const EditFst<A, WrappedFstT, MutableFstT> &fst, bool safe = false) :$/;"	f	class:fst::EditFst
fst::EditFst::EditFst	edit-fst.h	/^  explicit EditFst(Impl *impl) : ImplToMutableFst<Impl>(impl) {}$/;"	f	class:fst::EditFst
fst::EditFst::EditFst	edit-fst.h	/^  explicit EditFst(const Fst<A> &fst) :$/;"	f	class:fst::EditFst
fst::EditFst::EditFst	edit-fst.h	/^  explicit EditFst(const WrappedFstT &fst) :$/;"	f	class:fst::EditFst
fst::EditFst::GetImpl	edit-fst.h	/^  Impl *GetImpl() const { return ImplToFst< Impl, MutableFst<A> >::GetImpl(); }$/;"	f	class:fst::EditFst
fst::EditFst::Impl	edit-fst.h	/^  typedef EditFstImpl<A, WrappedFstT, MutableFstT> Impl;$/;"	t	class:fst::EditFst
fst::EditFst::InitArcIterator	edit-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::EditFst
fst::EditFst::InitMutableArcIterator	edit-fst.h	/^  void InitMutableArcIterator(StateId s, MutableArcIteratorData<A> *data) {$/;"	f	class:fst::EditFst
fst::EditFst::InitStateIterator	edit-fst.h	/^  virtual void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::EditFst
fst::EditFst::Read	edit-fst.h	/^  Read(istream &strm,$/;"	f	class:fst::EditFst
fst::EditFst::Read	edit-fst.h	/^  static EditFst<A, WrappedFstT, MutableFstT> *Read(const string &filename) {$/;"	f	class:fst::EditFst
fst::EditFst::SetImpl	edit-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = true) {$/;"	f	class:fst::EditFst
fst::EditFst::StateId	edit-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::EditFst
fst::EditFst::Write	edit-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::EditFst
fst::EditFst::Write	edit-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::EditFst
fst::EditFst::operator =	edit-fst.h	/^  operator=(const EditFst<A, WrappedFstT, MutableFstT> &fst) {$/;"	f	class:fst::EditFst
fst::EditFst::operator =	edit-fst.h	/^  virtual EditFst<A, WrappedFstT, MutableFstT> &operator=(const Fst<A> &fst) {$/;"	f	class:fst::EditFst
fst::EditFst::~EditFst	edit-fst.h	/^  virtual ~EditFst() {}$/;"	f	class:fst::EditFst
fst::EditFstData	edit-fst.h	/^class EditFstData {$/;"	c	namespace:fst
fst::EditFstData::AddArc	edit-fst.h	/^  const A *AddArc(StateId s, const Arc &arc, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
fst::EditFstData::AddState	edit-fst.h	/^  StateId AddState(StateId curr_num_states) {$/;"	f	class:fst::EditFstData
fst::EditFstData::Arc	edit-fst.h	/^  typedef A Arc;$/;"	t	class:fst::EditFstData
fst::EditFstData::DecrRefCount	edit-fst.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::EditFstData
fst::EditFstData::DeleteArcs	edit-fst.h	/^  void DeleteArcs(StateId s, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
fst::EditFstData::DeleteArcs	edit-fst.h	/^  void DeleteArcs(StateId s, size_t n, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
fst::EditFstData::DeleteStates	edit-fst.h	/^  void DeleteStates() {$/;"	f	class:fst::EditFstData
fst::EditFstData::EditFstData	edit-fst.h	/^  EditFstData() : num_new_states_(0) {$/;"	f	class:fst::EditFstData
fst::EditFstData::EditFstData	edit-fst.h	/^  EditFstData(const EditFstData &other) :$/;"	f	class:fst::EditFstData
fst::EditFstData::EditedStart	edit-fst.h	/^  StateId EditedStart() const {$/;"	f	class:fst::EditFstData
fst::EditFstData::Final	edit-fst.h	/^  Weight Final(StateId s, const WrappedFstT *wrapped) const {$/;"	f	class:fst::EditFstData
fst::EditFstData::FinalWeightIterator	edit-fst.h	/^      FinalWeightIterator;$/;"	t	class:fst::EditFstData
fst::EditFstData::GetEditableInternalId	edit-fst.h	/^  StateId GetEditableInternalId(StateId s, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
fst::EditFstData::GetEditedIdMapIterator	edit-fst.h	/^  IdMapIterator GetEditedIdMapIterator(StateId s) const {$/;"	f	class:fst::EditFstData
fst::EditFstData::GetFinalWeightIterator	edit-fst.h	/^  FinalWeightIterator GetFinalWeightIterator(StateId s) const {$/;"	f	class:fst::EditFstData
fst::EditFstData::IdMapIterator	edit-fst.h	/^      IdMapIterator;$/;"	t	class:fst::EditFstData
fst::EditFstData::IncrRefCount	edit-fst.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::EditFstData
fst::EditFstData::InitArcIterator	edit-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data,$/;"	f	class:fst::EditFstData
fst::EditFstData::InitMutableArcIterator	edit-fst.h	/^  void InitMutableArcIterator(StateId s, MutableArcIteratorData<A> *data,$/;"	f	class:fst::EditFstData
fst::EditFstData::NotInEditedMap	edit-fst.h	/^  IdMapIterator NotInEditedMap() const {$/;"	f	class:fst::EditFstData
fst::EditFstData::NotInFinalWeightMap	edit-fst.h	/^  FinalWeightIterator NotInFinalWeightMap() const {$/;"	f	class:fst::EditFstData
fst::EditFstData::NumArcs	edit-fst.h	/^  size_t NumArcs(StateId s, const WrappedFstT *wrapped) const {$/;"	f	class:fst::EditFstData
fst::EditFstData::NumInputEpsilons	edit-fst.h	/^  size_t NumInputEpsilons(StateId s, const WrappedFstT *wrapped) const {$/;"	f	class:fst::EditFstData
fst::EditFstData::NumNewStates	edit-fst.h	/^  StateId NumNewStates() const {$/;"	f	class:fst::EditFstData
fst::EditFstData::NumOutputEpsilons	edit-fst.h	/^  size_t NumOutputEpsilons(StateId s, const WrappedFstT *wrapped) const {$/;"	f	class:fst::EditFstData
fst::EditFstData::PrintMap	edit-fst.h	/^  void PrintMap() {$/;"	f	class:fst::EditFstData
fst::EditFstData::Read	edit-fst.h	/^EditFstData<A, WrappedFstT, MutableFstT>::Read(istream &strm,$/;"	f	class:fst::EditFstData
fst::EditFstData::RefCount	edit-fst.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::EditFstData
fst::EditFstData::SetEditedProperties	edit-fst.h	/^  void SetEditedProperties(uint64 props, uint64 mask) {$/;"	f	class:fst::EditFstData
fst::EditFstData::SetEmptyAndDeleteKeysForInternalMaps	edit-fst.h	/^  void SetEmptyAndDeleteKeysForInternalMaps() {$/;"	f	class:fst::EditFstData
fst::EditFstData::SetFinal	edit-fst.h	/^  Weight SetFinal(StateId s, Weight w, const WrappedFstT *wrapped) {$/;"	f	class:fst::EditFstData
fst::EditFstData::SetStart	edit-fst.h	/^  void SetStart(StateId s) {$/;"	f	class:fst::EditFstData
fst::EditFstData::StateId	edit-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::EditFstData
fst::EditFstData::Weight	edit-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::EditFstData
fst::EditFstData::Write	edit-fst.h	/^  bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::EditFstData
fst::EditFstData::edited_final_weights_	edit-fst.h	/^  unordered_map<StateId, Weight> edited_final_weights_;$/;"	m	class:fst::EditFstData
fst::EditFstData::edits_	edit-fst.h	/^  MutableFstT edits_;$/;"	m	class:fst::EditFstData
fst::EditFstData::external_to_internal_ids_	edit-fst.h	/^  unordered_map<StateId, StateId> external_to_internal_ids_;$/;"	m	class:fst::EditFstData
fst::EditFstData::num_new_states_	edit-fst.h	/^  StateId num_new_states_;$/;"	m	class:fst::EditFstData
fst::EditFstData::ref_count_	edit-fst.h	/^  RefCounter ref_count_;$/;"	m	class:fst::EditFstData
fst::EditFstData::~EditFstData	edit-fst.h	/^  ~EditFstData() {$/;"	f	class:fst::EditFstData
fst::EditFstImpl	edit-fst.h	/^class EditFstImpl : public FstImpl<A> {$/;"	c	namespace:fst
fst::EditFstImpl::AddArc	edit-fst.h	/^  void AddArc(StateId s, const Arc &arc) {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::AddState	edit-fst.h	/^  StateId AddState() {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::Arc	edit-fst.h	/^  typedef A Arc;$/;"	t	class:fst::EditFstImpl
fst::EditFstImpl::DeleteArcs	edit-fst.h	/^  void DeleteArcs(StateId s) {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::DeleteArcs	edit-fst.h	/^  void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::DeleteStates	edit-fst.h	/^  void DeleteStates(const vector<StateId>& dstates) {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::DeleteStates	edit-fst.h	/^inline void EditFstImpl<A, WrappedFstT, MutableFstT>::DeleteStates() {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::EditFstImpl	edit-fst.h	/^  EditFstImpl() {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::EditFstImpl	edit-fst.h	/^  EditFstImpl(const EditFstImpl &impl)$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::EditFstImpl	edit-fst.h	/^  explicit EditFstImpl(const Fst<A> &wrapped)$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::Final	edit-fst.h	/^  Weight Final(StateId s) const {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::FinalWeightIterator	edit-fst.h	/^    FinalWeightIterator;$/;"	t	class:fst::EditFstImpl
fst::EditFstImpl::IdMapIterator	edit-fst.h	/^    IdMapIterator;$/;"	t	class:fst::EditFstImpl
fst::EditFstImpl::InheritPropertiesFromWrapped	edit-fst.h	/^  void InheritPropertiesFromWrapped() {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::InitArcIterator	edit-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::InitMutableArcIterator	edit-fst.h	/^  void InitMutableArcIterator(StateId s, MutableArcIteratorData<A> *data) {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::InitStateIterator	edit-fst.h	/^  void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::MutateCheck	edit-fst.h	/^  void MutateCheck() {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::NumArcs	edit-fst.h	/^  size_t NumArcs(StateId s) const {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::NumInputEpsilons	edit-fst.h	/^  size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::NumOutputEpsilons	edit-fst.h	/^  size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::NumStates	edit-fst.h	/^  StateId NumStates() const {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::Read	edit-fst.h	/^EditFstImpl<A, WrappedFstT, MutableFstT>::Read(istream &strm,$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::ReserveArcs	edit-fst.h	/^  void ReserveArcs(StateId s, size_t n) {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::ReserveStates	edit-fst.h	/^  void ReserveStates(StateId s) {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::SetFinal	edit-fst.h	/^  void SetFinal(StateId s, Weight w) {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::SetStart	edit-fst.h	/^  void SetStart(StateId s) {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::Start	edit-fst.h	/^  StateId Start() const {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::StateId	edit-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::EditFstImpl
fst::EditFstImpl::Weight	edit-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::EditFstImpl
fst::EditFstImpl::Write	edit-fst.h	/^  bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::EditFstImpl
fst::EditFstImpl::data_	edit-fst.h	/^  EditFstData<A, WrappedFstT, MutableFstT> *data_;$/;"	m	class:fst::EditFstImpl
fst::EditFstImpl::kFileVersion	edit-fst.h	/^  static const int kFileVersion = 2;$/;"	m	class:fst::EditFstImpl
fst::EditFstImpl::kMinFileVersion	edit-fst.h	/^  static const int kMinFileVersion = 2;$/;"	m	class:fst::EditFstImpl
fst::EditFstImpl::kStaticProperties	edit-fst.h	/^  static const uint64 kStaticProperties = kExpanded | kMutable;$/;"	m	class:fst::EditFstImpl
fst::EditFstImpl::kStaticProperties	edit-fst.h	/^const uint64 EditFstImpl<A, WrappedFstT, MutableFstT>::kStaticProperties;$/;"	m	class:fst::EditFstImpl
fst::EditFstImpl::wrapped_	edit-fst.h	/^  const WrappedFstT *wrapped_;$/;"	m	class:fst::EditFstImpl
fst::EditFstImpl::~EditFstImpl	edit-fst.h	/^  ~EditFstImpl() {$/;"	f	class:fst::EditFstImpl
fst::Encode	encode.h	/^void Encode(MutableFst<A> *fst, EncodeMapper<A>* mapper) {$/;"	f	namespace:fst
fst::EncodeFst	encode.h	/^class EncodeFst : public ArcMapFst<A, A, EncodeMapper<A> > {$/;"	c	namespace:fst
fst::EncodeFst::Arc	encode.h	/^  typedef A Arc;$/;"	t	class:fst::EncodeFst
fst::EncodeFst::C	encode.h	/^  typedef EncodeMapper<A> C;$/;"	t	class:fst::EncodeFst
fst::EncodeFst::Copy	encode.h	/^  virtual EncodeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::EncodeFst
fst::EncodeFst::EncodeFst	encode.h	/^  EncodeFst(const EncodeFst<A> &fst, bool copy = false)$/;"	f	class:fst::EncodeFst
fst::EncodeFst::EncodeFst	encode.h	/^  EncodeFst(const Fst<A> &fst, EncodeMapper<A>* encoder)$/;"	f	class:fst::EncodeFst
fst::EncodeFst::EncodeFst	encode.h	/^  EncodeFst(const Fst<A> &fst, const EncodeMapper<A>& encoder)$/;"	f	class:fst::EncodeFst
fst::EncodeFst::Impl	encode.h	/^  typedef ArcMapFstImpl< A, A, EncodeMapper<A> > Impl;$/;"	t	class:fst::EncodeFst
fst::EncodeMapper	encode.h	/^template <class A> class EncodeMapper {$/;"	c	namespace:fst
fst::EncodeMapper::EncodeMapper	encode.h	/^  EncodeMapper(const EncodeMapper& mapper)$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::EncodeMapper	encode.h	/^  EncodeMapper(const EncodeMapper& mapper, EncodeType type)$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::EncodeMapper	encode.h	/^  EncodeMapper(uint32 flags, EncodeType type)$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::EncodeMapper	encode.h	/^  explicit EncodeMapper(uint32 flags, EncodeType type, EncodeTable<A> *table)$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::FinalAction	encode.h	/^  MapFinalAction FinalAction() const {$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::InputSymbols	encode.h	/^  SymbolTable *InputSymbols() const { return table_->InputSymbols(); }$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::InputSymbolsAction	encode.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_CLEAR_SYMBOLS; }$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::Label	encode.h	/^  typedef typename A::Label  Label;$/;"	t	class:fst::EncodeMapper
fst::EncodeMapper::OutputSymbols	encode.h	/^  SymbolTable *OutputSymbols() const { return table_->OutputSymbols(); }$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::OutputSymbolsAction	encode.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS;}$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::Properties	encode.h	/^  uint64 Properties(uint64 inprops) {$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::Read	encode.h	/^  static EncodeMapper<A> *Read(const string& filename,$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::Read	encode.h	/^  static EncodeMapper<A> *Read(istream &strm,$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::SetInputSymbols	encode.h	/^  void SetInputSymbols(const SymbolTable* syms) {$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::SetOutputSymbols	encode.h	/^  void SetOutputSymbols(const SymbolTable* syms) {$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::Weight	encode.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::EncodeMapper
fst::EncodeMapper::Write	encode.h	/^  bool Write(const string& filename) {$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::Write	encode.h	/^  bool Write(ostream &strm, const string& source) {$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::error_	encode.h	/^  bool error_;$/;"	m	class:fst::EncodeMapper
fst::EncodeMapper::flags	encode.h	/^  const uint32 flags() const { return flags_; }$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::flags_	encode.h	/^  uint32 flags_;$/;"	m	class:fst::EncodeMapper
fst::EncodeMapper::operator ()	encode.h	/^A EncodeMapper<A>::operator()(const A &arc) {$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::table	encode.h	/^  const EncodeTable<A> &table() const { return *table_; }$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::table_	encode.h	/^  EncodeTable<A>* table_;$/;"	m	class:fst::EncodeMapper
fst::EncodeMapper::type	encode.h	/^  const EncodeType type() const { return type_; }$/;"	f	class:fst::EncodeMapper
fst::EncodeMapper::type_	encode.h	/^  EncodeType type_;$/;"	m	class:fst::EncodeMapper
fst::EncodeMapper::~EncodeMapper	encode.h	/^  ~EncodeMapper() {$/;"	f	class:fst::EncodeMapper
fst::EncodeTable	encode.h	/^template <class A>  class EncodeTable {$/;"	c	namespace:fst
fst::EncodeTable::Decode	encode.h	/^  const Tuple* Decode(Label key) const {$/;"	f	class:fst::EncodeTable
fst::EncodeTable::DecrRefCount	encode.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::EncodeTable
fst::EncodeTable::Encode	encode.h	/^  Label Encode(const A &arc) {$/;"	f	class:fst::EncodeTable
fst::EncodeTable::EncodeHash	encode.h	/^                   TupleEqual> EncodeHash;$/;"	t	class:fst::EncodeTable
fst::EncodeTable::EncodeTable	encode.h	/^  explicit EncodeTable(uint32 encode_flags)$/;"	f	class:fst::EncodeTable
fst::EncodeTable::GetLabel	encode.h	/^  Label GetLabel(const A &arc) const {$/;"	f	class:fst::EncodeTable
fst::EncodeTable::IncrRefCount	encode.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::EncodeTable
fst::EncodeTable::InputSymbols	encode.h	/^  SymbolTable *InputSymbols() const { return isymbols_; }$/;"	f	class:fst::EncodeTable
fst::EncodeTable::Label	encode.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::EncodeTable
fst::EncodeTable::OutputSymbols	encode.h	/^  SymbolTable *OutputSymbols() const { return osymbols_; }$/;"	f	class:fst::EncodeTable
fst::EncodeTable::Read	encode.h	/^EncodeTable<A> *EncodeTable<A>::Read(istream &strm, const string &source) {$/;"	f	class:fst::EncodeTable
fst::EncodeTable::RefCount	encode.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::EncodeTable
fst::EncodeTable::SetInputSymbols	encode.h	/^  void SetInputSymbols(const SymbolTable* syms) {$/;"	f	class:fst::EncodeTable
fst::EncodeTable::SetOutputSymbols	encode.h	/^  void SetOutputSymbols(const SymbolTable* syms) {$/;"	f	class:fst::EncodeTable
fst::EncodeTable::Size	encode.h	/^  size_t Size() const { return encode_tuples_.size(); }$/;"	f	class:fst::EncodeTable
fst::EncodeTable::Tuple	encode.h	/^  struct Tuple {$/;"	s	class:fst::EncodeTable
fst::EncodeTable::Tuple::Tuple	encode.h	/^    Tuple() {}$/;"	f	struct:fst::EncodeTable::Tuple
fst::EncodeTable::Tuple::Tuple	encode.h	/^    Tuple(Label ilabel_, Label olabel_, Weight weight_)$/;"	f	struct:fst::EncodeTable::Tuple
fst::EncodeTable::Tuple::Tuple	encode.h	/^    Tuple(const Tuple& tuple)$/;"	f	struct:fst::EncodeTable::Tuple
fst::EncodeTable::Tuple::ilabel	encode.h	/^    Label ilabel;$/;"	m	struct:fst::EncodeTable::Tuple
fst::EncodeTable::Tuple::olabel	encode.h	/^    Label olabel;$/;"	m	struct:fst::EncodeTable::Tuple
fst::EncodeTable::Tuple::weight	encode.h	/^    Weight weight;$/;"	m	struct:fst::EncodeTable::Tuple
fst::EncodeTable::TupleEqual	encode.h	/^  class TupleEqual {$/;"	c	class:fst::EncodeTable
fst::EncodeTable::TupleEqual::operator ()	encode.h	/^    bool operator()(const Tuple* x, const Tuple* y) const {$/;"	f	class:fst::EncodeTable::TupleEqual
fst::EncodeTable::TupleKey	encode.h	/^  class TupleKey {$/;"	c	class:fst::EncodeTable
fst::EncodeTable::TupleKey::TupleKey	encode.h	/^    TupleKey()$/;"	f	class:fst::EncodeTable::TupleKey
fst::EncodeTable::TupleKey::TupleKey	encode.h	/^    TupleKey(const TupleKey& key)$/;"	f	class:fst::EncodeTable::TupleKey
fst::EncodeTable::TupleKey::TupleKey	encode.h	/^    explicit TupleKey(uint32 encode_flags)$/;"	f	class:fst::EncodeTable::TupleKey
fst::EncodeTable::TupleKey::encode_flags_	encode.h	/^    int32 encode_flags_;$/;"	m	class:fst::EncodeTable::TupleKey
fst::EncodeTable::TupleKey::operator ()	encode.h	/^    size_t operator()(const Tuple* x) const {$/;"	f	class:fst::EncodeTable::TupleKey
fst::EncodeTable::Weight	encode.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::EncodeTable
fst::EncodeTable::Write	encode.h	/^bool EncodeTable<A>::Write(ostream &strm, const string &source) const {$/;"	f	class:fst::EncodeTable
fst::EncodeTable::encode_hash_	encode.h	/^  EncodeHash encode_hash_;$/;"	m	class:fst::EncodeTable
fst::EncodeTable::encode_tuples_	encode.h	/^  vector<Tuple*> encode_tuples_;$/;"	m	class:fst::EncodeTable
fst::EncodeTable::flags	encode.h	/^  const uint32 flags() const { return flags_ & kEncodeFlags; }$/;"	f	class:fst::EncodeTable
fst::EncodeTable::flags_	encode.h	/^  uint32 flags_;$/;"	m	class:fst::EncodeTable
fst::EncodeTable::isymbols_	encode.h	/^  SymbolTable *isymbols_;       \/\/ Pre-encoded ilabel symbol table$/;"	m	class:fst::EncodeTable
fst::EncodeTable::osymbols_	encode.h	/^  SymbolTable *osymbols_;       \/\/ Pre-encoded olabel symbol table$/;"	m	class:fst::EncodeTable
fst::EncodeTable::ref_count_	encode.h	/^  RefCounter ref_count_;$/;"	m	class:fst::EncodeTable
fst::EncodeTable::~EncodeTable	encode.h	/^  ~EncodeTable() {$/;"	f	class:fst::EncodeTable
fst::EncodeType	encode.h	/^enum EncodeType { ENCODE = 1, DECODE = 2 };$/;"	g	namespace:fst
fst::EpsNormalize	epsnormalize.h	/^void EpsNormalize(const Fst<Arc> &ifst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
fst::EpsNormalizeType	epsnormalize.h	/^enum EpsNormalizeType {EPS_NORM_INPUT, EPS_NORM_OUTPUT};$/;"	g	namespace:fst
fst::EpsilonArcFilter	arcfilter.h	/^class EpsilonArcFilter {$/;"	c	namespace:fst
fst::EpsilonArcFilter::operator ()	arcfilter.h	/^  bool operator()(const A &arc) const {$/;"	f	class:fst::EpsilonArcFilter
fst::Equal	equal.h	/^bool Equal(const Fst<Arc> &fst1, const Fst<Arc> &fst2, float delta = kDelta) {$/;"	f	namespace:fst
fst::EquivalenceUtil	equivalent.h	/^struct EquivalenceUtil {$/;"	s	namespace:fst
fst::EquivalenceUtil::FindSet	equivalent.h	/^  static MappedId FindSet(UnionFind<MappedId> *sets, MappedId id) {$/;"	f	struct:fst::EquivalenceUtil
fst::EquivalenceUtil::IsFinal	equivalent.h	/^  static bool IsFinal(const Fst<Arc> &fa, MappedId s) {$/;"	f	struct:fst::EquivalenceUtil
fst::EquivalenceUtil::MapState	equivalent.h	/^  static MappedId MapState(StateId s, int32 which_fst) {$/;"	f	struct:fst::EquivalenceUtil
fst::EquivalenceUtil::MappedId	equivalent.h	/^  typedef StateId MappedId;  \/\/ ID for an equivalence class.$/;"	t	struct:fst::EquivalenceUtil
fst::EquivalenceUtil::StateId	equivalent.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::EquivalenceUtil
fst::EquivalenceUtil::UnMapState	equivalent.h	/^  static StateId UnMapState(MappedId id) {$/;"	f	struct:fst::EquivalenceUtil
fst::EquivalenceUtil::Weight	equivalent.h	/^  typedef typename Arc::Weight Weight;$/;"	t	struct:fst::EquivalenceUtil
fst::EquivalenceUtil::kDeadState	equivalent.h	/^  static const MappedId kDeadState = 0;$/;"	m	struct:fst::EquivalenceUtil
fst::EquivalenceUtil::kDeadState	equivalent.h	/^typename EquivalenceUtil<Arc>::MappedId EquivalenceUtil<Arc>::kDeadState;$/;"	m	class:fst::EquivalenceUtil
fst::EquivalenceUtil::kInvalidId	equivalent.h	/^  static const MappedId kInvalidId = -1;$/;"	m	struct:fst::EquivalenceUtil
fst::EquivalenceUtil::kInvalidId	equivalent.h	/^typename EquivalenceUtil<Arc>::MappedId EquivalenceUtil<Arc>::kInvalidId;$/;"	m	class:fst::EquivalenceUtil
fst::Equivalent	equivalent.h	/^bool Equivalent(const Fst<Arc> &fst1,$/;"	f	namespace:fst
fst::ErasableBiTable	bi-table.h	/^class ErasableBiTable {$/;"	c	namespace:fst
fst::ErasableBiTable::ErasableBiTable	bi-table.h	/^  ErasableBiTable() : first_(0) {}$/;"	f	class:fst::ErasableBiTable
fst::ErasableBiTable::Erase	bi-table.h	/^  void Erase(I s) {$/;"	f	class:fst::ErasableBiTable
fst::ErasableBiTable::FindEntry	bi-table.h	/^  const T &FindEntry(I s) const { return id2entry_[s - first_]; }$/;"	f	class:fst::ErasableBiTable
fst::ErasableBiTable::FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::ErasableBiTable
fst::ErasableBiTable::Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::ErasableBiTable
fst::ErasableBiTable::empty_entry_	bi-table.h	/^  const T empty_entry_;$/;"	m	class:fst::ErasableBiTable
fst::ErasableBiTable::entry2id_	bi-table.h	/^  unordered_map<T, I, F> entry2id_;$/;"	m	class:fst::ErasableBiTable
fst::ErasableBiTable::first_	bi-table.h	/^  I first_;        \/\/ I of first element in the deque;$/;"	m	class:fst::ErasableBiTable
fst::ErasableBiTable::id2entry_	bi-table.h	/^  deque<T> id2entry_;$/;"	m	class:fst::ErasableBiTable
fst::ErasableComposeStateTable	state-table.h	/^class ErasableComposeStateTable : public$/;"	c	namespace:fst
fst::ErasableComposeStateTable::Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::ErasableComposeStateTable
fst::ErasableComposeStateTable::ErasableComposeStateTable	state-table.h	/^  ErasableComposeStateTable(const ErasableComposeStateTable<A, F> &table) {}$/;"	f	class:fst::ErasableComposeStateTable
fst::ErasableComposeStateTable::ErasableComposeStateTable	state-table.h	/^  ErasableComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2) {}$/;"	f	class:fst::ErasableComposeStateTable
fst::ErasableComposeStateTable::Error	state-table.h	/^  bool Error() const { return false; }$/;"	f	class:fst::ErasableComposeStateTable
fst::ErasableComposeStateTable::FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ErasableComposeStateTable
fst::ErasableComposeStateTable::StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ErasableComposeStateTable
fst::ErasableComposeStateTable::StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::ErasableComposeStateTable
fst::ErasableStateTable	state-table.h	/^class ErasableStateTable : public ErasableBiTable<typename T::StateId, T, F> {$/;"	c	namespace:fst
fst::ErasableStateTable::ErasableStateTable	state-table.h	/^  ErasableStateTable() : ErasableBiTable<StateId, T, F>() {}$/;"	f	class:fst::ErasableStateTable
fst::ErasableStateTable::FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::ErasableStateTable
fst::ErasableStateTable::StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::ErasableStateTable
fst::ErasableStateTable::StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::ErasableStateTable
fst::ErasableStateTable::Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::ErasableStateTable
fst::ExpandedFst	expanded-fst.h	/^class ExpandedFst : public Fst<A> {$/;"	c	namespace:fst
fst::ExpandedFst::Arc	expanded-fst.h	/^  typedef A Arc;$/;"	t	class:fst::ExpandedFst
fst::ExpandedFst::Read	expanded-fst.h	/^  static ExpandedFst<A> *Read(const string &filename) {$/;"	f	class:fst::ExpandedFst
fst::ExpandedFst::Read	expanded-fst.h	/^  static ExpandedFst<A> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::ExpandedFst
fst::ExpandedFst::StateId	expanded-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ExpandedFst
fst::ExpectationArc	arc.h	/^struct ExpectationArc {$/;"	s	namespace:fst
fst::ExpectationArc::Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::ExpectationArc
fst::ExpectationArc::ExpectationArc	arc.h	/^  ExpectationArc() {}$/;"	f	struct:fst::ExpectationArc
fst::ExpectationArc::ExpectationArc	arc.h	/^  ExpectationArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::ExpectationArc
fst::ExpectationArc::Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::ExpectationArc
fst::ExpectationArc::StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::ExpectationArc
fst::ExpectationArc::Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::ExpectationArc
fst::ExpectationArc::Weight	arc.h	/^  typedef ExpectationWeight<X1, X2> Weight;$/;"	t	struct:fst::ExpectationArc
fst::ExpectationArc::X1	arc.h	/^  typedef typename A::Weight X1;$/;"	t	struct:fst::ExpectationArc
fst::ExpectationArc::ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::ExpectationArc
fst::ExpectationArc::nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::ExpectationArc
fst::ExpectationArc::olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::ExpectationArc
fst::ExpectationArc::weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::ExpectationArc
fst::ExpectationWeight	expectation-weight.h	/^class ExpectationWeight : public PairWeight<X1, X2> {$/;"	c	namespace:fst
fst::ExpectationWeight::ExpectationWeight	expectation-weight.h	/^  ExpectationWeight() : PairWeight<X1, X2>(Zero()) { }$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::ExpectationWeight	expectation-weight.h	/^  ExpectationWeight(const ExpectationWeight<X1, X2>& w)$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::ExpectationWeight	expectation-weight.h	/^  ExpectationWeight(const PairWeight<X1, X2>& w)$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::ExpectationWeight	expectation-weight.h	/^  ExpectationWeight(const X1& x1, const X2& x2)$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::Member	expectation-weight.h	/^  bool Member() const {$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::NoWeight	expectation-weight.h	/^  static const ExpectationWeight<X1, X2> &NoWeight() {$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::One	expectation-weight.h	/^  static const ExpectationWeight<X1, X2> &One() {$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::Properties	expectation-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::Quantize	expectation-weight.h	/^  PairWeight<X1, X2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::Reverse	expectation-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::ReverseWeight	expectation-weight.h	/^                            typename X2::ReverseWeight> ReverseWeight;$/;"	t	class:fst::ExpectationWeight
fst::ExpectationWeight::Type	expectation-weight.h	/^  static const string &Type() {$/;"	f	class:fst::ExpectationWeight
fst::ExpectationWeight::W1	expectation-weight.h	/^  typedef X1 W1;$/;"	t	class:fst::ExpectationWeight
fst::ExpectationWeight::W2	expectation-weight.h	/^  typedef X2 W2;$/;"	t	class:fst::ExpectationWeight
fst::ExpectationWeight::Zero	expectation-weight.h	/^  static const ExpectationWeight<X1, X2> &Zero() {$/;"	f	class:fst::ExpectationWeight
fst::FIFO_QUEUE	queue.h	/^  FIFO_QUEUE = 1,            \/\/ First-in, first-out queue$/;"	e	enum:fst::QueueType
fst::FST_ONCE_INIT	lock.h	/^static const int FST_ONCE_INIT = 1;$/;"	m	namespace:fst
fst::FactorWeightFst	factor-weight.h	/^class FactorWeightFst : public ImplToFst< FactorWeightFstImpl<A, F> > {$/;"	c	namespace:fst
fst::FactorWeightFst::Arc	factor-weight.h	/^  typedef A Arc;$/;"	t	class:fst::FactorWeightFst
fst::FactorWeightFst::Copy	factor-weight.h	/^  virtual FactorWeightFst<A, F> *Copy(bool copy = false) const {$/;"	f	class:fst::FactorWeightFst
fst::FactorWeightFst::FactorWeightFst	factor-weight.h	/^  FactorWeightFst(const FactorWeightFst<A, F> &fst, bool copy)$/;"	f	class:fst::FactorWeightFst
fst::FactorWeightFst::FactorWeightFst	factor-weight.h	/^  FactorWeightFst(const Fst<A> &fst)$/;"	f	class:fst::FactorWeightFst
fst::FactorWeightFst::FactorWeightFst	factor-weight.h	/^  FactorWeightFst(const Fst<A> &fst,  const FactorWeightOptions<A> &opts)$/;"	f	class:fst::FactorWeightFst
fst::FactorWeightFst::GetImpl	factor-weight.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::FactorWeightFst
fst::FactorWeightFst::Impl	factor-weight.h	/^  typedef FactorWeightFstImpl<A, F> Impl;$/;"	t	class:fst::FactorWeightFst
fst::FactorWeightFst::InitArcIterator	factor-weight.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::FactorWeightFst
fst::FactorWeightFst::InitStateIterator	factor-weight.h	/^void FactorWeightFst<A, F>::InitStateIterator(StateIteratorData<A> *data) const$/;"	f	class:fst::FactorWeightFst
fst::FactorWeightFst::State	factor-weight.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::FactorWeightFst
fst::FactorWeightFst::StateId	factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FactorWeightFst
fst::FactorWeightFst::Weight	factor-weight.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FactorWeightFst
fst::FactorWeightFstImpl	factor-weight.h	/^class FactorWeightFstImpl$/;"	c	namespace:fst
fst::FactorWeightFstImpl::Arc	factor-weight.h	/^  typedef A Arc;$/;"	t	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::Element	factor-weight.h	/^  struct Element {$/;"	s	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::Element::Element	factor-weight.h	/^    Element() {}$/;"	f	struct:fst::FactorWeightFstImpl::Element
fst::FactorWeightFstImpl::Element::Element	factor-weight.h	/^    Element(StateId s, Weight w) : state(s), weight(w) {}$/;"	f	struct:fst::FactorWeightFstImpl::Element
fst::FactorWeightFstImpl::Element::state	factor-weight.h	/^    StateId state;     \/\/ Input state Id$/;"	m	struct:fst::FactorWeightFstImpl::Element
fst::FactorWeightFstImpl::Element::weight	factor-weight.h	/^    Weight weight;     \/\/ Residual weight$/;"	m	struct:fst::FactorWeightFstImpl::Element
fst::FactorWeightFstImpl::ElementEqual	factor-weight.h	/^  class ElementEqual {$/;"	c	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::ElementEqual::operator ()	factor-weight.h	/^    bool operator()(const Element &x, const Element &y) const {$/;"	f	class:fst::FactorWeightFstImpl::ElementEqual
fst::FactorWeightFstImpl::ElementKey	factor-weight.h	/^  class ElementKey {$/;"	c	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::ElementKey::operator ()	factor-weight.h	/^    size_t operator()(const Element &x) const {$/;"	f	class:fst::FactorWeightFstImpl::ElementKey
fst::FactorWeightFstImpl::ElementMap	factor-weight.h	/^  typedef unordered_map<Element, StateId, ElementKey, ElementEqual> ElementMap;$/;"	t	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::Expand	factor-weight.h	/^  void Expand(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::FactorIterator	factor-weight.h	/^  typedef F FactorIterator;$/;"	t	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::FactorWeightFstImpl	factor-weight.h	/^  FactorWeightFstImpl(const FactorWeightFstImpl<A, F> &impl)$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::FactorWeightFstImpl	factor-weight.h	/^  FactorWeightFstImpl(const Fst<A> &fst, const FactorWeightOptions<A> &opts)$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::Final	factor-weight.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::FindState	factor-weight.h	/^  StateId FindState(const Element &e) {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::InitArcIterator	factor-weight.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::Label	factor-weight.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::NumArcs	factor-weight.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::NumInputEpsilons	factor-weight.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::NumOutputEpsilons	factor-weight.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::Properties	factor-weight.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::Properties	factor-weight.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::Start	factor-weight.h	/^  StateId Start() {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::StateId	factor-weight.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::Weight	factor-weight.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::delta_	factor-weight.h	/^  float delta_;$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::element_map_	factor-weight.h	/^  ElementMap element_map_;    \/\/ mapping Elements to Fst state$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::elements_	factor-weight.h	/^  vector<Element> elements_;  \/\/ mapping Fst state to Elements$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::final_ilabel_	factor-weight.h	/^  Label final_ilabel_;        \/\/ ilabel of arc created when factoring final w's$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::final_olabel_	factor-weight.h	/^  Label final_olabel_;        \/\/ olabel of arc created when factoring final w's$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::fst_	factor-weight.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::kPrime	factor-weight.h	/^  static const size_t kPrime = 7853;$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::kPrime	factor-weight.h	/^template <class A, class F> const size_t FactorWeightFstImpl<A, F>::kPrime;$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::mode_	factor-weight.h	/^  uint32 mode_;               \/\/ factoring arc and\/or final weights$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::unfactored_	factor-weight.h	/^  vector<StateId> unfactored_;$/;"	m	class:fst::FactorWeightFstImpl
fst::FactorWeightFstImpl::~FactorWeightFstImpl	factor-weight.h	/^  ~FactorWeightFstImpl() {$/;"	f	class:fst::FactorWeightFstImpl
fst::FactorWeightOptions	factor-weight.h	/^struct FactorWeightOptions : CacheOptions {$/;"	s	namespace:fst
fst::FactorWeightOptions::FactorWeightOptions	factor-weight.h	/^  FactorWeightOptions(const CacheOptions &opts, float d,$/;"	f	struct:fst::FactorWeightOptions
fst::FactorWeightOptions::FactorWeightOptions	factor-weight.h	/^  FactorWeightOptions(uint32 m = kFactorArcWeights | kFactorFinalWeights,$/;"	f	struct:fst::FactorWeightOptions
fst::FactorWeightOptions::FactorWeightOptions	factor-weight.h	/^  explicit FactorWeightOptions($/;"	f	struct:fst::FactorWeightOptions
fst::FactorWeightOptions::Label	factor-weight.h	/^  typedef typename Arc::Label Label;$/;"	t	struct:fst::FactorWeightOptions
fst::FactorWeightOptions::delta	factor-weight.h	/^  float delta;$/;"	m	struct:fst::FactorWeightOptions
fst::FactorWeightOptions::final_ilabel	factor-weight.h	/^  Label final_ilabel;  \/\/ input label of arc created when factoring final w's$/;"	m	struct:fst::FactorWeightOptions
fst::FactorWeightOptions::final_olabel	factor-weight.h	/^  Label final_olabel;  \/\/ output label of arc created when factoring final w's$/;"	m	struct:fst::FactorWeightOptions
fst::FactorWeightOptions::mode	factor-weight.h	/^  uint32 mode;         \/\/ factor arc weights and\/or final weights$/;"	m	struct:fst::FactorWeightOptions
fst::FastLogAccumulator	accumulator.h	/^class FastLogAccumulator {$/;"	c	namespace:fst
fst::FastLogAccumulator::Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::FastLogAccumulator
fst::FastLogAccumulator::Error	accumulator.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::FastLogAccumulator	accumulator.h	/^  FastLogAccumulator(const FastLogAccumulator<A> &acc)$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::FastLogAccumulator	accumulator.h	/^  explicit FastLogAccumulator(ssize_t arc_limit = 20, ssize_t arc_period = 10)$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::Init	accumulator.h	/^  void Init(const F &fst, bool copy = false) {$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::LogMinus	accumulator.h	/^  Weight LogMinus(double f1, double f2) {$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::LogMinusExp	accumulator.h	/^  double LogMinusExp(double x) {$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::LogPlus	accumulator.h	/^  Weight LogPlus(Weight w, Weight v) {$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::LogPlus	accumulator.h	/^  double LogPlus(double f1, Weight v) {$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::LogPosExp	accumulator.h	/^  double LogPosExp(double x) {$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::SetState	accumulator.h	/^  void SetState(StateId s) {$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FastLogAccumulator
fst::FastLogAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, ArcIterator *aiter, ssize_t begin,$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulator::Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FastLogAccumulator
fst::FastLogAccumulator::arc_limit_	accumulator.h	/^  ssize_t arc_limit_;     \/\/ Minimum # of arcs to pre-compute state$/;"	m	class:fst::FastLogAccumulator
fst::FastLogAccumulator::arc_period_	accumulator.h	/^  ssize_t arc_period_;    \/\/ Save cumulative weights per 'arc_period_'.$/;"	m	class:fst::FastLogAccumulator
fst::FastLogAccumulator::data_	accumulator.h	/^  FastLogAccumulatorData *data_;$/;"	m	class:fst::FastLogAccumulator
fst::FastLogAccumulator::error_	accumulator.h	/^  bool error_;$/;"	m	class:fst::FastLogAccumulator
fst::FastLogAccumulator::init_	accumulator.h	/^  bool init_;             \/\/ Cumulative weights initialized?$/;"	m	class:fst::FastLogAccumulator
fst::FastLogAccumulator::state_weights_	accumulator.h	/^  double *state_weights_;$/;"	m	class:fst::FastLogAccumulator
fst::FastLogAccumulator::to_log_weight_	accumulator.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::FastLogAccumulator
fst::FastLogAccumulator::to_weight_	accumulator.h	/^  WeightConvert<Log64Weight, Weight> to_weight_;$/;"	m	class:fst::FastLogAccumulator
fst::FastLogAccumulator::~FastLogAccumulator	accumulator.h	/^  ~FastLogAccumulator() {$/;"	f	class:fst::FastLogAccumulator
fst::FastLogAccumulatorData	accumulator.h	/^class FastLogAccumulatorData {$/;"	c	namespace:fst
fst::FastLogAccumulatorData::DecrRefCount	accumulator.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::FastLogAccumulatorData
fst::FastLogAccumulatorData::FastLogAccumulatorData	accumulator.h	/^  FastLogAccumulatorData() {}$/;"	f	class:fst::FastLogAccumulatorData
fst::FastLogAccumulatorData::IncrRefCount	accumulator.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::FastLogAccumulatorData
fst::FastLogAccumulatorData::RefCount	accumulator.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::FastLogAccumulatorData
fst::FastLogAccumulatorData::WeightEnd	accumulator.h	/^  double *WeightEnd() { return &(weights_[weights_.size() - 1]); };$/;"	f	class:fst::FastLogAccumulatorData
fst::FastLogAccumulatorData::WeightPositions	accumulator.h	/^  vector<ssize_t> *WeightPositions() { return &weight_positions_; }$/;"	f	class:fst::FastLogAccumulatorData
fst::FastLogAccumulatorData::Weights	accumulator.h	/^  vector<double> *Weights() { return &weights_; }$/;"	f	class:fst::FastLogAccumulatorData
fst::FastLogAccumulatorData::ref_count_	accumulator.h	/^  RefCounter ref_count_;                  \/\/ Reference count.$/;"	m	class:fst::FastLogAccumulatorData
fst::FastLogAccumulatorData::weight_positions_	accumulator.h	/^  vector<ssize_t> weight_positions_;$/;"	m	class:fst::FastLogAccumulatorData
fst::FastLogAccumulatorData::weights_	accumulator.h	/^  vector<double> weights_;$/;"	m	class:fst::FastLogAccumulatorData
fst::FastLogProbArcSelector	randgen.h	/^class FastLogProbArcSelector : public LogProbArcSelector<A> {$/;"	c	namespace:fst
fst::FastLogProbArcSelector::FastLogProbArcSelector	randgen.h	/^  FastLogProbArcSelector(int seed = time(0))$/;"	f	class:fst::FastLogProbArcSelector
fst::FastLogProbArcSelector::Seed	randgen.h	/^  int Seed() const { return seed_; }$/;"	f	class:fst::FastLogProbArcSelector
fst::FastLogProbArcSelector::StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FastLogProbArcSelector
fst::FastLogProbArcSelector::Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FastLogProbArcSelector
fst::FastLogProbArcSelector::operator ()	randgen.h	/^  size_t operator()(const Fst<A> &fst, StateId s,$/;"	f	class:fst::FastLogProbArcSelector
fst::FastLogProbArcSelector::seed_	randgen.h	/^  int seed_;$/;"	m	class:fst::FastLogProbArcSelector
fst::FastLogProbArcSelector::to_log_weight_	randgen.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::FastLogProbArcSelector
fst::FifoQueue	queue.h	/^class FifoQueue : public QueueBase<S>, public deque<S> {$/;"	c	namespace:fst
fst::FifoQueue::Clear	queue.h	/^  void Clear() { clear(); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Dequeue	queue.h	/^  void Dequeue() { pop_back(); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Empty	queue.h	/^  bool Empty() const { return empty(); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Enqueue	queue.h	/^  void Enqueue(StateId s) { push_front(s); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::FifoQueue	queue.h	/^  FifoQueue() : QueueBase<S>(FIFO_QUEUE) {}$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Head	queue.h	/^  StateId Head() const { return back(); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::FifoQueue
fst::FifoQueue::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::FifoQueue
fst::FifoQueue::Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::FifoQueue
fst::FifoQueue::Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::FifoQueue
fst::FloatLimits	float-weight.h	/^class FloatLimits {$/;"	c	namespace:fst
fst::FloatLimits::NegInfinity	float-weight.h	/^  static const T NegInfinity() {$/;"	f	class:fst::FloatLimits
fst::FloatLimits::NumberBad	float-weight.h	/^  static const T NumberBad() {$/;"	f	class:fst::FloatLimits
fst::FloatLimits::PosInfinity	float-weight.h	/^  static const T PosInfinity() {$/;"	f	class:fst::FloatLimits
fst::FloatWeight	float-weight.h	/^typedef FloatWeightTpl<float> FloatWeight;$/;"	t	namespace:fst
fst::FloatWeight	fst-decl.h	/^typedef FloatWeightTpl<float> FloatWeight;$/;"	t	namespace:fst
fst::FloatWeightTpl	float-weight.h	/^class FloatWeightTpl {$/;"	c	namespace:fst
fst::FloatWeightTpl::FloatWeightTpl	float-weight.h	/^  FloatWeightTpl() {}$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::FloatWeightTpl	float-weight.h	/^  FloatWeightTpl(T f) : value_(f) {}$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::FloatWeightTpl	float-weight.h	/^  FloatWeightTpl(const FloatWeightTpl<T> &w) : value_(w.value_) {}$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::GetPrecisionString	float-weight.h	/^  inline static string GetPrecisionString() {$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::Hash	float-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::Read	float-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::SetValue	float-weight.h	/^  void SetValue(const T &f) { value_ = f; }$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::Value	float-weight.h	/^  const T &Value() const { return value_; }$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::Write	float-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::operator =	float-weight.h	/^  FloatWeightTpl<T> &operator=(const FloatWeightTpl<T> &w) {$/;"	f	class:fst::FloatWeightTpl
fst::FloatWeightTpl::value_	float-weight.h	/^  T value_;$/;"	m	class:fst::FloatWeightTpl
fst::FromGallicMapper	arc-map.h	/^struct FromGallicMapper {$/;"	s	namespace:fst
fst::FromGallicMapper::AW	arc-map.h	/^  typedef typename A::Weight AW;$/;"	t	struct:fst::FromGallicMapper
fst::FromGallicMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_ALLOW_SUPERFINAL; }$/;"	f	struct:fst::FromGallicMapper
fst::FromGallicMapper::FromArc	arc-map.h	/^  typedef GallicArc<A, S> FromArc;$/;"	t	struct:fst::FromGallicMapper
fst::FromGallicMapper::FromGallicMapper	arc-map.h	/^  FromGallicMapper(Label superfinal_label = 0)$/;"	f	struct:fst::FromGallicMapper
fst::FromGallicMapper::GW	arc-map.h	/^  typedef typename GallicArc<A, S>::Weight GW;$/;"	t	struct:fst::FromGallicMapper
fst::FromGallicMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::FromGallicMapper
fst::FromGallicMapper::Label	arc-map.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::FromGallicMapper
fst::FromGallicMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS;}$/;"	f	struct:fst::FromGallicMapper
fst::FromGallicMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 inprops) const {$/;"	f	struct:fst::FromGallicMapper
fst::FromGallicMapper::SW	arc-map.h	/^  typedef StringWeight<Label, S> SW;$/;"	t	struct:fst::FromGallicMapper
fst::FromGallicMapper::ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::FromGallicMapper
fst::FromGallicMapper::error_	arc-map.h	/^  mutable bool error_;$/;"	m	struct:fst::FromGallicMapper
fst::FromGallicMapper::operator ()	arc-map.h	/^  A operator()(const FromArc &arc) const {$/;"	f	struct:fst::FromGallicMapper
fst::FromGallicMapper::superfinal_label_	arc-map.h	/^  Label superfinal_label_;$/;"	m	struct:fst::FromGallicMapper
fst::Fst	fst.h	/^class Fst {$/;"	c	namespace:fst
fst::Fst::Arc	fst.h	/^  typedef A Arc;$/;"	t	class:fst::Fst
fst::Fst::InitMatcher	fst.h	/^MatcherBase<A> *Fst<A>::InitMatcher(MatchType match_type) const {$/;"	f	class:fst::Fst
fst::Fst::Read	fst.h	/^  static Fst<A> *Read(const string &filename) {$/;"	f	class:fst::Fst
fst::Fst::Read	fst.h	/^  static Fst<A> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::Fst
fst::Fst::StateId	fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::Fst
fst::Fst::Weight	fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::Fst
fst::Fst::Write	fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::Fst
fst::Fst::Write	fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::Fst
fst::Fst::WriteFile	fst.h	/^  bool WriteFile(const string &filename) const {$/;"	f	class:fst::Fst
fst::Fst::~Fst	fst.h	/^  virtual ~Fst() {}$/;"	f	class:fst::Fst
fst::FstHeader	fst.h	/^class FstHeader {$/;"	c	namespace:fst
fst::FstHeader::ArcType	fst.h	/^  const string &ArcType() const { return arctype_; }$/;"	f	class:fst::FstHeader
fst::FstHeader::Flags	fst.h	/^  } Flags;$/;"	m	class:fst::FstHeader	typeref:enum:fst::FstHeader::__anon1
fst::FstHeader::FstHeader	fst.h	/^  FstHeader() : version_(0), flags_(0), properties_(0), start_(-1),$/;"	f	class:fst::FstHeader
fst::FstHeader::FstType	fst.h	/^  const string &FstType() const { return fsttype_; }$/;"	f	class:fst::FstHeader
fst::FstHeader::GetFlags	fst.h	/^  int32 GetFlags() const { return flags_; }$/;"	f	class:fst::FstHeader
fst::FstHeader::HAS_ISYMBOLS	fst.h	/^    HAS_ISYMBOLS = 0x1,          \/\/ Has input symbol table$/;"	e	enum:fst::FstHeader::__anon1
fst::FstHeader::HAS_OSYMBOLS	fst.h	/^    HAS_OSYMBOLS = 0x2,          \/\/ Has output symbol table$/;"	e	enum:fst::FstHeader::__anon1
fst::FstHeader::IS_ALIGNED	fst.h	/^    IS_ALIGNED   = 0x4,          \/\/ Memory-aligned (where appropriate)$/;"	e	enum:fst::FstHeader::__anon1
fst::FstHeader::NumArcs	fst.h	/^  int64 NumArcs() const { return numarcs_; }$/;"	f	class:fst::FstHeader
fst::FstHeader::NumStates	fst.h	/^  int64 NumStates() const { return numstates_; }$/;"	f	class:fst::FstHeader
fst::FstHeader::Properties	fst.h	/^  uint64 Properties() const { return properties_; }$/;"	f	class:fst::FstHeader
fst::FstHeader::SetArcType	fst.h	/^  void SetArcType(const string& type) { arctype_ = type; }$/;"	f	class:fst::FstHeader
fst::FstHeader::SetFlags	fst.h	/^  void SetFlags(int32 flags) { flags_ = flags; }$/;"	f	class:fst::FstHeader
fst::FstHeader::SetFstType	fst.h	/^  void SetFstType(const string& type) { fsttype_ = type; }$/;"	f	class:fst::FstHeader
fst::FstHeader::SetNumArcs	fst.h	/^  void SetNumArcs(int64 numarcs) { numarcs_ = numarcs; }$/;"	f	class:fst::FstHeader
fst::FstHeader::SetNumStates	fst.h	/^  void SetNumStates(int64 numstates) { numstates_ = numstates; }$/;"	f	class:fst::FstHeader
fst::FstHeader::SetProperties	fst.h	/^  void SetProperties(uint64 properties) { properties_ = properties; }$/;"	f	class:fst::FstHeader
fst::FstHeader::SetStart	fst.h	/^  void SetStart(int64 start) { start_ = start; }$/;"	f	class:fst::FstHeader
fst::FstHeader::SetVersion	fst.h	/^  void SetVersion(int32 version) { version_ = version; }$/;"	f	class:fst::FstHeader
fst::FstHeader::Start	fst.h	/^  int64 Start() const { return start_; }$/;"	f	class:fst::FstHeader
fst::FstHeader::Version	fst.h	/^  int32 Version() const { return version_; }$/;"	f	class:fst::FstHeader
fst::FstHeader::arctype_	fst.h	/^  string arctype_;                   \/\/ E.g. "standard"$/;"	m	class:fst::FstHeader
fst::FstHeader::flags_	fst.h	/^  int32 flags_;                      \/\/ File format bits$/;"	m	class:fst::FstHeader
fst::FstHeader::fsttype_	fst.h	/^  string fsttype_;                   \/\/ E.g. "vector"$/;"	m	class:fst::FstHeader
fst::FstHeader::numarcs_	fst.h	/^  int64 numarcs_;                    \/\/ # of arcs$/;"	m	class:fst::FstHeader
fst::FstHeader::numstates_	fst.h	/^  int64 numstates_;                  \/\/ # of states$/;"	m	class:fst::FstHeader
fst::FstHeader::properties_	fst.h	/^  uint64 properties_;                \/\/ FST property bits$/;"	m	class:fst::FstHeader
fst::FstHeader::start_	fst.h	/^  int64 start_;                      \/\/ Start state$/;"	m	class:fst::FstHeader
fst::FstHeader::version_	fst.h	/^  int32 version_;                    \/\/ Type version #$/;"	m	class:fst::FstHeader
fst::FstImpl	fst.h	/^template <class A> class FstImpl {$/;"	c	namespace:fst
fst::FstImpl::DecrRefCount	fst.h	/^  int DecrRefCount() {$/;"	f	class:fst::FstImpl
fst::FstImpl::FstImpl	fst.h	/^  FstImpl()$/;"	f	class:fst::FstImpl
fst::FstImpl::FstImpl	fst.h	/^  FstImpl(const FstImpl<A> &impl)$/;"	f	class:fst::FstImpl
fst::FstImpl::IncrRefCount	fst.h	/^  int IncrRefCount() {$/;"	f	class:fst::FstImpl
fst::FstImpl::InputSymbols	fst.h	/^  SymbolTable* InputSymbols() { return isymbols_; }$/;"	f	class:fst::FstImpl
fst::FstImpl::InputSymbols	fst.h	/^  const SymbolTable* InputSymbols() const { return isymbols_; }$/;"	f	class:fst::FstImpl
fst::FstImpl::OutputSymbols	fst.h	/^  SymbolTable* OutputSymbols() { return osymbols_; }$/;"	f	class:fst::FstImpl
fst::FstImpl::OutputSymbols	fst.h	/^  const SymbolTable* OutputSymbols() const { return osymbols_; }$/;"	f	class:fst::FstImpl
fst::FstImpl::Properties	fst.h	/^  virtual uint64 Properties() const { return properties_; }$/;"	f	class:fst::FstImpl
fst::FstImpl::Properties	fst.h	/^  virtual uint64 Properties(uint64 mask) const { return properties_ & mask; }$/;"	f	class:fst::FstImpl
fst::FstImpl::ReadHeader	fst.h	/^bool FstImpl<A>::ReadHeader(istream &strm, const FstReadOptions& opts,$/;"	f	class:fst::FstImpl
fst::FstImpl::RefCount	fst.h	/^  int RefCount() const {$/;"	f	class:fst::FstImpl
fst::FstImpl::SetInputSymbols	fst.h	/^  void SetInputSymbols(const SymbolTable* isyms) {$/;"	f	class:fst::FstImpl
fst::FstImpl::SetOutputSymbols	fst.h	/^  void SetOutputSymbols(const SymbolTable* osyms) {$/;"	f	class:fst::FstImpl
fst::FstImpl::SetProperties	fst.h	/^  void SetProperties(uint64 props) {$/;"	f	class:fst::FstImpl
fst::FstImpl::SetProperties	fst.h	/^  void SetProperties(uint64 props, uint64 mask) const {$/;"	f	class:fst::FstImpl
fst::FstImpl::SetProperties	fst.h	/^  void SetProperties(uint64 props, uint64 mask) {$/;"	f	class:fst::FstImpl
fst::FstImpl::SetType	fst.h	/^  void SetType(const string &type) { type_ = type; }$/;"	f	class:fst::FstImpl
fst::FstImpl::StateId	fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::FstImpl
fst::FstImpl::Type	fst.h	/^  const string& Type() const { return type_; }$/;"	f	class:fst::FstImpl
fst::FstImpl::UpdateFstHeader	fst.h	/^  static bool UpdateFstHeader(const Fst<A> &fst, ostream &strm,$/;"	f	class:fst::FstImpl
fst::FstImpl::Weight	fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::FstImpl
fst::FstImpl::WriteFstHeader	fst.h	/^  static void WriteFstHeader(const Fst<A> &fst, ostream &strm,$/;"	f	class:fst::FstImpl
fst::FstImpl::WriteHeader	fst.h	/^  void WriteHeader(ostream &strm, const FstWriteOptions& opts,$/;"	f	class:fst::FstImpl
fst::FstImpl::isymbols_	fst.h	/^  SymbolTable *isymbols_;       \/\/ Ilabel symbol table$/;"	m	class:fst::FstImpl
fst::FstImpl::osymbols_	fst.h	/^  SymbolTable *osymbols_;       \/\/ Olabel symbol table$/;"	m	class:fst::FstImpl
fst::FstImpl::properties_	fst.h	/^  mutable uint64 properties_;           \/\/ Property bits$/;"	m	class:fst::FstImpl
fst::FstImpl::ref_count_	fst.h	/^  RefCounter ref_count_;        \/\/ Reference count$/;"	m	class:fst::FstImpl
fst::FstImpl::type_	fst.h	/^  string type_;                 \/\/ Unique name of Fst class$/;"	m	class:fst::FstImpl
fst::FstImpl::~FstImpl	fst.h	/^  virtual ~FstImpl() {$/;"	f	class:fst::FstImpl
fst::FstOnceInit	lock.h	/^inline int FstOnceInit(FstOnceType *once, void (*init)(void)) {$/;"	f	namespace:fst
fst::FstOnceType	lock.h	/^typedef int FstOnceType;$/;"	t	namespace:fst
fst::FstReadOptions	fst.h	/^struct FstReadOptions {$/;"	s	namespace:fst
fst::FstReadOptions::FstReadOptions	fst.h	/^  explicit FstReadOptions(const string& src = "<unspecfied>",$/;"	f	struct:fst::FstReadOptions
fst::FstReadOptions::FstReadOptions	fst.h	/^  explicit FstReadOptions(const string& src,$/;"	f	struct:fst::FstReadOptions
fst::FstReadOptions::header	fst.h	/^  const FstHeader *header;      \/\/ Pointer to Fst header. If non-zero, use$/;"	m	struct:fst::FstReadOptions
fst::FstReadOptions::isymbols	fst.h	/^  const SymbolTable* isymbols;  \/\/ Pointer to input symbols. If non-zero, use$/;"	m	struct:fst::FstReadOptions
fst::FstReadOptions::osymbols	fst.h	/^  const SymbolTable* osymbols;  \/\/ Pointer to output symbols. If non-zero, use$/;"	m	struct:fst::FstReadOptions
fst::FstReadOptions::source	fst.h	/^  string source;                \/\/ Where you're reading from$/;"	m	struct:fst::FstReadOptions
fst::FstRegister	register.h	/^class FstRegister : public GenericRegister<string, FstRegisterEntry<A>,$/;"	c	namespace:fst
fst::FstRegister::ConvertKeyToSoFilename	register.h	/^  virtual string ConvertKeyToSoFilename(const string& key) const {$/;"	f	class:fst::FstRegister
fst::FstRegister::Converter	register.h	/^  typedef typename FstRegisterEntry<A>::Converter Converter;$/;"	t	class:fst::FstRegister
fst::FstRegister::GetConverter	register.h	/^  const Converter GetConverter(const string &type) const {$/;"	f	class:fst::FstRegister
fst::FstRegister::GetReader	register.h	/^  const Reader GetReader(const string &type) const {$/;"	f	class:fst::FstRegister
fst::FstRegister::Reader	register.h	/^  typedef typename FstRegisterEntry<A>::Reader Reader;$/;"	t	class:fst::FstRegister
fst::FstRegisterEntry	register.h	/^struct FstRegisterEntry {$/;"	s	namespace:fst
fst::FstRegisterEntry::Converter	register.h	/^  typedef Fst<A> *(*Converter)(const Fst<A> &fst);$/;"	t	struct:fst::FstRegisterEntry
fst::FstRegisterEntry::FstRegisterEntry	register.h	/^  FstRegisterEntry() : reader(0), converter(0) {}$/;"	f	struct:fst::FstRegisterEntry
fst::FstRegisterEntry::FstRegisterEntry	register.h	/^  FstRegisterEntry(Reader r, Converter c) : reader(r), converter(c) { }$/;"	f	struct:fst::FstRegisterEntry
fst::FstRegisterEntry::Reader	register.h	/^  typedef Fst<A> *(*Reader)(istream &strm, const FstReadOptions &opts);$/;"	t	struct:fst::FstRegisterEntry
fst::FstRegisterEntry::converter	register.h	/^  Converter converter;$/;"	m	struct:fst::FstRegisterEntry
fst::FstRegisterEntry::reader	register.h	/^  Reader reader;$/;"	m	struct:fst::FstRegisterEntry
fst::FstRegisterer	register.h	/^class FstRegisterer$/;"	c	namespace:fst
fst::FstRegisterer::Arc	register.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::FstRegisterer
fst::FstRegisterer::BuildEntry	register.h	/^  Entry BuildEntry() {$/;"	f	class:fst::FstRegisterer
fst::FstRegisterer::Convert	register.h	/^  static Fst<Arc> *Convert(const Fst<Arc> &fst) { return new F(fst); }$/;"	f	class:fst::FstRegisterer
fst::FstRegisterer::Entry	register.h	/^  typedef typename FstRegister<Arc>::Entry Entry;$/;"	t	class:fst::FstRegisterer
fst::FstRegisterer::FstRegisterer	register.h	/^  FstRegisterer() :$/;"	f	class:fst::FstRegisterer
fst::FstRegisterer::Reader	register.h	/^  typedef typename FstRegister<Arc>::Reader Reader;$/;"	t	class:fst::FstRegisterer
fst::FstToString	fst.h	/^void FstToString(const Fst<A> &fst, string *result) {$/;"	f	namespace:fst
fst::FstWriteOptions	fst.h	/^struct FstWriteOptions {$/;"	s	namespace:fst
fst::FstWriteOptions::FstWriteOptions	fst.h	/^  explicit FstWriteOptions(const string& src = "<unspecifed>",$/;"	f	struct:fst::FstWriteOptions
fst::FstWriteOptions::align	fst.h	/^  bool align;                    \/\/ Write data aligned where appropriate;$/;"	m	struct:fst::FstWriteOptions
fst::FstWriteOptions::source	fst.h	/^  string source;                 \/\/ Where you're writing to$/;"	m	struct:fst::FstWriteOptions
fst::FstWriteOptions::write_header	fst.h	/^  bool write_header;             \/\/ Write the header?$/;"	m	struct:fst::FstWriteOptions
fst::FstWriteOptions::write_isymbols	fst.h	/^  bool write_isymbols;           \/\/ Write input symbols?$/;"	m	struct:fst::FstWriteOptions
fst::FstWriteOptions::write_osymbols	fst.h	/^  bool write_osymbols;           \/\/ Write output symbols?$/;"	m	struct:fst::FstWriteOptions
fst::GallicArc	arc.h	/^struct GallicArc {$/;"	s	namespace:fst
fst::GallicArc::Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::GallicArc
fst::GallicArc::GallicArc	arc.h	/^  GallicArc() {}$/;"	f	struct:fst::GallicArc
fst::GallicArc::GallicArc	arc.h	/^  GallicArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::GallicArc
fst::GallicArc::GallicArc	arc.h	/^  GallicArc(const A &arc)$/;"	f	struct:fst::GallicArc
fst::GallicArc::Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::GallicArc
fst::GallicArc::StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::GallicArc
fst::GallicArc::Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::GallicArc
fst::GallicArc::Weight	arc.h	/^  typedef GallicWeight<Label, typename A::Weight, S> Weight;$/;"	t	struct:fst::GallicArc
fst::GallicArc::ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::GallicArc
fst::GallicArc::nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::GallicArc
fst::GallicArc::olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::GallicArc
fst::GallicArc::weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::GallicArc
fst::GallicCommonDivisor	determinize.h	/^class GallicCommonDivisor {$/;"	c	namespace:fst
fst::GallicCommonDivisor::Weight	determinize.h	/^  typedef GallicWeight<L, W, S> Weight;$/;"	t	class:fst::GallicCommonDivisor
fst::GallicCommonDivisor::label_common_divisor_	determinize.h	/^  LabelCommonDivisor<L, S> label_common_divisor_;$/;"	m	class:fst::GallicCommonDivisor
fst::GallicCommonDivisor::operator ()	determinize.h	/^  Weight operator()(const Weight &w1, const Weight &w2) const {$/;"	f	class:fst::GallicCommonDivisor
fst::GallicCommonDivisor::weight_common_divisor_	determinize.h	/^  D weight_common_divisor_;$/;"	m	class:fst::GallicCommonDivisor
fst::GallicFactor	factor-weight.h	/^class GallicFactor {$/;"	c	namespace:fst
fst::GallicFactor::Done	factor-weight.h	/^  bool Done() const { return done_; }$/;"	f	class:fst::GallicFactor
fst::GallicFactor::GallicFactor	factor-weight.h	/^  GallicFactor(const GallicWeight<L, W, S> &w)$/;"	f	class:fst::GallicFactor
fst::GallicFactor::Next	factor-weight.h	/^  void Next() { done_ = true; }$/;"	f	class:fst::GallicFactor
fst::GallicFactor::Reset	factor-weight.h	/^  void Reset() { done_ = weight_.Value1().Size() <= 1; }$/;"	f	class:fst::GallicFactor
fst::GallicFactor::Value	factor-weight.h	/^  pair< GallicWeight<L, W, S>, GallicWeight<L, W, S> > Value() const {$/;"	f	class:fst::GallicFactor
fst::GallicFactor::done_	factor-weight.h	/^  bool done_;$/;"	m	class:fst::GallicFactor
fst::GallicFactor::weight_	factor-weight.h	/^  GallicWeight<L, W, S> weight_;$/;"	m	class:fst::GallicFactor
fst::GallicToNewSymbolsMapper	arc-map.h	/^struct GallicToNewSymbolsMapper {$/;"	s	namespace:fst
fst::GallicToNewSymbolsMapper::AW	arc-map.h	/^  typedef typename A::Weight AW;$/;"	t	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_ALLOW_SUPERFINAL; }$/;"	f	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::FromArc	arc-map.h	/^  typedef GallicArc<A, S> FromArc;$/;"	t	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::GW	arc-map.h	/^  typedef typename GallicArc<A, S>::Weight GW;$/;"	t	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::GallicToNewSymbolsMapper	arc-map.h	/^  GallicToNewSymbolsMapper(MutableFst<ToArc> *fst)$/;"	f	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::Label	arc-map.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::Map	arc-map.h	/^  typedef unordered_map<SW, Label, StringKey> Map;$/;"	t	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS; }$/;"	f	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 inprops) const {$/;"	f	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::SW	arc-map.h	/^  typedef StringWeight<Label, S> SW;$/;"	t	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::StateId	arc-map.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::StringKey	arc-map.h	/^  class StringKey {$/;"	c	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::StringKey::operator ()	arc-map.h	/^    size_t operator()(const SW &x) const {$/;"	f	class:fst::GallicToNewSymbolsMapper::StringKey
fst::GallicToNewSymbolsMapper::ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::error_	arc-map.h	/^  mutable bool error_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::fst_	arc-map.h	/^  MutableFst<ToArc> *fst_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::isymbols_	arc-map.h	/^  SymbolTable *isymbols_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::lmax_	arc-map.h	/^  Label lmax_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::map_	arc-map.h	/^  Map map_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::operator ()	arc-map.h	/^  A operator()(const FromArc &arc) {$/;"	f	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::osymbols_	arc-map.h	/^  const SymbolTable *osymbols_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
fst::GallicToNewSymbolsMapper::state_	arc-map.h	/^  StateId state_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
fst::GallicWeight	string-weight.h	/^struct GallicWeight : public ProductWeight<StringWeight<L, S>, W> {$/;"	s	namespace:fst
fst::GallicWeight::GallicWeight	string-weight.h	/^  GallicWeight() {}$/;"	f	struct:fst::GallicWeight
fst::GallicWeight::GallicWeight	string-weight.h	/^  GallicWeight(StringWeight<L, S> w1, W w2)$/;"	f	struct:fst::GallicWeight
fst::GallicWeight::GallicWeight	string-weight.h	/^  GallicWeight(const ProductWeight<StringWeight<L, S>, W> &w)$/;"	f	struct:fst::GallicWeight
fst::GallicWeight::GallicWeight	string-weight.h	/^  explicit GallicWeight(const string &s, int *nread = 0)$/;"	f	struct:fst::GallicWeight
fst::GallicWeight::ReverseWeight	string-weight.h	/^  ReverseWeight;$/;"	t	struct:fst::GallicWeight
fst::GallicWeightGenerator	random-weight.h	/^class GallicWeightGenerator$/;"	c	namespace:fst
fst::GallicWeightGenerator::GallicWeightGenerator	random-weight.h	/^  GallicWeightGenerator(const PG &pg) : PG(pg) {}$/;"	f	class:fst::GallicWeightGenerator
fst::GallicWeightGenerator::GallicWeightGenerator	random-weight.h	/^  GallicWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::GallicWeightGenerator
fst::GallicWeightGenerator::PG	random-weight.h	/^  typedef ProductWeightGenerator<StringWeightGenerator<L, S>, G> PG;$/;"	t	class:fst::GallicWeightGenerator
fst::GallicWeightGenerator::W	random-weight.h	/^  typedef typename G::Weight W;$/;"	t	class:fst::GallicWeightGenerator
fst::GallicWeightGenerator::Weight	random-weight.h	/^  typedef GallicWeight<L, W, S> Weight;$/;"	t	class:fst::GallicWeightGenerator
fst::GenericComposeStateTable	state-table.h	/^class GenericComposeStateTable : public H {$/;"	c	namespace:fst
fst::GenericComposeStateTable::Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::GenericComposeStateTable
fst::GenericComposeStateTable::Error	state-table.h	/^  bool Error() const { return false; }$/;"	f	class:fst::GenericComposeStateTable
fst::GenericComposeStateTable::FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::GenericComposeStateTable
fst::GenericComposeStateTable::GenericComposeStateTable	state-table.h	/^  GenericComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2) {}$/;"	f	class:fst::GenericComposeStateTable
fst::GenericComposeStateTable::GenericComposeStateTable	state-table.h	/^  GenericComposeStateTable(const GenericComposeStateTable<A, F> &table) {}$/;"	f	class:fst::GenericComposeStateTable
fst::GenericComposeStateTable::StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::GenericComposeStateTable
fst::GenericComposeStateTable::StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::GenericComposeStateTable
fst::GenericRegister	generic-register.h	/^class GenericRegister {$/;"	c	namespace:fst
fst::GenericRegister::Entry	generic-register.h	/^  typedef EntryType Entry;$/;"	t	class:fst::GenericRegister
fst::GenericRegister::GetEntry	generic-register.h	/^  EntryType GetEntry(const KeyType &key) const {$/;"	f	class:fst::GenericRegister
fst::GenericRegister::GetRegister	generic-register.h	/^  static RegisterType *GetRegister() {$/;"	f	class:fst::GenericRegister
fst::GenericRegister::Init	generic-register.h	/^  static void Init() {$/;"	f	class:fst::GenericRegister
fst::GenericRegister::Key	generic-register.h	/^  typedef KeyType Key;$/;"	t	class:fst::GenericRegister
fst::GenericRegister::LoadEntryFromSharedObject	generic-register.h	/^  virtual EntryType LoadEntryFromSharedObject(const KeyType &key) const {$/;"	f	class:fst::GenericRegister
fst::GenericRegister::LookupEntry	generic-register.h	/^  virtual const EntryType *LookupEntry($/;"	f	class:fst::GenericRegister
fst::GenericRegister::RegisterMapType	generic-register.h	/^  typedef map<KeyType, EntryType> RegisterMapType;$/;"	t	class:fst::GenericRegister
fst::GenericRegister::SetEntry	generic-register.h	/^  void SetEntry(const KeyType &key,$/;"	f	class:fst::GenericRegister
fst::GenericRegister::register_	generic-register.h	/^  static RegisterType *register_;$/;"	m	class:fst::GenericRegister
fst::GenericRegister::register_	generic-register.h	/^RegisterType *GenericRegister<KeyType, EntryType, RegisterType>::register_ = 0;$/;"	m	class:fst::GenericRegister
fst::GenericRegister::register_init_	generic-register.h	/^                               RegisterType>::register_init_ = FST_ONCE_INIT;$/;"	m	class:fst::GenericRegister
fst::GenericRegister::register_init_	generic-register.h	/^  static FstOnceType register_init_;$/;"	m	class:fst::GenericRegister
fst::GenericRegister::register_lock_	generic-register.h	/^  static Mutex *register_lock_;$/;"	m	class:fst::GenericRegister
fst::GenericRegister::register_lock_	generic-register.h	/^Mutex *GenericRegister<KeyType, EntryType, RegisterType>::register_lock_ = 0;$/;"	m	class:fst::GenericRegister
fst::GenericRegister::register_table_	generic-register.h	/^  RegisterMapType register_table_;$/;"	m	class:fst::GenericRegister
fst::GenericRegister::~GenericRegister	generic-register.h	/^  virtual ~GenericRegister() { }$/;"	f	class:fst::GenericRegister
fst::GenericRegisterer	generic-register.h	/^class GenericRegisterer {$/;"	c	namespace:fst
fst::GenericRegisterer::Entry	generic-register.h	/^  typedef typename RegisterType::Entry Entry;$/;"	t	class:fst::GenericRegisterer
fst::GenericRegisterer::GenericRegisterer	generic-register.h	/^  GenericRegisterer(Key key, Entry entry) {$/;"	f	class:fst::GenericRegisterer
fst::GenericRegisterer::Key	generic-register.h	/^  typedef typename RegisterType::Key Key;$/;"	t	class:fst::GenericRegisterer
fst::HashBiTable	bi-table.h	/^class HashBiTable {$/;"	c	namespace:fst
fst::HashBiTable::FindEntry	bi-table.h	/^  const T &FindEntry(I s) const {$/;"	f	class:fst::HashBiTable
fst::HashBiTable::FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::HashBiTable
fst::HashBiTable::HashBiTable	bi-table.h	/^  HashBiTable() {$/;"	f	class:fst::HashBiTable
fst::HashBiTable::Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::HashBiTable
fst::HashBiTable::entry2id_	bi-table.h	/^  unordered_map<T, I, H> entry2id_;$/;"	m	class:fst::HashBiTable
fst::HashBiTable::id2entry_	bi-table.h	/^  vector<T> id2entry_;$/;"	m	class:fst::HashBiTable
fst::HashStateTable	state-table.h	/^class HashStateTable : public HashBiTable<typename T::StateId, T, H> {$/;"	c	namespace:fst
fst::HashStateTable::FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::HashStateTable
fst::HashStateTable::HashStateTable	state-table.h	/^  HashStateTable() : HashBiTable<StateId, T, H>() {}$/;"	f	class:fst::HashStateTable
fst::HashStateTable::StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::HashStateTable
fst::HashStateTable::StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::HashStateTable
fst::HashStateTable::Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::HashStateTable
fst::Heap	heap.h	/^class Heap {$/;"	c	namespace:fst
fst::Heap::A_	heap.h	/^  vector<T>   A_;$/;"	m	class:fst::Heap
fst::Heap::Better	heap.h	/^  bool Better(const T& x, const T& y) {$/;"	f	class:fst::Heap
fst::Heap::Clear	heap.h	/^  void Clear() {$/;"	f	class:fst::Heap
fst::Heap::Empty	heap.h	/^  bool Empty() const {$/;"	f	class:fst::Heap
fst::Heap::Heap	heap.h	/^  Heap() : size_(0) { }$/;"	f	class:fst::Heap
fst::Heap::Heap	heap.h	/^  Heap(Compare comp) : comp_(comp), size_(0) { }$/;"	f	class:fst::Heap
fst::Heap::Heapify	heap.h	/^  void Heapify(int i) {$/;"	f	class:fst::Heap
fst::Heap::Insert	heap.h	/^  int Insert(const T& val) {$/;"	f	class:fst::Heap
fst::Heap::Insert	heap.h	/^  int Insert(const T& val, int i) {$/;"	f	class:fst::Heap
fst::Heap::Left	heap.h	/^  int Left(int i) {$/;"	f	class:fst::Heap
fst::Heap::Parent	heap.h	/^  int Parent(int i) {$/;"	f	class:fst::Heap
fst::Heap::Pop	heap.h	/^  T Pop() {$/;"	f	class:fst::Heap
fst::Heap::Right	heap.h	/^  int Right(int i) {$/;"	f	class:fst::Heap
fst::Heap::Swap	heap.h	/^  void Swap(int j, int k) {$/;"	f	class:fst::Heap
fst::Heap::Top	heap.h	/^  T Top() const {$/;"	f	class:fst::Heap
fst::Heap::Update	heap.h	/^  void Update(int key, const T& val) {$/;"	f	class:fst::Heap
fst::Heap::comp_	heap.h	/^  Compare comp_;$/;"	m	class:fst::Heap
fst::Heap::key_	heap.h	/^  vector<int> key_;$/;"	m	class:fst::Heap
fst::Heap::pos_	heap.h	/^  vector<int> pos_;$/;"	m	class:fst::Heap
fst::Heap::size_	heap.h	/^  int  size_;$/;"	m	class:fst::Heap
fst::Heap::~Heap	heap.h	/^  ~Heap() { }$/;"	f	class:fst::Heap
fst::ILabelCompare	arcsort.h	/^template<class A> class ILabelCompare {$/;"	c	namespace:fst
fst::ILabelCompare::Properties	arcsort.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::ILabelCompare
fst::ILabelCompare::operator ()	arcsort.h	/^  bool operator() (A arc1, A arc2) const {$/;"	f	class:fst::ILabelCompare
fst::IdentityArcMapper	arc-map.h	/^struct IdentityArcMapper {$/;"	s	namespace:fst
fst::IdentityArcMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::IdentityArcMapper
fst::IdentityArcMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::IdentityArcMapper
fst::IdentityArcMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::IdentityArcMapper
fst::IdentityArcMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::IdentityArcMapper
fst::IdentityArcMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	struct:fst::IdentityArcMapper
fst::IdentityArcMapper::ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::IdentityArcMapper
fst::IdentityArcMapper::operator ()	arc-map.h	/^  A operator()(const A &arc) const { return arc; }$/;"	f	struct:fst::IdentityArcMapper
fst::IdentityFactor	factor-weight.h	/^class IdentityFactor {$/;"	c	namespace:fst
fst::IdentityFactor::Done	factor-weight.h	/^  bool Done() const { return true; }$/;"	f	class:fst::IdentityFactor
fst::IdentityFactor::IdentityFactor	factor-weight.h	/^  IdentityFactor(const W &w) {}$/;"	f	class:fst::IdentityFactor
fst::IdentityFactor::Next	factor-weight.h	/^  void Next() {}$/;"	f	class:fst::IdentityFactor
fst::IdentityFactor::Reset	factor-weight.h	/^  void Reset() {}$/;"	f	class:fst::IdentityFactor
fst::IdentityFactor::Value	factor-weight.h	/^  pair<W, W> Value() const { return make_pair(W::One(), W::One()); } \/\/ unused$/;"	f	class:fst::IdentityFactor
fst::IdentityMapper	map.h	/^struct IdentityMapper {$/;"	s	namespace:fst
fst::IdentityMapper::FinalAction	map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::IdentityMapper
fst::IdentityMapper::FromArc	map.h	/^  typedef A FromArc;$/;"	t	struct:fst::IdentityMapper
fst::IdentityMapper::InputSymbolsAction	map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::IdentityMapper
fst::IdentityMapper::OutputSymbolsAction	map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::IdentityMapper
fst::IdentityMapper::Properties	map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	struct:fst::IdentityMapper
fst::IdentityMapper::ToArc	map.h	/^  typedef A ToArc;$/;"	t	struct:fst::IdentityMapper
fst::IdentityMapper::operator ()	map.h	/^  A operator()(const A &arc) const { return arc; }$/;"	f	struct:fst::IdentityMapper
fst::IdentityStateMapper	state-map.h	/^class IdentityStateMapper {$/;"	c	namespace:fst
fst::IdentityStateMapper::Done	state-map.h	/^  bool Done() const { return aiter_->Done(); }$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::Final	state-map.h	/^  Weight Final(StateId s) const { return fst_.Final(s); }$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::FromArc	state-map.h	/^  typedef A FromArc;$/;"	t	class:fst::IdentityStateMapper
fst::IdentityStateMapper::IdentityStateMapper	state-map.h	/^  IdentityStateMapper(const IdentityStateMapper<A> &mapper,$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::IdentityStateMapper	state-map.h	/^  explicit IdentityStateMapper(const Fst<A> &fst) : fst_(fst), aiter_(0) {}$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::InputSymbolsAction	state-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::Next	state-map.h	/^  void Next() { aiter_->Next(); }$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::OutputSymbolsAction	state-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::Properties	state-map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::SetState	state-map.h	/^  void SetState(StateId s) {$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::Start	state-map.h	/^  StateId Start() const { return fst_.Start(); }$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::StateId	state-map.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::IdentityStateMapper
fst::IdentityStateMapper::ToArc	state-map.h	/^  typedef A ToArc;$/;"	t	class:fst::IdentityStateMapper
fst::IdentityStateMapper::Value	state-map.h	/^  const A &Value() const { return aiter_->Value(); }$/;"	f	class:fst::IdentityStateMapper
fst::IdentityStateMapper::Weight	state-map.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::IdentityStateMapper
fst::IdentityStateMapper::aiter_	state-map.h	/^  ArcIterator< Fst<A> > *aiter_;$/;"	m	class:fst::IdentityStateMapper
fst::IdentityStateMapper::fst_	state-map.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::IdentityStateMapper
fst::IdentityStateMapper::~IdentityStateMapper	state-map.h	/^  ~IdentityStateMapper() { delete aiter_; }$/;"	f	class:fst::IdentityStateMapper
fst::ImplToExpandedFst	expanded-fst.h	/^class ImplToExpandedFst : public ImplToFst<I, F> {$/;"	c	namespace:fst
fst::ImplToExpandedFst::Arc	expanded-fst.h	/^  typedef typename I::Arc Arc;$/;"	t	class:fst::ImplToExpandedFst
fst::ImplToExpandedFst::ImplToExpandedFst	expanded-fst.h	/^  ImplToExpandedFst() : ImplToFst<I, F>() {}$/;"	f	class:fst::ImplToExpandedFst
fst::ImplToExpandedFst::ImplToExpandedFst	expanded-fst.h	/^  ImplToExpandedFst(I *impl) : ImplToFst<I, F>(impl) {}$/;"	f	class:fst::ImplToExpandedFst
fst::ImplToExpandedFst::ImplToExpandedFst	expanded-fst.h	/^  ImplToExpandedFst(const ImplToExpandedFst<I, F> &fst)$/;"	f	class:fst::ImplToExpandedFst
fst::ImplToExpandedFst::ImplToExpandedFst	expanded-fst.h	/^  ImplToExpandedFst(const ImplToExpandedFst<I, F> &fst, bool safe)$/;"	f	class:fst::ImplToExpandedFst
fst::ImplToExpandedFst::NumStates	expanded-fst.h	/^  virtual StateId NumStates() const { return GetImpl()->NumStates(); }$/;"	f	class:fst::ImplToExpandedFst
fst::ImplToExpandedFst::Read	expanded-fst.h	/^  static I *Read(const string &filename) {$/;"	f	class:fst::ImplToExpandedFst
fst::ImplToExpandedFst::StateId	expanded-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ImplToExpandedFst
fst::ImplToExpandedFst::Weight	expanded-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ImplToExpandedFst
fst::ImplToExpandedFst::operator =	expanded-fst.h	/^  ImplToExpandedFst<I, F> &operator=(const Fst<Arc> &fst) {$/;"	f	class:fst::ImplToExpandedFst
fst::ImplToFst	fst.h	/^class ImplToFst : public F {$/;"	c	namespace:fst
fst::ImplToFst::Arc	fst.h	/^  typedef typename I::Arc Arc;$/;"	t	class:fst::ImplToFst
fst::ImplToFst::Final	fst.h	/^  virtual Weight Final(StateId s) const { return impl_->Final(s); }$/;"	f	class:fst::ImplToFst
fst::ImplToFst::GetImpl	fst.h	/^  I *GetImpl() const { return impl_; }$/;"	f	class:fst::ImplToFst
fst::ImplToFst::ImplToFst	fst.h	/^  ImplToFst() : impl_(0) {}$/;"	f	class:fst::ImplToFst
fst::ImplToFst::ImplToFst	fst.h	/^  ImplToFst(I *impl) : impl_(impl) {}$/;"	f	class:fst::ImplToFst
fst::ImplToFst::ImplToFst	fst.h	/^  ImplToFst(const ImplToFst<I, F> &fst) {$/;"	f	class:fst::ImplToFst
fst::ImplToFst::ImplToFst	fst.h	/^  ImplToFst(const ImplToFst<I, F> &fst, bool safe) {$/;"	f	class:fst::ImplToFst
fst::ImplToFst::InputSymbols	fst.h	/^  virtual const SymbolTable* InputSymbols() const {$/;"	f	class:fst::ImplToFst
fst::ImplToFst::NumArcs	fst.h	/^  virtual size_t NumArcs(StateId s) const { return impl_->NumArcs(s); }$/;"	f	class:fst::ImplToFst
fst::ImplToFst::NumInputEpsilons	fst.h	/^  virtual size_t NumInputEpsilons(StateId s) const {$/;"	f	class:fst::ImplToFst
fst::ImplToFst::NumOutputEpsilons	fst.h	/^  virtual size_t NumOutputEpsilons(StateId s) const {$/;"	f	class:fst::ImplToFst
fst::ImplToFst::OutputSymbols	fst.h	/^  virtual const SymbolTable* OutputSymbols() const {$/;"	f	class:fst::ImplToFst
fst::ImplToFst::Properties	fst.h	/^  virtual uint64 Properties(uint64 mask, bool test) const {$/;"	f	class:fst::ImplToFst
fst::ImplToFst::SetImpl	fst.h	/^  void SetImpl(I *impl, bool own_impl = true) {$/;"	f	class:fst::ImplToFst
fst::ImplToFst::Start	fst.h	/^  virtual StateId Start() const { return impl_->Start(); }$/;"	f	class:fst::ImplToFst
fst::ImplToFst::StateId	fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ImplToFst
fst::ImplToFst::Type	fst.h	/^  virtual const string& Type() const { return impl_->Type(); }$/;"	f	class:fst::ImplToFst
fst::ImplToFst::Weight	fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ImplToFst
fst::ImplToFst::impl_	fst.h	/^  I *impl_;$/;"	m	class:fst::ImplToFst
fst::ImplToFst::operator =	fst.h	/^  ImplToFst<I, F> &operator=(const Fst<Arc> &fst) {$/;"	f	class:fst::ImplToFst
fst::ImplToFst::~ImplToFst	fst.h	/^  virtual ~ImplToFst() { if (!impl_->DecrRefCount()) delete impl_;  }$/;"	f	class:fst::ImplToFst
fst::ImplToMutableFst	mutable-fst.h	/^class ImplToMutableFst : public ImplToExpandedFst<I, F> {$/;"	c	namespace:fst
fst::ImplToMutableFst::AddArc	mutable-fst.h	/^  virtual void AddArc(StateId s, const Arc &arc) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::AddState	mutable-fst.h	/^  virtual StateId AddState() {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::Arc	mutable-fst.h	/^  typedef typename I::Arc Arc;$/;"	t	class:fst::ImplToMutableFst
fst::ImplToMutableFst::DeleteArcs	mutable-fst.h	/^  virtual void DeleteArcs(StateId s) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::DeleteArcs	mutable-fst.h	/^  virtual void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::DeleteStates	mutable-fst.h	/^  virtual void DeleteStates() {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::DeleteStates	mutable-fst.h	/^  virtual void DeleteStates(const vector<StateId> &dstates) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::ImplToMutableFst	mutable-fst.h	/^  ImplToMutableFst() : ImplToExpandedFst<I, F>() {}$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::ImplToMutableFst	mutable-fst.h	/^  ImplToMutableFst(I *impl) : ImplToExpandedFst<I, F>(impl) {}$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::ImplToMutableFst	mutable-fst.h	/^  ImplToMutableFst(const ImplToMutableFst<I, F> &fst)$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::ImplToMutableFst	mutable-fst.h	/^  ImplToMutableFst(const ImplToMutableFst<I, F> &fst, bool safe)$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::InputSymbols	mutable-fst.h	/^  virtual const SymbolTable* InputSymbols() const {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::MutableInputSymbols	mutable-fst.h	/^  virtual SymbolTable* MutableInputSymbols() {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::MutableOutputSymbols	mutable-fst.h	/^  virtual SymbolTable* MutableOutputSymbols() {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::MutateCheck	mutable-fst.h	/^  void MutateCheck() {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::OutputSymbols	mutable-fst.h	/^  virtual const SymbolTable* OutputSymbols() const {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::ReserveArcs	mutable-fst.h	/^  virtual void ReserveArcs(StateId s, size_t n) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::ReserveStates	mutable-fst.h	/^  virtual void ReserveStates(StateId s) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::SetFinal	mutable-fst.h	/^  virtual void SetFinal(StateId s, Weight w) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::SetInputSymbols	mutable-fst.h	/^  virtual void SetInputSymbols(const SymbolTable* isyms) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::SetOutputSymbols	mutable-fst.h	/^  virtual void SetOutputSymbols(const SymbolTable* osyms) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::SetProperties	mutable-fst.h	/^  virtual void SetProperties(uint64 props, uint64 mask) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::SetStart	mutable-fst.h	/^  virtual void SetStart(StateId s) {$/;"	f	class:fst::ImplToMutableFst
fst::ImplToMutableFst::StateId	mutable-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ImplToMutableFst
fst::ImplToMutableFst::Weight	mutable-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ImplToMutableFst
fst::ImplToMutableFst::operator =	mutable-fst.h	/^  ImplToMutableFst<I, F> &operator=(const Fst<Arc> &fst) {$/;"	f	class:fst::ImplToMutableFst
fst::InputEpsilonArcFilter	arcfilter.h	/^class InputEpsilonArcFilter {$/;"	c	namespace:fst
fst::InputEpsilonArcFilter::operator ()	arcfilter.h	/^  bool operator()(const A &arc) const {$/;"	f	class:fst::InputEpsilonArcFilter
fst::IntFilterState	compose-filter.h	/^typedef IntegerFilterState<int> IntFilterState;$/;"	t	namespace:fst
fst::IntFilterState	fst-decl.h	/^typedef IntegerFilterState<int> IntFilterState;$/;"	t	namespace:fst
fst::IntegerFilterState	compose-filter.h	/^class IntegerFilterState {$/;"	c	namespace:fst
fst::IntegerFilterState::GetState	compose-filter.h	/^  T GetState() const { return state_; }$/;"	f	class:fst::IntegerFilterState
fst::IntegerFilterState::Hash	compose-filter.h	/^  size_t Hash() const { return static_cast<size_t>(state_); }$/;"	f	class:fst::IntegerFilterState
fst::IntegerFilterState::IntegerFilterState	compose-filter.h	/^  IntegerFilterState() : state_(kNoStateId) {}$/;"	f	class:fst::IntegerFilterState
fst::IntegerFilterState::IntegerFilterState	compose-filter.h	/^  explicit IntegerFilterState(T s) : state_(s) {}$/;"	f	class:fst::IntegerFilterState
fst::IntegerFilterState::NoState	compose-filter.h	/^  static const IntegerFilterState NoState() { return IntegerFilterState(); }$/;"	f	class:fst::IntegerFilterState
fst::IntegerFilterState::SetState	compose-filter.h	/^  void SetState(T state) { state_ = state; }$/;"	f	class:fst::IntegerFilterState
fst::IntegerFilterState::operator !=	compose-filter.h	/^  bool operator!=(const IntegerFilterState &f) const {$/;"	f	class:fst::IntegerFilterState
fst::IntegerFilterState::operator ==	compose-filter.h	/^  bool operator==(const IntegerFilterState &f) const {$/;"	f	class:fst::IntegerFilterState
fst::IntegerFilterState::state_	compose-filter.h	/^  T state_;$/;"	m	class:fst::IntegerFilterState
fst::Intersect	intersect.h	/^void Intersect(const Fst<Arc> &ifst1, const Fst<Arc> &ifst2,$/;"	f	namespace:fst
fst::IntersectFst	intersect.h	/^class IntersectFst : public ComposeFst<A> {$/;"	c	namespace:fst
fst::IntersectFst::Arc	intersect.h	/^  typedef A Arc;$/;"	t	class:fst::IntersectFst
fst::IntersectFst::Copy	intersect.h	/^  virtual IntersectFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::IntersectFst
fst::IntersectFst::IntersectFst	intersect.h	/^  IntersectFst(const Fst<A> &fst1, const Fst<A> &fst2,$/;"	f	class:fst::IntersectFst
fst::IntersectFst::IntersectFst	intersect.h	/^  IntersectFst(const IntersectFst<A> &fst, bool safe = false) :$/;"	f	class:fst::IntersectFst
fst::IntersectFst::StateId	intersect.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::IntersectFst
fst::IntersectFst::Weight	intersect.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::IntersectFst
fst::IntersectFstOptions	intersect.h	/^struct IntersectFstOptions : public ComposeFstOptions<A, M, F, T> {$/;"	s	namespace:fst
fst::IntersectFstOptions::IntersectFstOptions	intersect.h	/^  IntersectFstOptions() {}$/;"	f	struct:fst::IntersectFstOptions
fst::IntersectFstOptions::IntersectFstOptions	intersect.h	/^  explicit IntersectFstOptions(const CacheOptions &opts,$/;"	f	struct:fst::IntersectFstOptions
fst::IntersectOptions	intersect.h	/^typedef ComposeOptions IntersectOptions;$/;"	t	namespace:fst
fst::IntervalReachVisitor	state-reachable.h	/^class IntervalReachVisitor {$/;"	c	namespace:fst
fst::IntervalReachVisitor::BackArc	state-reachable.h	/^  bool BackArc(StateId s, const A &arc) {$/;"	f	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::Error	state-reachable.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::FinishState	state-reachable.h	/^  void FinishState(StateId s, StateId p, const A *arc) {$/;"	f	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::FinishVisit	state-reachable.h	/^  void FinishVisit() {}$/;"	f	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::ForwardOrCrossArc	state-reachable.h	/^  bool ForwardOrCrossArc(StateId s, const A &arc) {$/;"	f	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::InitState	state-reachable.h	/^  bool InitState(StateId s, StateId r) {$/;"	f	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::InitVisit	state-reachable.h	/^  void InitVisit(const Fst<A> &fst) { error_ = false; }$/;"	f	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::Interval	state-reachable.h	/^  typedef typename IntervalSet<I>::Interval Interval;$/;"	t	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::IntervalReachVisitor	state-reachable.h	/^  IntervalReachVisitor(const Fst<A> &fst,$/;"	f	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::Label	state-reachable.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::StateId	state-reachable.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::TreeArc	state-reachable.h	/^  bool TreeArc(StateId s, const A &arc) {$/;"	f	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::Weight	state-reachable.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::error_	state-reachable.h	/^  bool error_;$/;"	m	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::fst_	state-reachable.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::index_	state-reachable.h	/^  I index_;$/;"	m	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::isets_	state-reachable.h	/^  vector< IntervalSet<I> > *isets_;$/;"	m	class:fst::IntervalReachVisitor
fst::IntervalReachVisitor::state2index_	state-reachable.h	/^  vector<I> *state2index_;$/;"	m	class:fst::IntervalReachVisitor
fst::IntervalSet	interval-set.h	/^class IntervalSet {$/;"	c	namespace:fst
fst::IntervalSet::Clear	interval-set.h	/^  void Clear() {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Complement	interval-set.h	/^void IntervalSet<T>::Complement(T maxval, IntervalSet<T> *oset) const {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Contains	interval-set.h	/^bool IntervalSet<T>::Contains(const IntervalSet<T> &iset) const {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Count	interval-set.h	/^  const T Count() const { return count_; }$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Difference	interval-set.h	/^void IntervalSet<T>::Difference(const IntervalSet<T> &iset,$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Empty	interval-set.h	/^  const bool Empty() const { return intervals_.empty(); }$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Intersect	interval-set.h	/^void IntervalSet<T>::Intersect(const IntervalSet<T> &iset,$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Interval	interval-set.h	/^  struct Interval {$/;"	s	class:fst::IntervalSet
fst::IntervalSet::Interval::Interval	interval-set.h	/^    Interval() : begin(-1), end(-1) {}$/;"	f	struct:fst::IntervalSet::Interval
fst::IntervalSet::Interval::Interval	interval-set.h	/^    Interval(T b, T e) : begin(b), end(e) {}$/;"	f	struct:fst::IntervalSet::Interval
fst::IntervalSet::Interval::Read	interval-set.h	/^    istream &Read(istream &strm) {$/;"	f	struct:fst::IntervalSet::Interval
fst::IntervalSet::Interval::Write	interval-set.h	/^    ostream &Write(ostream &strm) const {$/;"	f	struct:fst::IntervalSet::Interval
fst::IntervalSet::Interval::begin	interval-set.h	/^    T begin;$/;"	m	struct:fst::IntervalSet::Interval
fst::IntervalSet::Interval::end	interval-set.h	/^    T end;$/;"	m	struct:fst::IntervalSet::Interval
fst::IntervalSet::Interval::operator !=	interval-set.h	/^    bool operator!=(const Interval &i) const {$/;"	f	struct:fst::IntervalSet::Interval
fst::IntervalSet::Interval::operator <	interval-set.h	/^    bool operator<(const Interval &i) const {$/;"	f	struct:fst::IntervalSet::Interval
fst::IntervalSet::Interval::operator ==	interval-set.h	/^    bool operator==(const Interval &i) const {$/;"	f	struct:fst::IntervalSet::Interval
fst::IntervalSet::IntervalSet	interval-set.h	/^  IntervalSet() : count_(-1) {}$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Intervals	interval-set.h	/^  const vector<Interval> *Intervals() const { return &intervals_; }$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Intervals	interval-set.h	/^  vector<Interval> *Intervals() { return &intervals_; }$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Member	interval-set.h	/^  bool Member(T value) const {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Normalize	interval-set.h	/^void IntervalSet<T>::Normalize() {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Overlaps	interval-set.h	/^bool IntervalSet<T>::Overlaps(const IntervalSet<T> &iset) const {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Read	interval-set.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Singleton	interval-set.h	/^  bool Singleton() const {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Size	interval-set.h	/^  const T Size() const { return intervals_.size(); }$/;"	f	class:fst::IntervalSet
fst::IntervalSet::StrictlyOverlaps	interval-set.h	/^bool IntervalSet<T>::StrictlyOverlaps(const IntervalSet<T> &iset) const {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Union	interval-set.h	/^  void Union(const IntervalSet<T> &iset) {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::Write	interval-set.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::count_	interval-set.h	/^  T count_;$/;"	m	class:fst::IntervalSet
fst::IntervalSet::intervals_	interval-set.h	/^  vector<Interval> intervals_;$/;"	m	class:fst::IntervalSet
fst::IntervalSet::operator !=	interval-set.h	/^  bool operator!=(const IntervalSet<T>& iset) const {$/;"	f	class:fst::IntervalSet
fst::IntervalSet::operator ==	interval-set.h	/^  bool operator==(const IntervalSet<T>& iset) const {$/;"	f	class:fst::IntervalSet
fst::Invert	invert.h	/^void Invert(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
fst::InvertFst	invert.h	/^class InvertFst : public ArcMapFst<A, A, InvertMapper<A> > {$/;"	c	namespace:fst
fst::InvertFst::Arc	invert.h	/^  typedef A Arc;$/;"	t	class:fst::InvertFst
fst::InvertFst::C	invert.h	/^  typedef InvertMapper<A> C;$/;"	t	class:fst::InvertFst
fst::InvertFst::Copy	invert.h	/^  virtual InvertFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::InvertFst
fst::InvertFst::Impl	invert.h	/^  typedef ArcMapFstImpl< A, A, InvertMapper<A> > Impl;$/;"	t	class:fst::InvertFst
fst::InvertFst::InvertFst	invert.h	/^  InvertFst(const InvertFst<A> &fst, bool safe = false)$/;"	f	class:fst::InvertFst
fst::InvertFst::InvertFst	invert.h	/^  explicit InvertFst(const Fst<A> &fst) : ArcMapFst<A, A, C>(fst, C()) {$/;"	f	class:fst::InvertFst
fst::InvertMapper	invert.h	/^template <class A> struct InvertMapper {$/;"	s	namespace:fst
fst::InvertMapper::FinalAction	invert.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::InvertMapper
fst::InvertMapper::InputSymbolsAction	invert.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_CLEAR_SYMBOLS; }$/;"	f	struct:fst::InvertMapper
fst::InvertMapper::InvertMapper	invert.h	/^  InvertMapper() {}$/;"	f	struct:fst::InvertMapper
fst::InvertMapper::OutputSymbolsAction	invert.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS;}$/;"	f	struct:fst::InvertMapper
fst::InvertMapper::Properties	invert.h	/^  uint64 Properties(uint64 props) { return InvertProperties(props); }$/;"	f	struct:fst::InvertMapper
fst::InvertMapper::operator ()	invert.h	/^  A operator()(const A &arc) {$/;"	f	struct:fst::InvertMapper
fst::InvertWeightMapper	arc-map.h	/^struct InvertWeightMapper {$/;"	s	namespace:fst
fst::InvertWeightMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::InvertWeightMapper
fst::InvertWeightMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::InvertWeightMapper
fst::InvertWeightMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::InvertWeightMapper
fst::InvertWeightMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::InvertWeightMapper
fst::InvertWeightMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::InvertWeightMapper
fst::InvertWeightMapper::ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::InvertWeightMapper
fst::InvertWeightMapper::Weight	arc-map.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::InvertWeightMapper
fst::InvertWeightMapper::operator ()	arc-map.h	/^  A operator()(const A &arc) const {$/;"	f	struct:fst::InvertWeightMapper
fst::KnownProperties	test-properties.h	/^inline uint64 KnownProperties(uint64 props) {$/;"	f	namespace:fst
fst::LIFO_QUEUE	queue.h	/^  LIFO_QUEUE = 2,            \/\/ Last-in, first-out queue$/;"	e	enum:fst::QueueType
fst::LabelCommonDivisor	determinize.h	/^class LabelCommonDivisor {$/;"	c	namespace:fst
fst::LabelCommonDivisor::Weight	determinize.h	/^  typedef StringWeight<L, S> Weight;$/;"	t	class:fst::LabelCommonDivisor
fst::LabelCommonDivisor::operator ()	determinize.h	/^  Weight operator()(const Weight &w1, const Weight &w2) const {$/;"	f	class:fst::LabelCommonDivisor
fst::LabelLookAheadMatcher	lookahead-matcher.h	/^class LabelLookAheadMatcher$/;"	c	namespace:fst
fst::LabelLookAheadMatcher::Arc	lookahead-matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Copy	lookahead-matcher.h	/^  LabelLookAheadMatcher<M, F, S> *Copy(bool safe = false) const {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Done	lookahead-matcher.h	/^  bool Done() const { return matcher_.Done(); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Done_	lookahead-matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::FST	lookahead-matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Find	lookahead-matcher.h	/^  bool Find(Label label) {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Find_	lookahead-matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Flags	lookahead-matcher.h	/^  uint32 Flags() const {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::GetData	lookahead-matcher.h	/^  MatcherData *GetData() const {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::GetFst	lookahead-matcher.h	/^  const FST &GetFst() const { return matcher_.GetFst(); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const L& fst, bool copy = false) {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Label	lookahead-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::LabelLookAheadMatcher	lookahead-matcher.h	/^  LabelLookAheadMatcher(const FST &fst, MatchType match_type,$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::LabelLookAheadMatcher	lookahead-matcher.h	/^  LabelLookAheadMatcher(const LabelLookAheadMatcher<M, F, S> &lmatcher,$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::LookAheadFst	lookahead-matcher.h	/^bool LabelLookAheadMatcher<M, F, S>::LookAheadFst(const L &fst, StateId s) {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::LookAheadFst_	lookahead-matcher.h	/^  bool LookAheadFst_(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::LookAheadLabel_	lookahead-matcher.h	/^  bool LookAheadLabel_(Label l) const { return LookAheadLabel(l); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::MatcherData	lookahead-matcher.h	/^  typedef LabelReachableData<Label> MatcherData;$/;"	t	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Next	lookahead-matcher.h	/^  void Next() { matcher_.Next(); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Next_	lookahead-matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Properties	lookahead-matcher.h	/^  uint64 Properties(uint64 inprops) const {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::SetState	lookahead-matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::SetState_	lookahead-matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::StateId	lookahead-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Type	lookahead-matcher.h	/^  MatchType Type(bool test) const { return matcher_.Type(test); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Value	lookahead-matcher.h	/^  const Arc& Value() const { return matcher_.Value(); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Value_	lookahead-matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::Weight	lookahead-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::error_	lookahead-matcher.h	/^  bool error_;$/;"	m	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::label_reachable_	lookahead-matcher.h	/^  LabelReachable<Arc, S> *label_reachable_;  \/\/ Label reachability info$/;"	m	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::lfst_	lookahead-matcher.h	/^  const Fst<Arc> *lfst_;                     \/\/ Look-ahead FST$/;"	m	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::match_set_state_	lookahead-matcher.h	/^  bool match_set_state_;                     \/\/ matcher_.SetState called?$/;"	m	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::matcher_	lookahead-matcher.h	/^  mutable M matcher_;$/;"	m	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::reach_set_state_	lookahead-matcher.h	/^  mutable bool reach_set_state_;             \/\/ reachable_.SetState called?$/;"	m	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::s_	lookahead-matcher.h	/^  StateId s_;                                \/\/ Matcher state$/;"	m	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadMatcher::~LabelLookAheadMatcher	lookahead-matcher.h	/^  ~LabelLookAheadMatcher() {$/;"	f	class:fst::LabelLookAheadMatcher
fst::LabelLookAheadRelabeler	lookahead-matcher.h	/^class LabelLookAheadRelabeler {$/;"	c	namespace:fst
fst::LabelLookAheadRelabeler::D	lookahead-matcher.h	/^  typedef AddOnPair<MatcherData, MatcherData> D;$/;"	t	class:fst::LabelLookAheadRelabeler
fst::LabelLookAheadRelabeler::Label	lookahead-matcher.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::LabelLookAheadRelabeler
fst::LabelLookAheadRelabeler::LabelLookAheadRelabeler	lookahead-matcher.h	/^LabelLookAheadRelabeler<A>::LabelLookAheadRelabeler(I **impl) {$/;"	f	class:fst::LabelLookAheadRelabeler
fst::LabelLookAheadRelabeler::MatcherData	lookahead-matcher.h	/^  typedef LabelReachableData<Label> MatcherData;$/;"	t	class:fst::LabelLookAheadRelabeler
fst::LabelLookAheadRelabeler::Relabel	lookahead-matcher.h	/^  static void Relabel(MutableFst<A> *fst, const L &mfst,$/;"	f	class:fst::LabelLookAheadRelabeler
fst::LabelLookAheadRelabeler::RelabelPairs	lookahead-matcher.h	/^  static void RelabelPairs(const L &mfst, vector<pair<Label, Label> > *pairs,$/;"	f	class:fst::LabelLookAheadRelabeler
fst::LabelReachable	label-reachable.h	/^class LabelReachable {$/;"	c	namespace:fst
fst::LabelReachable::Arc	label-reachable.h	/^  typedef A Arc;$/;"	t	class:fst::LabelReachable
fst::LabelReachable::Error	label-reachable.h	/^  bool Error() const { return error_ || accumulator_->Error(); }$/;"	f	class:fst::LabelReachable
fst::LabelReachable::FindIntervals	label-reachable.h	/^  void FindIntervals(StateId ins) {$/;"	f	class:fst::LabelReachable
fst::LabelReachable::GetData	label-reachable.h	/^  LabelReachableData<Label> *GetData() const { return data_; }$/;"	f	class:fst::LabelReachable
fst::LabelReachable::Interval	label-reachable.h	/^  typedef typename IntervalSet<Label>::Interval Interval;$/;"	t	class:fst::LabelReachable
fst::LabelReachable::Label	label-reachable.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::LabelReachable
fst::LabelReachable::Label2Index	label-reachable.h	/^  const unordered_map<Label, Label>& Label2Index() const {$/;"	f	class:fst::LabelReachable
fst::LabelReachable::LabelReachable	label-reachable.h	/^  LabelReachable(const Fst<A> &fst, bool reach_input, S *s = 0,$/;"	f	class:fst::LabelReachable
fst::LabelReachable::LabelReachable	label-reachable.h	/^  LabelReachable(const LabelReachable<A, S> &reachable) :$/;"	f	class:fst::LabelReachable
fst::LabelReachable::LabelReachable	label-reachable.h	/^  explicit LabelReachable(LabelReachableData<Label> *data, S *s = 0)$/;"	f	class:fst::LabelReachable
fst::LabelReachable::LowerBound	label-reachable.h	/^  ssize_t LowerBound(Iterator *aiter, ssize_t aiter_begin,$/;"	f	class:fst::LabelReachable
fst::LabelReachable::Reach	label-reachable.h	/^  bool Reach(Iterator *aiter, ssize_t aiter_begin,$/;"	f	class:fst::LabelReachable
fst::LabelReachable::Reach	label-reachable.h	/^  bool Reach(Label label) {$/;"	f	class:fst::LabelReachable
fst::LabelReachable::ReachBegin	label-reachable.h	/^  ssize_t ReachBegin() const { return reach_begin_;  }$/;"	f	class:fst::LabelReachable
fst::LabelReachable::ReachEnd	label-reachable.h	/^  ssize_t ReachEnd() const { return reach_end_; }$/;"	f	class:fst::LabelReachable
fst::LabelReachable::ReachFinal	label-reachable.h	/^  bool ReachFinal() {$/;"	f	class:fst::LabelReachable
fst::LabelReachable::ReachInit	label-reachable.h	/^  void ReachInit(const F &fst, bool copy = false) {$/;"	f	class:fst::LabelReachable
fst::LabelReachable::ReachWeight	label-reachable.h	/^  Weight ReachWeight() const { return reach_weight_; }$/;"	f	class:fst::LabelReachable
fst::LabelReachable::Relabel	label-reachable.h	/^  Label Relabel(Label label) {$/;"	f	class:fst::LabelReachable
fst::LabelReachable::Relabel	label-reachable.h	/^  void Relabel(MutableFst<Arc> *fst, bool relabel_input) {$/;"	f	class:fst::LabelReachable
fst::LabelReachable::RelabelPairs	label-reachable.h	/^  void RelabelPairs(vector<pair<Label, Label> > *pairs,$/;"	f	class:fst::LabelReachable
fst::LabelReachable::SetState	label-reachable.h	/^  void SetState(StateId s, StateId aiter_s = kNoStateId) {$/;"	f	class:fst::LabelReachable
fst::LabelReachable::StateId	label-reachable.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::LabelReachable
fst::LabelReachable::TransformFst	label-reachable.h	/^  void TransformFst() {$/;"	f	class:fst::LabelReachable
fst::LabelReachable::Weight	label-reachable.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::LabelReachable
fst::LabelReachable::accumulator_	label-reachable.h	/^  S *accumulator_;                        \/\/ Sums arc weights$/;"	m	class:fst::LabelReachable
fst::LabelReachable::data_	label-reachable.h	/^  LabelReachableData<Label> *data_;       \/\/ Shareable data between copies$/;"	m	class:fst::LabelReachable
fst::LabelReachable::error_	label-reachable.h	/^  bool error_;$/;"	m	class:fst::LabelReachable
fst::LabelReachable::fst_	label-reachable.h	/^  VectorFst<Arc> *fst_;$/;"	m	class:fst::LabelReachable
fst::LabelReachable::label2state_	label-reachable.h	/^  unordered_map<Label, StateId> label2state_;  \/\/ Finds final state for a label$/;"	m	class:fst::LabelReachable
fst::LabelReachable::ncalls_	label-reachable.h	/^  double ncalls_;$/;"	m	class:fst::LabelReachable
fst::LabelReachable::nintervals_	label-reachable.h	/^  double nintervals_;$/;"	m	class:fst::LabelReachable
fst::LabelReachable::reach_begin_	label-reachable.h	/^  ssize_t reach_begin_;                   \/\/ Iterator pos of first match$/;"	m	class:fst::LabelReachable
fst::LabelReachable::reach_end_	label-reachable.h	/^  ssize_t reach_end_;                     \/\/ Iterator pos after last match$/;"	m	class:fst::LabelReachable
fst::LabelReachable::reach_weight_	label-reachable.h	/^  Weight reach_weight_;                   \/\/ Gives weight sum of arc iterator$/;"	m	class:fst::LabelReachable
fst::LabelReachable::s_	label-reachable.h	/^  StateId s_;                             \/\/ Current state$/;"	m	class:fst::LabelReachable
fst::LabelReachable::~LabelReachable	label-reachable.h	/^  ~LabelReachable() {$/;"	f	class:fst::LabelReachable
fst::LabelReachableData	label-reachable.h	/^class LabelReachableData {$/;"	c	namespace:fst
fst::LabelReachableData::DecrRefCount	label-reachable.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::FinalLabel	label-reachable.h	/^  Label FinalLabel() {$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::IncrRefCount	label-reachable.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::Interval	label-reachable.h	/^  typedef typename IntervalSet<L>::Interval Interval;$/;"	t	class:fst::LabelReachableData
fst::LabelReachableData::IntervalSets	label-reachable.h	/^  vector< IntervalSet<L> > *IntervalSets() { return &isets_; }$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::Label	label-reachable.h	/^  typedef L Label;$/;"	t	class:fst::LabelReachableData
fst::LabelReachableData::Label2Index	label-reachable.h	/^  unordered_map<L, L> *Label2Index() {$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::LabelReachableData	label-reachable.h	/^  LabelReachableData() {}$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::LabelReachableData	label-reachable.h	/^  explicit LabelReachableData(bool reach_input, bool keep_relabel_data = true)$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::ReachInput	label-reachable.h	/^  bool ReachInput() const { return reach_input_; }$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::Read	label-reachable.h	/^  static LabelReachableData<L> *Read(istream &istrm) {$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::RefCount	label-reachable.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::Write	label-reachable.h	/^  bool Write(ostream &ostrm) {$/;"	f	class:fst::LabelReachableData
fst::LabelReachableData::final_label_	label-reachable.h	/^  Label final_label_;                 \/\/ Final label$/;"	m	class:fst::LabelReachableData
fst::LabelReachableData::have_relabel_data_	label-reachable.h	/^  bool have_relabel_data_;            \/\/ Using label2index_?$/;"	m	class:fst::LabelReachableData
fst::LabelReachableData::isets_	label-reachable.h	/^  vector<IntervalSet <L> > isets_;    \/\/ Interval sets per state.$/;"	m	class:fst::LabelReachableData
fst::LabelReachableData::keep_relabel_data_	label-reachable.h	/^  bool keep_relabel_data_;            \/\/ Save label2index_ to file?$/;"	m	class:fst::LabelReachableData
fst::LabelReachableData::label2index_	label-reachable.h	/^  unordered_map<L, L> label2index_;        \/\/ Finds index for a label.$/;"	m	class:fst::LabelReachableData
fst::LabelReachableData::reach_input_	label-reachable.h	/^  bool reach_input_;                  \/\/ Input or output labels considered?$/;"	m	class:fst::LabelReachableData
fst::LabelReachableData::ref_count_	label-reachable.h	/^  RefCounter ref_count_;              \/\/ Reference count.$/;"	m	class:fst::LabelReachableData
fst::LabelReachableData::~LabelReachableData	label-reachable.h	/^  ~LabelReachableData() {}$/;"	f	class:fst::LabelReachableData
fst::LabelsToUTF8String	icu.h	/^bool LabelsToUTF8String(const vector<Label> &labels, string *str) {$/;"	f	namespace:fst
fst::LexicographicArc	arc.h	/^struct LexicographicArc {$/;"	s	namespace:fst
fst::LexicographicArc::Label	arc.h	/^  typedef int Label;$/;"	t	struct:fst::LexicographicArc
fst::LexicographicArc::LexicographicArc	arc.h	/^  LexicographicArc() {}$/;"	f	struct:fst::LexicographicArc
fst::LexicographicArc::LexicographicArc	arc.h	/^  LexicographicArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::LexicographicArc
fst::LexicographicArc::StateId	arc.h	/^  typedef int StateId;$/;"	t	struct:fst::LexicographicArc
fst::LexicographicArc::Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::LexicographicArc
fst::LexicographicArc::Weight	arc.h	/^  typedef LexicographicWeight<W1, W2> Weight;$/;"	t	struct:fst::LexicographicArc
fst::LexicographicArc::ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::LexicographicArc
fst::LexicographicArc::nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::LexicographicArc
fst::LexicographicArc::olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::LexicographicArc
fst::LexicographicArc::weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::LexicographicArc
fst::LexicographicWeight	lexicographic-weight.h	/^class LexicographicWeight : public PairWeight<W1, W2> {$/;"	c	namespace:fst
fst::LexicographicWeight::LexicographicWeight	lexicographic-weight.h	/^  LexicographicWeight() {}$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::LexicographicWeight	lexicographic-weight.h	/^  LexicographicWeight(W1 w1, W2 w2) : PairWeight<W1, W2>(w1, w2) {$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::LexicographicWeight	lexicographic-weight.h	/^  LexicographicWeight(const PairWeight<W1, W2>& w)$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::Member	lexicographic-weight.h	/^  bool Member() const {$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::NoWeight	lexicographic-weight.h	/^  static const LexicographicWeight<W1, W2> &NoWeight() {$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::One	lexicographic-weight.h	/^  static const LexicographicWeight<W1, W2> &One() {$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::Properties	lexicographic-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::Quantize	lexicographic-weight.h	/^  LexicographicWeight<W1, W2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::Reverse	lexicographic-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::ReverseWeight	lexicographic-weight.h	/^  ReverseWeight;$/;"	t	class:fst::LexicographicWeight
fst::LexicographicWeight::Type	lexicographic-weight.h	/^  static const string &Type() {$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeight::Zero	lexicographic-weight.h	/^  static const LexicographicWeight<W1, W2> &Zero() {$/;"	f	class:fst::LexicographicWeight
fst::LexicographicWeightGenerator	random-weight.h	/^class LexicographicWeightGenerator {$/;"	c	namespace:fst
fst::LexicographicWeightGenerator::LexicographicWeightGenerator	random-weight.h	/^  LexicographicWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::LexicographicWeightGenerator
fst::LexicographicWeightGenerator::W1	random-weight.h	/^  typedef typename G1::Weight W1;$/;"	t	class:fst::LexicographicWeightGenerator
fst::LexicographicWeightGenerator::W2	random-weight.h	/^  typedef typename G2::Weight W2;$/;"	t	class:fst::LexicographicWeightGenerator
fst::LexicographicWeightGenerator::Weight	random-weight.h	/^  typedef LexicographicWeight<W1, W2> Weight;$/;"	t	class:fst::LexicographicWeightGenerator
fst::LexicographicWeightGenerator::allow_zero_	random-weight.h	/^  bool allow_zero_;$/;"	m	class:fst::LexicographicWeightGenerator
fst::LexicographicWeightGenerator::generator1_	random-weight.h	/^  G1 generator1_;$/;"	m	class:fst::LexicographicWeightGenerator
fst::LexicographicWeightGenerator::generator2_	random-weight.h	/^  G2 generator2_;$/;"	m	class:fst::LexicographicWeightGenerator
fst::LexicographicWeightGenerator::kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::LexicographicWeightGenerator
fst::LexicographicWeightGenerator::kNumRandomWeights	random-weight.h	/^const int LexicographicWeightGenerator<G1, G2>::kNumRandomWeights;$/;"	m	class:fst::LexicographicWeightGenerator
fst::LexicographicWeightGenerator::operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::LexicographicWeightGenerator
fst::LifoQueue	queue.h	/^class LifoQueue : public QueueBase<S>, public deque<S> {$/;"	c	namespace:fst
fst::LifoQueue::Clear	queue.h	/^  void Clear() { clear(); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Dequeue	queue.h	/^  void Dequeue() { pop_front(); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Empty	queue.h	/^  bool Empty() const { return empty(); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Enqueue	queue.h	/^  void Enqueue(StateId s) { push_front(s); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Head	queue.h	/^  StateId Head() const { return front(); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::LifoQueue
fst::LifoQueue::LifoQueue	queue.h	/^  LifoQueue() : QueueBase<S>(LIFO_QUEUE) {}$/;"	f	class:fst::LifoQueue
fst::LifoQueue::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::LifoQueue
fst::LifoQueue::Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::LifoQueue
fst::LifoQueue::Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::LifoQueue
fst::Log64Arc	arc.h	/^typedef ArcTpl<Log64Weight> Log64Arc;$/;"	t	namespace:fst
fst::Log64ToLogMapper	arc-map.h	/^typedef WeightConvertMapper<Log64Arc, LogArc> Log64ToLogMapper;$/;"	t	namespace:fst
fst::Log64ToStdMapper	arc-map.h	/^typedef WeightConvertMapper<Log64Arc, StdArc> Log64ToStdMapper;$/;"	t	namespace:fst
fst::Log64Weight	float-weight.h	/^typedef LogWeightTpl<double> Log64Weight;$/;"	t	namespace:fst
fst::LogAccumulator	accumulator.h	/^class LogAccumulator {$/;"	c	namespace:fst
fst::LogAccumulator::Arc	accumulator.h	/^  typedef A Arc;$/;"	t	class:fst::LogAccumulator
fst::LogAccumulator::Error	accumulator.h	/^  bool Error() const { return false; }$/;"	f	class:fst::LogAccumulator
fst::LogAccumulator::Init	accumulator.h	/^  void Init(const Fst<A>& fst, bool copy = false) {}$/;"	f	class:fst::LogAccumulator
fst::LogAccumulator::LogAccumulator	accumulator.h	/^  LogAccumulator() {}$/;"	f	class:fst::LogAccumulator
fst::LogAccumulator::LogAccumulator	accumulator.h	/^  LogAccumulator(const LogAccumulator<A> &acc) {}$/;"	f	class:fst::LogAccumulator
fst::LogAccumulator::LogPlus	accumulator.h	/^  Weight LogPlus(Weight w, Weight v) {$/;"	f	class:fst::LogAccumulator
fst::LogAccumulator::LogPosExp	accumulator.h	/^  double LogPosExp(double x) { return log(1.0F + exp(-x)); }$/;"	f	class:fst::LogAccumulator
fst::LogAccumulator::SetState	accumulator.h	/^  void SetState(StateId) {}$/;"	f	class:fst::LogAccumulator
fst::LogAccumulator::StateId	accumulator.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::LogAccumulator
fst::LogAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, ArcIterator *aiter, ssize_t begin,$/;"	f	class:fst::LogAccumulator
fst::LogAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::LogAccumulator
fst::LogAccumulator::Weight	accumulator.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::LogAccumulator
fst::LogAccumulator::to_log_weight_	accumulator.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::LogAccumulator
fst::LogAccumulator::to_weight_	accumulator.h	/^  WeightConvert<Log64Weight, Weight> to_weight_;$/;"	m	class:fst::LogAccumulator
fst::LogArc	arc.h	/^typedef ArcTpl<LogWeight> LogArc;$/;"	t	namespace:fst
fst::LogArc	fst-decl.h	/^typedef ArcTpl<LogWeight> LogArc;$/;"	t	namespace:fst
fst::LogArcLookAheadFst	matcher-fst.h	/^                   arc_lookahead_fst_type> LogArcLookAheadFst;$/;"	t	namespace:fst
fst::LogArcSelector	randgen.h	/^typedef LogProbArcSelector<LogArc> LogArcSelector;$/;"	t	namespace:fst
fst::LogExp	float-weight.h	/^inline T LogExp(T x) { return log(1.0F + exp(-x)); }$/;"	f	namespace:fst
fst::LogILabelLookAheadFst	matcher-fst.h	/^                   LabelLookAheadRelabeler<LogArc> > LogILabelLookAheadFst;$/;"	t	namespace:fst
fst::LogOLabelLookAheadFst	matcher-fst.h	/^                   LabelLookAheadRelabeler<LogArc> > LogOLabelLookAheadFst;$/;"	t	namespace:fst
fst::LogProbArcSelector	randgen.h	/^class LogProbArcSelector {$/;"	c	namespace:fst
fst::LogProbArcSelector::LogProbArcSelector	randgen.h	/^  LogProbArcSelector(int seed = time(0)) { srand(seed); }$/;"	f	class:fst::LogProbArcSelector
fst::LogProbArcSelector::StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::LogProbArcSelector
fst::LogProbArcSelector::Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::LogProbArcSelector
fst::LogProbArcSelector::operator ()	randgen.h	/^  size_t operator()(const Fst<A> &fst, StateId s) const {$/;"	f	class:fst::LogProbArcSelector
fst::LogProbArcSelector::to_log_weight_	randgen.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::LogProbArcSelector
fst::LogToLog64Mapper	arc-map.h	/^typedef WeightConvertMapper<LogArc, Log64Arc> LogToLog64Mapper;$/;"	t	namespace:fst
fst::LogToStdMapper	arc-map.h	/^typedef WeightConvertMapper<LogArc, StdArc> LogToStdMapper;$/;"	t	namespace:fst
fst::LogWeight	float-weight.h	/^typedef LogWeightTpl<float> LogWeight;$/;"	t	namespace:fst
fst::LogWeight	fst-decl.h	/^typedef LogWeightTpl<float> LogWeight;$/;"	t	namespace:fst
fst::LogWeightGenerator	random-weight.h	/^typedef LogWeightGenerator_<float> LogWeightGenerator;$/;"	t	namespace:fst
fst::LogWeightGenerator_	random-weight.h	/^class LogWeightGenerator_ {$/;"	c	namespace:fst
fst::LogWeightGenerator_::LogWeightGenerator_	random-weight.h	/^  LogWeightGenerator_(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::LogWeightGenerator_
fst::LogWeightGenerator_::Weight	random-weight.h	/^  typedef LogWeightTpl<T> Weight;$/;"	t	class:fst::LogWeightGenerator_
fst::LogWeightGenerator_::allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero divisors$/;"	m	class:fst::LogWeightGenerator_
fst::LogWeightGenerator_::kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::LogWeightGenerator_
fst::LogWeightGenerator_::kNumRandomWeights	random-weight.h	/^template <class T> const int LogWeightGenerator_<T>::kNumRandomWeights;$/;"	m	class:fst::LogWeightGenerator_
fst::LogWeightGenerator_::operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::LogWeightGenerator_
fst::LogWeightTpl	float-weight.h	/^class LogWeightTpl : public FloatWeightTpl<T> {$/;"	c	namespace:fst
fst::LogWeightTpl::LogWeightTpl	float-weight.h	/^  LogWeightTpl() : FloatWeightTpl<T>() {}$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::LogWeightTpl	float-weight.h	/^  LogWeightTpl(T f) : FloatWeightTpl<T>(f) {}$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::LogWeightTpl	float-weight.h	/^  LogWeightTpl(const LogWeightTpl<T> &w) : FloatWeightTpl<T>(w) {}$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::Member	float-weight.h	/^  bool Member() const {$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::NoWeight	float-weight.h	/^  static const LogWeightTpl<T> NoWeight() {$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::One	float-weight.h	/^  static const LogWeightTpl<T> One() {$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::Properties	float-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::Quantize	float-weight.h	/^  LogWeightTpl<T> Quantize(float delta = kDelta) const {$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::Reverse	float-weight.h	/^  LogWeightTpl<T> Reverse() const { return *this; }$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::ReverseWeight	float-weight.h	/^  typedef LogWeightTpl ReverseWeight;$/;"	t	class:fst::LogWeightTpl
fst::LogWeightTpl::Type	float-weight.h	/^  static const string &Type() {$/;"	f	class:fst::LogWeightTpl
fst::LogWeightTpl::Zero	float-weight.h	/^  static const LogWeightTpl<T> Zero() {$/;"	f	class:fst::LogWeightTpl
fst::LookAheadComposeFilter	lookahead-filter.h	/^class LookAheadComposeFilter {$/;"	c	namespace:fst
fst::LookAheadComposeFilter::Arc	lookahead-filter.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::FST1	lookahead-filter.h	/^  typedef typename F::FST1 FST1;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::FST2	lookahead-filter.h	/^  typedef typename F::FST2 FST2;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::Filter	lookahead-filter.h	/^  typedef LookAheadComposeFilter<F, M1, M2, MT> Filter;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::FilterArc	lookahead-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::FilterFinal	lookahead-filter.h	/^  void FilterFinal(Weight *weight1, Weight *weight2) const {$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::FilterState	lookahead-filter.h	/^  typedef typename F::FilterState FilterState;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::GetMatcher1	lookahead-filter.h	/^  Matcher1 *GetMatcher1() { return filter_.GetMatcher1(); }$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::GetMatcher2	lookahead-filter.h	/^  Matcher2 *GetMatcher2() { return filter_.GetMatcher2(); }$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::Label	lookahead-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::LookAheadArc	lookahead-filter.h	/^  bool LookAheadArc() const { return lookahead_arc_; }$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::LookAheadComposeFilter	lookahead-filter.h	/^  LookAheadComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::LookAheadComposeFilter	lookahead-filter.h	/^  LookAheadComposeFilter(const LookAheadComposeFilter<F, M1, M2, MT> &filter,$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::LookAheadFilterArc	lookahead-filter.h	/^  FilterState LookAheadFilterArc(Arc *arca, Arc *arcb,$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::LookAheadFlags	lookahead-filter.h	/^  uint32 LookAheadFlags() const { return flags_; }$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::LookAheadOutput	lookahead-filter.h	/^  bool LookAheadOutput() const {$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::Matcher1	lookahead-filter.h	/^  typedef typename F::Matcher1 Matcher1;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::Matcher2	lookahead-filter.h	/^  typedef typename F::Matcher2 Matcher2;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::Properties	lookahead-filter.h	/^  uint64 Properties(uint64 inprops) const {$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::Selector	lookahead-filter.h	/^  const LookAheadSelector<Matcher1, Matcher2, MT> &Selector() const {$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::SetState	lookahead-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::Start	lookahead-filter.h	/^  FilterState Start() const {$/;"	f	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::StateId	lookahead-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::Weight	lookahead-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::filter_	lookahead-filter.h	/^  F filter_;                    \/\/ Underlying filter$/;"	m	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::flags_	lookahead-filter.h	/^  uint32 flags_;                \/\/ Lookahead flags$/;"	m	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::lookahead_arc_	lookahead-filter.h	/^  mutable bool lookahead_arc_;  \/\/ Look-ahead performed at last FilterArc()?$/;"	m	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::lookahead_type_	lookahead-filter.h	/^  MatchType lookahead_type_;    \/\/ Lookahead match type$/;"	m	class:fst::LookAheadComposeFilter
fst::LookAheadComposeFilter::selector_	lookahead-filter.h	/^  LookAheadSelector<Matcher1, Matcher2, MT> selector_;$/;"	m	class:fst::LookAheadComposeFilter
fst::LookAheadMatchType	lookahead-filter.h	/^MatchType LookAheadMatchType(const Fst<Arc> &fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
fst::LookAheadMatchType	lookahead-filter.h	/^MatchType LookAheadMatchType(const M1 &m1, const M2 &m2) {$/;"	f	namespace:fst
fst::LookAheadMatcher	lookahead-matcher.h	/^class LookAheadMatcher {$/;"	c	namespace:fst
fst::LookAheadMatcher	matcher-fst.h	/^class LookAheadMatcher< MatcherFst<F, M, N, I> > {$/;"	c	namespace:fst
fst::LookAheadMatcher::Arc	lookahead-matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Arc	matcher-fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Copy	lookahead-matcher.h	/^  LookAheadMatcher<F> *Copy(bool safe = false) const {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Copy	matcher-fst.h	/^  LookAheadMatcher<FST> *Copy(bool safe = false) const {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Done	lookahead-matcher.h	/^  bool Done() const { return base_->Done(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Done	matcher-fst.h	/^  bool Done() const { return matcher_->Done(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::FST	lookahead-matcher.h	/^  typedef F FST;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::FST	matcher-fst.h	/^  typedef MatcherFst<F, M, N, I> FST;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Find	lookahead-matcher.h	/^  bool Find(Label label) { return base_->Find(label); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Find	matcher-fst.h	/^  bool Find(Label label) { return matcher_->Find(label); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Flags	lookahead-matcher.h	/^  uint32 Flags() const { return base_->Flags(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Flags	matcher-fst.h	/^  uint32 Flags() const { return matcher_->Flags(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::GetFst	lookahead-matcher.h	/^  const F &GetFst() const { return static_cast<const F &>(base_->GetFst()); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::GetFst	matcher-fst.h	/^  const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::InitLookAheadFst	matcher-fst.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LBase	lookahead-matcher.h	/^  typedef LookAheadMatcherBase<Arc> LBase;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Label	lookahead-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Label	matcher-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadCheck	lookahead-matcher.h	/^  bool LookAheadCheck() const {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadFst	lookahead-matcher.h	/^  bool LookAheadFst(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadFst	matcher-fst.h	/^  bool LookAheadFst(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadLabel	matcher-fst.h	/^  bool LookAheadLabel(Label label) const {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadMatcher	lookahead-matcher.h	/^  LookAheadMatcher(const F &fst, MatchType match_type) {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadMatcher	lookahead-matcher.h	/^  LookAheadMatcher(const LookAheadMatcher<F> &matcher, bool safe = false) {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadMatcher	matcher-fst.h	/^  LookAheadMatcher(const FST &fst, MatchType match_type) {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadMatcher	matcher-fst.h	/^  LookAheadMatcher(const LookAheadMatcher<FST> &matcher, bool safe = false) {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadPrefix	lookahead-matcher.h	/^  bool LookAheadPrefix(Arc *arc) const {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadPrefix	matcher-fst.h	/^  bool LookAheadPrefix(Arc *arc) const {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadWeight	lookahead-matcher.h	/^  Weight LookAheadWeight() const {$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::LookAheadWeight	matcher-fst.h	/^  Weight LookAheadWeight() const { return matcher_->LookAheadWeight(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Next	lookahead-matcher.h	/^  void Next() { base_->Next(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Next	matcher-fst.h	/^  void Next() { matcher_->Next(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Properties	lookahead-matcher.h	/^  uint64 Properties(uint64 props) const { return base_->Properties(props); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Properties	matcher-fst.h	/^  uint64 Properties(uint64 props) const { return matcher_->Properties(props); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::SetState	lookahead-matcher.h	/^  void SetState(StateId s) { base_->SetState(s); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::SetState	matcher-fst.h	/^  void SetState(StateId s) { matcher_->SetState(s); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::StateId	lookahead-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::StateId	matcher-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Type	lookahead-matcher.h	/^  MatchType Type(bool test) const { return base_->Type(test); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Type	matcher-fst.h	/^  MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Value	lookahead-matcher.h	/^  const Arc& Value() const { return base_->Value(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Value	matcher-fst.h	/^  const Arc& Value() const { return matcher_->Value(); }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Weight	lookahead-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::Weight	matcher-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::LookAheadMatcher
fst::LookAheadMatcher::base_	lookahead-matcher.h	/^  MatcherBase<Arc> *base_;$/;"	m	class:fst::LookAheadMatcher
fst::LookAheadMatcher::lookahead_	lookahead-matcher.h	/^  mutable bool lookahead_;$/;"	m	class:fst::LookAheadMatcher
fst::LookAheadMatcher::matcher_	matcher-fst.h	/^  M *matcher_;$/;"	m	class:fst::LookAheadMatcher
fst::LookAheadMatcher::~LookAheadMatcher	lookahead-matcher.h	/^  ~LookAheadMatcher() { delete base_; }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcher::~LookAheadMatcher	matcher-fst.h	/^  ~LookAheadMatcher() { delete matcher_; }$/;"	f	class:fst::LookAheadMatcher
fst::LookAheadMatcherBase	lookahead-matcher.h	/^class LookAheadMatcherBase : public MatcherBase<A> {$/;"	c	namespace:fst
fst::LookAheadMatcherBase::Arc	lookahead-matcher.h	/^  typedef A Arc;$/;"	t	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::ClearLookAheadPrefix	lookahead-matcher.h	/^  void ClearLookAheadPrefix() { prefix_arc_.nextstate = kNoStateId; }$/;"	f	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::Label	lookahead-matcher.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::LookAheadFst	lookahead-matcher.h	/^  bool LookAheadFst(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const { return LookAheadLabel_(label); }$/;"	f	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::LookAheadMatcherBase	lookahead-matcher.h	/^  LookAheadMatcherBase()$/;"	f	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::LookAheadPrefix	lookahead-matcher.h	/^  bool LookAheadPrefix(Arc *arc) const {$/;"	f	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::LookAheadWeight	lookahead-matcher.h	/^  Weight LookAheadWeight() const { return weight_; }$/;"	f	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::SetLookAheadPrefix	lookahead-matcher.h	/^  void SetLookAheadPrefix(const Arc &arc) { prefix_arc_ = arc; }$/;"	f	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::SetLookAheadWeight	lookahead-matcher.h	/^  void SetLookAheadWeight(const Weight &w) { weight_ = w; }$/;"	f	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::StateId	lookahead-matcher.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::Weight	lookahead-matcher.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::prefix_arc_	lookahead-matcher.h	/^  Arc prefix_arc_;                            \/\/ Look-ahead prefix arc$/;"	m	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::weight_	lookahead-matcher.h	/^  Weight weight_;                             \/\/ Look-ahead weight$/;"	m	class:fst::LookAheadMatcherBase
fst::LookAheadMatcherBase::~LookAheadMatcherBase	lookahead-matcher.h	/^  virtual ~LookAheadMatcherBase() {}$/;"	f	class:fst::LookAheadMatcherBase
fst::LookAheadSelector	lookahead-filter.h	/^class LookAheadSelector {$/;"	c	namespace:fst
fst::LookAheadSelector	lookahead-filter.h	/^class LookAheadSelector<M, M, MT> {$/;"	c	namespace:fst
fst::LookAheadSelector	lookahead-filter.h	/^class LookAheadSelector<M1, M2, MATCH_INPUT> {$/;"	c	namespace:fst
fst::LookAheadSelector	lookahead-filter.h	/^class LookAheadSelector<M1, M2, MATCH_OUTPUT> {$/;"	c	namespace:fst
fst::LookAheadSelector::Arc	lookahead-filter.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::LookAheadSelector
fst::LookAheadSelector::F	lookahead-filter.h	/^  typedef typename M::FST F;$/;"	t	class:fst::LookAheadSelector
fst::LookAheadSelector::F1	lookahead-filter.h	/^  typedef typename M1::FST F1;$/;"	t	class:fst::LookAheadSelector
fst::LookAheadSelector::F2	lookahead-filter.h	/^  typedef typename M2::FST F2;$/;"	t	class:fst::LookAheadSelector
fst::LookAheadSelector::GetFst	lookahead-filter.h	/^  const F &GetFst() const {$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::GetFst	lookahead-filter.h	/^  const F1 &GetFst() const { return *fst_; }$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::GetFst	lookahead-filter.h	/^  const F2 &GetFst() const { return *fst_; }$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::GetMatcher	lookahead-filter.h	/^  M *GetMatcher() const {$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::GetMatcher	lookahead-filter.h	/^  M1 *GetMatcher() const { return lmatcher_; }$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::GetMatcher	lookahead-filter.h	/^  M2 *GetMatcher() const { return lmatcher_; }$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(M *lmatcher1, M *lmatcher2, MatchType type)$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(M1 *lmatcher1, M2 *lmatcher2, MatchType)$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(const LookAheadSelector<M, M, MT> &selector)$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(const LookAheadSelector<M1, M2, MATCH_INPUT> &selector)$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::LookAheadSelector	lookahead-filter.h	/^  LookAheadSelector(const LookAheadSelector<M1, M2, MATCH_OUTPUT> &selector)$/;"	f	class:fst::LookAheadSelector
fst::LookAheadSelector::fst_	lookahead-filter.h	/^  const F1 *fst_;$/;"	m	class:fst::LookAheadSelector
fst::LookAheadSelector::fst_	lookahead-filter.h	/^  const F2 *fst_;$/;"	m	class:fst::LookAheadSelector
fst::LookAheadSelector::lmatcher1_	lookahead-filter.h	/^  M *lmatcher1_;$/;"	m	class:fst::LookAheadSelector
fst::LookAheadSelector::lmatcher2_	lookahead-filter.h	/^  M *lmatcher2_;$/;"	m	class:fst::LookAheadSelector
fst::LookAheadSelector::lmatcher_	lookahead-filter.h	/^  M1 *lmatcher_;$/;"	m	class:fst::LookAheadSelector
fst::LookAheadSelector::lmatcher_	lookahead-filter.h	/^  M2 *lmatcher_;$/;"	m	class:fst::LookAheadSelector
fst::LookAheadSelector::type_	lookahead-filter.h	/^  MatchType type_;$/;"	m	class:fst::LookAheadSelector
fst::LookAheadSelector::~LookAheadSelector	lookahead-filter.h	/^  ~LookAheadSelector() {$/;"	f	class:fst::LookAheadSelector
fst::MAP_ALLOW_SUPERFINAL	arc-map.h	/^  MAP_ALLOW_SUPERFINAL,$/;"	e	enum:fst::MapFinalAction
fst::MAP_CLEAR_SYMBOLS	arc-map.h	/^  MAP_CLEAR_SYMBOLS,$/;"	e	enum:fst::MapSymbolsAction
fst::MAP_COPY_SYMBOLS	arc-map.h	/^  MAP_COPY_SYMBOLS,$/;"	e	enum:fst::MapSymbolsAction
fst::MAP_NOOP_SYMBOLS	arc-map.h	/^  MAP_NOOP_SYMBOLS$/;"	e	enum:fst::MapSymbolsAction
fst::MAP_NO_SUPERFINAL	arc-map.h	/^  MAP_NO_SUPERFINAL,$/;"	e	enum:fst::MapFinalAction
fst::MAP_REQUIRE_SUPERFINAL	arc-map.h	/^  MAP_REQUIRE_SUPERFINAL$/;"	e	enum:fst::MapFinalAction
fst::MATCHER_REWRITE_ALWAYS	matcher.h	/^  MATCHER_REWRITE_ALWAYS,$/;"	e	enum:fst::MatcherRewriteMode
fst::MATCHER_REWRITE_AUTO	matcher.h	/^  MATCHER_REWRITE_AUTO = 0,    \/\/ Rewrites both sides iff acceptor.$/;"	e	enum:fst::MatcherRewriteMode
fst::MATCHER_REWRITE_NEVER	matcher.h	/^  MATCHER_REWRITE_NEVER$/;"	e	enum:fst::MatcherRewriteMode
fst::MATCH_BOTH	fst.h	/^                 MATCH_BOTH,       \/\/ Match input or output label.$/;"	e	enum:fst::MatchType
fst::MATCH_FILTER	compose.h	/^                     MATCH_FILTER };$/;"	e	enum:fst::ComposeFilter
fst::MATCH_INPUT	fst.h	/^enum MatchType { MATCH_INPUT,      \/\/ Match input label.$/;"	e	enum:fst::MatchType
fst::MATCH_NONE	fst.h	/^                 MATCH_NONE,       \/\/ Match nothing.$/;"	e	enum:fst::MatchType
fst::MATCH_OUTPUT	fst.h	/^                 MATCH_OUTPUT,     \/\/ Match output label.$/;"	e	enum:fst::MatchType
fst::MATCH_UNKNOWN	fst.h	/^                 MATCH_UNKNOWN };  \/\/ Match type unknown.$/;"	e	enum:fst::MatchType
fst::Map	map.h	/^void Map(MutableFst<A> *fst, C mapper) {$/;"	f	namespace:fst
fst::Map	map.h	/^void Map(MutableFst<A> *fst, C* mapper) {$/;"	f	namespace:fst
fst::Map	map.h	/^void Map(const Fst<A> &ifst, MutableFst<B> *ofst, C mapper) {$/;"	f	namespace:fst
fst::Map	map.h	/^void Map(const Fst<A> &ifst, MutableFst<B> *ofst, C* mapper) {$/;"	f	namespace:fst
fst::MapFinalAction	arc-map.h	/^enum MapFinalAction {$/;"	g	namespace:fst
fst::MapFst	map.h	/^class MapFst : public ArcMapFst<A, B, C> {$/;"	c	namespace:fst
fst::MapFst::Arc	map.h	/^  typedef B Arc;$/;"	t	class:fst::MapFst
fst::MapFst::Copy	map.h	/^virtual MapFst<A, B, C> *Copy(bool safe = false) const {$/;"	f	class:fst::MapFst
fst::MapFst::MapFst	map.h	/^  MapFst(const ArcMapFst<A, B, C> &fst, bool safe = false)$/;"	f	class:fst::MapFst
fst::MapFst::MapFst	map.h	/^  MapFst(const Fst<A> &fst, C* mapper) : ArcMapFst<A, B, C>(fst, mapper) {}$/;"	f	class:fst::MapFst
fst::MapFst::MapFst	map.h	/^  MapFst(const Fst<A> &fst, C* mapper, const MapFstOptions& opts)$/;"	f	class:fst::MapFst
fst::MapFst::MapFst	map.h	/^  MapFst(const Fst<A> &fst, const C &mapper)$/;"	f	class:fst::MapFst
fst::MapFst::MapFst	map.h	/^  MapFst(const Fst<A> &fst, const C &mapper, const MapFstOptions& opts)$/;"	f	class:fst::MapFst
fst::MapFst::State	map.h	/^  typedef CacheState<B> State;$/;"	t	class:fst::MapFst
fst::MapFst::StateId	map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::MapFst
fst::MapFst::Weight	map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::MapFst
fst::MapFstOptions	map.h	/^typedef ArcMapFstOptions MapFstOptions;$/;"	t	namespace:fst
fst::MapSymbolsAction	arc-map.h	/^enum MapSymbolsAction {$/;"	g	namespace:fst
fst::MatchComposeFilter	compose-filter.h	/^class MatchComposeFilter {$/;"	c	namespace:fst
fst::MatchComposeFilter::Arc	compose-filter.h	/^  typedef typename FST1::Arc Arc;$/;"	t	class:fst::MatchComposeFilter
fst::MatchComposeFilter::FST1	compose-filter.h	/^  typedef typename M1::FST FST1;$/;"	t	class:fst::MatchComposeFilter
fst::MatchComposeFilter::FST2	compose-filter.h	/^  typedef typename M2::FST FST2;$/;"	t	class:fst::MatchComposeFilter
fst::MatchComposeFilter::FilterArc	compose-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::MatchComposeFilter
fst::MatchComposeFilter::FilterFinal	compose-filter.h	/^  void FilterFinal(Weight *, Weight *) const {}$/;"	f	class:fst::MatchComposeFilter
fst::MatchComposeFilter::FilterState	compose-filter.h	/^  typedef CharFilterState FilterState;$/;"	t	class:fst::MatchComposeFilter
fst::MatchComposeFilter::GetMatcher1	compose-filter.h	/^  Matcher1 *GetMatcher1() { return matcher1_; }$/;"	f	class:fst::MatchComposeFilter
fst::MatchComposeFilter::GetMatcher2	compose-filter.h	/^  Matcher2 *GetMatcher2() { return matcher2_; }$/;"	f	class:fst::MatchComposeFilter
fst::MatchComposeFilter::Label	compose-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::MatchComposeFilter
fst::MatchComposeFilter::MatchComposeFilter	compose-filter.h	/^  MatchComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::MatchComposeFilter
fst::MatchComposeFilter::MatchComposeFilter	compose-filter.h	/^  MatchComposeFilter(const MatchComposeFilter<M1, M2> &filter,$/;"	f	class:fst::MatchComposeFilter
fst::MatchComposeFilter::Matcher1	compose-filter.h	/^  typedef M1 Matcher1;$/;"	t	class:fst::MatchComposeFilter
fst::MatchComposeFilter::Matcher2	compose-filter.h	/^  typedef M2 Matcher2;$/;"	t	class:fst::MatchComposeFilter
fst::MatchComposeFilter::Properties	compose-filter.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::MatchComposeFilter
fst::MatchComposeFilter::SetState	compose-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::MatchComposeFilter
fst::MatchComposeFilter::Start	compose-filter.h	/^  FilterState Start() const { return FilterState(0); }$/;"	f	class:fst::MatchComposeFilter
fst::MatchComposeFilter::StateId	compose-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MatchComposeFilter
fst::MatchComposeFilter::Weight	compose-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::MatchComposeFilter
fst::MatchComposeFilter::alleps1_	compose-filter.h	/^  bool alleps1_, alleps2_;  \/\/ Only epsilons (and non-final) leaving s1, s2?$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::alleps2_	compose-filter.h	/^  bool alleps1_, alleps2_;  \/\/ Only epsilons (and non-final) leaving s1, s2?$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::f_	compose-filter.h	/^  FilterState f_;           \/\/ Current filter state ID$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::fst1_	compose-filter.h	/^  const FST1 &fst1_;$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::fst2_	compose-filter.h	/^  const FST2 &fst2_;$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::matcher1_	compose-filter.h	/^  Matcher1 *matcher1_;$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::matcher2_	compose-filter.h	/^  Matcher2 *matcher2_;$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::noeps1_	compose-filter.h	/^  bool noeps1_, noeps2_;    \/\/ No epsilons leaving s1, s2?$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::noeps2_	compose-filter.h	/^  bool noeps1_, noeps2_;    \/\/ No epsilons leaving s1, s2?$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::s1_	compose-filter.h	/^  StateId s1_;              \/\/ Current fst1_ state;$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::s2_	compose-filter.h	/^  StateId s2_;              \/\/ Current fst2_ state;$/;"	m	class:fst::MatchComposeFilter
fst::MatchComposeFilter::~MatchComposeFilter	compose-filter.h	/^  ~MatchComposeFilter() {$/;"	f	class:fst::MatchComposeFilter
fst::MatchType	fst.h	/^enum MatchType { MATCH_INPUT,      \/\/ Match input label.$/;"	g	namespace:fst
fst::Matcher	matcher-fst.h	/^class Matcher< MatcherFst<F, M, N, I> > {$/;"	c	namespace:fst
fst::Matcher	matcher.h	/^class Matcher {$/;"	c	namespace:fst
fst::Matcher::Arc	matcher-fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::Matcher
fst::Matcher::Arc	matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::Matcher
fst::Matcher::Copy	matcher-fst.h	/^  Matcher<FST> *Copy() const {$/;"	f	class:fst::Matcher
fst::Matcher::Copy	matcher.h	/^  Matcher<F> *Copy(bool safe = false) const {$/;"	f	class:fst::Matcher
fst::Matcher::Done	matcher-fst.h	/^  bool Done() const { return matcher_->Done(); }$/;"	f	class:fst::Matcher
fst::Matcher::Done	matcher.h	/^  bool Done() const { return base_->Done(); }$/;"	f	class:fst::Matcher
fst::Matcher::FST	matcher-fst.h	/^  typedef MatcherFst<F, M, N, I> FST;$/;"	t	class:fst::Matcher
fst::Matcher::FST	matcher.h	/^  typedef F FST;$/;"	t	class:fst::Matcher
fst::Matcher::Find	matcher-fst.h	/^  bool Find(Label label) { return matcher_->Find(label); }$/;"	f	class:fst::Matcher
fst::Matcher::Find	matcher.h	/^  bool Find(Label label) { return base_->Find(label); }$/;"	f	class:fst::Matcher
fst::Matcher::Flags	matcher-fst.h	/^  uint32 Flags() const { return matcher_->Flags(); }$/;"	f	class:fst::Matcher
fst::Matcher::Flags	matcher.h	/^  uint32 Flags() const { return base_->Flags() & kMatcherFlags; }$/;"	f	class:fst::Matcher
fst::Matcher::GetFst	matcher.h	/^  const F &GetFst() const { return static_cast<const F &>(base_->GetFst()); }$/;"	f	class:fst::Matcher
fst::Matcher::Label	matcher-fst.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::Matcher
fst::Matcher::Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::Matcher
fst::Matcher::Matcher	matcher-fst.h	/^  Matcher(const FST &fst, MatchType match_type) {$/;"	f	class:fst::Matcher
fst::Matcher::Matcher	matcher-fst.h	/^  Matcher(const Matcher<FST> &matcher) {$/;"	f	class:fst::Matcher
fst::Matcher::Matcher	matcher.h	/^  Matcher(MatcherBase<Arc>* base_matcher) { base_ = base_matcher; }$/;"	f	class:fst::Matcher
fst::Matcher::Matcher	matcher.h	/^  Matcher(const F &fst, MatchType match_type) {$/;"	f	class:fst::Matcher
fst::Matcher::Matcher	matcher.h	/^  Matcher(const Matcher<F> &matcher, bool safe = false) {$/;"	f	class:fst::Matcher
fst::Matcher::Next	matcher-fst.h	/^  void Next() { matcher_->Next(); }$/;"	f	class:fst::Matcher
fst::Matcher::Next	matcher.h	/^  void Next() { base_->Next(); }$/;"	f	class:fst::Matcher
fst::Matcher::Properties	matcher-fst.h	/^  uint64 Properties(uint64 props) const { return matcher_->Properties(props); }$/;"	f	class:fst::Matcher
fst::Matcher::Properties	matcher.h	/^  uint64 Properties(uint64 props) const { return base_->Properties(props); }$/;"	f	class:fst::Matcher
fst::Matcher::SetState	matcher-fst.h	/^  void SetState(StateId s) { matcher_->SetState(s); }$/;"	f	class:fst::Matcher
fst::Matcher::SetState	matcher.h	/^  void SetState(StateId s) { base_->SetState(s); }$/;"	f	class:fst::Matcher
fst::Matcher::StateId	matcher-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::Matcher
fst::Matcher::StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::Matcher
fst::Matcher::Type	matcher-fst.h	/^  MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::Matcher
fst::Matcher::Type	matcher.h	/^  MatchType Type(bool test) const { return base_->Type(test); }$/;"	f	class:fst::Matcher
fst::Matcher::Value	matcher-fst.h	/^  const Arc& Value() const { return matcher_->Value(); }$/;"	f	class:fst::Matcher
fst::Matcher::Value	matcher.h	/^  const Arc& Value() const { return base_->Value(); }$/;"	f	class:fst::Matcher
fst::Matcher::Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::Matcher
fst::Matcher::base_	matcher.h	/^  MatcherBase<Arc> *base_;$/;"	m	class:fst::Matcher
fst::Matcher::matcher_	matcher-fst.h	/^  M *matcher_;$/;"	m	class:fst::Matcher
fst::Matcher::~Matcher	matcher-fst.h	/^  ~Matcher() { delete matcher_; }$/;"	f	class:fst::Matcher
fst::Matcher::~Matcher	matcher.h	/^  ~Matcher() { delete base_; }$/;"	f	class:fst::Matcher
fst::MatcherBase	matcher.h	/^class MatcherBase {$/;"	c	namespace:fst
fst::MatcherBase::Arc	matcher.h	/^  typedef A Arc;$/;"	t	class:fst::MatcherBase
fst::MatcherBase::Done	matcher.h	/^  bool Done() const { return Done_(); }$/;"	f	class:fst::MatcherBase
fst::MatcherBase::Find	matcher.h	/^  bool Find(Label label) { return Find_(label); }$/;"	f	class:fst::MatcherBase
fst::MatcherBase::Flags	matcher.h	/^  virtual uint32 Flags() const { return 0; }$/;"	f	class:fst::MatcherBase
fst::MatcherBase::Label	matcher.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::MatcherBase
fst::MatcherBase::Next	matcher.h	/^  void Next() { Next_(); }$/;"	f	class:fst::MatcherBase
fst::MatcherBase::SetState	matcher.h	/^  void SetState(StateId s) { SetState_(s); }$/;"	f	class:fst::MatcherBase
fst::MatcherBase::StateId	matcher.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::MatcherBase
fst::MatcherBase::Value	matcher.h	/^  const A& Value() const { return Value_(); }$/;"	f	class:fst::MatcherBase
fst::MatcherBase::Weight	matcher.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::MatcherBase
fst::MatcherBase::~MatcherBase	matcher.h	/^  virtual ~MatcherBase() {}$/;"	f	class:fst::MatcherBase
fst::MatcherFst	matcher-fst.h	/^class MatcherFst$/;"	c	namespace:fst
fst::MatcherFst::Arc	matcher-fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::MatcherFst
fst::MatcherFst::Copy	matcher-fst.h	/^  virtual MatcherFst<F, M, N, I> *Copy(bool safe = false) const {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::CreateImpl	matcher-fst.h	/^  static Impl *CreateImpl(const F &fst, const string &name) {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::CreateImpl	matcher-fst.h	/^  static Impl *CreateImpl(const Fst<Arc> &fst, const string &name) {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::D	matcher-fst.h	/^  typedef AddOnPair<typename M::MatcherData, typename M::MatcherData> D;$/;"	t	class:fst::MatcherFst
fst::MatcherFst::FST	matcher-fst.h	/^  typedef F FST;$/;"	t	class:fst::MatcherFst
fst::MatcherFst::FstMatcher	matcher-fst.h	/^  typedef M FstMatcher;$/;"	t	class:fst::MatcherFst
fst::MatcherFst::GetData	matcher-fst.h	/^  typename M::MatcherData *GetData(MatchType match_type) const {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::GetFst	matcher-fst.h	/^  F& GetFst() const { return GetImpl()->GetFst(); }$/;"	f	class:fst::MatcherFst
fst::MatcherFst::GetImpl	matcher-fst.h	/^  Impl *GetImpl() const {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::Impl	matcher-fst.h	/^  typedef AddOnImpl<F, D> Impl;$/;"	t	class:fst::MatcherFst
fst::MatcherFst::InitArcIterator	matcher-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::InitMatcher	matcher-fst.h	/^  virtual M *InitMatcher(MatchType match_type) const {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::InitStateIterator	matcher-fst.h	/^  virtual void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::MatcherFst	matcher-fst.h	/^  MatcherFst() : ImplToExpandedFst<Impl>(new Impl(F(), N)) {}$/;"	f	class:fst::MatcherFst
fst::MatcherFst::MatcherFst	matcher-fst.h	/^  MatcherFst(const MatcherFst<F, M, N, I> &fst, bool safe = false)$/;"	f	class:fst::MatcherFst
fst::MatcherFst::MatcherFst	matcher-fst.h	/^  explicit MatcherFst(Impl *impl) : ImplToExpandedFst<Impl>(impl) {}$/;"	f	class:fst::MatcherFst
fst::MatcherFst::MatcherFst	matcher-fst.h	/^  explicit MatcherFst(const F &fst)$/;"	f	class:fst::MatcherFst
fst::MatcherFst::MatcherFst	matcher-fst.h	/^  explicit MatcherFst(const Fst<Arc> &fst)$/;"	f	class:fst::MatcherFst
fst::MatcherFst::Read	matcher-fst.h	/^  static MatcherFst<F, M, N, I> *Read(const string &filename) {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::Read	matcher-fst.h	/^  static MatcherFst<F, M, N, I> *Read(istream &strm,$/;"	f	class:fst::MatcherFst
fst::MatcherFst::SetImpl	matcher-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = true) {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::StateId	matcher-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MatcherFst
fst::MatcherFst::Write	matcher-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::MatcherFst
fst::MatcherFst::Write	matcher-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::MatcherFst
fst::MatcherRewriteMode	matcher.h	/^enum MatcherRewriteMode {$/;"	g	namespace:fst
fst::MergeStates	minimize.h	/^void MergeStates($/;"	f	namespace:fst
fst::MinMaxArc	arc.h	/^typedef ArcTpl<MinMaxWeight> MinMaxArc;$/;"	t	namespace:fst
fst::MinMaxWeight	float-weight.h	/^typedef MinMaxWeightTpl<float> MinMaxWeight;$/;"	t	namespace:fst
fst::MinMaxWeight	fst-decl.h	/^typedef MinMaxWeightTpl<float> MinMaxWeight;$/;"	t	namespace:fst
fst::MinMaxWeightGenerator	random-weight.h	/^typedef MinMaxWeightGenerator_<float> MinMaxWeightGenerator;$/;"	t	namespace:fst
fst::MinMaxWeightGenerator_	random-weight.h	/^class MinMaxWeightGenerator_ {$/;"	c	namespace:fst
fst::MinMaxWeightGenerator_::MinMaxWeightGenerator_	random-weight.h	/^  MinMaxWeightGenerator_(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::MinMaxWeightGenerator_
fst::MinMaxWeightGenerator_::Weight	random-weight.h	/^  typedef MinMaxWeightTpl<T> Weight;$/;"	t	class:fst::MinMaxWeightGenerator_
fst::MinMaxWeightGenerator_::allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero divisors$/;"	m	class:fst::MinMaxWeightGenerator_
fst::MinMaxWeightGenerator_::kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::MinMaxWeightGenerator_
fst::MinMaxWeightGenerator_::kNumRandomWeights	random-weight.h	/^template <class T> const int MinMaxWeightGenerator_<T>::kNumRandomWeights;$/;"	m	class:fst::MinMaxWeightGenerator_
fst::MinMaxWeightGenerator_::operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::MinMaxWeightGenerator_
fst::MinMaxWeightTpl	float-weight.h	/^class MinMaxWeightTpl : public FloatWeightTpl<T> {$/;"	c	namespace:fst
fst::MinMaxWeightTpl::Member	float-weight.h	/^  bool Member() const {$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::MinMaxWeightTpl	float-weight.h	/^  MinMaxWeightTpl() : FloatWeightTpl<T>() {}$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::MinMaxWeightTpl	float-weight.h	/^  MinMaxWeightTpl(T f) : FloatWeightTpl<T>(f) {}$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::MinMaxWeightTpl	float-weight.h	/^  MinMaxWeightTpl(const MinMaxWeightTpl<T> &w) : FloatWeightTpl<T>(w) {}$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::NoWeight	float-weight.h	/^  static const MinMaxWeightTpl<T> NoWeight() {$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::One	float-weight.h	/^  static const MinMaxWeightTpl<T> One() {$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::Properties	float-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::Quantize	float-weight.h	/^  MinMaxWeightTpl<T> Quantize(float delta = kDelta) const {$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::Reverse	float-weight.h	/^  MinMaxWeightTpl<T> Reverse() const { return *this; }$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::ReverseWeight	float-weight.h	/^  typedef MinMaxWeightTpl<T> ReverseWeight;$/;"	t	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::Type	float-weight.h	/^  static const string &Type() {$/;"	f	class:fst::MinMaxWeightTpl
fst::MinMaxWeightTpl::Zero	float-weight.h	/^  static const MinMaxWeightTpl<T> Zero() {$/;"	f	class:fst::MinMaxWeightTpl
fst::Minimize	minimize.h	/^void Minimize(MutableFst<A>* fst,$/;"	f	namespace:fst
fst::Minus	signed-log-weight.h	/^inline SignedLogWeightTpl<T> Minus(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::MultiEpsFilter	compose-filter.h	/^class MultiEpsFilter {$/;"	c	namespace:fst
fst::MultiEpsFilter::Arc	compose-filter.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::FST1	compose-filter.h	/^  typedef typename F::FST1 FST1;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::FST2	compose-filter.h	/^  typedef typename F::FST2 FST2;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::Filter	compose-filter.h	/^  typedef MultiEpsFilter<F> Filter;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::FilterArc	compose-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::MultiEpsFilter
fst::MultiEpsFilter::FilterFinal	compose-filter.h	/^  void FilterFinal(Weight *w1, Weight *w2) const {$/;"	f	class:fst::MultiEpsFilter
fst::MultiEpsFilter::FilterState	compose-filter.h	/^  typedef typename F::FilterState FilterState;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::GetMatcher1	compose-filter.h	/^  Matcher1 *GetMatcher1() { return filter_.GetMatcher1(); }$/;"	f	class:fst::MultiEpsFilter
fst::MultiEpsFilter::GetMatcher2	compose-filter.h	/^  Matcher2 *GetMatcher2() { return filter_.GetMatcher2(); }$/;"	f	class:fst::MultiEpsFilter
fst::MultiEpsFilter::Label	compose-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::Matcher1	compose-filter.h	/^  typedef typename F::Matcher1 Matcher1;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::Matcher2	compose-filter.h	/^  typedef typename F::Matcher2 Matcher2;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::MultiEpsFilter	compose-filter.h	/^  MultiEpsFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::MultiEpsFilter
fst::MultiEpsFilter::MultiEpsFilter	compose-filter.h	/^  MultiEpsFilter(const Filter &filter, bool safe = false)$/;"	f	class:fst::MultiEpsFilter
fst::MultiEpsFilter::Properties	compose-filter.h	/^  uint64 Properties(uint64 iprops) const {$/;"	f	class:fst::MultiEpsFilter
fst::MultiEpsFilter::SetState	compose-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::MultiEpsFilter
fst::MultiEpsFilter::Start	compose-filter.h	/^  FilterState Start() const { return filter_.Start(); }$/;"	f	class:fst::MultiEpsFilter
fst::MultiEpsFilter::StateId	compose-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::Weight	compose-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::MultiEpsFilter
fst::MultiEpsFilter::filter_	compose-filter.h	/^  F filter_;$/;"	m	class:fst::MultiEpsFilter
fst::MultiEpsFilter::keep_multi_eps_	compose-filter.h	/^  bool keep_multi_eps_;$/;"	m	class:fst::MultiEpsFilter
fst::MultiEpsMatcher	matcher.h	/^class MultiEpsMatcher {$/;"	c	namespace:fst
fst::MultiEpsMatcher::AddMultiEpsLabel	matcher.h	/^  void AddMultiEpsLabel(Label label) {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Arc	matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::ClearMultiEpsLabels	matcher.h	/^  void ClearMultiEpsLabels() {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Copy	matcher.h	/^  MultiEpsMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Done	matcher.h	/^  bool Done() const {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::FST	matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Find	matcher.h	/^bool MultiEpsMatcher<M>::Find(Label match_label) {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Flags	matcher.h	/^  uint32 Flags() const { return matcher_->Flags(); }$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::GetFst	matcher.h	/^  const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::IsMultiEps	matcher.h	/^  bool IsMultiEps(const set<Label> &multi_eps_labels, Label label) const {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::MultiEpsMatcher	matcher.h	/^  MultiEpsMatcher(const FST &fst, MatchType match_type,$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::MultiEpsMatcher	matcher.h	/^  MultiEpsMatcher(const MultiEpsMatcher<M> &matcher, bool safe = false)$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Next	matcher.h	/^  void Next() {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Properties	matcher.h	/^  uint64 Properties(uint64 props) const { return matcher_->Properties(props); }$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Type	matcher.h	/^  MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::current_loop_	matcher.h	/^  bool current_loop_;            \/\/ Current arc is the implicit loop$/;"	m	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::done_	matcher.h	/^  bool done_;                    \/\/ Matching done$/;"	m	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::flags_	matcher.h	/^  uint32 flags_;$/;"	m	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::loop_	matcher.h	/^  mutable Arc loop_;             \/\/ For non-consuming symbols$/;"	m	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::matcher_	matcher.h	/^  M *matcher_;$/;"	m	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::multi_eps_iter_	matcher.h	/^  typename CompactSet<Label, kNoLabel>::const_iterator multi_eps_iter_;$/;"	m	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::multi_eps_labels_	matcher.h	/^  CompactSet<Label, kNoLabel> multi_eps_labels_;$/;"	m	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::own_matcher_	matcher.h	/^  bool own_matcher_;             \/\/ Does this class delete the matcher?$/;"	m	class:fst::MultiEpsMatcher
fst::MultiEpsMatcher::~MultiEpsMatcher	matcher.h	/^  ~MultiEpsMatcher() {$/;"	f	class:fst::MultiEpsMatcher
fst::MultiLabelArcFilter	arcfilter.h	/^class MultiLabelArcFilter {$/;"	c	namespace:fst
fst::MultiLabelArcFilter::AddLabel	arcfilter.h	/^  void AddLabel(Label label) {$/;"	f	class:fst::MultiLabelArcFilter
fst::MultiLabelArcFilter::Label	arcfilter.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::MultiLabelArcFilter
fst::MultiLabelArcFilter::MultiLabelArcFilter	arcfilter.h	/^  MultiLabelArcFilter(bool match_input = true, bool keep_match = true)$/;"	f	class:fst::MultiLabelArcFilter
fst::MultiLabelArcFilter::keep_match_	arcfilter.h	/^  bool keep_match_;$/;"	m	class:fst::MultiLabelArcFilter
fst::MultiLabelArcFilter::labels_	arcfilter.h	/^  CompactSet<Label, kNoLabel> labels_;$/;"	m	class:fst::MultiLabelArcFilter
fst::MultiLabelArcFilter::match_input_	arcfilter.h	/^  bool match_input_;$/;"	m	class:fst::MultiLabelArcFilter
fst::MultiLabelArcFilter::operator ()	arcfilter.h	/^  bool operator()(const A &arc) const {$/;"	f	class:fst::MultiLabelArcFilter
fst::MutableArcIterator	mutable-fst.h	/^class MutableArcIterator {$/;"	c	namespace:fst
fst::MutableArcIterator	vector-fst.h	/^class MutableArcIterator< VectorFst<A> >$/;"	c	namespace:fst
fst::MutableArcIterator::Arc	mutable-fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::MutableArcIterator
fst::MutableArcIterator::Done	mutable-fst.h	/^  bool Done() const { return data_.base->Done(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Done	vector-fst.h	/^  bool Done() const { return i_ >= state_->arcs.size(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Done_	vector-fst.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::FST	mutable-fst.h	/^  typedef F FST;$/;"	t	class:fst::MutableArcIterator
fst::MutableArcIterator::Flags	mutable-fst.h	/^  uint32 Flags() const { return data_.base->Flags(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Flags	vector-fst.h	/^  uint32 Flags() const {$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Flags_	vector-fst.h	/^  uint32 Flags_() const { return Flags(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::MutableArcIterator	mutable-fst.h	/^  MutableArcIterator(F *fst, StateId s) {$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::MutableArcIterator	vector-fst.h	/^  MutableArcIterator(VectorFst<A> *fst, StateId s) : i_(0) {$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Next	mutable-fst.h	/^  void Next() { data_.base->Next(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Next	vector-fst.h	/^  void Next() { ++i_; }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Next_	vector-fst.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Position	mutable-fst.h	/^  size_t Position() const { return data_.base->Position(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Position	vector-fst.h	/^  size_t Position() const { return i_; }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Position_	vector-fst.h	/^  virtual size_t Position_() const { return Position(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Reset	mutable-fst.h	/^  void Reset() { data_.base->Reset(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Reset	vector-fst.h	/^  void Reset() { i_ = 0; }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Reset_	vector-fst.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Seek	mutable-fst.h	/^  void Seek(size_t a) { data_.base->Seek(a); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Seek	vector-fst.h	/^  void Seek(size_t a) { i_ = a; }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Seek_	vector-fst.h	/^  virtual void Seek_(size_t a) { Seek(a); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::SetFlags	mutable-fst.h	/^  void SetFlags(uint32 f, uint32 m) {$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::SetFlags	vector-fst.h	/^  void SetFlags(uint32 f, uint32 m) {}$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::SetFlags_	vector-fst.h	/^  void SetFlags_(uint32 f, uint32 m) { SetFlags(f, m); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::SetValue	mutable-fst.h	/^  void SetValue(const Arc &a) { data_.base->SetValue(a); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::SetValue	vector-fst.h	/^  void SetValue(const A &arc) {$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::SetValue_	vector-fst.h	/^  virtual void SetValue_(const A &a) { SetValue(a); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::StateId	mutable-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::MutableArcIterator
fst::MutableArcIterator::StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::MutableArcIterator
fst::MutableArcIterator::Value	mutable-fst.h	/^  const Arc& Value() const { return data_.base->Value(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Value	vector-fst.h	/^  const A& Value() const { return state_->arcs[i_]; }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Value_	vector-fst.h	/^  virtual const A& Value_() const { return Value(); }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIterator::Weight	vector-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::MutableArcIterator
fst::MutableArcIterator::data_	mutable-fst.h	/^  MutableArcIteratorData<Arc> data_;$/;"	m	class:fst::MutableArcIterator
fst::MutableArcIterator::i_	vector-fst.h	/^  size_t i_;$/;"	m	class:fst::MutableArcIterator
fst::MutableArcIterator::properties_	vector-fst.h	/^  uint64 *properties_;$/;"	m	class:fst::MutableArcIterator
fst::MutableArcIterator::state_	vector-fst.h	/^  struct VectorState<A> *state_;$/;"	m	class:fst::MutableArcIterator	typeref:struct:fst::MutableArcIterator::VectorState
fst::MutableArcIterator::~MutableArcIterator	mutable-fst.h	/^  ~MutableArcIterator() { delete data_.base; }$/;"	f	class:fst::MutableArcIterator
fst::MutableArcIteratorBase	mutable-fst.h	/^class MutableArcIteratorBase : public ArcIteratorBase<A> {$/;"	c	namespace:fst
fst::MutableArcIteratorBase::Arc	mutable-fst.h	/^  typedef A Arc;$/;"	t	class:fst::MutableArcIteratorBase
fst::MutableArcIteratorBase::SetValue	mutable-fst.h	/^  void SetValue(const A &arc) { SetValue_(arc); }  \/\/ Set current arc's content$/;"	f	class:fst::MutableArcIteratorBase
fst::MutableArcIteratorData	mutable-fst.h	/^struct MutableArcIteratorData {$/;"	s	namespace:fst
fst::MutableArcIteratorData::base	mutable-fst.h	/^  MutableArcIteratorBase<A> *base;  \/\/ Specific iterator$/;"	m	struct:fst::MutableArcIteratorData
fst::MutableFst	mutable-fst.h	/^class MutableFst : public ExpandedFst<A> {$/;"	c	namespace:fst
fst::MutableFst::Arc	mutable-fst.h	/^  typedef A Arc;$/;"	t	class:fst::MutableFst
fst::MutableFst::Read	mutable-fst.h	/^  static MutableFst<A> *Read(const string &filename, bool convert = false,$/;"	f	class:fst::MutableFst
fst::MutableFst::Read	mutable-fst.h	/^  static MutableFst<A> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::MutableFst
fst::MutableFst::ReserveArcs	mutable-fst.h	/^  virtual void ReserveArcs(StateId s, size_t n) { }  \/\/ Optional, Best effort.$/;"	f	class:fst::MutableFst
fst::MutableFst::ReserveStates	mutable-fst.h	/^  virtual void ReserveStates(StateId n) { }  \/\/ Optional, best effort only.$/;"	f	class:fst::MutableFst
fst::MutableFst::StateId	mutable-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::MutableFst
fst::MutableFst::Weight	mutable-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::MutableFst
fst::MutableFst::operator =	mutable-fst.h	/^  MutableFst<A> &operator=(const MutableFst<A> &fst) {$/;"	f	class:fst::MutableFst
fst::Mutex	lock.h	/^class Mutex {$/;"	c	namespace:fst
fst::Mutex::Mutex	lock.h	/^  Mutex() {}$/;"	f	class:fst::Mutex
fst::MutexLock	lock.h	/^class MutexLock {$/;"	c	namespace:fst
fst::MutexLock::MutexLock	lock.h	/^  MutexLock(Mutex *) {}$/;"	f	class:fst::MutexLock
fst::NShortestPath	shortest-path.h	/^void NShortestPath(const Fst<RevArc> &ifst,$/;"	f	namespace:fst
fst::NaturalAStarQueue	queue.h	/^class NaturalAStarQueue :$/;"	c	namespace:fst
fst::NaturalAStarQueue::C	queue.h	/^  typedef AStarWeightCompare<S, NaturalLess<W>, E> C;$/;"	t	class:fst::NaturalAStarQueue
fst::NaturalAStarQueue::NaturalAStarQueue	queue.h	/^  NaturalAStarQueue(const vector<W> &distance, const E &estimate) :$/;"	f	class:fst::NaturalAStarQueue
fst::NaturalAStarQueue::less_	queue.h	/^  NaturalLess<W> less_;$/;"	m	class:fst::NaturalAStarQueue
fst::NaturalLess	weight.h	/^class NaturalLess {$/;"	c	namespace:fst
fst::NaturalLess::NaturalLess	weight.h	/^  NaturalLess() {$/;"	f	class:fst::NaturalLess
fst::NaturalLess::Weight	weight.h	/^  typedef W Weight;$/;"	t	class:fst::NaturalLess
fst::NaturalLess::operator ()	weight.h	/^  bool operator()(const W &w1, const W &w2) const {$/;"	f	class:fst::NaturalLess
fst::NaturalPruneQueue	queue.h	/^class NaturalPruneQueue :$/;"	c	namespace:fst
fst::NaturalPruneQueue::NaturalPruneQueue	queue.h	/^  NaturalPruneQueue(const vector<W> &distance, Q *queue,$/;"	f	class:fst::NaturalPruneQueue
fst::NaturalPruneQueue::StateId	queue.h	/^  typedef typename Q::StateId StateId;$/;"	t	class:fst::NaturalPruneQueue
fst::NaturalPruneQueue::Weight	queue.h	/^  typedef W Weight;$/;"	t	class:fst::NaturalPruneQueue
fst::NaturalPruneQueue::less_	queue.h	/^  NaturalLess<W> less_;$/;"	m	class:fst::NaturalPruneQueue
fst::NaturalShortestFirstQueue	queue.h	/^class NaturalShortestFirstQueue :$/;"	c	namespace:fst
fst::NaturalShortestFirstQueue::C	queue.h	/^  typedef StateWeightCompare<S, NaturalLess<W> > C;$/;"	t	class:fst::NaturalShortestFirstQueue
fst::NaturalShortestFirstQueue::NaturalShortestFirstQueue	queue.h	/^  NaturalShortestFirstQueue(const vector<W> &distance) :$/;"	f	class:fst::NaturalShortestFirstQueue
fst::NaturalShortestFirstQueue::less_	queue.h	/^  NaturalLess<W> less_;$/;"	m	class:fst::NaturalShortestFirstQueue
fst::NullAddOn	add-on.h	/^class NullAddOn {$/;"	c	namespace:fst
fst::NullAddOn::DecrRefCount	add-on.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::NullAddOn
fst::NullAddOn::IncrRefCount	add-on.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::NullAddOn
fst::NullAddOn::NullAddOn	add-on.h	/^  NullAddOn() {}$/;"	f	class:fst::NullAddOn
fst::NullAddOn::Read	add-on.h	/^  static NullAddOn *Read(istream &istrm) {$/;"	f	class:fst::NullAddOn
fst::NullAddOn::RefCount	add-on.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::NullAddOn
fst::NullAddOn::Write	add-on.h	/^  bool Write(ostream &ostrm) const { return true; }$/;"	f	class:fst::NullAddOn
fst::NullAddOn::ref_count_	add-on.h	/^  RefCounter ref_count_;$/;"	m	class:fst::NullAddOn
fst::NullMatcherFstInit	matcher-fst.h	/^class NullMatcherFstInit {$/;"	c	namespace:fst
fst::NullMatcherFstInit::D	matcher-fst.h	/^  typedef AddOnPair<typename M::MatcherData, typename M::MatcherData> D;$/;"	t	class:fst::NullMatcherFstInit
fst::NullMatcherFstInit::Impl	matcher-fst.h	/^  typedef AddOnImpl<typename M::FST, D> Impl;$/;"	t	class:fst::NullMatcherFstInit
fst::NullMatcherFstInit::NullMatcherFstInit	matcher-fst.h	/^  NullMatcherFstInit(Impl **) {}$/;"	f	class:fst::NullMatcherFstInit
fst::OLabelCompare	arcsort.h	/^template<class A> class OLabelCompare {$/;"	c	namespace:fst
fst::OLabelCompare::Properties	arcsort.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::OLabelCompare
fst::OLabelCompare::operator ()	arcsort.h	/^  bool operator() (const A &arc1, const A &arc2) const {$/;"	f	class:fst::OLabelCompare
fst::OTHER_QUEUE	queue.h	/^  OTHER_QUEUE = 8$/;"	e	enum:fst::QueueType
fst::OutputEpsilonArcFilter	arcfilter.h	/^class OutputEpsilonArcFilter {$/;"	c	namespace:fst
fst::OutputEpsilonArcFilter::operator ()	arcfilter.h	/^  bool operator()(const A &arc) const {$/;"	f	class:fst::OutputEpsilonArcFilter
fst::PROJECT_INPUT	project.h	/^enum ProjectType { PROJECT_INPUT = 1, PROJECT_OUTPUT = 2 };$/;"	e	enum:fst::ProjectType
fst::PROJECT_OUTPUT	project.h	/^enum ProjectType { PROJECT_INPUT = 1, PROJECT_OUTPUT = 2 };$/;"	e	enum:fst::ProjectType
fst::PairFilterState	compose-filter.h	/^class PairFilterState {$/;"	c	namespace:fst
fst::PairFilterState::GetState1	compose-filter.h	/^  const F1 &GetState1() const { return f1_; }$/;"	f	class:fst::PairFilterState
fst::PairFilterState::GetState2	compose-filter.h	/^  const F2 &GetState2() const { return f2_; }$/;"	f	class:fst::PairFilterState
fst::PairFilterState::Hash	compose-filter.h	/^  size_t Hash() const {$/;"	f	class:fst::PairFilterState
fst::PairFilterState::NoState	compose-filter.h	/^  static const PairFilterState NoState() { return PairFilterState(); }$/;"	f	class:fst::PairFilterState
fst::PairFilterState::PairFilterState	compose-filter.h	/^  PairFilterState() : f1_(F1::NoState()), f2_(F2::NoState()) {}$/;"	f	class:fst::PairFilterState
fst::PairFilterState::PairFilterState	compose-filter.h	/^  PairFilterState(const F1 &f1, const F2 &f2) : f1_(f1), f2_(f2) {}$/;"	f	class:fst::PairFilterState
fst::PairFilterState::SetState	compose-filter.h	/^  void SetState(const F1 &f1, const F2 &f2) {$/;"	f	class:fst::PairFilterState
fst::PairFilterState::f1_	compose-filter.h	/^  F1 f1_;$/;"	m	class:fst::PairFilterState
fst::PairFilterState::f2_	compose-filter.h	/^  F2 f2_;$/;"	m	class:fst::PairFilterState
fst::PairFilterState::operator !=	compose-filter.h	/^  bool operator!=(const PairFilterState &f) const {$/;"	f	class:fst::PairFilterState
fst::PairFilterState::operator ==	compose-filter.h	/^  bool operator==(const PairFilterState &f) const {$/;"	f	class:fst::PairFilterState
fst::PairWeight	pair-weight.h	/^class PairWeight {$/;"	c	namespace:fst
fst::PairWeight::Hash	pair-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::PairWeight
fst::PairWeight::Member	pair-weight.h	/^  bool Member() const { return value1_.Member() && value2_.Member(); }$/;"	f	class:fst::PairWeight
fst::PairWeight::NoWeight	pair-weight.h	/^  static const PairWeight<W1, W2> &NoWeight() {$/;"	f	class:fst::PairWeight
fst::PairWeight::One	pair-weight.h	/^  static const PairWeight<W1, W2> &One() {$/;"	f	class:fst::PairWeight
fst::PairWeight::PairWeight	pair-weight.h	/^  PairWeight() {}$/;"	f	class:fst::PairWeight
fst::PairWeight::PairWeight	pair-weight.h	/^  PairWeight(W1 w1, W2 w2) : value1_(w1), value2_(w2) {}$/;"	f	class:fst::PairWeight
fst::PairWeight::PairWeight	pair-weight.h	/^  PairWeight(const PairWeight& w) : value1_(w.value1_), value2_(w.value2_) {}$/;"	f	class:fst::PairWeight
fst::PairWeight::Quantize	pair-weight.h	/^  PairWeight<W1, W2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::PairWeight
fst::PairWeight::Read	pair-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::PairWeight
fst::PairWeight::ReadNoParen	pair-weight.h	/^  inline static istream &ReadNoParen($/;"	f	class:fst::PairWeight
fst::PairWeight::ReadWithParen	pair-weight.h	/^  inline static istream &ReadWithParen($/;"	f	class:fst::PairWeight
fst::PairWeight::Reverse	pair-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::PairWeight
fst::PairWeight::ReverseWeight	pair-weight.h	/^  ReverseWeight;$/;"	t	class:fst::PairWeight
fst::PairWeight::SetValue1	pair-weight.h	/^  void SetValue1(const W1 &w) { value1_ = w; }$/;"	f	class:fst::PairWeight
fst::PairWeight::SetValue2	pair-weight.h	/^  void SetValue2(const W2 &w) { value2_ = w; }$/;"	f	class:fst::PairWeight
fst::PairWeight::Value1	pair-weight.h	/^  const W1& Value1() const { return value1_; }$/;"	f	class:fst::PairWeight
fst::PairWeight::Value2	pair-weight.h	/^  const W2& Value2() const { return value2_; }$/;"	f	class:fst::PairWeight
fst::PairWeight::Write	pair-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::PairWeight
fst::PairWeight::Zero	pair-weight.h	/^  static const PairWeight<W1, W2> &Zero() {$/;"	f	class:fst::PairWeight
fst::PairWeight::operator =	pair-weight.h	/^  PairWeight<W1, W2> &operator=(const PairWeight<W1, W2> &w) {$/;"	f	class:fst::PairWeight
fst::PairWeight::value1_	pair-weight.h	/^  W1 value1_;$/;"	m	class:fst::PairWeight
fst::PairWeight::value2_	pair-weight.h	/^  W2 value2_;$/;"	m	class:fst::PairWeight
fst::PartialVisitor	visit.h	/^class PartialVisitor {$/;"	c	namespace:fst
fst::PartialVisitor::Arc	visit.h	/^  typedef A Arc;$/;"	t	class:fst::PartialVisitor
fst::PartialVisitor::BlackArc	visit.h	/^  bool BlackArc(StateId s, const Arc &arc) { return true; }$/;"	f	class:fst::PartialVisitor
fst::PartialVisitor::FinishState	visit.h	/^  void FinishState(StateId s) {}$/;"	f	class:fst::PartialVisitor
fst::PartialVisitor::FinishVisit	visit.h	/^  void FinishVisit() {}$/;"	f	class:fst::PartialVisitor
fst::PartialVisitor::GreyArc	visit.h	/^  bool GreyArc(StateId s, const Arc &arc) { return true; }$/;"	f	class:fst::PartialVisitor
fst::PartialVisitor::InitState	visit.h	/^  bool InitState(StateId s, StateId) {$/;"	f	class:fst::PartialVisitor
fst::PartialVisitor::InitVisit	visit.h	/^  void InitVisit(const Fst<A> &ifst) { nvisit_ = 0; }$/;"	f	class:fst::PartialVisitor
fst::PartialVisitor::PartialVisitor	visit.h	/^  explicit PartialVisitor(StateId maxvisit) : maxvisit_(maxvisit) {}$/;"	f	class:fst::PartialVisitor
fst::PartialVisitor::StateId	visit.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::PartialVisitor
fst::PartialVisitor::WhiteArc	visit.h	/^  bool WhiteArc(StateId s, const Arc &arc) { return true; }$/;"	f	class:fst::PartialVisitor
fst::PartialVisitor::maxvisit_	visit.h	/^  StateId maxvisit_;$/;"	m	class:fst::PartialVisitor
fst::PartialVisitor::nvisit_	visit.h	/^  StateId nvisit_;$/;"	m	class:fst::PartialVisitor
fst::Partition	partition.h	/^class Partition {$/;"	c	namespace:fst
fst::Partition::Add	partition.h	/^  void Add(T element_id, T class_id) {$/;"	f	class:fst::Partition
fst::Partition::AddClass	partition.h	/^  size_t AddClass() {$/;"	f	class:fst::Partition
fst::Partition::AllocateClasses	partition.h	/^  void AllocateClasses(T num_classes) {$/;"	f	class:fst::Partition
fst::Partition::Element	partition.h	/^  struct Element {$/;"	s	class:fst::Partition
fst::Partition::Element::Element	partition.h	/^    Element() : value(0), next(0), prev(0) {}$/;"	f	struct:fst::Partition::Element
fst::Partition::Element::Element	partition.h	/^    Element(T v) : value(v), next(0), prev(0) {}$/;"	f	struct:fst::Partition::Element
fst::Partition::Element::next	partition.h	/^   Element* next;$/;"	m	struct:fst::Partition::Element
fst::Partition::Element::prev	partition.h	/^   Element* prev;$/;"	m	struct:fst::Partition::Element
fst::Partition::Element::value	partition.h	/^   T        value;$/;"	m	struct:fst::Partition::Element
fst::Partition::FinalizeSplit	partition.h	/^  void FinalizeSplit(Queue* L) {$/;"	f	class:fst::Partition
fst::Partition::Initialize	partition.h	/^  void Initialize(size_t num_states) {$/;"	f	class:fst::Partition
fst::Partition::Move	partition.h	/^  void Move(T element_id, T class_id) {$/;"	f	class:fst::Partition
fst::Partition::Partition	partition.h	/^  Partition(bool allow_repeated_split):$/;"	f	class:fst::Partition
fst::Partition::Partition	partition.h	/^  Partition(bool allow_repeated_split, T num_states):$/;"	f	class:fst::Partition
fst::Partition::SplitOn	partition.h	/^  void SplitOn(T element_id) {$/;"	f	class:fst::Partition
fst::Partition::SplitRefine	partition.h	/^  T SplitRefine(T class_id) {$/;"	f	class:fst::Partition
fst::Partition::allow_repeated_split_	partition.h	/^  bool allow_repeated_split_;$/;"	m	class:fst::Partition
fst::Partition::class_id	partition.h	/^  const T class_id(T element_id) const {$/;"	f	class:fst::Partition
fst::Partition::class_index_	partition.h	/^  vector<T> class_index_;$/;"	m	class:fst::Partition
fst::Partition::class_size	partition.h	/^  const size_t class_size(T class_id)  const {$/;"	f	class:fst::Partition
fst::Partition::class_size_	partition.h	/^  vector<T> class_size_;$/;"	m	class:fst::Partition
fst::Partition::class_sizes	partition.h	/^  const vector<T>& class_sizes() const {$/;"	f	class:fst::Partition
fst::Partition::class_split_	partition.h	/^  vector<Element*> class_split_;$/;"	m	class:fst::Partition
fst::Partition::classes_	partition.h	/^  vector<Element*> classes_;$/;"	m	class:fst::Partition
fst::Partition::elements_	partition.h	/^  vector<Element*> elements_;$/;"	m	class:fst::Partition
fst::Partition::num_classes	partition.h	/^  const T num_classes() const {$/;"	f	class:fst::Partition
fst::Partition::num_states_	partition.h	/^  int num_states_;$/;"	m	class:fst::Partition
fst::Partition::split_size_	partition.h	/^  vector<T> split_size_;$/;"	m	class:fst::Partition
fst::Partition::visited_classes_	partition.h	/^  vector<T> visited_classes_;$/;"	m	class:fst::Partition
fst::Partition::~Partition	partition.h	/^  ~Partition() {$/;"	f	class:fst::Partition
fst::PartitionIterator	partition.h	/^class PartitionIterator {$/;"	c	namespace:fst
fst::PartitionIterator::Done	partition.h	/^  bool Done() {$/;"	f	class:fst::PartitionIterator
fst::PartitionIterator::Element	partition.h	/^  typedef typename Partition<T>::Element Element;$/;"	t	class:fst::PartitionIterator
fst::PartitionIterator::Next	partition.h	/^  void Next() {$/;"	f	class:fst::PartitionIterator
fst::PartitionIterator::PartitionIterator	partition.h	/^  PartitionIterator(const Partition<T>& partition, T class_id)$/;"	f	class:fst::PartitionIterator
fst::PartitionIterator::Reset	partition.h	/^  void Reset() {$/;"	f	class:fst::PartitionIterator
fst::PartitionIterator::Value	partition.h	/^  const T Value() {$/;"	f	class:fst::PartitionIterator
fst::PartitionIterator::class_id_	partition.h	/^  T class_id_;$/;"	m	class:fst::PartitionIterator
fst::PartitionIterator::element_	partition.h	/^  const Element* element_;$/;"	m	class:fst::PartitionIterator
fst::PartitionIterator::p_	partition.h	/^  const Partition<T>& p_;$/;"	m	class:fst::PartitionIterator
fst::PhiMatcher	matcher.h	/^class PhiMatcher : public MatcherBase<typename M::Arc> {$/;"	c	namespace:fst
fst::PhiMatcher::Arc	matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::PhiMatcher
fst::PhiMatcher::Copy	matcher.h	/^  virtual PhiMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::Done	matcher.h	/^  bool Done() const { return matcher_->Done(); }$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::Done_	matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::FST	matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::PhiMatcher
fst::PhiMatcher::Find	matcher.h	/^bool PhiMatcher<M>::Find(Label match_label) {$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::Find_	matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::GetFst	matcher.h	/^  virtual const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::PhiMatcher
fst::PhiMatcher::Next	matcher.h	/^  void Next() { matcher_->Next(); }$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::Next_	matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::PhiMatcher	matcher.h	/^  PhiMatcher(const FST &fst,$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::PhiMatcher	matcher.h	/^  PhiMatcher(const PhiMatcher<M> &matcher, bool safe = false)$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::Properties	matcher.h	/^uint64 PhiMatcher<M>::Properties(uint64 inprops) const {$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::SetState_	matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::PhiMatcher
fst::PhiMatcher::Type	matcher.h	/^  virtual MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::Value_	matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::PhiMatcher
fst::PhiMatcher::Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::PhiMatcher
fst::PhiMatcher::error_	matcher.h	/^  bool error_;             \/\/ Error encountered$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::has_phi_	matcher.h	/^  bool has_phi_;          \/\/ Are there possibly phis at the current state?$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::match_type_	matcher.h	/^  MatchType match_type_;  \/\/ Type of match requested$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::matcher_	matcher.h	/^  M *matcher_;$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::phi_arc_	matcher.h	/^  mutable Arc phi_arc_;   \/\/ Arc to return$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::phi_label_	matcher.h	/^  Label phi_label_;       \/\/ Label that represents the phi transition$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::phi_loop_	matcher.h	/^  bool phi_loop_;         \/\/ When true, phi self-loop are allowed and treated$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::phi_match_	matcher.h	/^  Label phi_match_;       \/\/ Current label that matches phi loop$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::phi_weight_	matcher.h	/^  Weight phi_weight_;     \/\/ Product of the weights of phi transitions taken$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::rewrite_both_	matcher.h	/^  bool rewrite_both_;     \/\/ Rewrite both sides when both are 'phi_label_'$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::state_	matcher.h	/^  StateId state_;         \/\/ State where looking for matches$/;"	m	class:fst::PhiMatcher
fst::PhiMatcher::~PhiMatcher	matcher.h	/^  virtual ~PhiMatcher() {$/;"	f	class:fst::PhiMatcher
fst::Plus	expectation-weight.h	/^inline ExpectationWeight<X1, X2> Plus(const ExpectationWeight<X1, X2> &w,$/;"	f	namespace:fst
fst::Plus	float-weight.h	/^inline LogWeightTpl<T> Plus(const LogWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Plus	float-weight.h	/^inline LogWeightTpl<double> Plus(const LogWeightTpl<double> &w1,$/;"	f	namespace:fst
fst::Plus	float-weight.h	/^inline LogWeightTpl<float> Plus(const LogWeightTpl<float> &w1,$/;"	f	namespace:fst
fst::Plus	float-weight.h	/^inline MinMaxWeightTpl<T> Plus($/;"	f	namespace:fst
fst::Plus	float-weight.h	/^inline MinMaxWeightTpl<double> Plus($/;"	f	namespace:fst
fst::Plus	float-weight.h	/^inline MinMaxWeightTpl<float> Plus($/;"	f	namespace:fst
fst::Plus	float-weight.h	/^inline TropicalWeightTpl<T> Plus(const TropicalWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Plus	float-weight.h	/^inline TropicalWeightTpl<double> Plus(const TropicalWeightTpl<double> &w1,$/;"	f	namespace:fst
fst::Plus	float-weight.h	/^inline TropicalWeightTpl<float> Plus(const TropicalWeightTpl<float> &w1,$/;"	f	namespace:fst
fst::Plus	lexicographic-weight.h	/^inline LexicographicWeight<W1, W2> Plus(const LexicographicWeight<W1, W2> &w,$/;"	f	namespace:fst
fst::Plus	power-weight.h	/^inline PowerWeight<W, n> Plus(const PowerWeight<W, n> &w1,$/;"	f	namespace:fst
fst::Plus	product-weight.h	/^inline ProductWeight<W1, W2> Plus(const ProductWeight<W1, W2> &w,$/;"	f	namespace:fst
fst::Plus	signed-log-weight.h	/^inline SignedLogWeightTpl<T> Plus(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Plus	sparse-power-weight.h	/^inline SparsePowerWeight<W, K> Plus(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
fst::Plus	string-weight.h	/^Plus(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
fst::Plus	string-weight.h	/^Plus(const StringWeight<L, STRING_LEFT> &w1,$/;"	f	namespace:fst
fst::Plus	string-weight.h	/^Plus(const StringWeight<L, STRING_RIGHT> &w1,$/;"	f	namespace:fst
fst::PlusMapper	arc-map.h	/^struct PlusMapper {$/;"	s	namespace:fst
fst::PlusMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::PlusMapper
fst::PlusMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::PlusMapper
fst::PlusMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::PlusMapper
fst::PlusMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::PlusMapper
fst::PlusMapper::PlusMapper	arc-map.h	/^  explicit PlusMapper(Weight w) : weight_(w) {}$/;"	f	struct:fst::PlusMapper
fst::PlusMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::PlusMapper
fst::PlusMapper::ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::PlusMapper
fst::PlusMapper::Weight	arc-map.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::PlusMapper
fst::PlusMapper::operator ()	arc-map.h	/^  A operator()(const A &arc) const {$/;"	f	struct:fst::PlusMapper
fst::PlusMapper::weight_	arc-map.h	/^  Weight weight_;$/;"	m	struct:fst::PlusMapper
fst::Power	weight.h	/^W Power(W w, size_t n) {$/;"	f	namespace:fst
fst::PowerArc	arc.h	/^struct PowerArc {$/;"	s	namespace:fst
fst::PowerArc::Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::PowerArc
fst::PowerArc::Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::PowerArc
fst::PowerArc::PowerArc	arc.h	/^  PowerArc() {}$/;"	f	struct:fst::PowerArc
fst::PowerArc::PowerArc	arc.h	/^  PowerArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::PowerArc
fst::PowerArc::StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::PowerArc
fst::PowerArc::Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::PowerArc
fst::PowerArc::Weight	arc.h	/^  typedef PowerWeight<typename A::Weight, n> Weight;$/;"	t	struct:fst::PowerArc
fst::PowerArc::ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::PowerArc
fst::PowerArc::nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::PowerArc
fst::PowerArc::olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::PowerArc
fst::PowerArc::weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::PowerArc
fst::PowerWeight	power-weight.h	/^class PowerWeight : public TupleWeight<W, n> {$/;"	c	namespace:fst
fst::PowerWeight::NoWeight	power-weight.h	/^  static const PowerWeight<W, n> &NoWeight() {$/;"	f	class:fst::PowerWeight
fst::PowerWeight::One	power-weight.h	/^  static const PowerWeight<W, n> &One() {$/;"	f	class:fst::PowerWeight
fst::PowerWeight::PowerWeight	power-weight.h	/^  PowerWeight() {}$/;"	f	class:fst::PowerWeight
fst::PowerWeight::PowerWeight	power-weight.h	/^  PowerWeight(Iterator begin, Iterator end) : TupleWeight<W, n>(begin, end) {}$/;"	f	class:fst::PowerWeight
fst::PowerWeight::PowerWeight	power-weight.h	/^  PowerWeight(const TupleWeight<W, n> &w) : TupleWeight<W, n>(w) {}$/;"	f	class:fst::PowerWeight
fst::PowerWeight::Properties	power-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::PowerWeight
fst::PowerWeight::Quantize	power-weight.h	/^  PowerWeight<W, n> Quantize(float delta = kDelta) const {$/;"	f	class:fst::PowerWeight
fst::PowerWeight::Reverse	power-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::PowerWeight
fst::PowerWeight::ReverseWeight	power-weight.h	/^  typedef PowerWeight<typename W::ReverseWeight, n> ReverseWeight;$/;"	t	class:fst::PowerWeight
fst::PowerWeight::Type	power-weight.h	/^  static const string &Type() {$/;"	f	class:fst::PowerWeight
fst::PowerWeight::Zero	power-weight.h	/^  static const PowerWeight<W, n> &Zero() {$/;"	f	class:fst::PowerWeight
fst::PowerWeightGenerator	random-weight.h	/^class PowerWeightGenerator {$/;"	c	namespace:fst
fst::PowerWeightGenerator::PowerWeightGenerator	random-weight.h	/^  PowerWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::PowerWeightGenerator
fst::PowerWeightGenerator::W	random-weight.h	/^  typedef typename G::Weight W;$/;"	t	class:fst::PowerWeightGenerator
fst::PowerWeightGenerator::Weight	random-weight.h	/^  typedef PowerWeight<W, n> Weight;$/;"	t	class:fst::PowerWeightGenerator
fst::PowerWeightGenerator::generator_	random-weight.h	/^  G generator_;$/;"	m	class:fst::PowerWeightGenerator
fst::PowerWeightGenerator::operator ()	random-weight.h	/^  Weight operator()() const {$/;"	f	class:fst::PowerWeightGenerator
fst::ProductArc	arc.h	/^struct ProductArc {$/;"	s	namespace:fst
fst::ProductArc::Label	arc.h	/^  typedef int Label;$/;"	t	struct:fst::ProductArc
fst::ProductArc::ProductArc	arc.h	/^  ProductArc() {}$/;"	f	struct:fst::ProductArc
fst::ProductArc::ProductArc	arc.h	/^  ProductArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::ProductArc
fst::ProductArc::StateId	arc.h	/^  typedef int StateId;$/;"	t	struct:fst::ProductArc
fst::ProductArc::Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::ProductArc
fst::ProductArc::Weight	arc.h	/^  typedef ProductWeight<W1, W2> Weight;$/;"	t	struct:fst::ProductArc
fst::ProductArc::ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::ProductArc
fst::ProductArc::nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::ProductArc
fst::ProductArc::olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::ProductArc
fst::ProductArc::weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::ProductArc
fst::ProductComposeStateTable	state-table.h	/^class ProductComposeStateTable : public$/;"	c	namespace:fst
fst::ProductComposeStateTable::Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::ProductComposeStateTable
fst::ProductComposeStateTable::Error	state-table.h	/^  bool Error() const { return false; }$/;"	f	class:fst::ProductComposeStateTable
fst::ProductComposeStateTable::FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::ProductComposeStateTable
fst::ProductComposeStateTable::ProductComposeStateTable	state-table.h	/^  ProductComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2)$/;"	f	class:fst::ProductComposeStateTable
fst::ProductComposeStateTable::ProductComposeStateTable	state-table.h	/^  ProductComposeStateTable(const ProductComposeStateTable<A, F> &table)$/;"	f	class:fst::ProductComposeStateTable
fst::ProductComposeStateTable::StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ProductComposeStateTable
fst::ProductComposeStateTable::StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::ProductComposeStateTable
fst::ProductWeight	product-weight.h	/^class ProductWeight : public PairWeight<W1, W2> {$/;"	c	namespace:fst
fst::ProductWeight::NoWeight	product-weight.h	/^  static const ProductWeight<W1, W2> &NoWeight() {$/;"	f	class:fst::ProductWeight
fst::ProductWeight::One	product-weight.h	/^  static const ProductWeight<W1, W2> &One() {$/;"	f	class:fst::ProductWeight
fst::ProductWeight::ProductWeight	product-weight.h	/^  ProductWeight() {}$/;"	f	class:fst::ProductWeight
fst::ProductWeight::ProductWeight	product-weight.h	/^  ProductWeight(W1 w1, W2 w2) : PairWeight<W1, W2>(w1, w2) {}$/;"	f	class:fst::ProductWeight
fst::ProductWeight::ProductWeight	product-weight.h	/^  ProductWeight(const PairWeight<W1, W2>& w) : PairWeight<W1, W2>(w) {}$/;"	f	class:fst::ProductWeight
fst::ProductWeight::Properties	product-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::ProductWeight
fst::ProductWeight::Quantize	product-weight.h	/^  ProductWeight<W1, W2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::ProductWeight
fst::ProductWeight::Reverse	product-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::ProductWeight
fst::ProductWeight::ReverseWeight	product-weight.h	/^  ReverseWeight;$/;"	t	class:fst::ProductWeight
fst::ProductWeight::Type	product-weight.h	/^  static const string &Type() {$/;"	f	class:fst::ProductWeight
fst::ProductWeight::Zero	product-weight.h	/^  static const ProductWeight<W1, W2> &Zero() {$/;"	f	class:fst::ProductWeight
fst::ProductWeightGenerator	random-weight.h	/^class ProductWeightGenerator {$/;"	c	namespace:fst
fst::ProductWeightGenerator::ProductWeightGenerator	random-weight.h	/^  ProductWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::ProductWeightGenerator
fst::ProductWeightGenerator::W1	random-weight.h	/^  typedef typename G1::Weight W1;$/;"	t	class:fst::ProductWeightGenerator
fst::ProductWeightGenerator::W2	random-weight.h	/^  typedef typename G2::Weight W2;$/;"	t	class:fst::ProductWeightGenerator
fst::ProductWeightGenerator::Weight	random-weight.h	/^  typedef W Weight;$/;"	t	class:fst::ProductWeightGenerator
fst::ProductWeightGenerator::generator1_	random-weight.h	/^  G1 generator1_;$/;"	m	class:fst::ProductWeightGenerator
fst::ProductWeightGenerator::generator2_	random-weight.h	/^  G2 generator2_;$/;"	m	class:fst::ProductWeightGenerator
fst::ProductWeightGenerator::operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::ProductWeightGenerator
fst::Project	project.h	/^void Project(MutableFst<Arc> *fst, ProjectType project_type) {$/;"	f	namespace:fst
fst::ProjectFst	project.h	/^class ProjectFst : public ArcMapFst<A, A, ProjectMapper<A> > {$/;"	c	namespace:fst
fst::ProjectFst::Arc	project.h	/^  typedef A Arc;$/;"	t	class:fst::ProjectFst
fst::ProjectFst::C	project.h	/^  typedef ProjectMapper<A> C;$/;"	t	class:fst::ProjectFst
fst::ProjectFst::Copy	project.h	/^  virtual ProjectFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::ProjectFst
fst::ProjectFst::Impl	project.h	/^  typedef ArcMapFstImpl< A, A, ProjectMapper<A> > Impl;$/;"	t	class:fst::ProjectFst
fst::ProjectFst::ProjectFst	project.h	/^  ProjectFst(const Fst<A> &fst, ProjectType project_type)$/;"	f	class:fst::ProjectFst
fst::ProjectFst::ProjectFst	project.h	/^  ProjectFst(const ProjectFst<A> &fst, bool safe = false)$/;"	f	class:fst::ProjectFst
fst::ProjectMapper	project.h	/^template <class A> class ProjectMapper {$/;"	c	namespace:fst
fst::ProjectMapper::FinalAction	project.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::ProjectMapper
fst::ProjectMapper::InputSymbolsAction	project.h	/^  MapSymbolsAction InputSymbolsAction() const {$/;"	f	class:fst::ProjectMapper
fst::ProjectMapper::OutputSymbolsAction	project.h	/^  MapSymbolsAction OutputSymbolsAction() const {$/;"	f	class:fst::ProjectMapper
fst::ProjectMapper::ProjectMapper	project.h	/^  explicit ProjectMapper(ProjectType project_type)$/;"	f	class:fst::ProjectMapper
fst::ProjectMapper::Properties	project.h	/^  uint64 Properties(uint64 props) {$/;"	f	class:fst::ProjectMapper
fst::ProjectMapper::operator ()	project.h	/^  A operator()(const A &arc) {$/;"	f	class:fst::ProjectMapper
fst::ProjectMapper::project_type_	project.h	/^  ProjectType project_type_;$/;"	m	class:fst::ProjectMapper
fst::ProjectType	project.h	/^enum ProjectType { PROJECT_INPUT = 1, PROJECT_OUTPUT = 2 };$/;"	g	namespace:fst
fst::Prune	prune.h	/^void Prune(MutableFst<Arc> *fst,$/;"	f	namespace:fst
fst::Prune	prune.h	/^void Prune(const Fst<Arc> &ifst,$/;"	f	namespace:fst
fst::PruneCompare	prune.h	/^class PruneCompare {$/;"	c	namespace:fst
fst::PruneCompare::PruneCompare	prune.h	/^  PruneCompare(const vector<Weight> &idistance,$/;"	f	class:fst::PruneCompare
fst::PruneCompare::StateId	prune.h	/^  typedef S StateId;$/;"	t	class:fst::PruneCompare
fst::PruneCompare::Weight	prune.h	/^  typedef W Weight;$/;"	t	class:fst::PruneCompare
fst::PruneCompare::fdistance_	prune.h	/^  const vector<Weight> &fdistance_;$/;"	m	class:fst::PruneCompare
fst::PruneCompare::idistance_	prune.h	/^  const vector<Weight> &idistance_;$/;"	m	class:fst::PruneCompare
fst::PruneCompare::less_	prune.h	/^  NaturalLess<Weight> less_;$/;"	m	class:fst::PruneCompare
fst::PruneCompare::operator ()	prune.h	/^  bool operator()(const StateId x, const StateId y) const {$/;"	f	class:fst::PruneCompare
fst::PruneOptions	prune.h	/^class PruneOptions {$/;"	c	namespace:fst
fst::PruneOptions::PruneOptions	prune.h	/^  explicit PruneOptions(const Weight& w, StateId s, ArcFilter f,$/;"	f	class:fst::PruneOptions
fst::PruneOptions::StateId	prune.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::PruneOptions
fst::PruneOptions::Weight	prune.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::PruneOptions
fst::PruneOptions::delta	prune.h	/^  float delta;$/;"	m	class:fst::PruneOptions
fst::PruneOptions::distance	prune.h	/^  const vector<Weight> *distance;$/;"	m	class:fst::PruneOptions
fst::PruneOptions::filter	prune.h	/^  ArcFilter filter;$/;"	m	class:fst::PruneOptions
fst::PruneOptions::state_threshold	prune.h	/^  StateId state_threshold;$/;"	m	class:fst::PruneOptions
fst::PruneOptions::weight_threshold	prune.h	/^  Weight weight_threshold;$/;"	m	class:fst::PruneOptions
fst::PruneQueue	queue.h	/^class PruneQueue : public QueueBase<typename Q::StateId> {$/;"	c	namespace:fst
fst::PruneQueue::Clear	queue.h	/^  void Clear() { queue_->Clear(); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Dequeue	queue.h	/^  void Dequeue() { queue_->Dequeue(); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Empty	queue.h	/^  bool Empty() const { return queue_->Empty(); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Head	queue.h	/^  StateId Head() const { return queue_->Head(); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::PruneQueue	queue.h	/^  PruneQueue(const vector<Weight> &distance, Q *queue, L comp,$/;"	f	class:fst::PruneQueue
fst::PruneQueue::StateId	queue.h	/^  typedef typename Q::StateId StateId;$/;"	t	class:fst::PruneQueue
fst::PruneQueue::Update	queue.h	/^  void Update(StateId s) {$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::PruneQueue
fst::PruneQueue::Weight	queue.h	/^  typedef typename L::Weight Weight;$/;"	t	class:fst::PruneQueue
fst::PruneQueue::class_distance_	queue.h	/^  vector<Weight> class_distance_;          \/\/ shortest distance to class$/;"	m	class:fst::PruneQueue
fst::PruneQueue::class_func_	queue.h	/^  const C &class_func_;                    \/\/ eqv. class function object$/;"	m	class:fst::PruneQueue
fst::PruneQueue::distance_	queue.h	/^  const vector<Weight> &distance_;         \/\/ shortest distance to state$/;"	m	class:fst::PruneQueue
fst::PruneQueue::less_	queue.h	/^  L less_;$/;"	m	class:fst::PruneQueue
fst::PruneQueue::queue_	queue.h	/^  Q *queue_;$/;"	m	class:fst::PruneQueue
fst::PruneQueue::threshold_	queue.h	/^  Weight threshold_;                       \/\/ pruning weight threshold$/;"	m	class:fst::PruneQueue
fst::PruneQueue::~PruneQueue	queue.h	/^  ~PruneQueue() { delete queue_; }$/;"	f	class:fst::PruneQueue
fst::PruneSymbolTable	symbol-table-ops.h	/^SymbolTable *PruneSymbolTable(const Fst<Arc> &fst, const SymbolTable &syms,$/;"	f	namespace:fst
fst::Push	push.h	/^void Push(MutableFst<Arc> *fst,$/;"	f	namespace:fst
fst::Push	push.h	/^void Push(const Fst<Arc> &ifst,$/;"	f	namespace:fst
fst::PushLabelsComposeFilter	lookahead-filter.h	/^class PushLabelsComposeFilter {$/;"	c	namespace:fst
fst::PushLabelsComposeFilter::Arc	lookahead-filter.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::FST1	lookahead-filter.h	/^  typedef typename F::FST1 FST1;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::FST2	lookahead-filter.h	/^  typedef typename F::FST2 FST2;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::FilterArc	lookahead-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::FilterFinal	lookahead-filter.h	/^  void FilterFinal(Weight *weight1, Weight *weight2) const {$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::FilterState	lookahead-filter.h	/^  typedef PairFilterState<FilterState1, FilterState2> FilterState;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::FilterState1	lookahead-filter.h	/^  typedef typename F::FilterState FilterState1;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::FilterState2	lookahead-filter.h	/^  typedef IntegerFilterState<typename Arc::Label> FilterState2;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::GetMatcher1	lookahead-filter.h	/^  Matcher1 *GetMatcher1() { return &matcher1_; }$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::GetMatcher2	lookahead-filter.h	/^  Matcher2 *GetMatcher2() { return &matcher2_; }$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::Label	lookahead-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::LookAheadArc	lookahead-filter.h	/^  bool LookAheadArc() const { return filter_.LookAheadArc(); }$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::LookAheadFlags	lookahead-filter.h	/^  uint32 LookAheadFlags() const { return filter_.LookAheadFlags(); }$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::LookAheadOutput	lookahead-filter.h	/^  bool LookAheadOutput() const { return filter_.LookAheadOutput(); }$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::Matcher1	lookahead-filter.h	/^  typedef MultiEpsMatcher<typename F::Matcher1> Matcher1;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::Matcher2	lookahead-filter.h	/^  typedef MultiEpsMatcher<typename F::Matcher2> Matcher2;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::Properties	lookahead-filter.h	/^  uint64 Properties(uint64 iprops) const {$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::PushLabelFilterArc	lookahead-filter.h	/^  FilterState PushLabelFilterArc(Arc *arca, Arc *arcb,$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::PushLabelsComposeFilter	lookahead-filter.h	/^  PushLabelsComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::PushLabelsComposeFilter	lookahead-filter.h	/^  PushLabelsComposeFilter(const PushLabelsComposeFilter<F, M1, M2, MT> &filter,$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::PushedLabelFilterArc	lookahead-filter.h	/^  FilterState PushedLabelFilterArc(Arc *arca, Arc *arcb,$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::Selector	lookahead-filter.h	/^  &Selector() const {$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::SetState	lookahead-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::Start	lookahead-filter.h	/^  FilterState Start() const {$/;"	f	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::StateId	lookahead-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::Weight	lookahead-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::f_	lookahead-filter.h	/^  FilterState f_ ;            \/\/ Current filter state$/;"	m	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::filter_	lookahead-filter.h	/^  F filter_;                  \/\/ Underlying filter$/;"	m	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::fst1_	lookahead-filter.h	/^  const FST1 &fst1_;$/;"	m	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::fst2_	lookahead-filter.h	/^  const FST2 &fst2_;$/;"	m	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::matcher1_	lookahead-filter.h	/^  Matcher1 matcher1_;         \/\/ Multi-epsilon matcher for fst1$/;"	m	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::matcher2_	lookahead-filter.h	/^  Matcher2 matcher2_;         \/\/ Multi-epsilon matcher for fst2$/;"	m	class:fst::PushLabelsComposeFilter
fst::PushLabelsComposeFilter::narcsa_	lookahead-filter.h	/^  ssize_t narcsa_;            \/\/ Number of arcs leaving look-ahead match FST$/;"	m	class:fst::PushLabelsComposeFilter
fst::PushWeightsComposeFilter	lookahead-filter.h	/^class PushWeightsComposeFilter {$/;"	c	namespace:fst
fst::PushWeightsComposeFilter::Arc	lookahead-filter.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::FST1	lookahead-filter.h	/^  typedef typename F::FST1 FST1;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::FST2	lookahead-filter.h	/^  typedef typename F::FST2 FST2;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::FilterArc	lookahead-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::FilterFinal	lookahead-filter.h	/^  void FilterFinal(Weight *weight1, Weight *weight2) const {$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::FilterState	lookahead-filter.h	/^  typedef PairFilterState<FilterState1, FilterState2> FilterState;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::FilterState1	lookahead-filter.h	/^  typedef typename F::FilterState FilterState1;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::FilterState2	lookahead-filter.h	/^  typedef WeightFilterState<typename Arc::Weight> FilterState2;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::GetMatcher1	lookahead-filter.h	/^  Matcher1 *GetMatcher1() { return filter_.GetMatcher1(); }$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::GetMatcher2	lookahead-filter.h	/^  Matcher2 *GetMatcher2() { return filter_.GetMatcher2(); }$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::Label	lookahead-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::LookAheadArc	lookahead-filter.h	/^  bool LookAheadArc() const { return filter_.LookAheadArc(); }$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::LookAheadFlags	lookahead-filter.h	/^  uint32 LookAheadFlags() const { return filter_.LookAheadFlags(); }$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::LookAheadOutput	lookahead-filter.h	/^  bool LookAheadOutput() const { return filter_.LookAheadOutput(); }$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::Matcher1	lookahead-filter.h	/^  typedef typename F::Matcher1 Matcher1;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::Matcher2	lookahead-filter.h	/^  typedef typename F::Matcher2 Matcher2;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::Properties	lookahead-filter.h	/^  uint64 Properties(uint64 props) const {$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::PushWeightsComposeFilter	lookahead-filter.h	/^  PushWeightsComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::PushWeightsComposeFilter	lookahead-filter.h	/^  PushWeightsComposeFilter(const PushWeightsComposeFilter<F, M1, M2, MT>$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::Selector	lookahead-filter.h	/^  const LookAheadSelector<Matcher1, Matcher2, MT> &Selector() const {$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::SetState	lookahead-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::Start	lookahead-filter.h	/^  FilterState Start() const {$/;"	f	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::StateId	lookahead-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::Weight	lookahead-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::f_	lookahead-filter.h	/^  FilterState f_;                  \/\/ Current filter state$/;"	m	class:fst::PushWeightsComposeFilter
fst::PushWeightsComposeFilter::filter_	lookahead-filter.h	/^  F filter_;                       \/\/ Underlying filter$/;"	m	class:fst::PushWeightsComposeFilter
fst::QuantizeMapper	arc-map.h	/^struct QuantizeMapper {$/;"	s	namespace:fst
fst::QuantizeMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::QuantizeMapper
fst::QuantizeMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::QuantizeMapper
fst::QuantizeMapper::FromWeight	arc-map.h	/^  typedef typename FromArc::Weight FromWeight;$/;"	t	struct:fst::QuantizeMapper
fst::QuantizeMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::QuantizeMapper
fst::QuantizeMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::QuantizeMapper
fst::QuantizeMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::QuantizeMapper
fst::QuantizeMapper::QuantizeMapper	arc-map.h	/^  QuantizeMapper() : delta_(kDelta) {}$/;"	f	struct:fst::QuantizeMapper
fst::QuantizeMapper::QuantizeMapper	arc-map.h	/^  explicit QuantizeMapper(float d) : delta_(d) {}$/;"	f	struct:fst::QuantizeMapper
fst::QuantizeMapper::ToArc	arc-map.h	/^  typedef B ToArc;$/;"	t	struct:fst::QuantizeMapper
fst::QuantizeMapper::ToWeight	arc-map.h	/^  typedef typename ToArc::Weight ToWeight;$/;"	t	struct:fst::QuantizeMapper
fst::QuantizeMapper::delta_	arc-map.h	/^  float delta_;$/;"	m	struct:fst::QuantizeMapper
fst::QuantizeMapper::operator ()	arc-map.h	/^  B operator()(const A &arc) const {$/;"	f	struct:fst::QuantizeMapper
fst::QueueBase	queue.h	/^class QueueBase {$/;"	c	namespace:fst
fst::QueueBase::Clear	queue.h	/^  void Clear() { Clear_(); }$/;"	f	class:fst::QueueBase
fst::QueueBase::Dequeue	queue.h	/^  void Dequeue() { Dequeue_(); }$/;"	f	class:fst::QueueBase
fst::QueueBase::Empty	queue.h	/^  bool Empty() const { return Empty_(); }$/;"	f	class:fst::QueueBase
fst::QueueBase::Enqueue	queue.h	/^  void Enqueue(StateId s) { Enqueue_(s); }$/;"	f	class:fst::QueueBase
fst::QueueBase::Error	queue.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::QueueBase
fst::QueueBase::Head	queue.h	/^  StateId Head() const { return Head_(); }$/;"	f	class:fst::QueueBase
fst::QueueBase::QueueBase	queue.h	/^  QueueBase(QueueType type) : queue_type_(type), error_(false) {}$/;"	f	class:fst::QueueBase
fst::QueueBase::SetError	queue.h	/^  void SetError(bool error) { error_ = error; }$/;"	f	class:fst::QueueBase
fst::QueueBase::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::QueueBase
fst::QueueBase::Type	queue.h	/^  QueueType Type() { return queue_type_; }$/;"	f	class:fst::QueueBase
fst::QueueBase::Update	queue.h	/^  void Update(StateId s) { Update_(s); }$/;"	f	class:fst::QueueBase
fst::QueueBase::error_	queue.h	/^  bool error_;$/;"	m	class:fst::QueueBase
fst::QueueBase::queue_type_	queue.h	/^  QueueType queue_type_;$/;"	m	class:fst::QueueBase
fst::QueueBase::~QueueBase	queue.h	/^  virtual ~QueueBase() {}$/;"	f	class:fst::QueueBase
fst::QueueType	queue.h	/^enum QueueType {$/;"	g	namespace:fst
fst::REWEIGHT_TO_FINAL	reweight.h	/^enum ReweightType { REWEIGHT_TO_INITIAL, REWEIGHT_TO_FINAL };$/;"	e	enum:fst::ReweightType
fst::REWEIGHT_TO_INITIAL	reweight.h	/^enum ReweightType { REWEIGHT_TO_INITIAL, REWEIGHT_TO_FINAL };$/;"	e	enum:fst::ReweightType
fst::RandEquivalent	randequivalent.h	/^bool RandEquivalent(const Fst<Arc> &fst1, const Fst<Arc> &fst2,$/;"	f	namespace:fst
fst::RandGen	randgen.h	/^void RandGen(const Fst<IArc> &ifst, MutableFst<OArc> *ofst) {$/;"	f	namespace:fst
fst::RandGen	randgen.h	/^void RandGen(const Fst<IArc> &ifst, MutableFst<OArc> *ofst,$/;"	f	namespace:fst
fst::RandGenFst	randgen.h	/^class RandGenFst : public ImplToFst< RandGenFstImpl<A, B, S> > {$/;"	c	namespace:fst
fst::RandGenFst::Arc	randgen.h	/^  typedef B Arc;$/;"	t	class:fst::RandGenFst
fst::RandGenFst::Copy	randgen.h	/^  virtual RandGenFst<A, B, S> *Copy(bool safe = false) const {$/;"	f	class:fst::RandGenFst
fst::RandGenFst::GetImpl	randgen.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::RandGenFst
fst::RandGenFst::Impl	randgen.h	/^  typedef RandGenFstImpl<A, B, S> Impl;$/;"	t	class:fst::RandGenFst
fst::RandGenFst::InitArcIterator	randgen.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<B> *data) const {$/;"	f	class:fst::RandGenFst
fst::RandGenFst::InitStateIterator	randgen.h	/^void RandGenFst<A, B, S>::InitStateIterator(StateIteratorData<B> *data) const$/;"	f	class:fst::RandGenFst
fst::RandGenFst::Label	randgen.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::RandGenFst
fst::RandGenFst::RandGenFst	randgen.h	/^  RandGenFst(const Fst<A> &fst, const RandGenFstOptions<S> &opts)$/;"	f	class:fst::RandGenFst
fst::RandGenFst::RandGenFst	randgen.h	/^ RandGenFst(const RandGenFst<A, B, S> &fst, bool safe = false)$/;"	f	class:fst::RandGenFst
fst::RandGenFst::Sampler	randgen.h	/^  typedef S Sampler;$/;"	t	class:fst::RandGenFst
fst::RandGenFst::State	randgen.h	/^  typedef CacheState<B> State;$/;"	t	class:fst::RandGenFst
fst::RandGenFst::StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RandGenFst
fst::RandGenFst::Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::RandGenFst
fst::RandGenFstImpl	randgen.h	/^class RandGenFstImpl : public CacheImpl<B> {$/;"	c	namespace:fst
fst::RandGenFstImpl::Arc	randgen.h	/^  typedef B Arc;$/;"	t	class:fst::RandGenFstImpl
fst::RandGenFstImpl::Expand	randgen.h	/^  void Expand(StateId s) {$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::Final	randgen.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::InitArcIterator	randgen.h	/^  void InitArcIterator(StateId s, ArcIteratorData<B> *data) {$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::Label	randgen.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::RandGenFstImpl
fst::RandGenFstImpl::NumArcs	randgen.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::NumInputEpsilons	randgen.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::NumOutputEpsilons	randgen.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::Properties	randgen.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::Properties	randgen.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::RandGenFstImpl	randgen.h	/^  RandGenFstImpl(const Fst<A> &fst, const RandGenFstOptions<S> &opts)$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::RandGenFstImpl	randgen.h	/^  RandGenFstImpl(const RandGenFstImpl &impl)$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::Start	randgen.h	/^  StateId Start() {$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstImpl::StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RandGenFstImpl
fst::RandGenFstImpl::Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::RandGenFstImpl
fst::RandGenFstImpl::arc_sampler_	randgen.h	/^  S *arc_sampler_;$/;"	m	class:fst::RandGenFstImpl
fst::RandGenFstImpl::fst_	randgen.h	/^  Fst<A> *fst_;$/;"	m	class:fst::RandGenFstImpl
fst::RandGenFstImpl::npath_	randgen.h	/^  size_t npath_;$/;"	m	class:fst::RandGenFstImpl
fst::RandGenFstImpl::remove_total_weight_	randgen.h	/^  bool remove_total_weight_;$/;"	m	class:fst::RandGenFstImpl
fst::RandGenFstImpl::state_table_	randgen.h	/^  vector<RandState<A> *> state_table_;$/;"	m	class:fst::RandGenFstImpl
fst::RandGenFstImpl::superfinal_	randgen.h	/^  StateId superfinal_;$/;"	m	class:fst::RandGenFstImpl
fst::RandGenFstImpl::to_weight_	randgen.h	/^  WeightConvert<Log64Weight, Weight> to_weight_;$/;"	m	class:fst::RandGenFstImpl
fst::RandGenFstImpl::weighted_	randgen.h	/^  bool weighted_;$/;"	m	class:fst::RandGenFstImpl
fst::RandGenFstImpl::~RandGenFstImpl	randgen.h	/^  ~RandGenFstImpl() {$/;"	f	class:fst::RandGenFstImpl
fst::RandGenFstOptions	randgen.h	/^struct RandGenFstOptions : public CacheOptions {$/;"	s	namespace:fst
fst::RandGenFstOptions::RandGenFstOptions	randgen.h	/^  RandGenFstOptions(const CacheOptions &copts, S *samp,$/;"	f	struct:fst::RandGenFstOptions
fst::RandGenFstOptions::arc_sampler	randgen.h	/^  S *arc_sampler;            \/\/ How to sample transitions at a state$/;"	m	struct:fst::RandGenFstOptions
fst::RandGenFstOptions::npath	randgen.h	/^  size_t npath;              \/\/ # of paths to generate$/;"	m	struct:fst::RandGenFstOptions
fst::RandGenFstOptions::remove_total_weight	randgen.h	/^  bool remove_total_weight;  \/\/ Remove total weight when output is weighted.$/;"	m	struct:fst::RandGenFstOptions
fst::RandGenFstOptions::weighted	randgen.h	/^  bool weighted;             \/\/ Output tree weighted by path count; o.w.$/;"	m	struct:fst::RandGenFstOptions
fst::RandGenOptions	randgen.h	/^struct RandGenOptions {$/;"	s	namespace:fst
fst::RandGenOptions::RandGenOptions	randgen.h	/^  RandGenOptions(const S &sel, int len = INT_MAX, size_t n = 1,$/;"	f	struct:fst::RandGenOptions
fst::RandGenOptions::arc_selector	randgen.h	/^  const S &arc_selector;     \/\/ How an arc is selected at a state$/;"	m	struct:fst::RandGenOptions
fst::RandGenOptions::max_length	randgen.h	/^  int max_length;            \/\/ Maximum path length$/;"	m	struct:fst::RandGenOptions
fst::RandGenOptions::npath	randgen.h	/^  size_t npath;              \/\/ # of paths to generate$/;"	m	struct:fst::RandGenOptions
fst::RandGenOptions::remove_total_weight	randgen.h	/^  bool remove_total_weight;  \/\/ Remove total weight when output is weighted.$/;"	m	struct:fst::RandGenOptions
fst::RandGenOptions::weighted	randgen.h	/^  bool weighted;             \/\/ Output is tree weighted by path count; o.w.$/;"	m	struct:fst::RandGenOptions
fst::RandGenVisitor	randgen.h	/^class RandGenVisitor {$/;"	c	namespace:fst
fst::RandGenVisitor::BackArc	randgen.h	/^  bool BackArc(StateId s, const IArc &arc) {$/;"	f	class:fst::RandGenVisitor
fst::RandGenVisitor::FinishState	randgen.h	/^  void FinishState(StateId s, StateId p, const IArc *) {$/;"	f	class:fst::RandGenVisitor
fst::RandGenVisitor::FinishVisit	randgen.h	/^  void FinishVisit() {}$/;"	f	class:fst::RandGenVisitor
fst::RandGenVisitor::ForwardOrCrossArc	randgen.h	/^  bool ForwardOrCrossArc(StateId s, const IArc &arc) {$/;"	f	class:fst::RandGenVisitor
fst::RandGenVisitor::InitState	randgen.h	/^  bool InitState(StateId s, StateId root) { return true; }$/;"	f	class:fst::RandGenVisitor
fst::RandGenVisitor::InitVisit	randgen.h	/^  void InitVisit(const Fst<IArc> &ifst) {$/;"	f	class:fst::RandGenVisitor
fst::RandGenVisitor::OutputPath	randgen.h	/^  void OutputPath() {$/;"	f	class:fst::RandGenVisitor
fst::RandGenVisitor::RandGenVisitor	randgen.h	/^  RandGenVisitor(MutableFst<OArc> *ofst) : ofst_(ofst) {}$/;"	f	class:fst::RandGenVisitor
fst::RandGenVisitor::StateId	randgen.h	/^  typedef typename IArc::StateId StateId;$/;"	t	class:fst::RandGenVisitor
fst::RandGenVisitor::TreeArc	randgen.h	/^  bool TreeArc(StateId s, const IArc &arc) {$/;"	f	class:fst::RandGenVisitor
fst::RandGenVisitor::Weight	randgen.h	/^  typedef typename IArc::Weight Weight;$/;"	t	class:fst::RandGenVisitor
fst::RandGenVisitor::ifst_	randgen.h	/^  const Fst<IArc> *ifst_;$/;"	m	class:fst::RandGenVisitor
fst::RandGenVisitor::ofst_	randgen.h	/^  MutableFst<OArc> *ofst_;$/;"	m	class:fst::RandGenVisitor
fst::RandGenVisitor::path_	randgen.h	/^  vector<OArc> path_;$/;"	m	class:fst::RandGenVisitor
fst::RandState	randgen.h	/^struct RandState {$/;"	s	namespace:fst
fst::RandState::RandState	randgen.h	/^  RandState()$/;"	f	struct:fst::RandState
fst::RandState::RandState	randgen.h	/^  RandState(StateId s, size_t n, size_t l, size_t k, const RandState<A> *p)$/;"	f	struct:fst::RandState
fst::RandState::StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::RandState
fst::RandState::length	randgen.h	/^  size_t length;                 \/\/ length of path to this random state$/;"	m	struct:fst::RandState
fst::RandState::nsamples	randgen.h	/^  size_t nsamples;               \/\/ # of samples to be sampled at this state$/;"	m	struct:fst::RandState
fst::RandState::parent	randgen.h	/^  const RandState<A> *parent;    \/\/ previous random state on this path$/;"	m	struct:fst::RandState
fst::RandState::select	randgen.h	/^  size_t select;                 \/\/ previous sample arc selection$/;"	m	struct:fst::RandState
fst::RandState::state_id	randgen.h	/^  StateId state_id;              \/\/ current input FST state$/;"	m	struct:fst::RandState
fst::RationalFst	rational.h	/^class RationalFst : public ImplToFst< RationalFstImpl<A> > {$/;"	c	namespace:fst
fst::RationalFst::Arc	rational.h	/^  typedef A Arc;$/;"	t	class:fst::RationalFst
fst::RationalFst::GetImpl	rational.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::RationalFst
fst::RationalFst::Impl	rational.h	/^  typedef RationalFstImpl<A> Impl;$/;"	t	class:fst::RationalFst
fst::RationalFst::InitArcIterator	rational.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::RationalFst
fst::RationalFst::InitStateIterator	rational.h	/^  virtual void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::RationalFst
fst::RationalFst::RationalFst	rational.h	/^  RationalFst()$/;"	f	class:fst::RationalFst
fst::RationalFst::RationalFst	rational.h	/^  RationalFst(const RationalFst<A> &fst , bool safe = false)$/;"	f	class:fst::RationalFst
fst::RationalFst::RationalFst	rational.h	/^  explicit RationalFst(const RationalFstOptions &opts)$/;"	f	class:fst::RationalFst
fst::RationalFst::StateId	rational.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RationalFst
fst::RationalFstImpl	rational.h	/^class RationalFstImpl : public FstImpl<A> {$/;"	c	namespace:fst
fst::RationalFstImpl::AddClosure	rational.h	/^  void AddClosure(ClosureType closure_type) {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::AddConcat	rational.h	/^  void AddConcat(const Fst<A> &fst, bool append) {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::AddUnion	rational.h	/^  void AddUnion(const Fst<A> &fst) {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::Arc	rational.h	/^  typedef A Arc;$/;"	t	class:fst::RationalFstImpl
fst::RationalFstImpl::Final	rational.h	/^  Weight Final(StateId s) { return Replace()->Final(s); }$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::InitClosure	rational.h	/^  void InitClosure(const Fst<A> &fst, ClosureType closure_type) {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::InitConcat	rational.h	/^  void InitConcat(const Fst<A> &fst1, const Fst<A> &fst2) {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::InitUnion	rational.h	/^  void InitUnion(const Fst<A> &fst1, const Fst<A> &fst2) {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::Label	rational.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::RationalFstImpl
fst::RationalFstImpl::NumArcs	rational.h	/^  size_t NumArcs(StateId s) { return Replace()->NumArcs(s); }$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::NumInputEpsilons	rational.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::NumOutputEpsilons	rational.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::Properties	rational.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::Properties	rational.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::RationalFstImpl	rational.h	/^  RationalFstImpl(const RationalFstImpl<A> &impl)$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::RationalFstImpl	rational.h	/^  explicit RationalFstImpl(const RationalFstOptions &opts)$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::Replace	rational.h	/^  ReplaceFst<A> *Replace() const {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::Start	rational.h	/^  StateId Start() { return Replace()->Start(); }$/;"	f	class:fst::RationalFstImpl
fst::RationalFstImpl::StateId	rational.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RationalFstImpl
fst::RationalFstImpl::Weight	rational.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::RationalFstImpl
fst::RationalFstImpl::fst_tuples_	rational.h	/^  mutable vector<pair<Label, const Fst<A>*> > fst_tuples_;$/;"	m	class:fst::RationalFstImpl
fst::RationalFstImpl::nonterminals_	rational.h	/^  Label nonterminals_;  \/\/ # of nonterminals used$/;"	m	class:fst::RationalFstImpl
fst::RationalFstImpl::replace_	rational.h	/^  mutable ReplaceFst<A> *replace_;        \/\/ Underlying ReplaceFst$/;"	m	class:fst::RationalFstImpl
fst::RationalFstImpl::replace_options_	rational.h	/^  ReplaceFstOptions<A> replace_options_;  \/\/ Options for creating 'replace_'$/;"	m	class:fst::RationalFstImpl
fst::RationalFstImpl::rfst_	rational.h	/^  VectorFst<A> rfst_;   \/\/ rational topology machine; uses neg. nonterminals$/;"	m	class:fst::RationalFstImpl
fst::RationalFstImpl::~RationalFstImpl	rational.h	/^  virtual ~RationalFstImpl() {$/;"	f	class:fst::RationalFstImpl
fst::RationalFstOptions	rational.h	/^typedef CacheOptions RationalFstOptions;$/;"	t	namespace:fst
fst::ReadLabelPairs	util.h	/^bool ReadLabelPairs(const string& filename,$/;"	f	namespace:fst
fst::ReadType	util.h	/^inline istream &ReadType(istream &strm, T *t) {$/;"	f	namespace:fst
fst::ReadType	util.h	/^inline istream &ReadType(istream &strm, pair<S, T> *p) {$/;"	f	namespace:fst
fst::ReadType	util.h	/^inline istream &ReadType(istream &strm, pair<const S, T> *p) {$/;"	f	namespace:fst
fst::ReadType	util.h	/^inline istream &ReadType(istream &strm, string *s) {$/;"	f	namespace:fst
fst::ReaderMutexLock	lock.h	/^class ReaderMutexLock {$/;"	c	namespace:fst
fst::ReaderMutexLock::ReaderMutexLock	lock.h	/^  ReaderMutexLock(Mutex *) {}$/;"	f	class:fst::ReaderMutexLock
fst::RefCounter	lock.h	/^class RefCounter {$/;"	c	namespace:fst
fst::RefCounter::Decr	lock.h	/^  int Decr() const {  return --count_; }$/;"	f	class:fst::RefCounter
fst::RefCounter::Incr	lock.h	/^  int Incr() const { return ++count_; }$/;"	f	class:fst::RefCounter
fst::RefCounter::RefCounter	lock.h	/^  RefCounter() : count_(1) {}$/;"	f	class:fst::RefCounter
fst::RefCounter::count	lock.h	/^  int count() const { return count_; }$/;"	f	class:fst::RefCounter
fst::RefCounter::count_	lock.h	/^  mutable int count_;$/;"	m	class:fst::RefCounter
fst::Relabel	relabel.h	/^void Relabel($/;"	f	namespace:fst
fst::Relabel	relabel.h	/^void Relabel(MutableFst<A> *fst,$/;"	f	namespace:fst
fst::RelabelFst	relabel.h	/^class RelabelFst : public ImplToFst< RelabelFstImpl<A> > {$/;"	c	namespace:fst
fst::RelabelFst::Arc	relabel.h	/^  typedef A Arc;$/;"	t	class:fst::RelabelFst
fst::RelabelFst::Copy	relabel.h	/^  virtual RelabelFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::RelabelFst
fst::RelabelFst::GetImpl	relabel.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::RelabelFst
fst::RelabelFst::Impl	relabel.h	/^  typedef RelabelFstImpl<A> Impl;$/;"	t	class:fst::RelabelFst
fst::RelabelFst::InitArcIterator	relabel.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::RelabelFst
fst::RelabelFst::InitStateIterator	relabel.h	/^void RelabelFst<A>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::RelabelFst
fst::RelabelFst::Label	relabel.h	/^  typedef typename A::Label   Label;$/;"	t	class:fst::RelabelFst
fst::RelabelFst::RelabelFst	relabel.h	/^  RelabelFst(const Fst<A>& fst,$/;"	f	class:fst::RelabelFst
fst::RelabelFst::RelabelFst	relabel.h	/^  RelabelFst(const RelabelFst<A> &fst, bool safe = false)$/;"	f	class:fst::RelabelFst
fst::RelabelFst::State	relabel.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::RelabelFst
fst::RelabelFst::StateId	relabel.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RelabelFst
fst::RelabelFst::Weight	relabel.h	/^  typedef typename A::Weight  Weight;$/;"	t	class:fst::RelabelFst
fst::RelabelFstImpl	relabel.h	/^class RelabelFstImpl : public CacheImpl<A> {$/;"	c	namespace:fst
fst::RelabelFstImpl::Arc	relabel.h	/^  typedef A Arc;$/;"	t	class:fst::RelabelFstImpl
fst::RelabelFstImpl::Expand	relabel.h	/^  void Expand(StateId s) {$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::Final	relabel.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::InitArcIterator	relabel.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A>* data) {$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::Label	relabel.h	/^  typedef typename A::Label   Label;$/;"	t	class:fst::RelabelFstImpl
fst::RelabelFstImpl::NumArcs	relabel.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::NumInputEpsilons	relabel.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::NumOutputEpsilons	relabel.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::Properties	relabel.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::Properties	relabel.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::RelabelFstImpl	relabel.h	/^  RelabelFstImpl(const Fst<A>& fst,$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::RelabelFstImpl	relabel.h	/^  RelabelFstImpl(const RelabelFstImpl<A>& impl)$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::Start	relabel.h	/^  StateId Start() {$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstImpl::State	relabel.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::RelabelFstImpl
fst::RelabelFstImpl::StateId	relabel.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RelabelFstImpl
fst::RelabelFstImpl::Weight	relabel.h	/^  typedef typename A::Weight  Weight;$/;"	t	class:fst::RelabelFstImpl
fst::RelabelFstImpl::fst_	relabel.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::RelabelFstImpl
fst::RelabelFstImpl::input_map_	relabel.h	/^  unordered_map<Label, Label> input_map_;$/;"	m	class:fst::RelabelFstImpl
fst::RelabelFstImpl::output_map_	relabel.h	/^  unordered_map<Label, Label> output_map_;$/;"	m	class:fst::RelabelFstImpl
fst::RelabelFstImpl::relabel_input_	relabel.h	/^  bool relabel_input_;$/;"	m	class:fst::RelabelFstImpl
fst::RelabelFstImpl::relabel_output_	relabel.h	/^  bool relabel_output_;$/;"	m	class:fst::RelabelFstImpl
fst::RelabelFstImpl::~RelabelFstImpl	relabel.h	/^  ~RelabelFstImpl() { delete fst_; }$/;"	f	class:fst::RelabelFstImpl
fst::RelabelFstOptions	relabel.h	/^typedef CacheOptions RelabelFstOptions;$/;"	t	namespace:fst
fst::RelabelSymbolTable	symbol-table.h	/^SymbolTable *RelabelSymbolTable(const SymbolTable *table,$/;"	f	namespace:fst
fst::Replace	replace.h	/^void Replace(const vector<pair<typename Arc::Label,$/;"	f	namespace:fst
fst::ReplaceAccumulator	accumulator.h	/^class ReplaceAccumulator {$/;"	c	namespace:fst
fst::ReplaceAccumulator::Arc	accumulator.h	/^  typedef typename Accumulator::Arc Arc;$/;"	t	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::Error	accumulator.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::Init	accumulator.h	/^  void Init(const vector<pair<Label, const Fst<Arc>*> > &fst_tuples,$/;"	f	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::Label	accumulator.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::ReplaceAccumulator	accumulator.h	/^  ReplaceAccumulator()$/;"	f	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::ReplaceAccumulator	accumulator.h	/^  ReplaceAccumulator(const ReplaceAccumulator<Accumulator, T> &acc)$/;"	f	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::ReplaceAccumulator	accumulator.h	/^  ReplaceAccumulator(const vector<Accumulator*> &accumulators)$/;"	f	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::SetState	accumulator.h	/^  void SetState(StateId s) {$/;"	f	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::StateId	accumulator.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::StateTable	accumulator.h	/^  typedef T StateTable;$/;"	t	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::StateTuple	accumulator.h	/^  typedef typename T::StateTuple StateTuple;$/;"	t	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, ArcIterator *aiter, ssize_t begin,$/;"	f	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::Sum	accumulator.h	/^  Weight Sum(Weight w, Weight v) {$/;"	f	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::Weight	accumulator.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::data_	accumulator.h	/^  ReplaceAccumulatorData<Accumulator, T> *data_;$/;"	m	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::error_	accumulator.h	/^  bool error_;$/;"	m	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::fst_id_	accumulator.h	/^  Label fst_id_;$/;"	m	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::init_	accumulator.h	/^  bool init_;$/;"	m	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::offset_	accumulator.h	/^  size_t offset_;$/;"	m	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::offset_weight_	accumulator.h	/^  Weight offset_weight_;$/;"	m	class:fst::ReplaceAccumulator
fst::ReplaceAccumulator::~ReplaceAccumulator	accumulator.h	/^  ~ReplaceAccumulator() {$/;"	f	class:fst::ReplaceAccumulator
fst::ReplaceAccumulatorData	accumulator.h	/^class ReplaceAccumulatorData {$/;"	c	namespace:fst
fst::ReplaceAccumulatorData::Arc	accumulator.h	/^  typedef typename Accumulator::Arc Arc;$/;"	t	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::DecrRefCount	accumulator.h	/^  int DecrRefCount() { return ref_count_.Decr(); }$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::GetAccumulator	accumulator.h	/^  Accumulator *GetAccumulator(size_t i) { return accumulators_[i]; }$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::GetFst	accumulator.h	/^  const Fst<Arc> *GetFst(size_t i) const { return fst_array_[i]; }$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::GetTuple	accumulator.h	/^  const StateTuple &GetTuple(StateId s) const {$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::IncrRefCount	accumulator.h	/^  int IncrRefCount() { return ref_count_.Incr(); }$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::Init	accumulator.h	/^  void Init(const vector<pair<Label, const Fst<Arc>*> > &fst_tuples,$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::Label	accumulator.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::RefCount	accumulator.h	/^  int RefCount() const { return ref_count_.count(); }$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::ReplaceAccumulatorData	accumulator.h	/^  ReplaceAccumulatorData() : state_table_(0) {}$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::ReplaceAccumulatorData	accumulator.h	/^  ReplaceAccumulatorData(const vector<Accumulator*> &accumulators)$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::StateId	accumulator.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::StateTable	accumulator.h	/^  typedef T StateTable;$/;"	t	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::StateTuple	accumulator.h	/^  typedef typename T::StateTuple StateTuple;$/;"	t	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::accumulators_	accumulator.h	/^  vector<Accumulator*> accumulators_;$/;"	m	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::fst_array_	accumulator.h	/^  vector<const Fst<Arc>*> fst_array_;$/;"	m	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::ref_count_	accumulator.h	/^  RefCounter ref_count_;$/;"	m	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::state_table_	accumulator.h	/^  const T * state_table_;$/;"	m	class:fst::ReplaceAccumulatorData
fst::ReplaceAccumulatorData::~ReplaceAccumulatorData	accumulator.h	/^  ~ReplaceAccumulatorData() {$/;"	f	class:fst::ReplaceAccumulatorData
fst::ReplaceFingerprint	replace.h	/^class ReplaceFingerprint {$/;"	c	namespace:fst
fst::ReplaceFingerprint::ReplaceFingerprint	replace.h	/^  ReplaceFingerprint(const vector<uint64> *size_array)$/;"	f	class:fst::ReplaceFingerprint
fst::ReplaceFingerprint::cumulative_size_array_	replace.h	/^  const vector<uint64> *cumulative_size_array_;$/;"	m	class:fst::ReplaceFingerprint
fst::ReplaceFingerprint::operator ()	replace.h	/^  uint64 operator()(const ReplaceStateTuple<S, P> &tuple) const {$/;"	f	class:fst::ReplaceFingerprint
fst::ReplaceFst	replace.h	/^class ReplaceFst : public ImplToFst< ReplaceFstImpl<A, T> > {$/;"	c	namespace:fst
fst::ReplaceFst::Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::ReplaceFst
fst::ReplaceFst::Copy	replace.h	/^  virtual ReplaceFst<A, T> *Copy(bool safe = false) const {$/;"	f	class:fst::ReplaceFst
fst::ReplaceFst::CyclicDependencies	replace.h	/^  bool CyclicDependencies() const {$/;"	f	class:fst::ReplaceFst
fst::ReplaceFst::GetImpl	replace.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::ReplaceFst
fst::ReplaceFst::Impl	replace.h	/^  typedef ReplaceFstImpl<A, T> Impl;$/;"	t	class:fst::ReplaceFst
fst::ReplaceFst::InitArcIterator	replace.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::ReplaceFst
fst::ReplaceFst::InitMatcher	replace.h	/^  virtual MatcherBase<A> *InitMatcher(MatchType match_type) const {$/;"	f	class:fst::ReplaceFst
fst::ReplaceFst::InitStateIterator	replace.h	/^void ReplaceFst<A, T>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::ReplaceFst
fst::ReplaceFst::Label	replace.h	/^  typedef typename A::Label   Label;$/;"	t	class:fst::ReplaceFst
fst::ReplaceFst::ReplaceFst	replace.h	/^  ReplaceFst(const ReplaceFst<A, T>& fst, bool safe = false)$/;"	f	class:fst::ReplaceFst
fst::ReplaceFst::ReplaceFst	replace.h	/^  ReplaceFst(const vector<pair<Label, const Fst<A>* > >& fst_array,$/;"	f	class:fst::ReplaceFst
fst::ReplaceFst::State	replace.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::ReplaceFst
fst::ReplaceFst::StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ReplaceFst
fst::ReplaceFst::Weight	replace.h	/^  typedef typename A::Weight  Weight;$/;"	t	class:fst::ReplaceFst
fst::ReplaceFstImpl	replace.h	/^class ReplaceFstImpl : public CacheImpl<A> {$/;"	c	namespace:fst
fst::ReplaceFstImpl::Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::ArcIteratorFlags	replace.h	/^  uint32 ArcIteratorFlags() const {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::ComputeArc	replace.h	/^  bool ComputeArc(const StateTuple &tuple, const A &arc, A* arcp,$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::ComputeFinalArc	replace.h	/^  bool ComputeFinalArc(const StateTuple &tuple, A* arcp,$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::CyclicDependencies	replace.h	/^  bool CyclicDependencies() const {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::EpsilonOnReplace	replace.h	/^  bool EpsilonOnReplace() const { return epsilon_on_replace_; }$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::Expand	replace.h	/^  void Expand(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::Expand	replace.h	/^  void Expand(StateId s, const StateTuple &tuple,$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::Final	replace.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::GetFst	replace.h	/^  const Fst<A>* GetFst(Label fst_id) const {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::GetPrefixId	replace.h	/^  PrefixId GetPrefixId(const StackPrefix& prefix) {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::GetStateTable	replace.h	/^  T* GetStateTable() const {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::InitArcIterator	replace.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::IsNonTerminal	replace.h	/^  bool IsNonTerminal(Label l) const {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::Label	replace.h	/^  typedef typename A::Label   Label;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::NonTerminalHash	replace.h	/^  typedef unordered_map<Label, Label> NonTerminalHash;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::NumArcs	replace.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::NumInputEpsilons	replace.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::NumOutputEpsilons	replace.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::PopPrefix	replace.h	/^  PrefixId PopPrefix(StackPrefix prefix) {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::PrefixId	replace.h	/^  typedef typename T::PrefixId PrefixId;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::PrefixTuple	replace.h	/^  struct PrefixTuple {$/;"	s	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::PrefixTuple::PrefixTuple	replace.h	/^    PrefixTuple(Label f, StateId s) : fst_id(f), nextstate(s) {}$/;"	f	struct:fst::ReplaceFstImpl::PrefixTuple
fst::ReplaceFstImpl::PrefixTuple::fst_id	replace.h	/^    Label   fst_id;$/;"	m	struct:fst::ReplaceFstImpl::PrefixTuple
fst::ReplaceFstImpl::PrefixTuple::nextstate	replace.h	/^    StateId nextstate;$/;"	m	struct:fst::ReplaceFstImpl::PrefixTuple
fst::ReplaceFstImpl::Properties	replace.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::Properties	replace.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::PushPrefix	replace.h	/^  PrefixId PushPrefix(StackPrefix prefix, Label fst_id, StateId nextstate) {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::ReplaceFstImpl	replace.h	/^  ReplaceFstImpl(const ReplaceFstImpl& impl)$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::ReplaceFstImpl	replace.h	/^  ReplaceFstImpl(const vector< pair<Label, const Fst<A>* > >& fst_tuples,$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::StackPrefix	replace.h	/^  class StackPrefix {$/;"	c	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::StackPrefix::Depth	replace.h	/^    size_t Depth() const {$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
fst::ReplaceFstImpl::StackPrefix::Pop	replace.h	/^    void Pop() {$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
fst::ReplaceFstImpl::StackPrefix::Push	replace.h	/^    void Push(StateId fst_id, StateId nextstate) {$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
fst::ReplaceFstImpl::StackPrefix::StackPrefix	replace.h	/^    StackPrefix() {}$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
fst::ReplaceFstImpl::StackPrefix::StackPrefix	replace.h	/^    StackPrefix(const StackPrefix& x) :$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
fst::ReplaceFstImpl::StackPrefix::Top	replace.h	/^    const PrefixTuple& Top() const {$/;"	f	class:fst::ReplaceFstImpl::StackPrefix
fst::ReplaceFstImpl::StackPrefix::prefix_	replace.h	/^    vector<PrefixTuple> prefix_;$/;"	m	class:fst::ReplaceFstImpl::StackPrefix
fst::ReplaceFstImpl::StackPrefixEqual	replace.h	/^  class StackPrefixEqual {$/;"	c	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::StackPrefixEqual::operator ()	replace.h	/^    bool operator()(const StackPrefix& x, const StackPrefix& y) const {$/;"	f	class:fst::ReplaceFstImpl::StackPrefixEqual
fst::ReplaceFstImpl::StackPrefixHash	replace.h	/^  StackPrefixHash;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::StackPrefixKey	replace.h	/^  class StackPrefixKey {$/;"	c	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::StackPrefixKey::operator ()	replace.h	/^    size_t operator()(const StackPrefix& x) const {$/;"	f	class:fst::ReplaceFstImpl::StackPrefixKey
fst::ReplaceFstImpl::Start	replace.h	/^  StateId Start() {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::State	replace.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::StateTable	replace.h	/^  typedef T StateTable;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::StateTuple	replace.h	/^  typedef ReplaceStateTuple<StateId, PrefixId> StateTuple;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::Weight	replace.h	/^  typedef typename A::Weight  Weight;$/;"	t	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::always_cache_	replace.h	/^  bool always_cache_;  \/\/ Optionally caching arc iterator disabled when true$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::epsilon_on_replace_	replace.h	/^  bool epsilon_on_replace_;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::fst_array_	replace.h	/^  vector<const Fst<A>*> fst_array_;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::kPrime0	replace.h	/^  static const size_t kPrime0;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::kPrime0	replace.h	/^const size_t ReplaceFstImpl<A, T>::kPrime0 = 7853;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::nonterminal_hash_	replace.h	/^  NonTerminalHash nonterminal_hash_;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::nonterminal_set_	replace.h	/^  set<Label> nonterminal_set_;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::prefix_hash_	replace.h	/^  StackPrefixHash prefix_hash_;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::root_	replace.h	/^  Label root_;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::stackprefix_array_	replace.h	/^  vector<StackPrefix> stackprefix_array_;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::state_table_	replace.h	/^  StateTable *state_table_;$/;"	m	class:fst::ReplaceFstImpl
fst::ReplaceFstImpl::~ReplaceFstImpl	replace.h	/^  ~ReplaceFstImpl() {$/;"	f	class:fst::ReplaceFstImpl
fst::ReplaceFstMatcher	replace.h	/^class ReplaceFstMatcher : public MatcherBase<A> {$/;"	c	namespace:fst
fst::ReplaceFstMatcher::Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::Copy	replace.h	/^  virtual ReplaceFstMatcher<A, T> *Copy(bool safe = false) const {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::Done_	replace.h	/^  virtual bool Done_() const {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::Find_	replace.h	/^  virtual bool Find_(Label label) {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::GetFst	replace.h	/^  virtual const Fst<A> &GetFst() const {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::InitMatchers	replace.h	/^  void InitMatchers() {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::Label	replace.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::LocalMatcher	replace.h	/^  typedef MultiEpsMatcher<Matcher<Fst<A> > > LocalMatcher;$/;"	t	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::Next_	replace.h	/^  virtual void Next_() {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::Properties	replace.h	/^  virtual uint64 Properties(uint64 props) const {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::ReplaceFstMatcher	replace.h	/^  ReplaceFstMatcher(const ReplaceFst<A, T> &fst, fst::MatchType match_type)$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::ReplaceFstMatcher	replace.h	/^  ReplaceFstMatcher(const ReplaceFstMatcher<A, T> &matcher, bool safe = false)$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::SetState_	replace.h	/^  virtual void SetState_(StateId s) {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::Type	replace.h	/^  virtual MatchType Type(bool test) const {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::Value_	replace.h	/^  virtual const Arc& Value_() const {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::arc_	replace.h	/^  mutable Arc arc_;$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::current_loop_	replace.h	/^  mutable bool current_loop_;        \/\/ Current arc is the implicit loop$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::current_matcher_	replace.h	/^  LocalMatcher* current_matcher_;$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::done_	replace.h	/^  mutable bool done_;$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::final_arc_	replace.h	/^  mutable bool final_arc_;           \/\/ Current arc for exiting recursion$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::fst_	replace.h	/^  const ReplaceFst<A, T>& fst_;$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::impl_	replace.h	/^  ReplaceFstImpl<A, T> *impl_;$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::label_	replace.h	/^  Label label_;                      \/\/ Current label$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::loop_	replace.h	/^  Arc loop_;$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::match_type_	replace.h	/^  MatchType match_type_;             \/\/ Supplied by caller$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::matcher_	replace.h	/^  vector<LocalMatcher*> matcher_;$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::s_	replace.h	/^  StateId s_;                        \/\/ Current state$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::tuple_	replace.h	/^  mutable typename T::StateTuple tuple_;  \/\/ Tuple corresponding to state_$/;"	m	class:fst::ReplaceFstMatcher
fst::ReplaceFstMatcher::~ReplaceFstMatcher	replace.h	/^  virtual ~ReplaceFstMatcher() {$/;"	f	class:fst::ReplaceFstMatcher
fst::ReplaceFstOptions	replace.h	/^struct ReplaceFstOptions : CacheOptions {$/;"	s	namespace:fst
fst::ReplaceFstOptions::ReplaceFstOptions	replace.h	/^  ReplaceFstOptions()$/;"	f	struct:fst::ReplaceFstOptions
fst::ReplaceFstOptions::ReplaceFstOptions	replace.h	/^  ReplaceFstOptions(const CacheOptions &opts, int64 r)$/;"	f	struct:fst::ReplaceFstOptions
fst::ReplaceFstOptions::ReplaceFstOptions	replace.h	/^  ReplaceFstOptions(int64 r, bool epsilon_replace_arc)$/;"	f	struct:fst::ReplaceFstOptions
fst::ReplaceFstOptions::ReplaceFstOptions	replace.h	/^  explicit ReplaceFstOptions(int64 r)$/;"	f	struct:fst::ReplaceFstOptions
fst::ReplaceFstOptions::epsilon_on_replace	replace.h	/^  bool  epsilon_on_replace;$/;"	m	struct:fst::ReplaceFstOptions
fst::ReplaceFstOptions::root	replace.h	/^  int64 root;    \/\/ root rule for expansion$/;"	m	struct:fst::ReplaceFstOptions
fst::ReplaceFstOptions::state_table	replace.h	/^  T*    state_table;$/;"	m	struct:fst::ReplaceFstOptions
fst::ReplaceFstOptions::take_ownership	replace.h	/^  bool  take_ownership;  \/\/ take ownership of input Fst(s)$/;"	m	struct:fst::ReplaceFstOptions
fst::ReplaceFstStateFingerprint	replace.h	/^class ReplaceFstStateFingerprint {$/;"	c	namespace:fst
fst::ReplaceFstStateFingerprint::operator ()	replace.h	/^  uint64 operator()(const ReplaceStateTuple<S, P>& tuple) const {$/;"	f	class:fst::ReplaceFstStateFingerprint
fst::ReplaceHash	replace.h	/^class ReplaceHash {$/;"	c	namespace:fst
fst::ReplaceHash::kPrime0	replace.h	/^  static const size_t kPrime0;$/;"	m	class:fst::ReplaceHash
fst::ReplaceHash::kPrime0	replace.h	/^const size_t ReplaceHash<S, P>::kPrime0 = 7853;$/;"	m	class:fst::ReplaceHash
fst::ReplaceHash::kPrime1	replace.h	/^  static const size_t kPrime1;$/;"	m	class:fst::ReplaceHash
fst::ReplaceHash::kPrime1	replace.h	/^const size_t ReplaceHash<S, P>::kPrime1 = 7867;$/;"	m	class:fst::ReplaceHash
fst::ReplaceHash::operator ()	replace.h	/^  size_t operator()(const ReplaceStateTuple<S, P>& t) const {$/;"	f	class:fst::ReplaceHash
fst::ReplaceRootSelector	replace.h	/^class ReplaceRootSelector {$/;"	c	namespace:fst
fst::ReplaceRootSelector::operator ()	replace.h	/^  bool operator()(const ReplaceStateTuple<S, P> &tuple) const {$/;"	f	class:fst::ReplaceRootSelector
fst::ReplaceStateTuple	replace.h	/^struct ReplaceStateTuple {$/;"	s	namespace:fst
fst::ReplaceStateTuple::PrefixId	replace.h	/^  typedef P PrefixId;$/;"	t	struct:fst::ReplaceStateTuple
fst::ReplaceStateTuple::ReplaceStateTuple	replace.h	/^  ReplaceStateTuple()$/;"	f	struct:fst::ReplaceStateTuple
fst::ReplaceStateTuple::ReplaceStateTuple	replace.h	/^  ReplaceStateTuple(PrefixId p, StateId f, StateId s)$/;"	f	struct:fst::ReplaceStateTuple
fst::ReplaceStateTuple::StateId	replace.h	/^  typedef S StateId;$/;"	t	struct:fst::ReplaceStateTuple
fst::ReplaceStateTuple::fst_id	replace.h	/^  StateId fst_id;      \/\/ current fst being walked$/;"	m	struct:fst::ReplaceStateTuple
fst::ReplaceStateTuple::fst_state	replace.h	/^  StateId fst_state;   \/\/ current state in fst being walked, not to be$/;"	m	struct:fst::ReplaceStateTuple
fst::ReplaceStateTuple::prefix_id	replace.h	/^  PrefixId prefix_id;  \/\/ index in prefix table$/;"	m	struct:fst::ReplaceStateTuple
fst::ReplaceUtil	replace-util.h	/^class ReplaceUtil {$/;"	c	namespace:fst
fst::ReplaceUtil::CheckMutableFsts	replace-util.h	/^void ReplaceUtil<Arc>::CheckMutableFsts() {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::ClearDependencies	replace-util.h	/^  void ClearDependencies() const {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::Connect	replace-util.h	/^void ReplaceUtil<Arc>::Connect() {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::Connected	replace-util.h	/^  bool Connected() const {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::CyclicDependencies	replace-util.h	/^  bool CyclicDependencies() const {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::FstPair	replace-util.h	/^  typedef pair<Label, const Fst<Arc>*> FstPair;$/;"	t	class:fst::ReplaceUtil
fst::ReplaceUtil::GetDependencies	replace-util.h	/^void ReplaceUtil<Arc>::GetDependencies(bool stats) const {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::GetFstPairs	replace-util.h	/^void ReplaceUtil<Arc>::GetFstPairs(vector<FstPair> *fst_pairs) {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::GetMutableFstPairs	replace-util.h	/^void ReplaceUtil<Arc>::GetMutableFstPairs($/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::GetTopOrder	replace-util.h	/^bool ReplaceUtil<Arc>::GetTopOrder(const Fst<Arc> &fst,$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::Label	replace-util.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::ReplaceUtil
fst::ReplaceUtil::MutableFstPair	replace-util.h	/^  typedef pair<Label, MutableFst<Arc>*> MutableFstPair;$/;"	t	class:fst::ReplaceUtil
fst::ReplaceUtil::NonTerminalHash	replace-util.h	/^  typedef unordered_map<Label, Label> NonTerminalHash;$/;"	t	class:fst::ReplaceUtil
fst::ReplaceUtil::ReplaceByInstances	replace-util.h	/^void ReplaceUtil<Arc>::ReplaceByInstances(size_t ninstances) {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::ReplaceBySize	replace-util.h	/^void ReplaceUtil<Arc>::ReplaceBySize(size_t nstates, size_t narcs,$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::ReplaceLabels	replace-util.h	/^void ReplaceUtil<Arc>::ReplaceLabels(const vector<Label> &labels) {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::ReplaceStats	replace-util.h	/^  struct ReplaceStats {$/;"	s	class:fst::ReplaceUtil
fst::ReplaceUtil::ReplaceStats::ReplaceStats	replace-util.h	/^    ReplaceStats()$/;"	f	struct:fst::ReplaceUtil::ReplaceStats
fst::ReplaceUtil::ReplaceStats::inref	replace-util.h	/^    map<Label, size_t> inref;$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
fst::ReplaceUtil::ReplaceStats::narcs	replace-util.h	/^    size_t narcs;       \/\/ # of arcs$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
fst::ReplaceUtil::ReplaceStats::nfinal	replace-util.h	/^    StateId nfinal;     \/\/ # of final states$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
fst::ReplaceUtil::ReplaceStats::nnonterms	replace-util.h	/^    Label nnonterms;    \/\/ # of non-terminals in Fst$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
fst::ReplaceUtil::ReplaceStats::nref	replace-util.h	/^    size_t nref;        \/\/ # of non-terminal instances referring to this Fst$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
fst::ReplaceUtil::ReplaceStats::nstates	replace-util.h	/^    StateId nstates;    \/\/ # of states$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
fst::ReplaceUtil::ReplaceStats::outref	replace-util.h	/^    map<Label, size_t> outref;$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
fst::ReplaceUtil::ReplaceTrivial	replace-util.h	/^  void ReplaceTrivial() { ReplaceBySize(2, 1, 1); }$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::ReplaceUnique	replace-util.h	/^  void ReplaceUnique() { ReplaceByInstances(1); }$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::ReplaceUtil	replace-util.h	/^ReplaceUtil<Arc>::ReplaceUtil($/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::StateId	replace-util.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ReplaceUtil
fst::ReplaceUtil::UpdateStats	replace-util.h	/^void ReplaceUtil<Arc>::UpdateStats(Label j) {$/;"	f	class:fst::ReplaceUtil
fst::ReplaceUtil::Weight	replace-util.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ReplaceUtil
fst::ReplaceUtil::depaccess_	replace-util.h	/^  mutable vector<bool> depaccess_;                \/\/ Fst ID accessibility$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::depfst_	replace-util.h	/^  mutable VectorFst<Arc> depfst_;                 \/\/ Fst ID dependencies$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::depprops_	replace-util.h	/^  mutable uint64 depprops_;                       \/\/ dependency Fst props$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::epsilon_on_replace_	replace-util.h	/^  bool epsilon_on_replace_;                       \/\/ see Replace()$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::fst_array_	replace-util.h	/^  vector<const Fst<Arc> *> fst_array_;            \/\/ Fst per ID$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::have_stats_	replace-util.h	/^  mutable bool have_stats_;                       \/\/ have dependency statistics$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::mutable_fst_array_	replace-util.h	/^  vector<MutableFst<Arc> *> mutable_fst_array_;   \/\/ MutableFst per ID$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::nonterminal_array_	replace-util.h	/^  vector<Label> nonterminal_array_;               \/\/ Fst ID to non-terminal$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::nonterminal_hash_	replace-util.h	/^  NonTerminalHash nonterminal_hash_;              \/\/ non-terminal to Fst ID$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::root_fst_	replace-util.h	/^  Label root_fst_;                                \/\/ root Fst ID$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::root_label_	replace-util.h	/^  Label root_label_;                              \/\/ root non-terminal$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::stats_	replace-util.h	/^  mutable vector<ReplaceStats> stats_;            \/\/ Per Fst statistics$/;"	m	class:fst::ReplaceUtil
fst::ReplaceUtil::~ReplaceUtil	replace-util.h	/^  ~ReplaceUtil() {$/;"	f	class:fst::ReplaceUtil
fst::Reverse	reverse.h	/^void Reverse(const Fst<Arc> &ifst, MutableFst<RevArc> *ofst) {$/;"	f	namespace:fst
fst::ReverseArc	arc.h	/^template <class A> struct ReverseArc {$/;"	s	namespace:fst
fst::ReverseArc::AWeight	arc.h	/^  typedef typename A::Weight AWeight;$/;"	t	struct:fst::ReverseArc
fst::ReverseArc::Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::ReverseArc
fst::ReverseArc::Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::ReverseArc
fst::ReverseArc::ReverseArc	arc.h	/^  ReverseArc() {}$/;"	f	struct:fst::ReverseArc
fst::ReverseArc::ReverseArc	arc.h	/^  ReverseArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::ReverseArc
fst::ReverseArc::StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::ReverseArc
fst::ReverseArc::Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::ReverseArc
fst::ReverseArc::Weight	arc.h	/^  typedef typename AWeight::ReverseWeight Weight;$/;"	t	struct:fst::ReverseArc
fst::ReverseArc::ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::ReverseArc
fst::ReverseArc::nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::ReverseArc
fst::ReverseArc::olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::ReverseArc
fst::ReverseArc::weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::ReverseArc
fst::ReverseWeightMapper	arc-map.h	/^struct ReverseWeightMapper {$/;"	s	namespace:fst
fst::ReverseWeightMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::ReverseWeightMapper
fst::ReverseWeightMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::ReverseWeightMapper
fst::ReverseWeightMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::ReverseWeightMapper
fst::ReverseWeightMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::ReverseWeightMapper
fst::ReverseWeightMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	struct:fst::ReverseWeightMapper
fst::ReverseWeightMapper::ToArc	arc-map.h	/^  typedef B ToArc;$/;"	t	struct:fst::ReverseWeightMapper
fst::ReverseWeightMapper::operator ()	arc-map.h	/^  B operator()(const A &arc) const {$/;"	f	struct:fst::ReverseWeightMapper
fst::Reweight	reweight.h	/^void Reweight(MutableFst<Arc> *fst,$/;"	f	namespace:fst
fst::ReweightType	reweight.h	/^enum ReweightType { REWEIGHT_TO_INITIAL, REWEIGHT_TO_FINAL };$/;"	g	namespace:fst
fst::RhoMatcher	matcher.h	/^class RhoMatcher : public MatcherBase<typename M::Arc> {$/;"	c	namespace:fst
fst::RhoMatcher::Arc	matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::RhoMatcher
fst::RhoMatcher::Copy	matcher.h	/^  virtual RhoMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::Done	matcher.h	/^  bool Done() const { return matcher_->Done(); }$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::Done_	matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::FST	matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::RhoMatcher
fst::RhoMatcher::Find	matcher.h	/^  bool Find(Label match_label) {$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::Find_	matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::GetFst	matcher.h	/^  virtual const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::RhoMatcher
fst::RhoMatcher::Next	matcher.h	/^  void Next() { matcher_->Next(); }$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::Next_	matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::Properties	matcher.h	/^uint64 RhoMatcher<M>::Properties(uint64 inprops) const {$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::RhoMatcher	matcher.h	/^  RhoMatcher(const FST &fst,$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::RhoMatcher	matcher.h	/^  RhoMatcher(const RhoMatcher<M> &matcher, bool safe = false)$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::SetState_	matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::RhoMatcher
fst::RhoMatcher::Type	matcher.h	/^  virtual MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::Value_	matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::RhoMatcher
fst::RhoMatcher::Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::RhoMatcher
fst::RhoMatcher::error_	matcher.h	/^  bool error_;            \/\/ Error encountered$/;"	m	class:fst::RhoMatcher
fst::RhoMatcher::has_rho_	matcher.h	/^  bool has_rho_;          \/\/ Are there possibly rhos at the current state?$/;"	m	class:fst::RhoMatcher
fst::RhoMatcher::match_type_	matcher.h	/^  MatchType match_type_;  \/\/ Type of match requested$/;"	m	class:fst::RhoMatcher
fst::RhoMatcher::matcher_	matcher.h	/^  M *matcher_;$/;"	m	class:fst::RhoMatcher
fst::RhoMatcher::rewrite_both_	matcher.h	/^  bool rewrite_both_;     \/\/ Rewrite both sides when both are 'rho_label_'$/;"	m	class:fst::RhoMatcher
fst::RhoMatcher::rho_arc_	matcher.h	/^  mutable Arc rho_arc_;   \/\/ Arc to return when rho match$/;"	m	class:fst::RhoMatcher
fst::RhoMatcher::rho_label_	matcher.h	/^  Label rho_label_;       \/\/ Label that represents the rho transition$/;"	m	class:fst::RhoMatcher
fst::RhoMatcher::rho_match_	matcher.h	/^  Label rho_match_;       \/\/ Current label that matches rho transition$/;"	m	class:fst::RhoMatcher
fst::RhoMatcher::~RhoMatcher	matcher.h	/^  virtual ~RhoMatcher() {$/;"	f	class:fst::RhoMatcher
fst::RmEpsilon	rmepsilon.h	/^void RmEpsilon(MutableFst<Arc> *fst,$/;"	f	namespace:fst
fst::RmEpsilonFst	rmepsilon.h	/^class RmEpsilonFst : public ImplToFst< RmEpsilonFstImpl<A> > {$/;"	c	namespace:fst
fst::RmEpsilonFst::Arc	rmepsilon.h	/^  typedef A Arc;$/;"	t	class:fst::RmEpsilonFst
fst::RmEpsilonFst::Copy	rmepsilon.h	/^  virtual RmEpsilonFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::RmEpsilonFst
fst::RmEpsilonFst::GetImpl	rmepsilon.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::RmEpsilonFst
fst::RmEpsilonFst::Impl	rmepsilon.h	/^  typedef RmEpsilonFstImpl<A> Impl;$/;"	t	class:fst::RmEpsilonFst
fst::RmEpsilonFst::InitArcIterator	rmepsilon.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::RmEpsilonFst
fst::RmEpsilonFst::InitStateIterator	rmepsilon.h	/^void RmEpsilonFst<A>::InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::RmEpsilonFst
fst::RmEpsilonFst::RmEpsilonFst	rmepsilon.h	/^  RmEpsilonFst(const Fst<A> &fst)$/;"	f	class:fst::RmEpsilonFst
fst::RmEpsilonFst::RmEpsilonFst	rmepsilon.h	/^  RmEpsilonFst(const Fst<A> &fst, const RmEpsilonFstOptions &opts)$/;"	f	class:fst::RmEpsilonFst
fst::RmEpsilonFst::RmEpsilonFst	rmepsilon.h	/^  RmEpsilonFst(const RmEpsilonFst<A> &fst, bool safe = false)$/;"	f	class:fst::RmEpsilonFst
fst::RmEpsilonFst::State	rmepsilon.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::RmEpsilonFst
fst::RmEpsilonFst::StateId	rmepsilon.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RmEpsilonFst
fst::RmEpsilonFstImpl	rmepsilon.h	/^class RmEpsilonFstImpl : public CacheImpl<A> {$/;"	c	namespace:fst
fst::RmEpsilonFstImpl::Expand	rmepsilon.h	/^  void Expand(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::Final	rmepsilon.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::InitArcIterator	rmepsilon.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::Label	rmepsilon.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::NumArcs	rmepsilon.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::NumInputEpsilons	rmepsilon.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::NumOutputEpsilons	rmepsilon.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::Properties	rmepsilon.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::Properties	rmepsilon.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::RmEpsilonFstImpl	rmepsilon.h	/^  RmEpsilonFstImpl(const Fst<A>& fst, const RmEpsilonFstOptions &opts)$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::RmEpsilonFstImpl	rmepsilon.h	/^  RmEpsilonFstImpl(const RmEpsilonFstImpl &impl)$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::Start	rmepsilon.h	/^  StateId Start() {$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::State	rmepsilon.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::StateId	rmepsilon.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::Weight	rmepsilon.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::delta_	rmepsilon.h	/^  float delta_;$/;"	m	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::distance_	rmepsilon.h	/^  vector<Weight> distance_;$/;"	m	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::fst_	rmepsilon.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::queue_	rmepsilon.h	/^  FifoQueue<StateId> queue_;$/;"	m	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::rmeps_state_	rmepsilon.h	/^  RmEpsilonState<A, FifoQueue<StateId> > rmeps_state_;$/;"	m	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstImpl::~RmEpsilonFstImpl	rmepsilon.h	/^  ~RmEpsilonFstImpl() {$/;"	f	class:fst::RmEpsilonFstImpl
fst::RmEpsilonFstOptions	rmepsilon.h	/^struct RmEpsilonFstOptions : CacheOptions {$/;"	s	namespace:fst
fst::RmEpsilonFstOptions::RmEpsilonFstOptions	rmepsilon.h	/^  RmEpsilonFstOptions(const CacheOptions &opts, float delta = kDelta)$/;"	f	struct:fst::RmEpsilonFstOptions
fst::RmEpsilonFstOptions::RmEpsilonFstOptions	rmepsilon.h	/^  explicit RmEpsilonFstOptions(float delta = kDelta) : delta(delta) {}$/;"	f	struct:fst::RmEpsilonFstOptions
fst::RmEpsilonFstOptions::delta	rmepsilon.h	/^  float delta;$/;"	m	struct:fst::RmEpsilonFstOptions
fst::RmEpsilonOptions	rmepsilon.h	/^class RmEpsilonOptions$/;"	c	namespace:fst
fst::RmEpsilonOptions::RmEpsilonOptions	rmepsilon.h	/^  explicit RmEpsilonOptions(Queue *q, float d = kDelta, bool c = true,$/;"	f	class:fst::RmEpsilonOptions
fst::RmEpsilonOptions::StateId	rmepsilon.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::RmEpsilonOptions
fst::RmEpsilonOptions::Weight	rmepsilon.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::RmEpsilonOptions
fst::RmEpsilonOptions::connect	rmepsilon.h	/^  bool connect;              \/\/ Connect output$/;"	m	class:fst::RmEpsilonOptions
fst::RmEpsilonOptions::state_threshold	rmepsilon.h	/^  StateId state_threshold;   \/\/ Pruning state threshold.$/;"	m	class:fst::RmEpsilonOptions
fst::RmEpsilonOptions::weight_threshold	rmepsilon.h	/^  Weight weight_threshold;   \/\/ Pruning weight threshold.$/;"	m	class:fst::RmEpsilonOptions
fst::RmEpsilonState	rmepsilon.h	/^class RmEpsilonState {$/;"	c	namespace:fst
fst::RmEpsilonState::Arcs	rmepsilon.h	/^  vector<Arc> &Arcs() { return arcs_; }$/;"	f	class:fst::RmEpsilonState
fst::RmEpsilonState::Element	rmepsilon.h	/^  struct Element {$/;"	s	class:fst::RmEpsilonState
fst::RmEpsilonState::Element::Element	rmepsilon.h	/^    Element() {}$/;"	f	struct:fst::RmEpsilonState::Element
fst::RmEpsilonState::Element::Element	rmepsilon.h	/^    Element(Label i, Label o, StateId s)$/;"	f	struct:fst::RmEpsilonState::Element
fst::RmEpsilonState::Element::ilabel	rmepsilon.h	/^    Label ilabel;$/;"	m	struct:fst::RmEpsilonState::Element
fst::RmEpsilonState::Element::nextstate	rmepsilon.h	/^    StateId nextstate;$/;"	m	struct:fst::RmEpsilonState::Element
fst::RmEpsilonState::Element::olabel	rmepsilon.h	/^    Label olabel;$/;"	m	struct:fst::RmEpsilonState::Element
fst::RmEpsilonState::ElementEqual	rmepsilon.h	/^  class ElementEqual {$/;"	c	class:fst::RmEpsilonState
fst::RmEpsilonState::ElementEqual::operator ()	rmepsilon.h	/^    bool operator()(const Element &e1, const Element &e2) const {$/;"	f	class:fst::RmEpsilonState::ElementEqual
fst::RmEpsilonState::ElementKey	rmepsilon.h	/^  class ElementKey {$/;"	c	class:fst::RmEpsilonState
fst::RmEpsilonState::ElementKey::operator ()	rmepsilon.h	/^    size_t operator()(const Element& e) const {$/;"	f	class:fst::RmEpsilonState::ElementKey
fst::RmEpsilonState::ElementMap	rmepsilon.h	/^                   ElementKey, ElementEqual> ElementMap;$/;"	t	class:fst::RmEpsilonState
fst::RmEpsilonState::Error	rmepsilon.h	/^  bool Error() const { return sd_state_.Error(); }$/;"	f	class:fst::RmEpsilonState
fst::RmEpsilonState::Expand	rmepsilon.h	/^void RmEpsilonState<Arc,Queue>::Expand(typename Arc::StateId source) {$/;"	f	class:fst::RmEpsilonState
fst::RmEpsilonState::Final	rmepsilon.h	/^  const Weight &Final() const { return final_; }$/;"	f	class:fst::RmEpsilonState
fst::RmEpsilonState::Label	rmepsilon.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::RmEpsilonState
fst::RmEpsilonState::RmEpsilonState	rmepsilon.h	/^  RmEpsilonState(const Fst<Arc> &fst,$/;"	f	class:fst::RmEpsilonState
fst::RmEpsilonState::StateId	rmepsilon.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::RmEpsilonState
fst::RmEpsilonState::Weight	rmepsilon.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::RmEpsilonState
fst::RmEpsilonState::arcs_	rmepsilon.h	/^  vector<Arc> arcs_;              \/\/ Arcs of state being expanded$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::distance_	rmepsilon.h	/^  vector<Weight> *distance_;$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::element_map_	rmepsilon.h	/^  ElementMap element_map_;$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::eps_filter_	rmepsilon.h	/^  EpsilonArcFilter<Arc> eps_filter_;$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::eps_queue_	rmepsilon.h	/^  stack<StateId> eps_queue_;      \/\/ Queue used to visit the epsilon-closure$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::expand_id_	rmepsilon.h	/^  StateId expand_id_;             \/\/ Unique ID for each call to Expand$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::final_	rmepsilon.h	/^  Weight final_;                  \/\/ Final weight of state being expanded$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::fst_	rmepsilon.h	/^  const Fst<Arc> &fst_;$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::kPrime0	rmepsilon.h	/^  static const size_t kPrime0 = 7853;$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::kPrime0	rmepsilon.h	/^const size_t RmEpsilonState<Arc, Queue>::kPrime0;$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::kPrime1	rmepsilon.h	/^  static const size_t kPrime1 = 7867;$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::kPrime1	rmepsilon.h	/^const size_t RmEpsilonState<Arc, Queue>::kPrime1;$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::sd_state_	rmepsilon.h	/^  ShortestDistanceState<Arc, Queue, EpsilonArcFilter<Arc> > sd_state_;$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::visited_	rmepsilon.h	/^  vector<bool> visited_;          \/\/ '[i] = true' if state 'i' has been visited$/;"	m	class:fst::RmEpsilonState
fst::RmEpsilonState::visited_states_	rmepsilon.h	/^  slist<StateId> visited_states_; \/\/ List of visited states$/;"	m	class:fst::RmEpsilonState
fst::RmFinalEpsilon	rmfinalepsilon.h	/^void RmFinalEpsilon(MutableFst<A>* fst) {$/;"	f	namespace:fst
fst::RmWeightMapper	arc-map.h	/^struct RmWeightMapper {$/;"	s	namespace:fst
fst::RmWeightMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::RmWeightMapper
fst::RmWeightMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::RmWeightMapper
fst::RmWeightMapper::FromWeight	arc-map.h	/^  typedef typename FromArc::Weight FromWeight;$/;"	t	struct:fst::RmWeightMapper
fst::RmWeightMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::RmWeightMapper
fst::RmWeightMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::RmWeightMapper
fst::RmWeightMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::RmWeightMapper
fst::RmWeightMapper::ToArc	arc-map.h	/^  typedef B ToArc;$/;"	t	struct:fst::RmWeightMapper
fst::RmWeightMapper::ToWeight	arc-map.h	/^  typedef typename ToArc::Weight ToWeight;$/;"	t	struct:fst::RmWeightMapper
fst::RmWeightMapper::operator ()	arc-map.h	/^  B operator()(const A &arc) const {$/;"	f	struct:fst::RmWeightMapper
fst::SCC_QUEUE	queue.h	/^  SCC_QUEUE = 6,             \/\/ Component graph top-ordered meta-queue$/;"	e	enum:fst::QueueType
fst::SEQUENCE_FILTER	compose.h	/^enum ComposeFilter { AUTO_FILTER, SEQUENCE_FILTER, ALT_SEQUENCE_FILTER,$/;"	e	enum:fst::ComposeFilter
fst::SHORTEST_FIRST_QUEUE	queue.h	/^  SHORTEST_FIRST_QUEUE = 3,  \/\/ Shortest-first queue$/;"	e	enum:fst::QueueType
fst::STATE_ORDER_QUEUE	queue.h	/^  STATE_ORDER_QUEUE = 5,     \/\/ State-ID ordered queue$/;"	e	enum:fst::QueueType
fst::STRING_LEFT	string-weight.h	/^enum StringType { STRING_LEFT = 0, STRING_RIGHT = 1 ,$/;"	e	enum:fst::StringType
fst::STRING_LEFT_RESTRICT	string-weight.h	/^                  STRING_LEFT_RESTRICT = 2, STRING_RIGHT_RESTRICT };$/;"	e	enum:fst::StringType
fst::STRING_RIGHT	string-weight.h	/^enum StringType { STRING_LEFT = 0, STRING_RIGHT = 1 ,$/;"	e	enum:fst::StringType
fst::STRING_RIGHT_RESTRICT	string-weight.h	/^                  STRING_LEFT_RESTRICT = 2, STRING_RIGHT_RESTRICT };$/;"	e	enum:fst::StringType
fst::SccQueue	queue.h	/^class SccQueue : public QueueBase<S> {$/;"	c	namespace:fst
fst::SccQueue::Clear	queue.h	/^  void Clear() {$/;"	f	class:fst::SccQueue
fst::SccQueue::Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::SccQueue
fst::SccQueue::Dequeue	queue.h	/^  void Dequeue() {$/;"	f	class:fst::SccQueue
fst::SccQueue::Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::SccQueue
fst::SccQueue::Empty	queue.h	/^  bool Empty() const {$/;"	f	class:fst::SccQueue
fst::SccQueue::Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::SccQueue
fst::SccQueue::Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::SccQueue
fst::SccQueue::Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::SccQueue
fst::SccQueue::Head	queue.h	/^  StateId Head() const {$/;"	f	class:fst::SccQueue
fst::SccQueue::Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::SccQueue
fst::SccQueue::Queue	queue.h	/^  typedef Q Queue;$/;"	t	class:fst::SccQueue
fst::SccQueue::SccQueue	queue.h	/^  SccQueue(const vector<StateId> &scc, vector<Queue*> *queue)$/;"	f	class:fst::SccQueue
fst::SccQueue::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::SccQueue
fst::SccQueue::Update	queue.h	/^  void Update(StateId s) {$/;"	f	class:fst::SccQueue
fst::SccQueue::Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::SccQueue
fst::SccQueue::back_	queue.h	/^  StateId back_;$/;"	m	class:fst::SccQueue
fst::SccQueue::front_	queue.h	/^  mutable StateId front_;$/;"	m	class:fst::SccQueue
fst::SccQueue::queue_	queue.h	/^  vector<Queue*> *queue_;$/;"	m	class:fst::SccQueue
fst::SccQueue::scc_	queue.h	/^  const vector<StateId> &scc_;$/;"	m	class:fst::SccQueue
fst::SccQueue::trivial_queue_	queue.h	/^  vector<StateId> trivial_queue_;$/;"	m	class:fst::SccQueue
fst::SccVisitor	connect.h	/^class SccVisitor {$/;"	c	namespace:fst
fst::SccVisitor::Arc	connect.h	/^  typedef A Arc;$/;"	t	class:fst::SccVisitor
fst::SccVisitor::BackArc	connect.h	/^  bool BackArc(StateId s, const A &arc) {$/;"	f	class:fst::SccVisitor
fst::SccVisitor::FinishState	connect.h	/^void SccVisitor<A>::FinishState(StateId s, StateId p, const A *) {$/;"	f	class:fst::SccVisitor
fst::SccVisitor::FinishVisit	connect.h	/^  void FinishVisit() {$/;"	f	class:fst::SccVisitor
fst::SccVisitor::ForwardOrCrossArc	connect.h	/^  bool ForwardOrCrossArc(StateId s, const A &arc) {$/;"	f	class:fst::SccVisitor
fst::SccVisitor::InitState	connect.h	/^bool SccVisitor<A>::InitState(StateId s, StateId root) {$/;"	f	class:fst::SccVisitor
fst::SccVisitor::InitVisit	connect.h	/^void SccVisitor<A>::InitVisit(const Fst<A> &fst) {$/;"	f	class:fst::SccVisitor
fst::SccVisitor::SccVisitor	connect.h	/^  SccVisitor(uint64 *props)$/;"	f	class:fst::SccVisitor
fst::SccVisitor::SccVisitor	connect.h	/^  SccVisitor(vector<StateId> *scc, vector<bool> *access,$/;"	f	class:fst::SccVisitor
fst::SccVisitor::StateId	connect.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::SccVisitor
fst::SccVisitor::TreeArc	connect.h	/^  bool TreeArc(StateId s, const A &arc) { return true; }$/;"	f	class:fst::SccVisitor
fst::SccVisitor::Weight	connect.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::SccVisitor
fst::SccVisitor::access_	connect.h	/^  vector<bool> *access_;        \/\/ State's accessibility$/;"	m	class:fst::SccVisitor
fst::SccVisitor::coaccess_	connect.h	/^  vector<bool> *coaccess_;      \/\/ State's coaccessibility$/;"	m	class:fst::SccVisitor
fst::SccVisitor::coaccess_internal_	connect.h	/^  bool coaccess_internal_;$/;"	m	class:fst::SccVisitor
fst::SccVisitor::dfnumber_	connect.h	/^  vector<StateId> *dfnumber_;   \/\/ state discovery times$/;"	m	class:fst::SccVisitor
fst::SccVisitor::fst_	connect.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::SccVisitor
fst::SccVisitor::lowlink_	connect.h	/^  vector<StateId> *lowlink_;    \/\/ lowlink[s] == dfnumber[s] => SCC root$/;"	m	class:fst::SccVisitor
fst::SccVisitor::nscc_	connect.h	/^  StateId nscc_;                \/\/ SCC count$/;"	m	class:fst::SccVisitor
fst::SccVisitor::nstates_	connect.h	/^  StateId nstates_;             \/\/ State count$/;"	m	class:fst::SccVisitor
fst::SccVisitor::onstack_	connect.h	/^  vector<bool> *onstack_;       \/\/ is a state on the SCC stack$/;"	m	class:fst::SccVisitor
fst::SccVisitor::props_	connect.h	/^  uint64 *props_;$/;"	m	class:fst::SccVisitor
fst::SccVisitor::scc_	connect.h	/^  vector<StateId> *scc_;        \/\/ State's scc number$/;"	m	class:fst::SccVisitor
fst::SccVisitor::scc_stack_	connect.h	/^  vector<StateId> *scc_stack_;  \/\/ SCC stack (w\/ random access)$/;"	m	class:fst::SccVisitor
fst::SccVisitor::start_	connect.h	/^  StateId start_;$/;"	m	class:fst::SccVisitor
fst::SequenceComposeFilter	compose-filter.h	/^class SequenceComposeFilter {$/;"	c	namespace:fst
fst::SequenceComposeFilter::Arc	compose-filter.h	/^  typedef typename FST1::Arc Arc;$/;"	t	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::FST1	compose-filter.h	/^  typedef typename M1::FST FST1;$/;"	t	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::FST2	compose-filter.h	/^  typedef typename M2::FST FST2;$/;"	t	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::FilterArc	compose-filter.h	/^  FilterState FilterArc(Arc *arc1, Arc *arc2) const {$/;"	f	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::FilterFinal	compose-filter.h	/^  void FilterFinal(Weight *, Weight *) const {}$/;"	f	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::FilterState	compose-filter.h	/^  typedef CharFilterState FilterState;$/;"	t	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::GetMatcher1	compose-filter.h	/^  Matcher1 *GetMatcher1() { return matcher1_; }$/;"	f	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::GetMatcher2	compose-filter.h	/^  Matcher2 *GetMatcher2() { return matcher2_; }$/;"	f	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::Label	compose-filter.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::Matcher1	compose-filter.h	/^  typedef M1 Matcher1;$/;"	t	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::Matcher2	compose-filter.h	/^  typedef M2 Matcher2;$/;"	t	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::Properties	compose-filter.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::SequenceComposeFilter	compose-filter.h	/^  SequenceComposeFilter(const FST1 &fst1, const FST2 &fst2,$/;"	f	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::SequenceComposeFilter	compose-filter.h	/^  SequenceComposeFilter(const SequenceComposeFilter<M1, M2> &filter,$/;"	f	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::SetState	compose-filter.h	/^  void SetState(StateId s1, StateId s2, const FilterState &f) {$/;"	f	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::Start	compose-filter.h	/^  FilterState Start() const { return FilterState(0); }$/;"	f	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::StateId	compose-filter.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::Weight	compose-filter.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::alleps1_	compose-filter.h	/^  bool alleps1_;   \/\/ Only epsilons (and non-final) leaving s1_?$/;"	m	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::f_	compose-filter.h	/^  FilterState f_;  \/\/ Current filter state$/;"	m	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::fst1_	compose-filter.h	/^  const FST1 &fst1_;$/;"	m	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::matcher1_	compose-filter.h	/^  Matcher1 *matcher1_;$/;"	m	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::matcher2_	compose-filter.h	/^  Matcher2 *matcher2_;$/;"	m	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::noeps1_	compose-filter.h	/^  bool noeps1_;    \/\/ No epsilons leaving s1_?$/;"	m	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::s1_	compose-filter.h	/^  StateId s1_;     \/\/ Current fst1_ state;$/;"	m	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::s2_	compose-filter.h	/^  StateId s2_;     \/\/ Current fst2_ state;$/;"	m	class:fst::SequenceComposeFilter
fst::SequenceComposeFilter::~SequenceComposeFilter	compose-filter.h	/^  ~SequenceComposeFilter() {$/;"	f	class:fst::SequenceComposeFilter
fst::SetFinalProperties	properties.h	/^uint64 SetFinalProperties(uint64 inprops, Weight old_weight,$/;"	f	namespace:fst
fst::SetStartProperties	properties.h	/^uint64 SetStartProperties(uint64 inprops) {$/;"	f	namespace:fst
fst::ShortFilterState	compose-filter.h	/^typedef IntegerFilterState<short> ShortFilterState;$/;"	t	namespace:fst
fst::ShortFilterState	fst-decl.h	/^typedef IntegerFilterState<short> ShortFilterState;$/;"	t	namespace:fst
fst::ShortestDistance	shortest-distance.h	/^typename Arc::Weight ShortestDistance(const Fst<Arc> &fst, float delta = kDelta) {$/;"	f	namespace:fst
fst::ShortestDistance	shortest-distance.h	/^void ShortestDistance($/;"	f	namespace:fst
fst::ShortestDistance	shortest-distance.h	/^void ShortestDistance(const Fst<Arc> &fst,$/;"	f	namespace:fst
fst::ShortestDistanceOptions	shortest-distance.h	/^struct ShortestDistanceOptions {$/;"	s	namespace:fst
fst::ShortestDistanceOptions::ShortestDistanceOptions	shortest-distance.h	/^  ShortestDistanceOptions(Queue *q, ArcFilter filt, StateId src = kNoStateId,$/;"	f	struct:fst::ShortestDistanceOptions
fst::ShortestDistanceOptions::StateId	shortest-distance.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::ShortestDistanceOptions
fst::ShortestDistanceOptions::arc_filter	shortest-distance.h	/^  ArcFilter arc_filter;  \/\/ Arc filter (e.g., limit to only epsilon graph)$/;"	m	struct:fst::ShortestDistanceOptions
fst::ShortestDistanceOptions::delta	shortest-distance.h	/^  float delta;           \/\/ Determines the degree of convergence required$/;"	m	struct:fst::ShortestDistanceOptions
fst::ShortestDistanceOptions::first_path	shortest-distance.h	/^  bool first_path;       \/\/ For a semiring with the path property (o.w.$/;"	m	struct:fst::ShortestDistanceOptions
fst::ShortestDistanceOptions::source	shortest-distance.h	/^  StateId source;        \/\/ If kNoStateId, use the Fst's initial state$/;"	m	struct:fst::ShortestDistanceOptions
fst::ShortestDistanceOptions::state_queue	shortest-distance.h	/^  Queue *state_queue;    \/\/ Queue discipline used; owned by caller$/;"	m	struct:fst::ShortestDistanceOptions
fst::ShortestDistanceState	shortest-distance.h	/^class ShortestDistanceState {$/;"	c	namespace:fst
fst::ShortestDistanceState::Error	shortest-distance.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::ShortestDistanceState
fst::ShortestDistanceState::ShortestDistance	shortest-distance.h	/^void ShortestDistanceState<Arc, Queue, ArcFilter>::ShortestDistance($/;"	f	class:fst::ShortestDistanceState
fst::ShortestDistanceState::ShortestDistanceState	shortest-distance.h	/^  ShortestDistanceState($/;"	f	class:fst::ShortestDistanceState
fst::ShortestDistanceState::StateId	shortest-distance.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::ShortestDistanceState
fst::ShortestDistanceState::Weight	shortest-distance.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::ShortestDistanceState
fst::ShortestDistanceState::arc_filter_	shortest-distance.h	/^  ArcFilter arc_filter_;$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::delta_	shortest-distance.h	/^  float delta_;$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::distance_	shortest-distance.h	/^  vector<Weight> *distance_;$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::enqueued_	shortest-distance.h	/^  vector<bool> enqueued_;     \/\/ Is state enqueued?$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::error_	shortest-distance.h	/^  bool error_;$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::first_path_	shortest-distance.h	/^  bool first_path_;$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::fst_	shortest-distance.h	/^  const Fst<Arc> &fst_;$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::rdistance_	shortest-distance.h	/^  vector<Weight> rdistance_;  \/\/ Relaxation distance.$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::retain_	shortest-distance.h	/^  bool retain_;               \/\/ Retain and reuse information across calls$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::source_id_	shortest-distance.h	/^  StateId source_id_;         \/\/ Unique ID characterizing each call to SD$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::sources_	shortest-distance.h	/^  vector<StateId> sources_;   \/\/ Source ID for ith state in 'distance_',$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::state_queue_	shortest-distance.h	/^  Queue *state_queue_;$/;"	m	class:fst::ShortestDistanceState
fst::ShortestDistanceState::~ShortestDistanceState	shortest-distance.h	/^  ~ShortestDistanceState() {}$/;"	f	class:fst::ShortestDistanceState
fst::ShortestFirstQueue	queue.h	/^class ShortestFirstQueue : public QueueBase<S> {$/;"	c	namespace:fst
fst::ShortestFirstQueue::Clear	queue.h	/^  void Clear() {$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Compare	queue.h	/^  typedef C Compare;$/;"	t	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Dequeue	queue.h	/^  void Dequeue() {$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Empty	queue.h	/^  bool Empty() const { return heap_.Empty(); }$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Head	queue.h	/^  StateId Head() const { return heap_.Top(); }$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::ShortestFirstQueue	queue.h	/^  ShortestFirstQueue(C comp)$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Update	queue.h	/^  void Update(StateId s) {$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::heap_	queue.h	/^  Heap<S, C, false> heap_;$/;"	m	class:fst::ShortestFirstQueue
fst::ShortestFirstQueue::key_	queue.h	/^  vector<ssize_t> key_;$/;"	m	class:fst::ShortestFirstQueue
fst::ShortestPath	shortest-path.h	/^void ShortestPath(const Fst<Arc> &ifst, MutableFst<Arc> *ofst,$/;"	f	namespace:fst
fst::ShortestPathCompare	shortest-path.h	/^class ShortestPathCompare {$/;"	c	namespace:fst
fst::ShortestPathCompare::Pair	shortest-path.h	/^  typedef pair<StateId, Weight> Pair;$/;"	t	class:fst::ShortestPathCompare
fst::ShortestPathCompare::ShortestPathCompare	shortest-path.h	/^  ShortestPathCompare(const vector<Pair>& pairs,$/;"	f	class:fst::ShortestPathCompare
fst::ShortestPathCompare::StateId	shortest-path.h	/^  typedef S StateId;$/;"	t	class:fst::ShortestPathCompare
fst::ShortestPathCompare::Weight	shortest-path.h	/^  typedef W Weight;$/;"	t	class:fst::ShortestPathCompare
fst::ShortestPathCompare::delta_	shortest-path.h	/^  float delta_;$/;"	m	class:fst::ShortestPathCompare
fst::ShortestPathCompare::distance_	shortest-path.h	/^  const vector<Weight> &distance_;$/;"	m	class:fst::ShortestPathCompare
fst::ShortestPathCompare::less_	shortest-path.h	/^  NaturalLess<Weight> less_;$/;"	m	class:fst::ShortestPathCompare
fst::ShortestPathCompare::operator ()	shortest-path.h	/^  bool operator()(const StateId x, const StateId y) const {$/;"	f	class:fst::ShortestPathCompare
fst::ShortestPathCompare::pairs_	shortest-path.h	/^  const vector<Pair> &pairs_;$/;"	m	class:fst::ShortestPathCompare
fst::ShortestPathCompare::superfinal_	shortest-path.h	/^  StateId superfinal_;$/;"	m	class:fst::ShortestPathCompare
fst::ShortestPathOptions	shortest-path.h	/^struct ShortestPathOptions$/;"	s	namespace:fst
fst::ShortestPathOptions::ShortestPathOptions	shortest-path.h	/^  ShortestPathOptions(Queue *q, ArcFilter filt, size_t n = 1, bool u = false,$/;"	f	struct:fst::ShortestPathOptions
fst::ShortestPathOptions::StateId	shortest-path.h	/^  typedef typename Arc::StateId StateId;$/;"	t	struct:fst::ShortestPathOptions
fst::ShortestPathOptions::Weight	shortest-path.h	/^  typedef typename Arc::Weight Weight;$/;"	t	struct:fst::ShortestPathOptions
fst::ShortestPathOptions::first_path	shortest-path.h	/^  bool first_path;    \/\/ Single shortest path stops after finding the first$/;"	m	struct:fst::ShortestPathOptions
fst::ShortestPathOptions::has_distance	shortest-path.h	/^  bool has_distance;  \/\/ distance vector already contains the$/;"	m	struct:fst::ShortestPathOptions
fst::ShortestPathOptions::nshortest	shortest-path.h	/^  size_t nshortest;   \/\/ return n-shortest paths$/;"	m	struct:fst::ShortestPathOptions
fst::ShortestPathOptions::state_threshold	shortest-path.h	/^  StateId state_threshold;   \/\/ pruning state threshold.$/;"	m	struct:fst::ShortestPathOptions
fst::ShortestPathOptions::unique	shortest-path.h	/^  bool unique;        \/\/ only return paths with distinct input strings$/;"	m	struct:fst::ShortestPathOptions
fst::ShortestPathOptions::weight_threshold	shortest-path.h	/^  Weight weight_threshold;   \/\/ pruning weight threshold.$/;"	m	struct:fst::ShortestPathOptions
fst::SigmaMatcher	matcher.h	/^class SigmaMatcher : public MatcherBase<typename M::Arc> {$/;"	c	namespace:fst
fst::SigmaMatcher::Arc	matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::SigmaMatcher
fst::SigmaMatcher::Copy	matcher.h	/^  virtual SigmaMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::Done	matcher.h	/^  bool Done() const {$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::Done_	matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::FST	matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::SigmaMatcher
fst::SigmaMatcher::Find	matcher.h	/^  bool Find(Label match_label) {$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::Find_	matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::GetFst	matcher.h	/^  virtual const FST &GetFst() const { return matcher_->GetFst(); }$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::SigmaMatcher
fst::SigmaMatcher::Next	matcher.h	/^  void Next() {$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::Next_	matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::Properties	matcher.h	/^uint64 SigmaMatcher<M>::Properties(uint64 inprops) const {$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::SetState_	matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::SigmaMatcher	matcher.h	/^  SigmaMatcher(const FST &fst,$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::SigmaMatcher	matcher.h	/^  SigmaMatcher(const SigmaMatcher<M> &matcher, bool safe = false)$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::SigmaMatcher
fst::SigmaMatcher::Type	matcher.h	/^  virtual MatchType Type(bool test) const { return matcher_->Type(test); }$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::Value_	matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::SigmaMatcher
fst::SigmaMatcher::Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::SigmaMatcher
fst::SigmaMatcher::error_	matcher.h	/^  bool error_;             \/\/ Error encountered$/;"	m	class:fst::SigmaMatcher
fst::SigmaMatcher::has_sigma_	matcher.h	/^  bool has_sigma_;         \/\/ Are there sigmas at the current state?$/;"	m	class:fst::SigmaMatcher
fst::SigmaMatcher::match_label_	matcher.h	/^  Label match_label_;      \/\/ Label being matched$/;"	m	class:fst::SigmaMatcher
fst::SigmaMatcher::match_type_	matcher.h	/^  MatchType match_type_;   \/\/ Type of match requested$/;"	m	class:fst::SigmaMatcher
fst::SigmaMatcher::matcher_	matcher.h	/^  M *matcher_;$/;"	m	class:fst::SigmaMatcher
fst::SigmaMatcher::rewrite_both_	matcher.h	/^  bool rewrite_both_;      \/\/ Rewrite both sides when both are 'sigma_label_'$/;"	m	class:fst::SigmaMatcher
fst::SigmaMatcher::sigma_arc_	matcher.h	/^  mutable Arc sigma_arc_;  \/\/ Arc to return when sigma match$/;"	m	class:fst::SigmaMatcher
fst::SigmaMatcher::sigma_label_	matcher.h	/^  Label sigma_label_;      \/\/ Label that represents the sigma transition$/;"	m	class:fst::SigmaMatcher
fst::SigmaMatcher::sigma_match_	matcher.h	/^  Label sigma_match_;      \/\/ Current label that matches sigma transition$/;"	m	class:fst::SigmaMatcher
fst::SigmaMatcher::~SigmaMatcher	matcher.h	/^  virtual ~SigmaMatcher() {$/;"	f	class:fst::SigmaMatcher
fst::SignedLog64Arc	arc.h	/^typedef ArcTpl<SignedLog64Weight> SignedLog64Arc;$/;"	t	namespace:fst
fst::SignedLog64Weight	signed-log-weight.h	/^typedef SignedLogWeightTpl<double> SignedLog64Weight;$/;"	t	namespace:fst
fst::SignedLogArc	arc.h	/^typedef ArcTpl<SignedLogWeight> SignedLogArc;$/;"	t	namespace:fst
fst::SignedLogConvertCheck	signed-log-weight.h	/^bool SignedLogConvertCheck(W1 w) {$/;"	f	namespace:fst
fst::SignedLogWeight	signed-log-weight.h	/^typedef SignedLogWeightTpl<float> SignedLogWeight;$/;"	t	namespace:fst
fst::SignedLogWeightGenerator	random-weight.h	/^typedef SignedLogWeightGenerator_<float> SignedLogWeightGenerator;$/;"	t	namespace:fst
fst::SignedLogWeightGenerator_	random-weight.h	/^class SignedLogWeightGenerator_ {$/;"	c	namespace:fst
fst::SignedLogWeightGenerator_::SignedLogWeightGenerator_	random-weight.h	/^  SignedLogWeightGenerator_(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::SignedLogWeightGenerator_
fst::SignedLogWeightGenerator_::Weight	random-weight.h	/^  typedef SignedLogWeightTpl<T> Weight;$/;"	t	class:fst::SignedLogWeightGenerator_
fst::SignedLogWeightGenerator_::allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero divisors$/;"	m	class:fst::SignedLogWeightGenerator_
fst::SignedLogWeightGenerator_::kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::SignedLogWeightGenerator_
fst::SignedLogWeightGenerator_::kNumRandomWeights	random-weight.h	/^template <class T> const int SignedLogWeightGenerator_<T>::kNumRandomWeights;$/;"	m	class:fst::SignedLogWeightGenerator_
fst::SignedLogWeightGenerator_::operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::SignedLogWeightGenerator_
fst::SignedLogWeightTpl	signed-log-weight.h	/^class SignedLogWeightTpl$/;"	c	namespace:fst
fst::SignedLogWeightTpl::Hash	signed-log-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::Member	signed-log-weight.h	/^  bool Member() const {$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::NoWeight	signed-log-weight.h	/^  static const SignedLogWeightTpl<T> &NoWeight() {$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::One	signed-log-weight.h	/^  static const SignedLogWeightTpl<T> &One() {$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::Properties	signed-log-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::Quantize	signed-log-weight.h	/^  ProductWeight<X1, X2> Quantize(float delta = kDelta) const {$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::Reverse	signed-log-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::ReverseWeight	signed-log-weight.h	/^  typedef SignedLogWeightTpl<T> ReverseWeight;$/;"	t	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::SignedLogWeightTpl	signed-log-weight.h	/^  SignedLogWeightTpl() : PairWeight<X1, X2>() {}$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::SignedLogWeightTpl	signed-log-weight.h	/^  SignedLogWeightTpl(const PairWeight<X1, X2>& w)$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::SignedLogWeightTpl	signed-log-weight.h	/^  SignedLogWeightTpl(const SignedLogWeightTpl<T>& w)$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::SignedLogWeightTpl	signed-log-weight.h	/^  SignedLogWeightTpl(const X1& x1, const X2& x2)$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::Type	signed-log-weight.h	/^  static const string &Type() {$/;"	f	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::X1	signed-log-weight.h	/^  typedef TropicalWeight X1;$/;"	t	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::X2	signed-log-weight.h	/^  typedef LogWeightTpl<T> X2;$/;"	t	class:fst::SignedLogWeightTpl
fst::SignedLogWeightTpl::Zero	signed-log-weight.h	/^  static const SignedLogWeightTpl<T> &Zero() {$/;"	f	class:fst::SignedLogWeightTpl
fst::SingleShortestPath	shortest-path.h	/^void SingleShortestPath(const Fst<Arc> &ifst,$/;"	f	namespace:fst
fst::SortedMatcher	matcher.h	/^class SortedMatcher : public MatcherBase<typename F::Arc> {$/;"	c	namespace:fst
fst::SortedMatcher::Arc	matcher.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::SortedMatcher
fst::SortedMatcher::Copy	matcher.h	/^  virtual SortedMatcher<F> *Copy(bool safe = false) const {$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::Done	matcher.h	/^  bool Done() const {$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::Done_	matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::FST	matcher.h	/^  typedef F FST;$/;"	t	class:fst::SortedMatcher
fst::SortedMatcher::Find	matcher.h	/^bool SortedMatcher<F>::Find(Label match_label) {$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::Find_	matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::GetFst	matcher.h	/^  virtual const F &GetFst() const { return *fst_; }$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::Label	matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::SortedMatcher
fst::SortedMatcher::Next	matcher.h	/^  void Next() {$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::Next_	matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::Properties	matcher.h	/^  virtual uint64 Properties(uint64 inprops) const {$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::SetState	matcher.h	/^  void SetState(StateId s) {$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::SetState_	matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::SortedMatcher	matcher.h	/^  SortedMatcher(const F &fst, MatchType match_type,$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::SortedMatcher	matcher.h	/^  SortedMatcher(const SortedMatcher<F> &matcher, bool safe = false)$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::StateId	matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::SortedMatcher
fst::SortedMatcher::Type	matcher.h	/^  virtual MatchType Type(bool test) const {$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::Value	matcher.h	/^  const Arc& Value() const {$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::Value_	matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::SortedMatcher
fst::SortedMatcher::Weight	matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::SortedMatcher
fst::SortedMatcher::aiter_	matcher.h	/^  ArcIterator<F> *aiter_;         \/\/ Iterator for current state$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::binary_label_	matcher.h	/^  Label binary_label_;            \/\/ Least label for binary search$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::current_loop_	matcher.h	/^  bool current_loop_;             \/\/ Current arc is the implicit loop$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::error_	matcher.h	/^  bool error_;                    \/\/ Error encountered$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::fst_	matcher.h	/^  const F *fst_;$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::loop_	matcher.h	/^  Arc loop_;                      \/\/ For non-consuming symbols$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::match_label_	matcher.h	/^  Label match_label_;             \/\/ Current label to be matched$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::match_type_	matcher.h	/^  MatchType match_type_;          \/\/ Type of match to perform$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::narcs_	matcher.h	/^  size_t narcs_;                  \/\/ Current state arc count$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::s_	matcher.h	/^  StateId s_;                     \/\/ Current state$/;"	m	class:fst::SortedMatcher
fst::SortedMatcher::~SortedMatcher	matcher.h	/^  virtual ~SortedMatcher() {$/;"	f	class:fst::SortedMatcher
fst::SparsePowerArc	arc.h	/^struct SparsePowerArc {$/;"	s	namespace:fst
fst::SparsePowerArc::Arc	arc.h	/^  typedef A Arc;$/;"	t	struct:fst::SparsePowerArc
fst::SparsePowerArc::Label	arc.h	/^  typedef typename A::Label Label;$/;"	t	struct:fst::SparsePowerArc
fst::SparsePowerArc::SparsePowerArc	arc.h	/^  SparsePowerArc() {}$/;"	f	struct:fst::SparsePowerArc
fst::SparsePowerArc::SparsePowerArc	arc.h	/^  SparsePowerArc(Label i, Label o, Weight w, StateId s)$/;"	f	struct:fst::SparsePowerArc
fst::SparsePowerArc::StateId	arc.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::SparsePowerArc
fst::SparsePowerArc::Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	struct:fst::SparsePowerArc
fst::SparsePowerArc::Weight	arc.h	/^  typedef SparsePowerWeight<typename A::Weight, K> Weight;$/;"	t	struct:fst::SparsePowerArc
fst::SparsePowerArc::ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::SparsePowerArc
fst::SparsePowerArc::nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::SparsePowerArc
fst::SparsePowerArc::olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::SparsePowerArc
fst::SparsePowerArc::weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::SparsePowerArc
fst::SparsePowerWeight	sparse-power-weight.h	/^class SparsePowerWeight : public SparseTupleWeight<W, K> {$/;"	c	namespace:fst
fst::SparsePowerWeight::NoWeight	sparse-power-weight.h	/^  static const SparsePowerWeight<W, K> &NoWeight() {$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::One	sparse-power-weight.h	/^  static const SparsePowerWeight<W, K> &One() {$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::Properties	sparse-power-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::Quantize	sparse-power-weight.h	/^  SparsePowerWeight<W, K> Quantize(float delta = kDelta) const {$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::Reverse	sparse-power-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::ReverseWeight	sparse-power-weight.h	/^  typedef SparsePowerWeight<typename W::ReverseWeight, K> ReverseWeight;$/;"	t	class:fst::SparsePowerWeight
fst::SparsePowerWeight::SparsePowerWeight	sparse-power-weight.h	/^  SparsePowerWeight() {}$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::SparsePowerWeight	sparse-power-weight.h	/^  SparsePowerWeight(Iterator begin, Iterator end) :$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::SparsePowerWeight	sparse-power-weight.h	/^  SparsePowerWeight(const K &key, const W &w) :$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::SparsePowerWeight	sparse-power-weight.h	/^  SparsePowerWeight(const SparseTupleWeight<W, K> &w) :$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::Type	sparse-power-weight.h	/^  static const string &Type() {$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeight::Zero	sparse-power-weight.h	/^  static const SparsePowerWeight<W, K> &Zero() {$/;"	f	class:fst::SparsePowerWeight
fst::SparsePowerWeightGenerator	random-weight.h	/^class SparsePowerWeightGenerator {$/;"	c	namespace:fst
fst::SparsePowerWeightGenerator::SparsePowerWeightGenerator	random-weight.h	/^  SparsePowerWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::SparsePowerWeightGenerator
fst::SparsePowerWeightGenerator::W	random-weight.h	/^  typedef typename G::Weight W;$/;"	t	class:fst::SparsePowerWeightGenerator
fst::SparsePowerWeightGenerator::Weight	random-weight.h	/^  typedef SparsePowerWeight<W, K> Weight;$/;"	t	class:fst::SparsePowerWeightGenerator
fst::SparsePowerWeightGenerator::generator_	random-weight.h	/^  G generator_;$/;"	m	class:fst::SparsePowerWeightGenerator
fst::SparsePowerWeightGenerator::operator ()	random-weight.h	/^  Weight operator()() const {$/;"	f	class:fst::SparsePowerWeightGenerator
fst::SparseTupleWeight	sparse-tuple-weight.h	/^class SparseTupleWeight {$/;"	c	namespace:fst
fst::SparseTupleWeight::DefaultValue	sparse-tuple-weight.h	/^  const W& DefaultValue() const { return default_; }$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Hash	sparse-tuple-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Init	sparse-tuple-weight.h	/^  void Init() {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Init	sparse-tuple-weight.h	/^  void Init(const W& default_value) {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Member	sparse-tuple-weight.h	/^  bool Member() const {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::NoWeight	sparse-tuple-weight.h	/^  static const SparseTupleWeight<W, K> &NoWeight() {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::One	sparse-tuple-weight.h	/^  static const SparseTupleWeight<W, K> &One() {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Pair	sparse-tuple-weight.h	/^  typedef pair<K, W> Pair;$/;"	t	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Push	sparse-tuple-weight.h	/^  inline void Push(const K &k, const W &w, bool default_value_check = true) {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Push	sparse-tuple-weight.h	/^  inline void Push(const Pair &p, bool default_value_check = true) {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Quantize	sparse-tuple-weight.h	/^  SparseTupleWeight<W, K> Quantize(float delta = kDelta) const {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Read	sparse-tuple-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::ReadNoParen	sparse-tuple-weight.h	/^inline istream& SparseTupleWeight<W, K>::ReadNoParen($/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::ReadWithParen	sparse-tuple-weight.h	/^inline istream& SparseTupleWeight<W, K>::ReadWithParen($/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Reverse	sparse-tuple-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::ReverseWeight	sparse-tuple-weight.h	/^  typedef SparseTupleWeight<typename W::ReverseWeight, K> ReverseWeight;$/;"	t	class:fst::SparseTupleWeight
fst::SparseTupleWeight::SetDefaultValue	sparse-tuple-weight.h	/^  void SetDefaultValue(const W& val) { default_ = val; }$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Size	sparse-tuple-weight.h	/^  size_t Size() const {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight() {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight(Iterator begin, Iterator end) {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight(const K& key, const W &w) {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight(const SparseTupleWeight<W, K> &w) {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::SparseTupleWeight	sparse-tuple-weight.h	/^  SparseTupleWeight(const W &w) {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Write	sparse-tuple-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::Zero	sparse-tuple-weight.h	/^  static const SparseTupleWeight<W, K> &Zero() {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::default_	sparse-tuple-weight.h	/^  W default_;$/;"	m	class:fst::SparseTupleWeight
fst::SparseTupleWeight::first_	sparse-tuple-weight.h	/^  Pair first_;$/;"	m	class:fst::SparseTupleWeight
fst::SparseTupleWeight::kNoKey	sparse-tuple-weight.h	/^  const static K kNoKey = -1;$/;"	m	class:fst::SparseTupleWeight
fst::SparseTupleWeight::operator =	sparse-tuple-weight.h	/^  SparseTupleWeight<W, K> &operator=(const SparseTupleWeight<W, K> &w) {$/;"	f	class:fst::SparseTupleWeight
fst::SparseTupleWeight::rest_	sparse-tuple-weight.h	/^  list<Pair> rest_;$/;"	m	class:fst::SparseTupleWeight
fst::SparseTupleWeightApproxMapper	sparse-power-weight.h	/^struct SparseTupleWeightApproxMapper {$/;"	s	namespace:fst
fst::SparseTupleWeightApproxMapper::Map	sparse-power-weight.h	/^  W Map(const K& k, const W& v1, const W& v2) const {$/;"	f	struct:fst::SparseTupleWeightApproxMapper
fst::SparseTupleWeightApproxMapper::SparseTupleWeightApproxMapper	sparse-power-weight.h	/^  SparseTupleWeightApproxMapper(float delta) { delta_ = delta; }$/;"	f	struct:fst::SparseTupleWeightApproxMapper
fst::SparseTupleWeightApproxMapper::delta_	sparse-power-weight.h	/^  float delta_;$/;"	m	struct:fst::SparseTupleWeightApproxMapper
fst::SparseTupleWeightDivideMapper	sparse-power-weight.h	/^struct SparseTupleWeightDivideMapper {$/;"	s	namespace:fst
fst::SparseTupleWeightDivideMapper::Map	sparse-power-weight.h	/^  W Map(const K& k, const W& v1, const W& v2) const {$/;"	f	struct:fst::SparseTupleWeightDivideMapper
fst::SparseTupleWeightDivideMapper::SparseTupleWeightDivideMapper	sparse-power-weight.h	/^  SparseTupleWeightDivideMapper(DivideType divide_type) {$/;"	f	struct:fst::SparseTupleWeightDivideMapper
fst::SparseTupleWeightDivideMapper::divide_type_	sparse-power-weight.h	/^  DivideType divide_type_;$/;"	m	struct:fst::SparseTupleWeightDivideMapper
fst::SparseTupleWeightIterator	sparse-tuple-weight.h	/^class SparseTupleWeightIterator {$/;"	c	namespace:fst
fst::SparseTupleWeightIterator::Done	sparse-tuple-weight.h	/^  bool Done() const {$/;"	f	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::Next	sparse-tuple-weight.h	/^  void Next() {$/;"	f	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::Pair	sparse-tuple-weight.h	/^  typedef typename SparseTupleWeight<W, K>::Pair Pair;$/;"	t	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::Reset	sparse-tuple-weight.h	/^  void Reset() {$/;"	f	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::SparseTupleWeightIterator	sparse-tuple-weight.h	/^  explicit SparseTupleWeightIterator(const SparseTupleWeight<W, K>& w)$/;"	f	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::Value	sparse-tuple-weight.h	/^  const Pair& Value() const { return init_ ? first_ : *iter_; }$/;"	f	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::const_iterator	sparse-tuple-weight.h	/^  typedef typename list<Pair>::const_iterator const_iterator;$/;"	t	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::first_	sparse-tuple-weight.h	/^  const Pair &first_;$/;"	m	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::init_	sparse-tuple-weight.h	/^  bool init_;  \/\/ in the initialized state?$/;"	m	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::iter_	sparse-tuple-weight.h	/^  typename list<Pair>::const_iterator iter_;$/;"	m	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::iterator	sparse-tuple-weight.h	/^  typedef typename list<Pair>::iterator iterator;$/;"	t	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightIterator::rest_	sparse-tuple-weight.h	/^  const list<Pair> & rest_;$/;"	m	class:fst::SparseTupleWeightIterator
fst::SparseTupleWeightMap	sparse-tuple-weight.h	/^inline void SparseTupleWeightMap($/;"	f	namespace:fst
fst::SparseTupleWeightPlusMapper	sparse-power-weight.h	/^struct SparseTupleWeightPlusMapper {$/;"	s	namespace:fst
fst::SparseTupleWeightPlusMapper::Map	sparse-power-weight.h	/^  W Map(const K& k, const W& v1, const W& v2) const {$/;"	f	struct:fst::SparseTupleWeightPlusMapper
fst::SparseTupleWeightTimesMapper	sparse-power-weight.h	/^struct SparseTupleWeightTimesMapper {$/;"	s	namespace:fst
fst::SparseTupleWeightTimesMapper::Map	sparse-power-weight.h	/^  W Map(const K& k, const W& v1, const W& v2) const {$/;"	f	struct:fst::SparseTupleWeightTimesMapper
fst::StateComparator	minimize.h	/^class StateComparator {$/;"	c	namespace:fst
fst::StateComparator::StateComparator	minimize.h	/^  StateComparator(const Fst<A>& fst,$/;"	f	class:fst::StateComparator
fst::StateComparator::StateId	minimize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateComparator
fst::StateComparator::Weight	minimize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StateComparator
fst::StateComparator::flags_	minimize.h	/^  const uint32 flags_;$/;"	m	class:fst::StateComparator
fst::StateComparator::fst_	minimize.h	/^  const Fst<A>& fst_;$/;"	m	class:fst::StateComparator
fst::StateComparator::kCompareAll	minimize.h	/^  static const uint32 kCompareAll       = 0x00000007;$/;"	m	class:fst::StateComparator
fst::StateComparator::kCompareAll	minimize.h	/^template <class A> const uint32 StateComparator<A>::kCompareAll;$/;"	m	class:fst::StateComparator
fst::StateComparator::kCompareArcs	minimize.h	/^  static const uint32 kCompareArcs      = 0x00000004;$/;"	m	class:fst::StateComparator
fst::StateComparator::kCompareArcs	minimize.h	/^template <class A> const uint32 StateComparator<A>::kCompareArcs;$/;"	m	class:fst::StateComparator
fst::StateComparator::kCompareFinal	minimize.h	/^  static const uint32 kCompareFinal     = 0x00000001;$/;"	m	class:fst::StateComparator
fst::StateComparator::kCompareFinal	minimize.h	/^template <class A> const uint32 StateComparator<A>::kCompareFinal;$/;"	m	class:fst::StateComparator
fst::StateComparator::kCompareOutDegree	minimize.h	/^  static const uint32 kCompareOutDegree = 0x00000002;$/;"	m	class:fst::StateComparator
fst::StateComparator::kCompareOutDegree	minimize.h	/^template <class A> const uint32 StateComparator<A>::kCompareOutDegree;$/;"	m	class:fst::StateComparator
fst::StateComparator::operator ()	minimize.h	/^  bool operator()(const StateId x, const StateId y) const {$/;"	f	class:fst::StateComparator
fst::StateComparator::partition_	minimize.h	/^  const Partition<typename A::StateId>& partition_;$/;"	m	class:fst::StateComparator
fst::StateIterator	arc-map.h	/^class StateIterator< ArcMapFst<A, B, C> > : public StateIteratorBase<B> {$/;"	c	namespace:fst
fst::StateIterator	arcsort.h	/^class StateIterator< ArcSortFst<A, C> >$/;"	c	namespace:fst
fst::StateIterator	closure.h	/^class StateIterator< ClosureFst<A> > : public StateIterator< RationalFst<A> > {$/;"	c	namespace:fst
fst::StateIterator	compact-fst.h	/^class StateIterator< CompactFst<A, C, U> > {$/;"	c	namespace:fst
fst::StateIterator	complement.h	/^class StateIterator< ComplementFst<A> > : public StateIteratorBase<A> {$/;"	c	namespace:fst
fst::StateIterator	compose.h	/^class StateIterator< ComposeFst<A> >$/;"	c	namespace:fst
fst::StateIterator	concat.h	/^class StateIterator< ConcatFst<A> > : public StateIterator< RationalFst<A> > {$/;"	c	namespace:fst
fst::StateIterator	const-fst.h	/^class StateIterator< ConstFst<A, U> > {$/;"	c	namespace:fst
fst::StateIterator	determinize.h	/^class StateIterator< DeterminizeFst<A> >$/;"	c	namespace:fst
fst::StateIterator	difference.h	/^class StateIterator< DifferenceFst<A> >$/;"	c	namespace:fst
fst::StateIterator	encode.h	/^class StateIterator< DecodeFst<A> >$/;"	c	namespace:fst
fst::StateIterator	encode.h	/^class StateIterator< EncodeFst<A> >$/;"	c	namespace:fst
fst::StateIterator	factor-weight.h	/^class StateIterator< FactorWeightFst<A, F> >$/;"	c	namespace:fst
fst::StateIterator	fst.h	/^class StateIterator {$/;"	c	namespace:fst
fst::StateIterator	intersect.h	/^class StateIterator< IntersectFst<A> >$/;"	c	namespace:fst
fst::StateIterator	invert.h	/^class StateIterator< InvertFst<A> >$/;"	c	namespace:fst
fst::StateIterator	map.h	/^class StateIterator< MapFst<A, B, C> >$/;"	c	namespace:fst
fst::StateIterator	matcher-fst.h	/^class StateIterator< MatcherFst<F, M, N, I> > : public StateIterator<F> {$/;"	c	namespace:fst
fst::StateIterator	project.h	/^class StateIterator< ProjectFst<A> >$/;"	c	namespace:fst
fst::StateIterator	randgen.h	/^class StateIterator< RandGenFst<A, B, S> >$/;"	c	namespace:fst
fst::StateIterator	rational.h	/^class StateIterator< RationalFst<A> >$/;"	c	namespace:fst
fst::StateIterator	relabel.h	/^class StateIterator< RelabelFst<A> > : public StateIteratorBase<A> {$/;"	c	namespace:fst
fst::StateIterator	replace.h	/^class StateIterator< ReplaceFst<A, T> >$/;"	c	namespace:fst
fst::StateIterator	rmepsilon.h	/^class StateIterator< RmEpsilonFst<A> >$/;"	c	namespace:fst
fst::StateIterator	synchronize.h	/^class StateIterator< SynchronizeFst<A> >$/;"	c	namespace:fst
fst::StateIterator	union.h	/^class StateIterator< UnionFst<A> > : public StateIterator< RationalFst<A> > {$/;"	c	namespace:fst
fst::StateIterator	vector-fst.h	/^class StateIterator< VectorFst<A> > {$/;"	c	namespace:fst
fst::StateIterator::Arc	fst.h	/^  typedef typename F::Arc Arc;$/;"	t	class:fst::StateIterator
fst::StateIterator::CheckSuperfinal	arc-map.h	/^  void CheckSuperfinal() {$/;"	f	class:fst::StateIterator
fst::StateIterator::Done	arc-map.h	/^  bool Done() const { return siter_.Done() && !superfinal_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Done	compact-fst.h	/^  bool Done() const { return s_ >= nstates_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Done	complement.h	/^  bool Done() const { return s_ > 0 && siter_.Done(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Done	const-fst.h	/^  bool Done() const { return s_ >= nstates_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Done	fst.h	/^  bool Done() const {$/;"	f	class:fst::StateIterator
fst::StateIterator::Done	relabel.h	/^  bool Done() const { return siter_.Done(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Done	vector-fst.h	/^  bool Done() const { return s_ >= nstates_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Done_	arc-map.h	/^  bool Done_() const { return Done(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Done_	complement.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Done_	relabel.h	/^  bool Done_() const { return Done(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::FST	fst.h	/^  typedef F FST;$/;"	t	class:fst::StateIterator
fst::StateIterator::Label	complement.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StateIterator
fst::StateIterator::Next	arc-map.h	/^  void Next() {$/;"	f	class:fst::StateIterator
fst::StateIterator::Next	compact-fst.h	/^  void Next() { ++s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Next	complement.h	/^  void Next() {$/;"	f	class:fst::StateIterator
fst::StateIterator::Next	const-fst.h	/^  void Next() { ++s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Next	fst.h	/^  void Next() {$/;"	f	class:fst::StateIterator
fst::StateIterator::Next	relabel.h	/^  void Next() {$/;"	f	class:fst::StateIterator
fst::StateIterator::Next	vector-fst.h	/^  void Next() { ++s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Next_	arc-map.h	/^  void Next_() { Next(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Next_	complement.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Next_	relabel.h	/^  void Next_() { Next(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset	arc-map.h	/^  void Reset() {$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset	compact-fst.h	/^  void Reset() { s_ = 0; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset	complement.h	/^  void Reset() {$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset	const-fst.h	/^  void Reset() { s_ = 0; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset	fst.h	/^  void Reset() {$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset	relabel.h	/^  void Reset() {$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset	vector-fst.h	/^  void Reset() { s_ = 0; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset_	arc-map.h	/^  void Reset_() { Reset(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset_	complement.h	/^  virtual void Reset_() { Reset(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Reset_	relabel.h	/^  void Reset_() { Reset(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::StateId	arc-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::StateIterator
fst::StateIterator::StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
fst::StateIterator::StateId	complement.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
fst::StateIterator::StateId	const-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
fst::StateIterator::StateId	fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::StateIterator
fst::StateIterator::StateId	relabel.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
fst::StateIterator::StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIterator
fst::StateIterator::StateIterator	arc-map.h	/^  explicit StateIterator(const ArcMapFst<A, B, C> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	arcsort.h	/^  explicit StateIterator(const ArcSortFst<A, C> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	closure.h	/^  explicit StateIterator(const ClosureFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	compact-fst.h	/^  explicit StateIterator(const CompactFst<A, C, U> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	complement.h	/^  explicit StateIterator(const ComplementFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	compose.h	/^  explicit StateIterator(const ComposeFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	concat.h	/^  explicit StateIterator(const ConcatFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	const-fst.h	/^  explicit StateIterator(const ConstFst<A, U> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	determinize.h	/^  explicit StateIterator(const DeterminizeFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	difference.h	/^  explicit StateIterator(const DifferenceFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	encode.h	/^  explicit StateIterator(const DecodeFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	encode.h	/^  explicit StateIterator(const EncodeFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	factor-weight.h	/^  explicit StateIterator(const FactorWeightFst<A, F> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	fst.h	/^  explicit StateIterator(const F &fst) : s_(0) {$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	intersect.h	/^  explicit StateIterator(const IntersectFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	invert.h	/^  explicit StateIterator(const InvertFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	map.h	/^  explicit StateIterator(const ArcMapFst<A, B, C> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	matcher-fst.h	/^  explicit StateIterator(const MatcherFst<F, M, N, I> &fst) :$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	project.h	/^  explicit StateIterator(const ProjectFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	randgen.h	/^  explicit StateIterator(const RandGenFst<A, B, S> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	rational.h	/^  explicit StateIterator(const RationalFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	relabel.h	/^  explicit StateIterator(const RelabelFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	replace.h	/^  explicit StateIterator(const ReplaceFst<A, T> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	rmepsilon.h	/^  explicit StateIterator(const RmEpsilonFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	synchronize.h	/^  explicit StateIterator(const SynchronizeFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	union.h	/^  explicit StateIterator(const UnionFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::StateIterator	vector-fst.h	/^  explicit StateIterator(const VectorFst<A> &fst)$/;"	f	class:fst::StateIterator
fst::StateIterator::Value	arc-map.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Value	compact-fst.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Value	complement.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Value	const-fst.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Value	fst.h	/^  StateId Value() const { return data_.base ? data_.base->Value() : s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Value	relabel.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Value	vector-fst.h	/^  StateId Value() const { return s_; }$/;"	f	class:fst::StateIterator
fst::StateIterator::Value_	arc-map.h	/^  StateId Value_() const { return Value(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Value_	complement.h	/^  virtual StateId Value_() const { return Value(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::Value_	relabel.h	/^  StateId Value_() const { return Value(); }$/;"	f	class:fst::StateIterator
fst::StateIterator::data_	fst.h	/^  StateIteratorData<Arc> data_;$/;"	m	class:fst::StateIterator
fst::StateIterator::impl_	arc-map.h	/^  const ArcMapFstImpl<A, B, C> *impl_;$/;"	m	class:fst::StateIterator
fst::StateIterator::impl_	relabel.h	/^  const RelabelFstImpl<A> *impl_;$/;"	m	class:fst::StateIterator
fst::StateIterator::nstates_	compact-fst.h	/^  StateId nstates_;$/;"	m	class:fst::StateIterator
fst::StateIterator::nstates_	const-fst.h	/^  StateId nstates_;$/;"	m	class:fst::StateIterator
fst::StateIterator::nstates_	vector-fst.h	/^  StateId nstates_;$/;"	m	class:fst::StateIterator
fst::StateIterator::s_	arc-map.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
fst::StateIterator::s_	compact-fst.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
fst::StateIterator::s_	complement.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
fst::StateIterator::s_	const-fst.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
fst::StateIterator::s_	fst.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
fst::StateIterator::s_	relabel.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
fst::StateIterator::s_	vector-fst.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
fst::StateIterator::siter_	arc-map.h	/^  StateIterator< Fst<A> > siter_;$/;"	m	class:fst::StateIterator
fst::StateIterator::siter_	complement.h	/^  StateIterator< Fst<A> > siter_;$/;"	m	class:fst::StateIterator
fst::StateIterator::siter_	relabel.h	/^  StateIterator< Fst<A> > siter_;$/;"	m	class:fst::StateIterator
fst::StateIterator::superfinal_	arc-map.h	/^  bool superfinal_;    \/\/ true if there is a superfinal state and not done$/;"	m	class:fst::StateIterator
fst::StateIterator::~StateIterator	fst.h	/^  ~StateIterator() { if (data_.base) delete data_.base; }$/;"	f	class:fst::StateIterator
fst::StateIteratorBase	fst.h	/^class StateIteratorBase {$/;"	c	namespace:fst
fst::StateIteratorBase::Arc	fst.h	/^  typedef A Arc;$/;"	t	class:fst::StateIteratorBase
fst::StateIteratorBase::Done	fst.h	/^  bool Done() const { return Done_(); }       \/\/ End of iterator?$/;"	f	class:fst::StateIteratorBase
fst::StateIteratorBase::Next	fst.h	/^  void Next() { Next_(); }      \/\/ Advance to next state (when !Done)$/;"	f	class:fst::StateIteratorBase
fst::StateIteratorBase::Reset	fst.h	/^  void Reset() { Reset_(); }    \/\/ Return to initial condition$/;"	f	class:fst::StateIteratorBase
fst::StateIteratorBase::StateId	fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateIteratorBase
fst::StateIteratorBase::Value	fst.h	/^  StateId Value() const { return Value_(); }  \/\/ Current state (when !Done)$/;"	f	class:fst::StateIteratorBase
fst::StateIteratorBase::~StateIteratorBase	fst.h	/^  virtual ~StateIteratorBase() {}$/;"	f	class:fst::StateIteratorBase
fst::StateIteratorData	fst.h	/^template <class A> struct StateIteratorData {$/;"	s	namespace:fst
fst::StateIteratorData::base	fst.h	/^  StateIteratorBase<A> *base;   \/\/ Specialized iterator if non-zero$/;"	m	struct:fst::StateIteratorData
fst::StateIteratorData::nstates	fst.h	/^  typename A::StateId nstates;  \/\/ O.w. total # of states$/;"	m	struct:fst::StateIteratorData
fst::StateMap	state-map.h	/^void StateMap(MutableFst<A> *fst, C mapper) {$/;"	f	namespace:fst
fst::StateMap	state-map.h	/^void StateMap(MutableFst<A> *fst, C* mapper) {$/;"	f	namespace:fst
fst::StateMap	state-map.h	/^void StateMap(const Fst<A> &ifst, MutableFst<B> *ofst, C mapper) {$/;"	f	namespace:fst
fst::StateMap	state-map.h	/^void StateMap(const Fst<A> &ifst, MutableFst<B> *ofst, C* mapper) {$/;"	f	namespace:fst
fst::StateMapFst	state-map.h	/^class StateMapFst : public ImplToFst< StateMapFstImpl<A, B, C> > {$/;"	c	namespace:fst
fst::StateMapFst::Arc	state-map.h	/^  typedef B Arc;$/;"	t	class:fst::StateMapFst
fst::StateMapFst::Copy	state-map.h	/^  virtual StateMapFst<A, B, C> *Copy(bool safe = false) const {$/;"	f	class:fst::StateMapFst
fst::StateMapFst::GetImpl	state-map.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::StateMapFst
fst::StateMapFst::Impl	state-map.h	/^  typedef StateMapFstImpl<A, B, C> Impl;$/;"	t	class:fst::StateMapFst
fst::StateMapFst::InitArcIterator	state-map.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<B> *data) const {$/;"	f	class:fst::StateMapFst
fst::StateMapFst::InitStateIterator	state-map.h	/^  virtual void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::StateMapFst
fst::StateMapFst::State	state-map.h	/^  typedef CacheState<B> State;$/;"	t	class:fst::StateMapFst
fst::StateMapFst::StateId	state-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::StateMapFst
fst::StateMapFst::StateMapFst	state-map.h	/^  StateMapFst(const Fst<A> &fst, C* mapper)$/;"	f	class:fst::StateMapFst
fst::StateMapFst::StateMapFst	state-map.h	/^  StateMapFst(const Fst<A> &fst, C* mapper, const StateMapFstOptions& opts)$/;"	f	class:fst::StateMapFst
fst::StateMapFst::StateMapFst	state-map.h	/^  StateMapFst(const Fst<A> &fst, const C &mapper)$/;"	f	class:fst::StateMapFst
fst::StateMapFst::StateMapFst	state-map.h	/^  StateMapFst(const Fst<A> &fst, const C &mapper,$/;"	f	class:fst::StateMapFst
fst::StateMapFst::StateMapFst	state-map.h	/^  StateMapFst(const StateMapFst<A, B, C> &fst, bool safe = false)$/;"	f	class:fst::StateMapFst
fst::StateMapFst::Weight	state-map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::StateMapFst
fst::StateMapFstImpl	state-map.h	/^class StateMapFstImpl : public CacheImpl<B> {$/;"	c	namespace:fst
fst::StateMapFstImpl::Arc	state-map.h	/^  typedef B Arc;$/;"	t	class:fst::StateMapFstImpl
fst::StateMapFstImpl::Expand	state-map.h	/^  void Expand(StateId s) {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::Final	state-map.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::Init	state-map.h	/^  void Init() {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::InitArcIterator	state-map.h	/^  void InitArcIterator(StateId s, ArcIteratorData<B> *data) {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::InitStateIterator	state-map.h	/^  void InitStateIterator(StateIteratorData<A> *data) const {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::NumArcs	state-map.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::NumInputEpsilons	state-map.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::NumOutputEpsilons	state-map.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::Properties	state-map.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::Properties	state-map.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::Start	state-map.h	/^  StateId Start() {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::StateId	state-map.h	/^  typedef typename B::StateId StateId;$/;"	t	class:fst::StateMapFstImpl
fst::StateMapFstImpl::StateMapFstImpl	state-map.h	/^  StateMapFstImpl(const Fst<A> &fst, C *mapper,$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::StateMapFstImpl	state-map.h	/^  StateMapFstImpl(const Fst<A> &fst, const C &mapper,$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::StateMapFstImpl	state-map.h	/^  StateMapFstImpl(const StateMapFstImpl<A, B, C> &impl)$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstImpl::Weight	state-map.h	/^  typedef typename B::Weight Weight;$/;"	t	class:fst::StateMapFstImpl
fst::StateMapFstImpl::fst_	state-map.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::StateMapFstImpl
fst::StateMapFstImpl::mapper_	state-map.h	/^  C*  mapper_;$/;"	m	class:fst::StateMapFstImpl
fst::StateMapFstImpl::own_mapper_	state-map.h	/^  bool own_mapper_;$/;"	m	class:fst::StateMapFstImpl
fst::StateMapFstImpl::~StateMapFstImpl	state-map.h	/^  ~StateMapFstImpl() {$/;"	f	class:fst::StateMapFstImpl
fst::StateMapFstOptions	state-map.h	/^typedef CacheOptions StateMapFstOptions;$/;"	t	namespace:fst
fst::StateOrderQueue	queue.h	/^class StateOrderQueue : public QueueBase<S> {$/;"	c	namespace:fst
fst::StateOrderQueue::Clear	queue.h	/^  void Clear() {$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Dequeue	queue.h	/^  void Dequeue() {$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Empty	queue.h	/^  bool Empty() const { return front_ > back_; }$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Head	queue.h	/^  StateId Head() const { return front_; }$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::StateOrderQueue
fst::StateOrderQueue::StateOrderQueue	queue.h	/^  StateOrderQueue()$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::StateOrderQueue
fst::StateOrderQueue::back_	queue.h	/^  StateId back_;$/;"	m	class:fst::StateOrderQueue
fst::StateOrderQueue::enqueued_	queue.h	/^  vector<bool> enqueued_;$/;"	m	class:fst::StateOrderQueue
fst::StateOrderQueue::front_	queue.h	/^  StateId front_;$/;"	m	class:fst::StateOrderQueue
fst::StateReachable	state-reachable.h	/^class StateReachable {$/;"	c	namespace:fst
fst::StateReachable::Arc	state-reachable.h	/^  typedef A Arc;$/;"	t	class:fst::StateReachable
fst::StateReachable::Error	state-reachable.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::StateReachable
fst::StateReachable::Index	state-reachable.h	/^  typedef I Index;$/;"	t	class:fst::StateReachable
fst::StateReachable::Interval	state-reachable.h	/^  typedef typename IntervalSet<I>::Interval Interval;$/;"	t	class:fst::StateReachable
fst::StateReachable::IntervalSets	state-reachable.h	/^  const vector< IntervalSet<I> > &IntervalSets() { return isets_; }$/;"	f	class:fst::StateReachable
fst::StateReachable::Label	state-reachable.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StateReachable
fst::StateReachable::Reach	state-reachable.h	/^  bool Reach(StateId s) {$/;"	f	class:fst::StateReachable
fst::StateReachable::SetState	state-reachable.h	/^  void SetState(StateId s) { s_ = s; }$/;"	f	class:fst::StateReachable
fst::StateReachable::State2Index	state-reachable.h	/^  vector<I> &State2Index() { return state2index_; }$/;"	f	class:fst::StateReachable
fst::StateReachable::StateId	state-reachable.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StateReachable
fst::StateReachable::StateReachable	state-reachable.h	/^  StateReachable(const Fst<A> &fst)$/;"	f	class:fst::StateReachable
fst::StateReachable::StateReachable	state-reachable.h	/^  StateReachable(const StateReachable<A> &reachable) {$/;"	f	class:fst::StateReachable
fst::StateReachable::Weight	state-reachable.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StateReachable
fst::StateReachable::error_	state-reachable.h	/^  bool error_;$/;"	m	class:fst::StateReachable
fst::StateReachable::isets_	state-reachable.h	/^  vector< IntervalSet<I> > isets_;            \/\/ Interval sets per state$/;"	m	class:fst::StateReachable
fst::StateReachable::s_	state-reachable.h	/^  StateId s_;                                 \/\/ Current state$/;"	m	class:fst::StateReachable
fst::StateReachable::state2index_	state-reachable.h	/^  vector<I> state2index_;                     \/\/ Finds index for a final state$/;"	m	class:fst::StateReachable
fst::StateSort	statesort.h	/^void StateSort(MutableFst<Arc> *fst,$/;"	f	namespace:fst
fst::StateWeightCompare	queue.h	/^class StateWeightCompare {$/;"	c	namespace:fst
fst::StateWeightCompare::Less	queue.h	/^  typedef L Less;$/;"	t	class:fst::StateWeightCompare
fst::StateWeightCompare::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::StateWeightCompare
fst::StateWeightCompare::StateWeightCompare	queue.h	/^  StateWeightCompare(const vector<Weight>& weights, const L &less)$/;"	f	class:fst::StateWeightCompare
fst::StateWeightCompare::Weight	queue.h	/^  typedef typename L::Weight Weight;$/;"	t	class:fst::StateWeightCompare
fst::StateWeightCompare::less_	queue.h	/^  L less_;$/;"	m	class:fst::StateWeightCompare
fst::StateWeightCompare::operator ()	queue.h	/^  bool operator()(const S x, const S y) const {$/;"	f	class:fst::StateWeightCompare
fst::StateWeightCompare::weights_	queue.h	/^  const vector<Weight>& weights_;$/;"	m	class:fst::StateWeightCompare
fst::StdArc	arc.h	/^typedef ArcTpl<TropicalWeight> StdArc;$/;"	t	namespace:fst
fst::StdArc	fst-decl.h	/^typedef ArcTpl<TropicalWeight> StdArc;$/;"	t	namespace:fst
fst::StdArcLookAheadFst	matcher-fst.h	/^                   arc_lookahead_fst_type> StdArcLookAheadFst;$/;"	t	namespace:fst
fst::StdArcSelector	randgen.h	/^typedef LogProbArcSelector<StdArc> StdArcSelector;$/;"	t	namespace:fst
fst::StdArcSortFst	arcsort.h	/^template<class C> class StdArcSortFst : public ArcSortFst<StdArc, C> {$/;"	c	namespace:fst
fst::StdArcSortFst::Arc	arcsort.h	/^  typedef StdArc Arc;$/;"	t	class:fst::StdArcSortFst
fst::StdArcSortFst::Compare	arcsort.h	/^  typedef C Compare;$/;"	t	class:fst::StdArcSortFst
fst::StdClosureFst	closure.h	/^typedef ClosureFst<StdArc> StdClosureFst;$/;"	t	namespace:fst
fst::StdClosureFst	fst-decl.h	/^typedef ClosureFst<StdArc> StdClosureFst;$/;"	t	namespace:fst
fst::StdCompactAcceptorFst	compact-fst.h	/^StdCompactAcceptorFst;$/;"	t	namespace:fst
fst::StdCompactAcceptorFst	fst-decl.h	/^StdCompactAcceptorFst;$/;"	t	namespace:fst
fst::StdCompactStringFst	compact-fst.h	/^StdCompactStringFst;$/;"	t	namespace:fst
fst::StdCompactStringFst	fst-decl.h	/^StdCompactStringFst;$/;"	t	namespace:fst
fst::StdCompactUnweightedAcceptorFst	compact-fst.h	/^StdCompactUnweightedAcceptorFst;$/;"	t	namespace:fst
fst::StdCompactUnweightedAcceptorFst	fst-decl.h	/^StdCompactUnweightedAcceptorFst;$/;"	t	namespace:fst
fst::StdCompactUnweightedFst	compact-fst.h	/^StdCompactUnweightedFst;$/;"	t	namespace:fst
fst::StdCompactUnweightedFst	fst-decl.h	/^StdCompactUnweightedFst;$/;"	t	namespace:fst
fst::StdCompactWeightedStringFst	compact-fst.h	/^StdCompactWeightedStringFst;$/;"	t	namespace:fst
fst::StdCompactWeightedStringFst	fst-decl.h	/^StdCompactWeightedStringFst;$/;"	t	namespace:fst
fst::StdComplementFst	complement.h	/^typedef ComplementFst<StdArc> StdComplementFst;$/;"	t	namespace:fst
fst::StdComposeFst	compose.h	/^typedef ComposeFst<StdArc> StdComposeFst;$/;"	t	namespace:fst
fst::StdComposeFst	fst-decl.h	/^typedef ComposeFst<StdArc> StdComposeFst;$/;"	t	namespace:fst
fst::StdConcatFst	concat.h	/^typedef ConcatFst<StdArc> StdConcatFst;$/;"	t	namespace:fst
fst::StdConcatFst	fst-decl.h	/^typedef ConcatFst<StdArc> StdConcatFst;$/;"	t	namespace:fst
fst::StdConstFst	const-fst.h	/^typedef ConstFst<StdArc> StdConstFst;$/;"	t	namespace:fst
fst::StdConstFst	fst-decl.h	/^typedef ConstFst<StdArc> StdConstFst;$/;"	t	namespace:fst
fst::StdDecodeFst	encode.h	/^typedef DecodeFst<StdArc> StdDecodeFst;$/;"	t	namespace:fst
fst::StdDeterminizeFst	determinize.h	/^typedef DeterminizeFst<StdArc> StdDeterminizeFst;$/;"	t	namespace:fst
fst::StdDeterminizeFst	fst-decl.h	/^typedef DeterminizeFst<StdArc> StdDeterminizeFst;$/;"	t	namespace:fst
fst::StdDifferenceFst	difference.h	/^typedef DifferenceFst<StdArc> StdDifferenceFst;$/;"	t	namespace:fst
fst::StdDifferenceFst	fst-decl.h	/^typedef DifferenceFst<StdArc> StdDifferenceFst;$/;"	t	namespace:fst
fst::StdEncodeFst	encode.h	/^typedef EncodeFst<StdArc> StdEncodeFst;$/;"	t	namespace:fst
fst::StdExpandedFst	expanded-fst.h	/^typedef ExpandedFst<StdArc> StdExpandedFst;$/;"	t	namespace:fst
fst::StdExpandedFst	fst-decl.h	/^typedef ExpandedFst<StdArc> StdExpandedFst;$/;"	t	namespace:fst
fst::StdFst	fst-decl.h	/^typedef Fst<StdArc> StdFst;$/;"	t	namespace:fst
fst::StdFst	fst.h	/^typedef Fst<StdArc> StdFst;$/;"	t	namespace:fst
fst::StdILabelCompare	arcsort.h	/^typedef ILabelCompare<StdArc> StdILabelCompare;$/;"	t	namespace:fst
fst::StdILabelLookAheadFst	matcher-fst.h	/^                   LabelLookAheadRelabeler<StdArc> > StdILabelLookAheadFst;$/;"	t	namespace:fst
fst::StdIntersectFst	fst-decl.h	/^typedef IntersectFst<StdArc> StdIntersectFst;$/;"	t	namespace:fst
fst::StdIntersectFst	intersect.h	/^typedef IntersectFst<StdArc> StdIntersectFst;$/;"	t	namespace:fst
fst::StdInvertFst	fst-decl.h	/^typedef InvertFst<StdArc> StdInvertFst;$/;"	t	namespace:fst
fst::StdInvertFst	invert.h	/^typedef InvertFst<StdArc> StdInvertFst;$/;"	t	namespace:fst
fst::StdMutableFst	fst-decl.h	/^typedef MutableFst<StdArc> StdMutableFst;$/;"	t	namespace:fst
fst::StdMutableFst	mutable-fst.h	/^typedef MutableFst<StdArc> StdMutableFst;$/;"	t	namespace:fst
fst::StdOLabelCompare	arcsort.h	/^typedef OLabelCompare<StdArc> StdOLabelCompare;$/;"	t	namespace:fst
fst::StdOLabelLookAheadFst	matcher-fst.h	/^                   LabelLookAheadRelabeler<StdArc> > StdOLabelLookAheadFst;$/;"	t	namespace:fst
fst::StdProjectFst	fst-decl.h	/^typedef ProjectFst<StdArc> StdProjectFst;$/;"	t	namespace:fst
fst::StdProjectFst	project.h	/^typedef ProjectFst<StdArc> StdProjectFst;$/;"	t	namespace:fst
fst::StdRelabelFst	fst-decl.h	/^typedef RelabelFst<StdArc> StdRelabelFst;$/;"	t	namespace:fst
fst::StdRelabelFst	relabel.h	/^typedef RelabelFst<StdArc> StdRelabelFst;$/;"	t	namespace:fst
fst::StdReplaceFst	fst-decl.h	/^StdReplaceFst;$/;"	t	namespace:fst
fst::StdReplaceFst	replace.h	/^typedef ReplaceFst<StdArc> StdReplaceFst;$/;"	t	namespace:fst
fst::StdRmEpsilonFst	fst-decl.h	/^typedef RmEpsilonFst<StdArc> StdRmEpsilonFst;$/;"	t	namespace:fst
fst::StdRmEpsilonFst	rmepsilon.h	/^typedef RmEpsilonFst<StdArc> StdRmEpsilonFst;$/;"	t	namespace:fst
fst::StdToLog64Mapper	arc-map.h	/^typedef WeightConvertMapper<StdArc, Log64Arc> StdToLog64Mapper;$/;"	t	namespace:fst
fst::StdToLogMapper	arc-map.h	/^typedef WeightConvertMapper<StdArc, LogArc> StdToLogMapper;$/;"	t	namespace:fst
fst::StdUnionFst	fst-decl.h	/^typedef UnionFst<StdArc> StdUnionFst;$/;"	t	namespace:fst
fst::StdUnionFst	union.h	/^typedef UnionFst<StdArc> StdUnionFst;$/;"	t	namespace:fst
fst::StdVectorFst	fst-decl.h	/^typedef VectorFst<StdArc> StdVectorFst;$/;"	t	namespace:fst
fst::StdVectorFst	vector-fst.h	/^typedef VectorFst<StdArc> StdVectorFst;$/;"	t	namespace:fst
fst::StlReserve	util.h	/^void StlReserve(C *c, int64 n) {}$/;"	f	namespace:fst
fst::StlReserve	util.h	/^void StlReserve(vector<S, T> *c, int64 n) {$/;"	f	namespace:fst
fst::StrToWeight	util.h	/^Weight StrToWeight(const string &s, const string &src, size_t nline) {$/;"	f	namespace:fst
fst::StringArc	arc.h	/^class StringArc {$/;"	c	namespace:fst
fst::StringArc::Label	arc.h	/^  typedef int Label;$/;"	t	class:fst::StringArc
fst::StringArc::StateId	arc.h	/^  typedef int StateId;$/;"	t	class:fst::StringArc
fst::StringArc::StringArc	arc.h	/^  StringArc() {}$/;"	f	class:fst::StringArc
fst::StringArc::StringArc	arc.h	/^  StringArc(Label i, Label o, Weight w, StateId s)$/;"	f	class:fst::StringArc
fst::StringArc::Type	arc.h	/^  static const string &Type() {  \/\/ Arc type name$/;"	f	class:fst::StringArc
fst::StringArc::Weight	arc.h	/^  typedef StringWeight<int, S> Weight;$/;"	t	class:fst::StringArc
fst::StringArc::ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	class:fst::StringArc
fst::StringArc::nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	class:fst::StringArc
fst::StringArc::olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	class:fst::StringArc
fst::StringArc::weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	class:fst::StringArc
fst::StringCompactor	compact-fst.h	/^class StringCompactor {$/;"	c	namespace:fst
fst::StringCompactor::Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::StringCompactor
fst::StringCompactor::Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const { return arc.ilabel; }$/;"	f	class:fst::StringCompactor
fst::StringCompactor::Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::StringCompactor
fst::StringCompactor::Element	compact-fst.h	/^  typedef typename A::Label Element;$/;"	t	class:fst::StringCompactor
fst::StringCompactor::Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::StringCompactor
fst::StringCompactor::Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StringCompactor
fst::StringCompactor::Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::StringCompactor
fst::StringCompactor::Read	compact-fst.h	/^  static StringCompactor *Read(istream &strm) {$/;"	f	class:fst::StringCompactor
fst::StringCompactor::Size	compact-fst.h	/^  ssize_t Size() const { return 1; }$/;"	f	class:fst::StringCompactor
fst::StringCompactor::StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StringCompactor
fst::StringCompactor::Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::StringCompactor
fst::StringCompactor::Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StringCompactor
fst::StringCompactor::Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::StringCompactor
fst::StringCompiler	string.h	/^class StringCompiler {$/;"	c	namespace:fst
fst::StringCompiler::Arc	string.h	/^  typedef A Arc;$/;"	t	class:fst::StringCompiler
fst::StringCompiler::BYTE	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringCompiler::TokenType
fst::StringCompiler::Compile	string.h	/^  void Compile(const vector<Label> &labels, CompactFst<A, StringCompactor<A>,$/;"	f	class:fst::StringCompiler
fst::StringCompiler::Compile	string.h	/^  void Compile(const vector<Label> &labels, MutableFst<A> *fst) const {$/;"	f	class:fst::StringCompiler
fst::StringCompiler::ConvertStringToLabels	string.h	/^  bool ConvertStringToLabels(const string &str, vector<Label> *labels) const {$/;"	f	class:fst::StringCompiler
fst::StringCompiler::ConvertSymbolToLabel	string.h	/^  bool ConvertSymbolToLabel(const char *s, Label* output) const {$/;"	f	class:fst::StringCompiler
fst::StringCompiler::Label	string.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StringCompiler
fst::StringCompiler::SYMBOL	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringCompiler::TokenType
fst::StringCompiler::StringCompiler	string.h	/^  StringCompiler(TokenType type, const SymbolTable *syms = 0,$/;"	f	class:fst::StringCompiler
fst::StringCompiler::TokenType	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	g	class:fst::StringCompiler
fst::StringCompiler::UTF8	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringCompiler::TokenType
fst::StringCompiler::Weight	string.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StringCompiler
fst::StringCompiler::allow_negative_	string.h	/^  bool allow_negative_;      \/\/ Negative labels allowed?$/;"	m	class:fst::StringCompiler
fst::StringCompiler::operator ()	string.h	/^  bool operator()(const string &s, F *fst) const {$/;"	f	class:fst::StringCompiler
fst::StringCompiler::syms_	string.h	/^  const SymbolTable *syms_;  \/\/ Symbol table used when token type is symbol$/;"	m	class:fst::StringCompiler
fst::StringCompiler::token_type_	string.h	/^  TokenType token_type_;     \/\/ Token type: symbol, byte or utf8 encoded$/;"	m	class:fst::StringCompiler
fst::StringCompiler::unknown_label_	string.h	/^  Label unknown_label_;      \/\/ Label for token missing from symbol table$/;"	m	class:fst::StringCompiler
fst::StringDetComposeStateTable	state-table.h	/^class StringDetComposeStateTable : public$/;"	c	namespace:fst
fst::StringDetComposeStateTable::Arc	state-table.h	/^  typedef A Arc;$/;"	t	class:fst::StringDetComposeStateTable
fst::StringDetComposeStateTable::Error	state-table.h	/^  bool Error() const { return error_; }$/;"	f	class:fst::StringDetComposeStateTable
fst::StringDetComposeStateTable::FilterState	state-table.h	/^  typedef F FilterState;$/;"	t	class:fst::StringDetComposeStateTable
fst::StringDetComposeStateTable::StateId	state-table.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StringDetComposeStateTable
fst::StringDetComposeStateTable::StateTuple	state-table.h	/^  typedef ComposeStateTuple<StateId, F> StateTuple;$/;"	t	class:fst::StringDetComposeStateTable
fst::StringDetComposeStateTable::StringDetComposeStateTable	state-table.h	/^  StringDetComposeStateTable(const Fst<A> &fst1, const Fst<A> &fst2)$/;"	f	class:fst::StringDetComposeStateTable
fst::StringDetComposeStateTable::StringDetComposeStateTable	state-table.h	/^  StringDetComposeStateTable(const StringDetComposeStateTable<A, F> &table)$/;"	f	class:fst::StringDetComposeStateTable
fst::StringDetComposeStateTable::error_	state-table.h	/^  bool error_;$/;"	m	class:fst::StringDetComposeStateTable
fst::StringFactor	factor-weight.h	/^class StringFactor {$/;"	c	namespace:fst
fst::StringFactor::Done	factor-weight.h	/^  bool Done() const { return done_; }$/;"	f	class:fst::StringFactor
fst::StringFactor::Next	factor-weight.h	/^  void Next() { done_ = true; }$/;"	f	class:fst::StringFactor
fst::StringFactor::Reset	factor-weight.h	/^  void Reset() { done_ = weight_.Size() <= 1; }$/;"	f	class:fst::StringFactor
fst::StringFactor::StringFactor	factor-weight.h	/^  StringFactor(const StringWeight<L, S> &w)$/;"	f	class:fst::StringFactor
fst::StringFactor::Value	factor-weight.h	/^  pair< StringWeight<L, S>, StringWeight<L, S> > Value() const {$/;"	f	class:fst::StringFactor
fst::StringFactor::done_	factor-weight.h	/^  bool done_;$/;"	m	class:fst::StringFactor
fst::StringFactor::weight_	factor-weight.h	/^  StringWeight<L, S> weight_;$/;"	m	class:fst::StringFactor
fst::StringPrinter	string.h	/^class StringPrinter {$/;"	c	namespace:fst
fst::StringPrinter::Arc	string.h	/^  typedef A Arc;$/;"	t	class:fst::StringPrinter
fst::StringPrinter::BYTE	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringPrinter::TokenType
fst::StringPrinter::FstToLabels	string.h	/^  bool FstToLabels(const Fst<A> &fst) {$/;"	f	class:fst::StringPrinter
fst::StringPrinter::Label	string.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::StringPrinter
fst::StringPrinter::PrintLabel	string.h	/^  bool PrintLabel(Label lab, ostream& ostrm) {$/;"	f	class:fst::StringPrinter
fst::StringPrinter::SYMBOL	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringPrinter::TokenType
fst::StringPrinter::StateId	string.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::StringPrinter
fst::StringPrinter::StringPrinter	string.h	/^  StringPrinter(TokenType token_type,$/;"	f	class:fst::StringPrinter
fst::StringPrinter::TokenType	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	g	class:fst::StringPrinter
fst::StringPrinter::UTF8	string.h	/^  enum TokenType { SYMBOL = 1, BYTE = 2, UTF8 = 3 };$/;"	e	enum:fst::StringPrinter::TokenType
fst::StringPrinter::Weight	string.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::StringPrinter
fst::StringPrinter::labels_	string.h	/^  vector<Label> labels_;     \/\/ Input FST labels.$/;"	m	class:fst::StringPrinter
fst::StringPrinter::operator ()	string.h	/^  bool operator()(const Fst<A> &fst, string *output) {$/;"	f	class:fst::StringPrinter
fst::StringPrinter::syms_	string.h	/^  const SymbolTable *syms_;  \/\/ Symbol table used when token type is symbol$/;"	m	class:fst::StringPrinter
fst::StringPrinter::token_type_	string.h	/^  TokenType token_type_;     \/\/ Token type: symbol, byte or utf8 encoded$/;"	m	class:fst::StringPrinter
fst::StringToFst	fst.h	/^Fst<A> *StringToFst(const string &s) {$/;"	f	namespace:fst
fst::StringToSymbolTable	symbol-table.h	/^inline SymbolTable *StringToSymbolTable(const string &s) {$/;"	f	namespace:fst
fst::StringType	string-weight.h	/^enum StringType { STRING_LEFT = 0, STRING_RIGHT = 1 ,$/;"	g	namespace:fst
fst::StringWeight	string-weight.h	/^class StringWeight {$/;"	c	namespace:fst
fst::StringWeight::Clear	string-weight.h	/^  void Clear() { first_ = 0; rest_.clear(); }$/;"	f	class:fst::StringWeight
fst::StringWeight::Hash	string-weight.h	/^inline size_t StringWeight<L, S>::Hash() const {$/;"	f	class:fst::StringWeight
fst::StringWeight::Init	string-weight.h	/^  void Init() { first_ = 0; }$/;"	f	class:fst::StringWeight
fst::StringWeight::Label	string-weight.h	/^  typedef L Label;$/;"	t	class:fst::StringWeight
fst::StringWeight::Member	string-weight.h	/^inline bool StringWeight<L, S>::Member() const {$/;"	f	class:fst::StringWeight
fst::StringWeight::NoWeight	string-weight.h	/^  static const StringWeight<L, S> &NoWeight() {$/;"	f	class:fst::StringWeight
fst::StringWeight::One	string-weight.h	/^  static const StringWeight<L, S> &One() {$/;"	f	class:fst::StringWeight
fst::StringWeight::Properties	string-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::StringWeight
fst::StringWeight::PushBack	string-weight.h	/^  void PushBack(L l) {$/;"	f	class:fst::StringWeight
fst::StringWeight::PushFront	string-weight.h	/^  void PushFront(L l) {$/;"	f	class:fst::StringWeight
fst::StringWeight::Quantize	string-weight.h	/^  StringWeight<L, S> Quantize(float delta = kDelta) const {$/;"	f	class:fst::StringWeight
fst::StringWeight::Read	string-weight.h	/^inline istream &StringWeight<L, S>::Read(istream &strm) {$/;"	f	class:fst::StringWeight
fst::StringWeight::Reverse	string-weight.h	/^StringWeight<L, S>::Reverse() const {$/;"	f	class:fst::StringWeight
fst::StringWeight::ReverseWeight	string-weight.h	/^  typedef StringWeight<L, REVERSE_STRING_TYPE(S)> ReverseWeight;$/;"	t	class:fst::StringWeight
fst::StringWeight::Size	string-weight.h	/^  size_t Size() const { return first_ ? rest_.size() + 1 : 0; }$/;"	f	class:fst::StringWeight
fst::StringWeight::StringWeight	string-weight.h	/^  StringWeight() { Init(); }$/;"	f	class:fst::StringWeight
fst::StringWeight::StringWeight	string-weight.h	/^  StringWeight(const Iter &begin, const Iter &end) {$/;"	f	class:fst::StringWeight
fst::StringWeight::StringWeight	string-weight.h	/^  explicit StringWeight(L l) { Init(); PushBack(l); }$/;"	f	class:fst::StringWeight
fst::StringWeight::Type	string-weight.h	/^  static const string &Type() {$/;"	f	class:fst::StringWeight
fst::StringWeight::Write	string-weight.h	/^inline ostream &StringWeight<L, S>::Write(ostream &strm) const {$/;"	f	class:fst::StringWeight
fst::StringWeight::Zero	string-weight.h	/^  static const StringWeight<L, S> &Zero() {$/;"	f	class:fst::StringWeight
fst::StringWeight::first_	string-weight.h	/^  L first_;         \/\/ first label in string (0 if empty)$/;"	m	class:fst::StringWeight
fst::StringWeight::rest_	string-weight.h	/^  list<L> rest_;    \/\/ remaining labels in string$/;"	m	class:fst::StringWeight
fst::StringWeightGenerator	random-weight.h	/^class StringWeightGenerator {$/;"	c	namespace:fst
fst::StringWeightGenerator::StringWeightGenerator	random-weight.h	/^  StringWeightGenerator(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::StringWeightGenerator
fst::StringWeightGenerator::Weight	random-weight.h	/^  typedef StringWeight<L, S> Weight;$/;"	t	class:fst::StringWeightGenerator
fst::StringWeightGenerator::allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero$/;"	m	class:fst::StringWeightGenerator
fst::StringWeightGenerator::kAlphabetSize	random-weight.h	/^  static const int kAlphabetSize = 5;$/;"	m	class:fst::StringWeightGenerator
fst::StringWeightGenerator::kAlphabetSize	random-weight.h	/^const int StringWeightGenerator<L, S>::kAlphabetSize;$/;"	m	class:fst::StringWeightGenerator
fst::StringWeightGenerator::kMaxStringLength	random-weight.h	/^  static const int kMaxStringLength = 5;$/;"	m	class:fst::StringWeightGenerator
fst::StringWeightGenerator::kMaxStringLength	random-weight.h	/^const int StringWeightGenerator<L, S>::kMaxStringLength;$/;"	m	class:fst::StringWeightGenerator
fst::StringWeightGenerator::operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::StringWeightGenerator
fst::StringWeightIterator	string-weight.h	/^class StringWeightIterator {$/;"	c	namespace:fst
fst::StringWeightIterator::Done	string-weight.h	/^  bool Done() const {$/;"	f	class:fst::StringWeightIterator
fst::StringWeightIterator::Next	string-weight.h	/^  void Next() {$/;"	f	class:fst::StringWeightIterator
fst::StringWeightIterator::Reset	string-weight.h	/^  void Reset() {$/;"	f	class:fst::StringWeightIterator
fst::StringWeightIterator::StringWeightIterator	string-weight.h	/^  explicit StringWeightIterator(const StringWeight<L, S>& w)$/;"	f	class:fst::StringWeightIterator
fst::StringWeightIterator::Value	string-weight.h	/^  const L& Value() const { return init_ ? first_ : *iter_; }$/;"	f	class:fst::StringWeightIterator
fst::StringWeightIterator::first_	string-weight.h	/^  const L &first_;$/;"	m	class:fst::StringWeightIterator
fst::StringWeightIterator::init_	string-weight.h	/^  bool init_;   \/\/ in the initialized state?$/;"	m	class:fst::StringWeightIterator
fst::StringWeightIterator::iter_	string-weight.h	/^  typename list<L>::const_iterator iter_;$/;"	m	class:fst::StringWeightIterator
fst::StringWeightIterator::rest_	string-weight.h	/^  const list<L> &rest_;$/;"	m	class:fst::StringWeightIterator
fst::StringWeightReverseIterator	string-weight.h	/^class StringWeightReverseIterator {$/;"	c	namespace:fst
fst::StringWeightReverseIterator::Done	string-weight.h	/^  bool Done() const { return fin_; }$/;"	f	class:fst::StringWeightReverseIterator
fst::StringWeightReverseIterator::Next	string-weight.h	/^  void Next() {$/;"	f	class:fst::StringWeightReverseIterator
fst::StringWeightReverseIterator::Reset	string-weight.h	/^  void Reset() {$/;"	f	class:fst::StringWeightReverseIterator
fst::StringWeightReverseIterator::StringWeightReverseIterator	string-weight.h	/^  explicit StringWeightReverseIterator(const StringWeight<L, S>& w)$/;"	f	class:fst::StringWeightReverseIterator
fst::StringWeightReverseIterator::Value	string-weight.h	/^  const L& Value() const { return iter_ == rest_.rend() ? first_ : *iter_; }$/;"	f	class:fst::StringWeightReverseIterator
fst::StringWeightReverseIterator::fin_	string-weight.h	/^  bool fin_;   \/\/ in the final state?$/;"	m	class:fst::StringWeightReverseIterator
fst::StringWeightReverseIterator::first_	string-weight.h	/^  const L &first_;$/;"	m	class:fst::StringWeightReverseIterator
fst::StringWeightReverseIterator::iter_	string-weight.h	/^  typename list<L>::const_reverse_iterator iter_;$/;"	m	class:fst::StringWeightReverseIterator
fst::StringWeightReverseIterator::rest_	string-weight.h	/^  const list<L> &rest_;$/;"	m	class:fst::StringWeightReverseIterator
fst::SuperFinalMapper	arc-map.h	/^struct SuperFinalMapper {$/;"	s	namespace:fst
fst::SuperFinalMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_REQUIRE_SUPERFINAL; }$/;"	f	struct:fst::SuperFinalMapper
fst::SuperFinalMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::SuperFinalMapper
fst::SuperFinalMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::SuperFinalMapper
fst::SuperFinalMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::SuperFinalMapper
fst::SuperFinalMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::SuperFinalMapper
fst::SuperFinalMapper::ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::SuperFinalMapper
fst::SuperFinalMapper::operator ()	arc-map.h	/^  A operator()(const A &arc) const { return arc; }$/;"	f	struct:fst::SuperFinalMapper
fst::SymbolTable	symbol-table.h	/^class SymbolTable {$/;"	c	namespace:fst
fst::SymbolTable::AddSymbol	symbol-table.h	/^  virtual int64 AddSymbol(const string& symbol) {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::AddSymbol	symbol-table.h	/^  virtual int64 AddSymbol(const string& symbol, int64 key) {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::AvailableKey	symbol-table.h	/^  virtual int64 AvailableKey(void) const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::CheckSum	symbol-table.h	/^  virtual string CheckSum() const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Copy	symbol-table.h	/^  virtual SymbolTable* Copy() const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Find	symbol-table.h	/^  virtual int64 Find(const char* symbol) const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Find	symbol-table.h	/^  virtual int64 Find(const string& symbol) const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Find	symbol-table.h	/^  virtual string Find(int64 key) const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::GetNthKey	symbol-table.h	/^  virtual int64 GetNthKey(ssize_t pos) const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Impl	symbol-table.h	/^  const SymbolTableImpl* Impl() const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::LabeledCheckSum	symbol-table.h	/^  virtual string LabeledCheckSum() const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::MutateCheck	symbol-table.h	/^  void MutateCheck() {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Name	symbol-table.h	/^  virtual const string& Name() const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::NumSymbols	symbol-table.h	/^  virtual size_t NumSymbols(void) const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Read	symbol-table.h	/^  static SymbolTable* Read(const string& filename) {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Read	symbol-table.h	/^  static SymbolTable* Read(istream &strm, const string& source) {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Read	symbol-table.h	/^  static SymbolTable* Read(istream &strm,$/;"	f	class:fst::SymbolTable
fst::SymbolTable::ReadText	symbol-table.h	/^  static SymbolTable* ReadText(const string& filename,$/;"	f	class:fst::SymbolTable
fst::SymbolTable::ReadText	symbol-table.h	/^  static SymbolTable* ReadText(istream &strm,$/;"	f	class:fst::SymbolTable
fst::SymbolTable::SymbolTable	symbol-table.h	/^  SymbolTable() : impl_(new SymbolTableImpl("<unspecified>")) {}$/;"	f	class:fst::SymbolTable
fst::SymbolTable::SymbolTable	symbol-table.h	/^  SymbolTable(const SymbolTable& table) : impl_(table.impl_) {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::SymbolTable	symbol-table.h	/^  SymbolTable(const string& name) : impl_(new SymbolTableImpl(name)) {}$/;"	f	class:fst::SymbolTable
fst::SymbolTable::SymbolTable	symbol-table.h	/^  explicit SymbolTable(SymbolTableImpl* impl) : impl_(impl) {}$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Write	symbol-table.h	/^  bool Write(const string& filename) const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::Write	symbol-table.h	/^  virtual bool Write(ostream &strm) const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::WriteText	symbol-table.h	/^  bool WriteText(const string& filename) const {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::impl_	symbol-table.h	/^  SymbolTableImpl* impl_;$/;"	m	class:fst::SymbolTable
fst::SymbolTable::kNoSymbol	symbol-table.h	/^  static const int64 kNoSymbol = -1;$/;"	m	class:fst::SymbolTable
fst::SymbolTable::operator =	symbol-table.h	/^  void operator=(const SymbolTable &st) {$/;"	f	class:fst::SymbolTable
fst::SymbolTable::~SymbolTable	symbol-table.h	/^  virtual ~SymbolTable() {$/;"	f	class:fst::SymbolTable
fst::SymbolTableImpl	symbol-table.h	/^class SymbolTableImpl {$/;"	c	namespace:fst
fst::SymbolTableImpl::AddSymbol	symbol-table.h	/^  int64 AddSymbol(const string& symbol) {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::AvailableKey	symbol-table.h	/^  int64 AvailableKey() const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::CheckSum	symbol-table.h	/^  string CheckSum() const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::DecrRefCount	symbol-table.h	/^  int DecrRefCount() const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::Find	symbol-table.h	/^  int64 Find(const char* symbol) const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::Find	symbol-table.h	/^  int64 Find(const string& symbol) const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::Find	symbol-table.h	/^  string Find(int64 key) const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::GetNthKey	symbol-table.h	/^  int64 GetNthKey(ssize_t pos) const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::IncrRefCount	symbol-table.h	/^  int IncrRefCount() const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::LabeledCheckSum	symbol-table.h	/^  string LabeledCheckSum() const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::Name	symbol-table.h	/^  const string& Name() const { return name_; }$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::NumSymbols	symbol-table.h	/^  size_t NumSymbols() const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::RefCount	symbol-table.h	/^  int RefCount() const {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::StrCmp	symbol-table.h	/^  struct StrCmp {$/;"	s	class:fst::SymbolTableImpl
fst::SymbolTableImpl::StrCmp::operator ()	symbol-table.h	/^    bool operator()(const char *s1, const char *s2) const {$/;"	f	struct:fst::SymbolTableImpl::StrCmp
fst::SymbolTableImpl::SymbolTableImpl	symbol-table.h	/^  SymbolTableImpl(const string &name)$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::SymbolTableImpl	symbol-table.h	/^  explicit SymbolTableImpl(const SymbolTableImpl& impl)$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableImpl::available_key_	symbol-table.h	/^  int64 available_key_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::check_sum_finalized_	symbol-table.h	/^  mutable bool check_sum_finalized_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::check_sum_mutex_	symbol-table.h	/^  mutable Mutex check_sum_mutex_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::check_sum_string_	symbol-table.h	/^  mutable string check_sum_string_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::dense_key_limit_	symbol-table.h	/^  int64 dense_key_limit_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::key_map_	symbol-table.h	/^  map<int64, const char*> key_map_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::labeled_check_sum_string_	symbol-table.h	/^  mutable string labeled_check_sum_string_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::name_	symbol-table.h	/^  string name_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::ref_count_	symbol-table.h	/^  mutable RefCounter ref_count_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::symbol_map_	symbol-table.h	/^  map<const char *, int64, StrCmp> symbol_map_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::symbols_	symbol-table.h	/^  vector<const char *> symbols_;$/;"	m	class:fst::SymbolTableImpl
fst::SymbolTableImpl::~SymbolTableImpl	symbol-table.h	/^  ~SymbolTableImpl() {$/;"	f	class:fst::SymbolTableImpl
fst::SymbolTableIterator	symbol-table.h	/^class SymbolTableIterator {$/;"	c	namespace:fst
fst::SymbolTableIterator::Done	symbol-table.h	/^  bool Done(void) {$/;"	f	class:fst::SymbolTableIterator
fst::SymbolTableIterator::Next	symbol-table.h	/^  void Next(void) {$/;"	f	class:fst::SymbolTableIterator
fst::SymbolTableIterator::Reset	symbol-table.h	/^  void Reset(void) {$/;"	f	class:fst::SymbolTableIterator
fst::SymbolTableIterator::Symbol	symbol-table.h	/^  string Symbol(void) {$/;"	f	class:fst::SymbolTableIterator
fst::SymbolTableIterator::SymbolTableIterator	symbol-table.h	/^  SymbolTableIterator(const SymbolTable& table)$/;"	f	class:fst::SymbolTableIterator
fst::SymbolTableIterator::Value	symbol-table.h	/^  int64 Value(void) {$/;"	f	class:fst::SymbolTableIterator
fst::SymbolTableIterator::key_	symbol-table.h	/^  int64 key_;$/;"	m	class:fst::SymbolTableIterator
fst::SymbolTableIterator::nsymbols_	symbol-table.h	/^  size_t nsymbols_;$/;"	m	class:fst::SymbolTableIterator
fst::SymbolTableIterator::pos_	symbol-table.h	/^  ssize_t pos_;$/;"	m	class:fst::SymbolTableIterator
fst::SymbolTableIterator::table_	symbol-table.h	/^  const SymbolTable& table_;$/;"	m	class:fst::SymbolTableIterator
fst::SymbolTableIterator::~SymbolTableIterator	symbol-table.h	/^  ~SymbolTableIterator() { }$/;"	f	class:fst::SymbolTableIterator
fst::SymbolTableReadOptions	symbol-table.h	/^struct SymbolTableReadOptions {$/;"	s	namespace:fst
fst::SymbolTableReadOptions::SymbolTableReadOptions	symbol-table.h	/^  SymbolTableReadOptions() { }$/;"	f	struct:fst::SymbolTableReadOptions
fst::SymbolTableReadOptions::SymbolTableReadOptions	symbol-table.h	/^  SymbolTableReadOptions(vector<pair<int64, int64> > string_hash_ranges_,$/;"	f	struct:fst::SymbolTableReadOptions
fst::SymbolTableReadOptions::source	symbol-table.h	/^  string source;$/;"	m	struct:fst::SymbolTableReadOptions
fst::SymbolTableReadOptions::string_hash_ranges	symbol-table.h	/^  vector<pair<int64, int64> > string_hash_ranges;$/;"	m	struct:fst::SymbolTableReadOptions
fst::SymbolTableToString	symbol-table.h	/^inline void SymbolTableToString(const SymbolTable *table, string *result) {$/;"	f	namespace:fst
fst::Synchronize	synchronize.h	/^void Synchronize(const Fst<Arc> &ifst, MutableFst<Arc> *ofst) {$/;"	f	namespace:fst
fst::SynchronizeFst	synchronize.h	/^class SynchronizeFst : public ImplToFst< SynchronizeFstImpl<A> > {$/;"	c	namespace:fst
fst::SynchronizeFst::Arc	synchronize.h	/^  typedef A Arc;$/;"	t	class:fst::SynchronizeFst
fst::SynchronizeFst::Copy	synchronize.h	/^  virtual SynchronizeFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::SynchronizeFst
fst::SynchronizeFst::GetImpl	synchronize.h	/^  Impl *GetImpl() const { return ImplToFst<Impl>::GetImpl(); }$/;"	f	class:fst::SynchronizeFst
fst::SynchronizeFst::Impl	synchronize.h	/^  typedef SynchronizeFstImpl<A> Impl;$/;"	t	class:fst::SynchronizeFst
fst::SynchronizeFst::InitArcIterator	synchronize.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<A> *data) const {$/;"	f	class:fst::SynchronizeFst
fst::SynchronizeFst::InitStateIterator	synchronize.h	/^void SynchronizeFst<A>::InitStateIterator(StateIteratorData<A> *data) const$/;"	f	class:fst::SynchronizeFst
fst::SynchronizeFst::State	synchronize.h	/^  typedef CacheState<A> State;$/;"	t	class:fst::SynchronizeFst
fst::SynchronizeFst::StateId	synchronize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::SynchronizeFst
fst::SynchronizeFst::SynchronizeFst	synchronize.h	/^  SynchronizeFst(const Fst<A> &fst)$/;"	f	class:fst::SynchronizeFst
fst::SynchronizeFst::SynchronizeFst	synchronize.h	/^  SynchronizeFst(const Fst<A> &fst,  const SynchronizeFstOptions &opts)$/;"	f	class:fst::SynchronizeFst
fst::SynchronizeFst::SynchronizeFst	synchronize.h	/^  SynchronizeFst(const SynchronizeFst<A> &fst, bool safe = false)$/;"	f	class:fst::SynchronizeFst
fst::SynchronizeFst::Weight	synchronize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::SynchronizeFst
fst::SynchronizeFstImpl	synchronize.h	/^class SynchronizeFstImpl$/;"	c	namespace:fst
fst::SynchronizeFstImpl::Arc	synchronize.h	/^  typedef A Arc;$/;"	t	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Car	synchronize.h	/^  Label Car(const String *s, Label l = 0) const {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Cdr	synchronize.h	/^  const String *Cdr(const String *s, Label l = 0) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Concat	synchronize.h	/^  const String *Concat(const String *s, Label l = 0) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Element	synchronize.h	/^  struct Element {$/;"	s	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Element::Element	synchronize.h	/^    Element() {}$/;"	f	struct:fst::SynchronizeFstImpl::Element
fst::SynchronizeFstImpl::Element::Element	synchronize.h	/^    Element(StateId s, const String *i, const String *o)$/;"	f	struct:fst::SynchronizeFstImpl::Element
fst::SynchronizeFstImpl::Element::istring	synchronize.h	/^    const String *istring;     \/\/ Residual input labels$/;"	m	struct:fst::SynchronizeFstImpl::Element
fst::SynchronizeFstImpl::Element::ostring	synchronize.h	/^    const String *ostring;     \/\/ Residual output labels$/;"	m	struct:fst::SynchronizeFstImpl::Element
fst::SynchronizeFstImpl::Element::state	synchronize.h	/^    StateId state;     \/\/ Input state Id$/;"	m	struct:fst::SynchronizeFstImpl::Element
fst::SynchronizeFstImpl::ElementEqual	synchronize.h	/^  class ElementEqual {$/;"	c	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::ElementEqual::operator ()	synchronize.h	/^    bool operator()(const Element &x, const Element &y) const {$/;"	f	class:fst::SynchronizeFstImpl::ElementEqual
fst::SynchronizeFstImpl::ElementKey	synchronize.h	/^  class ElementKey {$/;"	c	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::ElementKey::operator ()	synchronize.h	/^    size_t operator()(const Element &x) const {$/;"	f	class:fst::SynchronizeFstImpl::ElementKey
fst::SynchronizeFstImpl::ElementMap	synchronize.h	/^  typedef unordered_map<Element, StateId, ElementKey, ElementEqual> ElementMap;$/;"	t	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Empty	synchronize.h	/^  bool Empty(const String *s, Label l = 0) const {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Expand	synchronize.h	/^  void Expand(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Final	synchronize.h	/^  Weight Final(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::FindState	synchronize.h	/^  StateId FindState(const Element &e) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::FindString	synchronize.h	/^  const String *FindString(const String *s) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::InitArcIterator	synchronize.h	/^  void InitArcIterator(StateId s, ArcIteratorData<A> *data) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Label	synchronize.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::NumArcs	synchronize.h	/^  size_t NumArcs(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::NumInputEpsilons	synchronize.h	/^  size_t NumInputEpsilons(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::NumOutputEpsilons	synchronize.h	/^  size_t NumOutputEpsilons(StateId s) {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Properties	synchronize.h	/^  uint64 Properties() const { return Properties(kFstProperties); }$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Properties	synchronize.h	/^  uint64 Properties(uint64 mask) const {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Start	synchronize.h	/^  StateId Start() {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::StateId	synchronize.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::String	synchronize.h	/^  typedef basic_string<Label> String;$/;"	t	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::StringEqual	synchronize.h	/^  class StringEqual {$/;"	c	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::StringEqual::operator ()	synchronize.h	/^    bool operator()(const String * const &x, const String * const &y) const {$/;"	f	class:fst::SynchronizeFstImpl::StringEqual
fst::SynchronizeFstImpl::StringKey	synchronize.h	/^  class StringKey{$/;"	c	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::StringKey::operator ()	synchronize.h	/^    size_t operator()(const String * const & x) const {$/;"	f	class:fst::SynchronizeFstImpl::StringKey
fst::SynchronizeFstImpl::StringSet	synchronize.h	/^  typedef unordered_set<const String*, StringKey, StringEqual> StringSet;$/;"	t	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::SynchronizeFstImpl	synchronize.h	/^  SynchronizeFstImpl(const Fst<A> &fst, const SynchronizeFstOptions &opts)$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::SynchronizeFstImpl	synchronize.h	/^  SynchronizeFstImpl(const SynchronizeFstImpl &impl)$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::Weight	synchronize.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::element_map_	synchronize.h	/^  ElementMap element_map_;    \/\/ mapping Elements to Fst state$/;"	m	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::elements_	synchronize.h	/^  vector<Element> elements_;  \/\/ mapping Fst state to Elements$/;"	m	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::fst_	synchronize.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::string_set_	synchronize.h	/^  StringSet string_set_;$/;"	m	class:fst::SynchronizeFstImpl
fst::SynchronizeFstImpl::~SynchronizeFstImpl	synchronize.h	/^  ~SynchronizeFstImpl() {$/;"	f	class:fst::SynchronizeFstImpl
fst::SynchronizeFstOptions	synchronize.h	/^typedef CacheOptions SynchronizeFstOptions;$/;"	t	namespace:fst
fst::TOP_ORDER_QUEUE	queue.h	/^  TOP_ORDER_QUEUE = 4,       \/\/ Topologically-ordered queue$/;"	e	enum:fst::QueueType
fst::TRIVIAL_QUEUE	queue.h	/^  TRIVIAL_QUEUE = 0,         \/\/ Single state queue$/;"	e	enum:fst::QueueType
fst::TestProperties	test-properties.h	/^uint64 TestProperties(const Fst<Arc> &fst, uint64 mask, uint64 *known) {$/;"	f	namespace:fst
fst::Times	expectation-weight.h	/^inline ExpectationWeight<X1, X2> Times(const ExpectationWeight<X1, X2> &w,$/;"	f	namespace:fst
fst::Times	float-weight.h	/^inline LogWeightTpl<T> Times(const LogWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Times	float-weight.h	/^inline LogWeightTpl<double> Times(const LogWeightTpl<double> &w1,$/;"	f	namespace:fst
fst::Times	float-weight.h	/^inline LogWeightTpl<float> Times(const LogWeightTpl<float> &w1,$/;"	f	namespace:fst
fst::Times	float-weight.h	/^inline MinMaxWeightTpl<T> Times($/;"	f	namespace:fst
fst::Times	float-weight.h	/^inline MinMaxWeightTpl<double> Times($/;"	f	namespace:fst
fst::Times	float-weight.h	/^inline MinMaxWeightTpl<float> Times($/;"	f	namespace:fst
fst::Times	float-weight.h	/^inline TropicalWeightTpl<T> Times(const TropicalWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Times	float-weight.h	/^inline TropicalWeightTpl<double> Times(const TropicalWeightTpl<double> &w1,$/;"	f	namespace:fst
fst::Times	float-weight.h	/^inline TropicalWeightTpl<float> Times(const TropicalWeightTpl<float> &w1,$/;"	f	namespace:fst
fst::Times	lexicographic-weight.h	/^inline LexicographicWeight<W1, W2> Times(const LexicographicWeight<W1, W2> &w,$/;"	f	namespace:fst
fst::Times	power-weight.h	/^inline PowerWeight<W, n> Times(const PowerWeight<W, n> &w, const W &s) {$/;"	f	namespace:fst
fst::Times	power-weight.h	/^inline PowerWeight<W, n> Times(const PowerWeight<W, n> &w1,$/;"	f	namespace:fst
fst::Times	power-weight.h	/^inline PowerWeight<W, n> Times(const W &s, const PowerWeight<W, n> &w) {$/;"	f	namespace:fst
fst::Times	product-weight.h	/^inline ProductWeight<W1, W2> Times(const ProductWeight<W1, W2> &w,$/;"	f	namespace:fst
fst::Times	signed-log-weight.h	/^inline SignedLogWeightTpl<T> Times(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::Times	sparse-power-weight.h	/^inline SparsePowerWeight<W, K> Times(const SparsePowerWeight<W, K> &w1,$/;"	f	namespace:fst
fst::Times	sparse-power-weight.h	/^inline SparsePowerWeight<W, K> Times(const W &k,$/;"	f	namespace:fst
fst::Times	string-weight.h	/^inline StringWeight<L, S> Times(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
fst::TimesMapper	arc-map.h	/^struct TimesMapper {$/;"	s	namespace:fst
fst::TimesMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::TimesMapper
fst::TimesMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::TimesMapper
fst::TimesMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::TimesMapper
fst::TimesMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	struct:fst::TimesMapper
fst::TimesMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::TimesMapper
fst::TimesMapper::TimesMapper	arc-map.h	/^  explicit TimesMapper(Weight w) : weight_(w) {}$/;"	f	struct:fst::TimesMapper
fst::TimesMapper::ToArc	arc-map.h	/^  typedef A ToArc;$/;"	t	struct:fst::TimesMapper
fst::TimesMapper::Weight	arc-map.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::TimesMapper
fst::TimesMapper::operator ()	arc-map.h	/^  A operator()(const A &arc) const {$/;"	f	struct:fst::TimesMapper
fst::TimesMapper::weight_	arc-map.h	/^  Weight weight_;$/;"	m	struct:fst::TimesMapper
fst::ToGallicMapper	arc-map.h	/^struct ToGallicMapper {$/;"	s	namespace:fst
fst::ToGallicMapper::AW	arc-map.h	/^  typedef typename A::Weight AW;$/;"	t	struct:fst::ToGallicMapper
fst::ToGallicMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	struct:fst::ToGallicMapper
fst::ToGallicMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	struct:fst::ToGallicMapper
fst::ToGallicMapper::GW	arc-map.h	/^  typedef typename GallicArc<A, S>::Weight GW;$/;"	t	struct:fst::ToGallicMapper
fst::ToGallicMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	struct:fst::ToGallicMapper
fst::ToGallicMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_CLEAR_SYMBOLS;}$/;"	f	struct:fst::ToGallicMapper
fst::ToGallicMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const {$/;"	f	struct:fst::ToGallicMapper
fst::ToGallicMapper::SW	arc-map.h	/^  typedef StringWeight<typename A::Label, S> SW;$/;"	t	struct:fst::ToGallicMapper
fst::ToGallicMapper::ToArc	arc-map.h	/^  typedef GallicArc<A, S> ToArc;$/;"	t	struct:fst::ToGallicMapper
fst::ToGallicMapper::operator ()	arc-map.h	/^  ToArc operator()(const A &arc) const {$/;"	f	struct:fst::ToGallicMapper
fst::TopOrderQueue	queue.h	/^class TopOrderQueue : public QueueBase<S> {$/;"	c	namespace:fst
fst::TopOrderQueue::Clear	queue.h	/^  void Clear() {$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Dequeue	queue.h	/^  void Dequeue() {$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Empty	queue.h	/^  bool Empty() const { return front_ > back_; }$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Enqueue	queue.h	/^  void Enqueue(StateId s) {$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Head	queue.h	/^  StateId Head() const { return state_[front_]; }$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::TopOrderQueue
fst::TopOrderQueue::TopOrderQueue	queue.h	/^  TopOrderQueue(const Fst<Arc> &fst, ArcFilter filter)$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::TopOrderQueue	queue.h	/^  TopOrderQueue(const vector<StateId> &order)$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::TopOrderQueue
fst::TopOrderQueue::back_	queue.h	/^  StateId back_;$/;"	m	class:fst::TopOrderQueue
fst::TopOrderQueue::front_	queue.h	/^  StateId front_;$/;"	m	class:fst::TopOrderQueue
fst::TopOrderQueue::order_	queue.h	/^  vector<StateId> order_;$/;"	m	class:fst::TopOrderQueue
fst::TopOrderQueue::state_	queue.h	/^  vector<StateId> state_;$/;"	m	class:fst::TopOrderQueue
fst::TopOrderVisitor	topsort.h	/^class TopOrderVisitor {$/;"	c	namespace:fst
fst::TopOrderVisitor::Arc	topsort.h	/^  typedef A Arc;$/;"	t	class:fst::TopOrderVisitor
fst::TopOrderVisitor::BackArc	topsort.h	/^  bool BackArc(StateId s, const A &arc) { return (*acyclic_ = false); }$/;"	f	class:fst::TopOrderVisitor
fst::TopOrderVisitor::FinishState	topsort.h	/^  void FinishState(StateId s, StateId p, const A *) { finish_->push_back(s); }$/;"	f	class:fst::TopOrderVisitor
fst::TopOrderVisitor::FinishVisit	topsort.h	/^  void FinishVisit() {$/;"	f	class:fst::TopOrderVisitor
fst::TopOrderVisitor::ForwardOrCrossArc	topsort.h	/^  bool ForwardOrCrossArc(StateId s, const A &arc) { return true; }$/;"	f	class:fst::TopOrderVisitor
fst::TopOrderVisitor::InitState	topsort.h	/^  bool InitState(StateId s, StateId r) { return true; }$/;"	f	class:fst::TopOrderVisitor
fst::TopOrderVisitor::InitVisit	topsort.h	/^  void InitVisit(const Fst<A> &fst) {$/;"	f	class:fst::TopOrderVisitor
fst::TopOrderVisitor::StateId	topsort.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::TopOrderVisitor
fst::TopOrderVisitor::TopOrderVisitor	topsort.h	/^  TopOrderVisitor(vector<StateId> *order, bool *acyclic)$/;"	f	class:fst::TopOrderVisitor
fst::TopOrderVisitor::TreeArc	topsort.h	/^  bool TreeArc(StateId s, const A &arc) { return true; }$/;"	f	class:fst::TopOrderVisitor
fst::TopOrderVisitor::acyclic_	topsort.h	/^  bool *acyclic_;$/;"	m	class:fst::TopOrderVisitor
fst::TopOrderVisitor::finish_	topsort.h	/^  vector<StateId> *finish_;  \/\/ states in finishing-time order$/;"	m	class:fst::TopOrderVisitor
fst::TopOrderVisitor::order_	topsort.h	/^  vector<StateId> *order_;$/;"	m	class:fst::TopOrderVisitor
fst::TopSort	topsort.h	/^bool TopSort(MutableFst<Arc> *fst) {$/;"	f	namespace:fst
fst::TrivialAStarEstimate	queue.h	/^struct TrivialAStarEstimate {$/;"	s	namespace:fst
fst::TrivialAStarEstimate::operator ()	queue.h	/^  W operator()(S s) const { return W::One(); }$/;"	f	struct:fst::TrivialAStarEstimate
fst::TrivialLookAheadMatcher	lookahead-matcher.h	/^class TrivialLookAheadMatcher$/;"	c	namespace:fst
fst::TrivialLookAheadMatcher::Arc	lookahead-matcher.h	/^  typedef typename M::Arc Arc;$/;"	t	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Copy	lookahead-matcher.h	/^  TrivialLookAheadMatcher<M> *Copy(bool safe = false) const {$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Done	lookahead-matcher.h	/^  bool Done() const { return matcher_.Done(); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Done_	lookahead-matcher.h	/^  virtual bool Done_() const { return Done(); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::FST	lookahead-matcher.h	/^  typedef typename M::FST FST;$/;"	t	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Find	lookahead-matcher.h	/^  bool Find(Label label) { return matcher_.Find(label); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Find_	lookahead-matcher.h	/^  virtual bool Find_(Label label) { return Find(label); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Flags	lookahead-matcher.h	/^  uint32 Flags() const {$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::GetFst	lookahead-matcher.h	/^  virtual const FST &GetFst() const { return matcher_.GetFst(); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::InitLookAheadFst	lookahead-matcher.h	/^  void InitLookAheadFst(const Fst<Arc>& fst, bool copy = false) {}$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Label	lookahead-matcher.h	/^  typedef typename Arc::Label Label;$/;"	t	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::LookAheadFst	lookahead-matcher.h	/^  bool LookAheadFst(const Fst<Arc> &fst, StateId s) {return true; }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::LookAheadFst_	lookahead-matcher.h	/^  bool LookAheadFst_(const Fst<Arc> &fst, StateId s) {$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::LookAheadLabel	lookahead-matcher.h	/^  bool LookAheadLabel(Label label) const { return true;  }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::LookAheadLabel_	lookahead-matcher.h	/^  bool LookAheadLabel_(Label l) const { return LookAheadLabel(l); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::LookAheadPrefix	lookahead-matcher.h	/^  bool LookAheadPrefix(Arc *arc) const { return false; }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::LookAheadPrefix_	lookahead-matcher.h	/^  bool LookAheadPrefix_(Arc *arc) const { return LookAheadPrefix(arc); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::LookAheadWeight	lookahead-matcher.h	/^  Weight LookAheadWeight() const { return Weight::One(); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::LookAheadWeight_	lookahead-matcher.h	/^  Weight LookAheadWeight_() const { return LookAheadWeight(); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Next	lookahead-matcher.h	/^  void Next() { matcher_.Next(); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Next_	lookahead-matcher.h	/^  virtual void Next_() { Next(); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Properties	lookahead-matcher.h	/^  uint64 Properties(uint64 props) const { return matcher_.Properties(props); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::SetState	lookahead-matcher.h	/^  void SetState(StateId s) { return matcher_.SetState(s); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::SetState_	lookahead-matcher.h	/^  virtual void SetState_(StateId s) { SetState(s); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::StateId	lookahead-matcher.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::TrivialLookAheadMatcher	lookahead-matcher.h	/^  TrivialLookAheadMatcher(const FST &fst, MatchType match_type)$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::TrivialLookAheadMatcher	lookahead-matcher.h	/^  TrivialLookAheadMatcher(const TrivialLookAheadMatcher<M> &lmatcher,$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Type	lookahead-matcher.h	/^  MatchType Type(bool test) const { return matcher_.Type(test); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Value	lookahead-matcher.h	/^  const Arc& Value() const { return matcher_.Value(); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Value_	lookahead-matcher.h	/^  virtual const Arc& Value_() const { return Value(); }$/;"	f	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::Weight	lookahead-matcher.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::TrivialLookAheadMatcher
fst::TrivialLookAheadMatcher::matcher_	lookahead-matcher.h	/^  M matcher_;$/;"	m	class:fst::TrivialLookAheadMatcher
fst::TrivialQueue	queue.h	/^class TrivialQueue : public QueueBase<S> {$/;"	c	namespace:fst
fst::TrivialQueue::Clear	queue.h	/^  void Clear() { front_ = kNoStateId; }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Clear_	queue.h	/^  virtual void Clear_() { return Clear(); }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Dequeue	queue.h	/^  void Dequeue() { front_ = kNoStateId; }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Dequeue_	queue.h	/^  virtual void Dequeue_() { Dequeue(); }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Empty	queue.h	/^  bool Empty() const { return front_ == kNoStateId; }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Empty_	queue.h	/^  virtual bool Empty_() const { return Empty(); }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Enqueue	queue.h	/^  void Enqueue(StateId s) { front_ = s; }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Enqueue_	queue.h	/^  virtual void Enqueue_(StateId s) { Enqueue(s); }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Head	queue.h	/^  StateId Head() const { return front_; }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Head_	queue.h	/^  virtual StateId Head_() const { return Head(); }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::StateId	queue.h	/^  typedef S StateId;$/;"	t	class:fst::TrivialQueue
fst::TrivialQueue::TrivialQueue	queue.h	/^  TrivialQueue() : QueueBase<S>(TRIVIAL_QUEUE), front_(kNoStateId) {}$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Update	queue.h	/^  void Update(StateId s) {}$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::Update_	queue.h	/^  virtual void Update_(StateId s) { Update(s); }$/;"	f	class:fst::TrivialQueue
fst::TrivialQueue::front_	queue.h	/^  StateId front_;$/;"	m	class:fst::TrivialQueue
fst::TrivialStateEquivClass	queue.h	/^struct TrivialStateEquivClass {$/;"	s	namespace:fst
fst::TrivialStateEquivClass::operator ()	queue.h	/^  S operator()(S s) const { return s; }$/;"	f	struct:fst::TrivialStateEquivClass
fst::TropicalWeight	float-weight.h	/^typedef TropicalWeightTpl<float> TropicalWeight;$/;"	t	namespace:fst
fst::TropicalWeight	fst-decl.h	/^typedef TropicalWeightTpl<float> TropicalWeight;$/;"	t	namespace:fst
fst::TropicalWeightGenerator	random-weight.h	/^typedef TropicalWeightGenerator_<float> TropicalWeightGenerator;$/;"	t	namespace:fst
fst::TropicalWeightGenerator_	random-weight.h	/^class TropicalWeightGenerator_ {$/;"	c	namespace:fst
fst::TropicalWeightGenerator_::TropicalWeightGenerator_	random-weight.h	/^  TropicalWeightGenerator_(int seed = time(0), bool allow_zero = true)$/;"	f	class:fst::TropicalWeightGenerator_
fst::TropicalWeightGenerator_::Weight	random-weight.h	/^  typedef TropicalWeightTpl<T> Weight;$/;"	t	class:fst::TropicalWeightGenerator_
fst::TropicalWeightGenerator_::allow_zero_	random-weight.h	/^  bool allow_zero_;  \/\/ permit Zero() and zero divisors$/;"	m	class:fst::TropicalWeightGenerator_
fst::TropicalWeightGenerator_::kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::TropicalWeightGenerator_
fst::TropicalWeightGenerator_::kNumRandomWeights	random-weight.h	/^template <class T> const int TropicalWeightGenerator_<T>::kNumRandomWeights;$/;"	m	class:fst::TropicalWeightGenerator_
fst::TropicalWeightGenerator_::operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::TropicalWeightGenerator_
fst::TropicalWeightTpl	float-weight.h	/^class TropicalWeightTpl : public FloatWeightTpl<T> {$/;"	c	namespace:fst
fst::TropicalWeightTpl::Member	float-weight.h	/^  bool Member() const {$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::NoWeight	float-weight.h	/^  static const TropicalWeightTpl<T> NoWeight() {$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::One	float-weight.h	/^  static const TropicalWeightTpl<T> One() {$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::Properties	float-weight.h	/^  static uint64 Properties() {$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::Quantize	float-weight.h	/^  TropicalWeightTpl<T> Quantize(float delta = kDelta) const {$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::Reverse	float-weight.h	/^  TropicalWeightTpl<T> Reverse() const { return *this; }$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::ReverseWeight	float-weight.h	/^  typedef TropicalWeightTpl<T> ReverseWeight;$/;"	t	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::TropicalWeightTpl	float-weight.h	/^  TropicalWeightTpl() : FloatWeightTpl<T>() {}$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::TropicalWeightTpl	float-weight.h	/^  TropicalWeightTpl(T f) : FloatWeightTpl<T>(f) {}$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::TropicalWeightTpl	float-weight.h	/^  TropicalWeightTpl(const TropicalWeightTpl<T> &w) : FloatWeightTpl<T>(w) {}$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::Type	float-weight.h	/^  static const string &Type() {$/;"	f	class:fst::TropicalWeightTpl
fst::TropicalWeightTpl::Zero	float-weight.h	/^  static const TropicalWeightTpl<T> Zero() {$/;"	f	class:fst::TropicalWeightTpl
fst::TupleWeight	tuple-weight.h	/^class TupleWeight {$/;"	c	namespace:fst
fst::TupleWeight::Hash	tuple-weight.h	/^  size_t Hash() const {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::Length	tuple-weight.h	/^  static unsigned int Length() {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::Member	tuple-weight.h	/^  bool Member() const {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::NoWeight	tuple-weight.h	/^  static const TupleWeight<W, n> &NoWeight() {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::One	tuple-weight.h	/^  static const TupleWeight<W, n> &One() {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::Quantize	tuple-weight.h	/^  TupleWeight<W, n> Quantize(float delta = kDelta) const {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::Read	tuple-weight.h	/^  istream &Read(istream &strm) {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::ReadNoParen	tuple-weight.h	/^  inline static istream &ReadNoParen(istream &strm,$/;"	f	class:fst::TupleWeight
fst::TupleWeight::ReadWithParen	tuple-weight.h	/^  inline static istream &ReadWithParen(istream &strm,$/;"	f	class:fst::TupleWeight
fst::TupleWeight::Reverse	tuple-weight.h	/^  ReverseWeight Reverse() const {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::ReverseWeight	tuple-weight.h	/^  typedef TupleWeight<typename W::ReverseWeight, n> ReverseWeight;$/;"	t	class:fst::TupleWeight
fst::TupleWeight::SetValue	tuple-weight.h	/^  void SetValue(size_t i, const W &w) { values_[i] = w; }$/;"	f	class:fst::TupleWeight
fst::TupleWeight::TupleWeight	tuple-weight.h	/^  TupleWeight() {}$/;"	f	class:fst::TupleWeight
fst::TupleWeight::TupleWeight	tuple-weight.h	/^  TupleWeight(Iterator begin, Iterator end) {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::TupleWeight	tuple-weight.h	/^  TupleWeight(const TupleWeight &w) {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::TupleWeight	tuple-weight.h	/^  TupleWeight(const W &w) {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::Value	tuple-weight.h	/^  const W& Value(size_t i) const { return values_[i]; }$/;"	f	class:fst::TupleWeight
fst::TupleWeight::Write	tuple-weight.h	/^  ostream &Write(ostream &strm) const {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::Zero	tuple-weight.h	/^  static const TupleWeight<W, n> &Zero() {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::operator =	tuple-weight.h	/^  TupleWeight<W, n> &operator=(const TupleWeight<W, n> &w) {$/;"	f	class:fst::TupleWeight
fst::TupleWeight::values_	tuple-weight.h	/^  W values_[n];$/;"	m	class:fst::TupleWeight
fst::UTF8StringToLabels	icu.h	/^bool UTF8StringToLabels(const string &str, vector<Label> *labels) {$/;"	f	namespace:fst
fst::UniformArcSelector	randgen.h	/^struct UniformArcSelector {$/;"	s	namespace:fst
fst::UniformArcSelector::StateId	randgen.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::UniformArcSelector
fst::UniformArcSelector::UniformArcSelector	randgen.h	/^  UniformArcSelector(int seed = time(0)) { srand(seed); }$/;"	f	struct:fst::UniformArcSelector
fst::UniformArcSelector::Weight	randgen.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::UniformArcSelector
fst::UniformArcSelector::operator ()	randgen.h	/^  size_t operator()(const Fst<A> &fst, StateId s) const {$/;"	f	struct:fst::UniformArcSelector
fst::Union	union.h	/^void Union(MutableFst<Arc> *fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
fst::Union	union.h	/^void Union(RationalFst<Arc> *fst1, const Fst<Arc> &fst2) {$/;"	f	namespace:fst
fst::UnionFind	union-find.h	/^class UnionFind {$/;"	c	namespace:fst
fst::UnionFind::FindSet	union-find.h	/^  T FindSet(T item) {$/;"	f	class:fst::UnionFind
fst::UnionFind::Link	union-find.h	/^  void Link(T x, T y) {$/;"	f	class:fst::UnionFind
fst::UnionFind::MakeAllSet	union-find.h	/^  void MakeAllSet(T max) {$/;"	f	class:fst::UnionFind
fst::UnionFind::MakeSet	union-find.h	/^  T MakeSet(T item) {$/;"	f	class:fst::UnionFind
fst::UnionFind::Union	union-find.h	/^  void Union(T x, T y) {$/;"	f	class:fst::UnionFind
fst::UnionFind::UnionFind	union-find.h	/^  UnionFind(T max, T fail)$/;"	f	class:fst::UnionFind
fst::UnionFind::exec_stack_	union-find.h	/^  stack<T*> exec_stack_;  \/\/ Used for path compression.$/;"	m	class:fst::UnionFind
fst::UnionFind::fail_	union-find.h	/^  T fail_;                \/\/ Value indicating lookup failure.$/;"	m	class:fst::UnionFind
fst::UnionFind::parent_	union-find.h	/^  vector<T> parent_;      \/\/ Parent nodes.$/;"	m	class:fst::UnionFind
fst::UnionFind::rank_	union-find.h	/^  vector<int> rank_;      \/\/ Rank of an element = min. depth in tree.$/;"	m	class:fst::UnionFind
fst::UnionFst	union.h	/^class UnionFst : public RationalFst<A> {$/;"	c	namespace:fst
fst::UnionFst::Arc	union.h	/^  typedef A Arc;$/;"	t	class:fst::UnionFst
fst::UnionFst::Copy	union.h	/^  virtual UnionFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::UnionFst
fst::UnionFst::StateId	union.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::UnionFst
fst::UnionFst::UnionFst	union.h	/^  UnionFst(const Fst<A> &fst1, const Fst<A> &fst2) {$/;"	f	class:fst::UnionFst
fst::UnionFst::UnionFst	union.h	/^  UnionFst(const Fst<A> &fst1, const Fst<A> &fst2, const UnionFstOptions &opts)$/;"	f	class:fst::UnionFst
fst::UnionFst::UnionFst	union.h	/^  UnionFst(const UnionFst<A> &fst, bool safe = false)$/;"	f	class:fst::UnionFst
fst::UnionFst::Weight	union.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::UnionFst
fst::UnionFstOptions	union.h	/^typedef RationalFstOptions UnionFstOptions;$/;"	t	namespace:fst
fst::UnweightedAcceptorCompactor	compact-fst.h	/^class UnweightedAcceptorCompactor {$/;"	c	namespace:fst
fst::UnweightedAcceptorCompactor::Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const {$/;"	f	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Element	compact-fst.h	/^  typedef pair<Label, StateId> Element;$/;"	t	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Read	compact-fst.h	/^  static UnweightedAcceptorCompactor *Read(istream &istrm) {$/;"	f	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Size	compact-fst.h	/^  ssize_t Size() const { return -1;}$/;"	f	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::UnweightedAcceptorCompactor
fst::UnweightedAcceptorCompactor::Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::UnweightedAcceptorCompactor
fst::UnweightedCompactor	compact-fst.h	/^class UnweightedCompactor {$/;"	c	namespace:fst
fst::UnweightedCompactor::Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const {$/;"	f	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Element	compact-fst.h	/^  typedef pair< pair<Label, Label>, StateId > Element;$/;"	t	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Read	compact-fst.h	/^  static UnweightedCompactor *Read(istream &strm) {$/;"	f	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Size	compact-fst.h	/^  ssize_t Size() const { return -1; }$/;"	f	class:fst::UnweightedCompactor
fst::UnweightedCompactor::StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::UnweightedCompactor
fst::UnweightedCompactor::Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::UnweightedCompactor
fst::VectorBiTable	bi-table.h	/^class VectorBiTable {$/;"	c	namespace:fst
fst::VectorBiTable::FindEntry	bi-table.h	/^  const T &FindEntry(I s) const { return id2entry_[s]; }$/;"	f	class:fst::VectorBiTable
fst::VectorBiTable::FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::VectorBiTable
fst::VectorBiTable::Fingerprint	bi-table.h	/^  const FP &Fingerprint() const { return *fp_; }$/;"	f	class:fst::VectorBiTable
fst::VectorBiTable::Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::VectorBiTable
fst::VectorBiTable::VectorBiTable	bi-table.h	/^  explicit VectorBiTable(FP *fp = 0) : fp_(fp ? fp : new FP()) {}$/;"	f	class:fst::VectorBiTable
fst::VectorBiTable::fp2id_	bi-table.h	/^  vector<I> fp2id_;$/;"	m	class:fst::VectorBiTable
fst::VectorBiTable::fp_	bi-table.h	/^  FP *fp_;$/;"	m	class:fst::VectorBiTable
fst::VectorBiTable::id2entry_	bi-table.h	/^  vector<T> id2entry_;$/;"	m	class:fst::VectorBiTable
fst::VectorBiTable::~VectorBiTable	bi-table.h	/^  ~VectorBiTable() { delete fp_; }$/;"	f	class:fst::VectorBiTable
fst::VectorFst	vector-fst.h	/^class VectorFst : public ImplToMutableFst< VectorFstImpl<A> > {$/;"	c	namespace:fst
fst::VectorFst::Arc	vector-fst.h	/^  typedef A Arc;$/;"	t	class:fst::VectorFst
fst::VectorFst::Copy	vector-fst.h	/^  virtual VectorFst<A> *Copy(bool safe = false) const {$/;"	f	class:fst::VectorFst
fst::VectorFst::GetImpl	vector-fst.h	/^  Impl *GetImpl() const { return ImplToFst< Impl, MutableFst<A> >::GetImpl(); }$/;"	f	class:fst::VectorFst
fst::VectorFst::Impl	vector-fst.h	/^  typedef VectorFstImpl<A> Impl;$/;"	t	class:fst::VectorFst
fst::VectorFst::InitArcIterator	vector-fst.h	/^  virtual void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::VectorFst
fst::VectorFst::InitMutableArcIterator	vector-fst.h	/^void VectorFst<A>::InitMutableArcIterator($/;"	f	class:fst::VectorFst
fst::VectorFst::InitStateIterator	vector-fst.h	/^  virtual void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::VectorFst
fst::VectorFst::MutateCheck	vector-fst.h	/^  void MutateCheck() { return ImplToMutableFst<Impl>::MutateCheck(); }$/;"	f	class:fst::VectorFst
fst::VectorFst::Read	vector-fst.h	/^  static VectorFst<A> *Read(const string &filename) {$/;"	f	class:fst::VectorFst
fst::VectorFst::Read	vector-fst.h	/^  static VectorFst<A> *Read(istream &strm, const FstReadOptions &opts) {$/;"	f	class:fst::VectorFst
fst::VectorFst::ReserveArcs	vector-fst.h	/^  void ReserveArcs(StateId s, size_t n) {$/;"	f	class:fst::VectorFst
fst::VectorFst::ReserveStates	vector-fst.h	/^  void ReserveStates(StateId n) {$/;"	f	class:fst::VectorFst
fst::VectorFst::SetImpl	vector-fst.h	/^  void SetImpl(Impl *impl, bool own_impl = true) {$/;"	f	class:fst::VectorFst
fst::VectorFst::StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::VectorFst
fst::VectorFst::VectorFst	vector-fst.h	/^  VectorFst() : ImplToMutableFst<Impl>(new Impl) {}$/;"	f	class:fst::VectorFst
fst::VectorFst::VectorFst	vector-fst.h	/^  VectorFst(const VectorFst<A> &fst) : ImplToMutableFst<Impl>(fst) {}$/;"	f	class:fst::VectorFst
fst::VectorFst::VectorFst	vector-fst.h	/^  explicit VectorFst(Impl *impl) : ImplToMutableFst<Impl>(impl) {}$/;"	f	class:fst::VectorFst
fst::VectorFst::VectorFst	vector-fst.h	/^  explicit VectorFst(const Fst<A> &fst)$/;"	f	class:fst::VectorFst
fst::VectorFst::Write	vector-fst.h	/^  virtual bool Write(const string &filename) const {$/;"	f	class:fst::VectorFst
fst::VectorFst::Write	vector-fst.h	/^  virtual bool Write(ostream &strm, const FstWriteOptions &opts) const {$/;"	f	class:fst::VectorFst
fst::VectorFst::WriteFst	vector-fst.h	/^bool VectorFst<A>::WriteFst(const F &fst, ostream &strm,$/;"	f	class:fst::VectorFst
fst::VectorFst::operator =	vector-fst.h	/^  VectorFst<A> &operator=(const VectorFst<A> &fst) {$/;"	f	class:fst::VectorFst
fst::VectorFst::operator =	vector-fst.h	/^  virtual VectorFst<A> &operator=(const Fst<A> &fst) {$/;"	f	class:fst::VectorFst
fst::VectorFstBaseImpl	vector-fst.h	/^class VectorFstBaseImpl : public FstImpl<typename State::Arc> {$/;"	c	namespace:fst
fst::VectorFstBaseImpl::AddArc	vector-fst.h	/^  void AddArc(StateId s, const Arc &arc) {$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::AddState	vector-fst.h	/^  StateId AddState() {$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::AddState	vector-fst.h	/^  StateId AddState(State *state) {$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::Arc	vector-fst.h	/^  typedef typename State::Arc Arc;$/;"	t	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::DeleteArcs	vector-fst.h	/^  void DeleteArcs(StateId s) { states_[s]->arcs.clear(); }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::DeleteArcs	vector-fst.h	/^  void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::DeleteStates	vector-fst.h	/^  void DeleteStates() {$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::DeleteStates	vector-fst.h	/^  void DeleteStates(const vector<StateId>& dstates) {$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::Final	vector-fst.h	/^  Weight Final(StateId s) const { return states_[s]->final; }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::GetState	vector-fst.h	/^  State *GetState(StateId s) { return states_[s]; }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::GetState	vector-fst.h	/^  const State *GetState(StateId s) const { return states_[s]; }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::InitArcIterator	vector-fst.h	/^  void InitArcIterator(StateId s, ArcIteratorData<Arc> *data) const {$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::InitStateIterator	vector-fst.h	/^  void InitStateIterator(StateIteratorData<Arc> *data) const {$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::NumArcs	vector-fst.h	/^  size_t NumArcs(StateId s) const { return states_[s]->arcs.size(); }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::NumStates	vector-fst.h	/^  StateId NumStates() const { return states_.size(); }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::ReserveArcs	vector-fst.h	/^  void ReserveArcs(StateId s, size_t n) { states_[s]->arcs.reserve(n); }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::ReserveStates	vector-fst.h	/^  void ReserveStates(StateId n) { states_.reserve(n); }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::SetFinal	vector-fst.h	/^  void SetFinal(StateId s, Weight w) { states_[s]->final = w; }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::SetStart	vector-fst.h	/^  void SetStart(StateId s) { start_ = s; }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::SetState	vector-fst.h	/^  void SetState(StateId s, State *state) { states_[s] = state; }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::Start	vector-fst.h	/^  StateId Start() const { return start_; }$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::StateId	vector-fst.h	/^  typedef typename Arc::StateId StateId;$/;"	t	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::VectorFstBaseImpl	vector-fst.h	/^  VectorFstBaseImpl() : start_(kNoStateId) {}$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::Weight	vector-fst.h	/^  typedef typename Arc::Weight Weight;$/;"	t	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::start_	vector-fst.h	/^  StateId start_;               \/\/ initial state$/;"	m	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::states_	vector-fst.h	/^  vector<State *> states_;      \/\/ States represenation.$/;"	m	class:fst::VectorFstBaseImpl
fst::VectorFstBaseImpl::~VectorFstBaseImpl	vector-fst.h	/^  ~VectorFstBaseImpl() {$/;"	f	class:fst::VectorFstBaseImpl
fst::VectorFstImpl	vector-fst.h	/^class VectorFstImpl : public VectorFstBaseImpl< VectorState<A> > {$/;"	c	namespace:fst
fst::VectorFstImpl::AddArc	vector-fst.h	/^  void AddArc(StateId s, const A &arc) {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::AddState	vector-fst.h	/^  StateId AddState() {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::BaseImpl	vector-fst.h	/^  typedef VectorFstBaseImpl< VectorState<A> > BaseImpl;$/;"	t	class:fst::VectorFstImpl
fst::VectorFstImpl::DeleteArcs	vector-fst.h	/^  void DeleteArcs(StateId s) {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::DeleteArcs	vector-fst.h	/^  void DeleteArcs(StateId s, size_t n) {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::DeleteStates	vector-fst.h	/^  void DeleteStates() {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::DeleteStates	vector-fst.h	/^  void DeleteStates(const vector<StateId> &dstates) {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::NumInputEpsilons	vector-fst.h	/^  size_t NumInputEpsilons(StateId s) const { return GetState(s)->niepsilons; }$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::NumOutputEpsilons	vector-fst.h	/^  size_t NumOutputEpsilons(StateId s) const { return GetState(s)->noepsilons; }$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::Read	vector-fst.h	/^VectorFstImpl<A> *VectorFstImpl<A>::Read(istream &strm,$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::SetFinal	vector-fst.h	/^  void SetFinal(StateId s, Weight w) {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::SetStart	vector-fst.h	/^  void SetStart(StateId s) {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::VectorFstImpl
fst::VectorFstImpl::VectorFstImpl	vector-fst.h	/^  VectorFstImpl() {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::VectorFstImpl	vector-fst.h	/^VectorFstImpl<A>::VectorFstImpl(const Fst<A> &fst) {$/;"	f	class:fst::VectorFstImpl
fst::VectorFstImpl::Weight	vector-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::VectorFstImpl
fst::VectorFstImpl::kFileVersion	vector-fst.h	/^  static const int kFileVersion = 2;$/;"	m	class:fst::VectorFstImpl
fst::VectorFstImpl::kFileVersion	vector-fst.h	/^template <class A> const int VectorFstImpl<A>::kFileVersion;$/;"	m	class:fst::VectorFstImpl
fst::VectorFstImpl::kMinFileVersion	vector-fst.h	/^  static const int kMinFileVersion = 1;$/;"	m	class:fst::VectorFstImpl
fst::VectorFstImpl::kMinFileVersion	vector-fst.h	/^template <class A> const int VectorFstImpl<A>::kMinFileVersion;$/;"	m	class:fst::VectorFstImpl
fst::VectorFstImpl::kStaticProperties	vector-fst.h	/^  static const uint64 kStaticProperties = kExpanded | kMutable;$/;"	m	class:fst::VectorFstImpl
fst::VectorFstImpl::kStaticProperties	vector-fst.h	/^template <class A> const uint64 VectorFstImpl<A>::kStaticProperties;$/;"	m	class:fst::VectorFstImpl
fst::VectorHashBiTable	bi-table.h	/^class VectorHashBiTable {$/;"	c	namespace:fst
fst::VectorHashBiTable::FindEntry	bi-table.h	/^  const T &FindEntry(I s) const {$/;"	f	class:fst::VectorHashBiTable
fst::VectorHashBiTable::FindId	bi-table.h	/^  I FindId(const T &entry, bool insert = true) {$/;"	f	class:fst::VectorHashBiTable
fst::VectorHashBiTable::Fingerprint	bi-table.h	/^  const FP &Fingerprint() const { return *fp_; }$/;"	f	class:fst::VectorHashBiTable
fst::VectorHashBiTable::Hash	bi-table.h	/^  const H &Hash() const { return *h_; }$/;"	f	class:fst::VectorHashBiTable
fst::VectorHashBiTable::HashEqual	bi-table.h	/^  class HashEqual {$/;"	c	class:fst::VectorHashBiTable
fst::VectorHashBiTable::HashEqual::HashEqual	bi-table.h	/^    HashEqual(const VectorHashBiTable &ht) : ht_(&ht) {}$/;"	f	class:fst::VectorHashBiTable::HashEqual
fst::VectorHashBiTable::HashEqual::ht_	bi-table.h	/^    const VectorHashBiTable *ht_;$/;"	m	class:fst::VectorHashBiTable::HashEqual
fst::VectorHashBiTable::HashEqual::operator ()	bi-table.h	/^    bool operator()(I k1, I k2) const {$/;"	f	class:fst::VectorHashBiTable::HashEqual
fst::VectorHashBiTable::HashFunc	bi-table.h	/^  class HashFunc {$/;"	c	class:fst::VectorHashBiTable
fst::VectorHashBiTable::HashFunc::HashFunc	bi-table.h	/^    HashFunc(const VectorHashBiTable &ht) : ht_(&ht) {}$/;"	f	class:fst::VectorHashBiTable::HashFunc
fst::VectorHashBiTable::HashFunc::ht_	bi-table.h	/^    const VectorHashBiTable *ht_;$/;"	m	class:fst::VectorHashBiTable::HashFunc
fst::VectorHashBiTable::HashFunc::operator ()	bi-table.h	/^    size_t operator()(I k) const { return (*(ht_->h_))(ht_->Key2Entry(k)); }$/;"	f	class:fst::VectorHashBiTable::HashFunc
fst::VectorHashBiTable::Key2Entry	bi-table.h	/^  const T &Key2Entry(I k) const {$/;"	f	class:fst::VectorHashBiTable
fst::VectorHashBiTable::KeyHashSet	bi-table.h	/^  typedef unordered_set<I, HashFunc, HashEqual> KeyHashSet;$/;"	t	class:fst::VectorHashBiTable
fst::VectorHashBiTable::Selector	bi-table.h	/^  const S &Selector() const { return *selector_; }$/;"	f	class:fst::VectorHashBiTable
fst::VectorHashBiTable::Size	bi-table.h	/^  I Size() const { return id2entry_.size(); }$/;"	f	class:fst::VectorHashBiTable
fst::VectorHashBiTable::VectorHashBiTable	bi-table.h	/^  VectorHashBiTable(S *s, FP *fp, H *h,$/;"	f	class:fst::VectorHashBiTable
fst::VectorHashBiTable::current_entry_	bi-table.h	/^  const T *current_entry_;$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::empty_entry_	bi-table.h	/^  const T empty_entry_;$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::fp2id_	bi-table.h	/^  vector<I> fp2id_;        \/\/ Maps entry fingerprints to IDs$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::fp_	bi-table.h	/^  FP *fp_;       \/\/ Fingerprint used when hashing entry into vector$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::h_	bi-table.h	/^  H *h_;         \/\/ Hash function used when hashing entry into hash_set$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::hash_equal_	bi-table.h	/^  HashEqual hash_equal_;$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::hash_func_	bi-table.h	/^  HashFunc hash_func_;$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::id2entry_	bi-table.h	/^  vector<T> id2entry_;  \/\/ Maps state IDs to entry$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::kCurrentKey	bi-table.h	/^  static const I kCurrentKey;$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::kCurrentKey	bi-table.h	/^const I VectorHashBiTable<I, T, S, FP, H>::kCurrentKey = -2;$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::kEmptyKey	bi-table.h	/^  static const I kEmptyKey;$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::kEmptyKey	bi-table.h	/^const I VectorHashBiTable<I, T, S, FP, H>::kEmptyKey = -1;$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::keys_	bi-table.h	/^  KeyHashSet keys_;$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::selector_	bi-table.h	/^  S *selector_;  \/\/ Returns true if entry hashed into vector$/;"	m	class:fst::VectorHashBiTable
fst::VectorHashBiTable::~VectorHashBiTable	bi-table.h	/^  ~VectorHashBiTable() {$/;"	f	class:fst::VectorHashBiTable
fst::VectorHashReplaceStateTable	replace.h	/^class VectorHashReplaceStateTable {$/;"	c	namespace:fst
fst::VectorHashReplaceStateTable::Arc	replace.h	/^  typedef A Arc;$/;"	t	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::FindState	replace.h	/^  StateId FindState(const StateTuple &tuple) {$/;"	f	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::Label	replace.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::PrefixId	replace.h	/^  typedef P PrefixId;$/;"	t	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::StateId	replace.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::StateTable	replace.h	/^                               ReplaceFingerprint<StateId, P> > StateTable;$/;"	t	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::StateTuple	replace.h	/^  typedef ReplaceStateTuple<StateId, P> StateTuple;$/;"	t	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::Tuple	replace.h	/^  const StateTuple &Tuple(StateId id) const {$/;"	f	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::VectorHashReplaceStateTable	replace.h	/^  VectorHashReplaceStateTable($/;"	f	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::VectorHashReplaceStateTable	replace.h	/^  VectorHashReplaceStateTable(const VectorHashReplaceStateTable<A, P> &table)$/;"	f	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::cumulative_size_array_	replace.h	/^  vector<uint64> cumulative_size_array_;$/;"	m	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::root_size_	replace.h	/^  StateId root_size_;$/;"	m	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::state_table_	replace.h	/^  StateTable *state_table_;$/;"	m	class:fst::VectorHashReplaceStateTable
fst::VectorHashReplaceStateTable::~VectorHashReplaceStateTable	replace.h	/^  ~VectorHashReplaceStateTable() {$/;"	f	class:fst::VectorHashReplaceStateTable
fst::VectorHashStateTable	state-table.h	/^class VectorHashStateTable$/;"	c	namespace:fst
fst::VectorHashStateTable::FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::VectorHashStateTable
fst::VectorHashStateTable::StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::VectorHashStateTable
fst::VectorHashStateTable::StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::VectorHashStateTable
fst::VectorHashStateTable::Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::VectorHashStateTable
fst::VectorHashStateTable::VectorHashStateTable	state-table.h	/^  VectorHashStateTable(S *s, FP *fp, H *h,$/;"	f	class:fst::VectorHashStateTable
fst::VectorState	vector-fst.h	/^struct VectorState {$/;"	s	namespace:fst
fst::VectorState::Arc	vector-fst.h	/^  typedef A Arc;$/;"	t	struct:fst::VectorState
fst::VectorState::StateId	vector-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	struct:fst::VectorState
fst::VectorState::VectorState	vector-fst.h	/^  VectorState() : final(Weight::Zero()), niepsilons(0), noepsilons(0) {}$/;"	f	struct:fst::VectorState
fst::VectorState::Weight	vector-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	struct:fst::VectorState
fst::VectorState::arcs	vector-fst.h	/^  vector<A> arcs;            \/\/ Arcs represenation$/;"	m	struct:fst::VectorState
fst::VectorState::final	vector-fst.h	/^  Weight final;              \/\/ Final weight$/;"	m	struct:fst::VectorState
fst::VectorState::niepsilons	vector-fst.h	/^  size_t niepsilons;         \/\/ # of input epsilons$/;"	m	struct:fst::VectorState
fst::VectorState::noepsilons	vector-fst.h	/^  size_t noepsilons;         \/\/ # of output epsilons$/;"	m	struct:fst::VectorState
fst::VectorStateTable	state-table.h	/^class VectorStateTable$/;"	c	namespace:fst
fst::VectorStateTable::FindState	state-table.h	/^  StateId FindState(const StateTuple &tuple) { return FindId(tuple); }$/;"	f	class:fst::VectorStateTable
fst::VectorStateTable::StateId	state-table.h	/^  typedef typename StateTuple::StateId StateId;$/;"	t	class:fst::VectorStateTable
fst::VectorStateTable::StateTuple	state-table.h	/^  typedef T StateTuple;$/;"	t	class:fst::VectorStateTable
fst::VectorStateTable::Tuple	state-table.h	/^  const StateTuple &Tuple(StateId s) const { return FindEntry(s); }$/;"	f	class:fst::VectorStateTable
fst::VectorStateTable::VectorStateTable	state-table.h	/^  explicit VectorStateTable(FP *fp = 0) : VectorBiTable<StateId, T, FP>(fp) {}$/;"	f	class:fst::VectorStateTable
fst::Verify	verify.h	/^bool Verify(const Fst<Arc> &fst, bool allow_negative_labels = false) {$/;"	f	namespace:fst
fst::Visit	visit.h	/^inline void Visit(const Fst<Arc> &fst, V *visitor, Q* queue) {$/;"	f	namespace:fst
fst::Visit	visit.h	/^void Visit(const Fst<Arc> &fst, V *visitor, Q *queue, ArcFilter filter) {$/;"	f	namespace:fst
fst::WeightConvert	float-weight.h	/^struct WeightConvert<Log64Weight, LogWeight> {$/;"	s	namespace:fst
fst::WeightConvert	float-weight.h	/^struct WeightConvert<Log64Weight, TropicalWeight> {$/;"	s	namespace:fst
fst::WeightConvert	float-weight.h	/^struct WeightConvert<LogWeight, Log64Weight> {$/;"	s	namespace:fst
fst::WeightConvert	float-weight.h	/^struct WeightConvert<LogWeight, TropicalWeight> {$/;"	s	namespace:fst
fst::WeightConvert	float-weight.h	/^struct WeightConvert<TropicalWeight, Log64Weight> {$/;"	s	namespace:fst
fst::WeightConvert	float-weight.h	/^struct WeightConvert<TropicalWeight, LogWeight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<Log64Weight, SignedLog64Weight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<Log64Weight, SignedLogWeight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<LogWeight, SignedLog64Weight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<LogWeight, SignedLogWeight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLog64Weight, Log64Weight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLog64Weight, LogWeight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLog64Weight, SignedLogWeight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLog64Weight, TropicalWeight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLogWeight, Log64Weight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLogWeight, LogWeight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLogWeight, SignedLog64Weight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<SignedLogWeight, TropicalWeight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<TropicalWeight, SignedLog64Weight> {$/;"	s	namespace:fst
fst::WeightConvert	signed-log-weight.h	/^struct WeightConvert<TropicalWeight, SignedLogWeight> {$/;"	s	namespace:fst
fst::WeightConvert	weight.h	/^struct WeightConvert {$/;"	s	namespace:fst
fst::WeightConvert	weight.h	/^struct WeightConvert<W, W> {$/;"	s	namespace:fst
fst::WeightConvert::operator ()	float-weight.h	/^  Log64Weight operator()(LogWeight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	float-weight.h	/^  Log64Weight operator()(TropicalWeight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	float-weight.h	/^  LogWeight operator()(Log64Weight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	float-weight.h	/^  LogWeight operator()(TropicalWeight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	float-weight.h	/^  TropicalWeight operator()(Log64Weight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	float-weight.h	/^  TropicalWeight operator()(LogWeight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  Log64Weight operator()(SignedLog64Weight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  Log64Weight operator()(SignedLogWeight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  LogWeight operator()(SignedLog64Weight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  LogWeight operator()(SignedLogWeight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  SignedLog64Weight operator()(Log64Weight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  SignedLog64Weight operator()(LogWeight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  SignedLog64Weight operator()(SignedLogWeight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  SignedLog64Weight operator()(TropicalWeight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  SignedLogWeight operator()(Log64Weight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  SignedLogWeight operator()(LogWeight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  SignedLogWeight operator()(SignedLog64Weight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  SignedLogWeight operator()(TropicalWeight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  TropicalWeight operator()(SignedLog64Weight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	signed-log-weight.h	/^  TropicalWeight operator()(SignedLogWeight w) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	weight.h	/^  W operator()(W w) const { return w; }$/;"	f	struct:fst::WeightConvert
fst::WeightConvert::operator ()	weight.h	/^  W2 operator()(W1 w1) const {$/;"	f	struct:fst::WeightConvert
fst::WeightConvertMapper	arc-map.h	/^class WeightConvertMapper {$/;"	c	namespace:fst
fst::WeightConvertMapper::FinalAction	arc-map.h	/^  MapFinalAction FinalAction() const { return MAP_NO_SUPERFINAL; }$/;"	f	class:fst::WeightConvertMapper
fst::WeightConvertMapper::FromArc	arc-map.h	/^  typedef A FromArc;$/;"	t	class:fst::WeightConvertMapper
fst::WeightConvertMapper::FromWeight	arc-map.h	/^  typedef typename FromArc::Weight FromWeight;$/;"	t	class:fst::WeightConvertMapper
fst::WeightConvertMapper::InputSymbolsAction	arc-map.h	/^  MapSymbolsAction InputSymbolsAction() const { return MAP_COPY_SYMBOLS; }$/;"	f	class:fst::WeightConvertMapper
fst::WeightConvertMapper::OutputSymbolsAction	arc-map.h	/^  MapSymbolsAction OutputSymbolsAction() const { return MAP_COPY_SYMBOLS;}$/;"	f	class:fst::WeightConvertMapper
fst::WeightConvertMapper::Properties	arc-map.h	/^  uint64 Properties(uint64 props) const { return props; }$/;"	f	class:fst::WeightConvertMapper
fst::WeightConvertMapper::ToArc	arc-map.h	/^  typedef B ToArc;$/;"	t	class:fst::WeightConvertMapper
fst::WeightConvertMapper::ToWeight	arc-map.h	/^  typedef typename ToArc::Weight ToWeight;$/;"	t	class:fst::WeightConvertMapper
fst::WeightConvertMapper::convert_weight_	arc-map.h	/^  WeightConvert<FromWeight, ToWeight> convert_weight_;$/;"	m	class:fst::WeightConvertMapper
fst::WeightConvertMapper::operator ()	arc-map.h	/^  ToArc operator()(const FromArc &arc) const {$/;"	f	class:fst::WeightConvertMapper
fst::WeightFilterState	compose-filter.h	/^class WeightFilterState {$/;"	c	namespace:fst
fst::WeightFilterState::GetWeight	compose-filter.h	/^  W GetWeight() const { return weight_; }$/;"	f	class:fst::WeightFilterState
fst::WeightFilterState::Hash	compose-filter.h	/^  size_t Hash() const { return weight_.Hash(); }$/;"	f	class:fst::WeightFilterState
fst::WeightFilterState::NoState	compose-filter.h	/^  static const WeightFilterState NoState() { return WeightFilterState(); }$/;"	f	class:fst::WeightFilterState
fst::WeightFilterState::SetWeight	compose-filter.h	/^  void SetWeight(W w) { weight_ = w; }$/;"	f	class:fst::WeightFilterState
fst::WeightFilterState::WeightFilterState	compose-filter.h	/^  WeightFilterState() : weight_(W::Zero()) {}$/;"	f	class:fst::WeightFilterState
fst::WeightFilterState::WeightFilterState	compose-filter.h	/^  explicit WeightFilterState(W w) : weight_(w) {}$/;"	f	class:fst::WeightFilterState
fst::WeightFilterState::operator !=	compose-filter.h	/^  bool operator!=(const WeightFilterState &f) const {$/;"	f	class:fst::WeightFilterState
fst::WeightFilterState::operator ==	compose-filter.h	/^  bool operator==(const WeightFilterState &f) const {$/;"	f	class:fst::WeightFilterState
fst::WeightFilterState::weight_	compose-filter.h	/^  W weight_;$/;"	m	class:fst::WeightFilterState
fst::WeightFromString	vector-fst.h	/^template <class W> class WeightFromString {$/;"	c	namespace:fst
fst::WeightFromString::operator ()	vector-fst.h	/^LogWeight WeightFromString<LogWeight>::operator()(const string &s) {$/;"	f	class:fst::WeightFromString
fst::WeightFromString::operator ()	vector-fst.h	/^TropicalWeight WeightFromString<TropicalWeight>::operator()(const string &s) {$/;"	f	class:fst::WeightFromString
fst::WeightFromString::operator ()	vector-fst.h	/^W WeightFromString<W>::operator()(const string &s) {$/;"	f	class:fst::WeightFromString
fst::WeightToStr	util.h	/^void WeightToStr(Weight w, string *s) {$/;"	f	namespace:fst
fst::WeightedStringCompactor	compact-fst.h	/^class WeightedStringCompactor {$/;"	c	namespace:fst
fst::WeightedStringCompactor::Arc	compact-fst.h	/^  typedef A Arc;$/;"	t	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Compact	compact-fst.h	/^  Element Compact(StateId s, const A &arc) const {$/;"	f	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Compatible	compact-fst.h	/^  bool Compatible(const Fst<A> &fst) const {$/;"	f	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Element	compact-fst.h	/^  typedef pair<Label, Weight> Element;$/;"	t	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Expand	compact-fst.h	/^  Arc Expand(StateId s, const Element &p, uint32 f = kArcValueFlags) const {$/;"	f	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Label	compact-fst.h	/^  typedef typename A::Label Label;$/;"	t	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Properties	compact-fst.h	/^  uint64 Properties() const {$/;"	f	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Read	compact-fst.h	/^  static WeightedStringCompactor *Read(istream &strm) {$/;"	f	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Size	compact-fst.h	/^  ssize_t Size() const { return 1;}$/;"	f	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::StateId	compact-fst.h	/^  typedef typename A::StateId StateId;$/;"	t	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Type	compact-fst.h	/^  static const string &Type() {$/;"	f	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Weight	compact-fst.h	/^  typedef typename A::Weight Weight;$/;"	t	class:fst::WeightedStringCompactor
fst::WeightedStringCompactor::Write	compact-fst.h	/^  bool Write(ostream &strm) const { return true; }$/;"	f	class:fst::WeightedStringCompactor
fst::WriteLabelPairs	util.h	/^bool WriteLabelPairs(const string& filename,$/;"	f	namespace:fst
fst::WriteType	util.h	/^inline ostream &WriteType(ostream &strm, const T t) {$/;"	f	namespace:fst
fst::WriteType	util.h	/^inline ostream &WriteType(ostream &strm, const pair<S, T> &p) {$/;"	f	namespace:fst
fst::WriteType	util.h	/^inline ostream &WriteType(ostream &strm, const string &s) {$/;"	f	namespace:fst
fst::bit_cast	compat.h	/^inline Dest bit_cast(const Source& source) {$/;"	f	namespace:fst
fst::down_cast	compat.h	/^inline To down_cast(From* f) {$/;"	f	namespace:fst
fst::ilabel_lookahead_flags	matcher-fst.h	/^static const uint32 ilabel_lookahead_flags = kInputLookAheadMatcher |$/;"	m	namespace:fst
fst::internal	expanded-fst.h	/^namespace internal {$/;"	n	namespace:fst
fst::internal	fst.h	/^namespace internal {$/;"	n	namespace:fst
fst::internal	mutable-fst.h	/^namespace internal {$/;"	n	namespace:fst
fst::internal	push.h	/^namespace internal {$/;"	n	namespace:fst
fst::internal::ComputeTotalWeight	push.h	/^typename Arc::Weight ComputeTotalWeight($/;"	f	namespace:fst::internal
fst::internal::Final	expanded-fst.h	/^typename A::Weight Final(const ExpandedFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::Final	fst.h	/^typename A::Weight Final(const Fst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::Final	fst.h	/^typename F::Arc::Weight Final(const F &fst, typename F::Arc::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::Final	mutable-fst.h	/^typename A::Weight Final(const MutableFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumArcs	expanded-fst.h	/^ssize_t NumArcs(const ExpandedFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumArcs	fst.h	/^ssize_t NumArcs(const F &fst, typename F::Arc::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumArcs	fst.h	/^ssize_t NumArcs(const Fst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumArcs	mutable-fst.h	/^ssize_t NumArcs(const MutableFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumInputEpsilons	expanded-fst.h	/^ssize_t NumInputEpsilons(const ExpandedFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumInputEpsilons	fst.h	/^ssize_t NumInputEpsilons(const F &fst, typename F::Arc::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumInputEpsilons	fst.h	/^ssize_t NumInputEpsilons(const Fst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumInputEpsilons	mutable-fst.h	/^ssize_t NumInputEpsilons(const MutableFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumOutputEpsilons	expanded-fst.h	/^ssize_t NumOutputEpsilons(const ExpandedFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumOutputEpsilons	fst.h	/^ssize_t NumOutputEpsilons(const F &fst, typename F::Arc::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumOutputEpsilons	fst.h	/^ssize_t NumOutputEpsilons(const Fst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::NumOutputEpsilons	mutable-fst.h	/^ssize_t NumOutputEpsilons(const MutableFst<A> &fst, typename A::StateId s) {$/;"	f	namespace:fst::internal
fst::internal::RemoveWeight	push.h	/^void RemoveWeight(MutableFst<Arc> *fst, typename Arc::Weight w, bool at_final) {$/;"	f	namespace:fst::internal
fst::kAcceptor	properties.h	/^const uint64 kAcceptor =          0x0000000000010000ULL;$/;"	m	namespace:fst
fst::kAccessible	properties.h	/^const uint64 kAccessible =        0x0000010000000000ULL;$/;"	m	namespace:fst
fst::kAcyclic	properties.h	/^const uint64 kAcyclic =           0x0000000800000000ULL;$/;"	m	namespace:fst
fst::kAddArcProperties	properties.h	/^const uint64 kAddArcProperties = kExpanded | kMutable | kError | kNotAcceptor |$/;"	m	namespace:fst
fst::kAddOnMagicNumber	add-on.h	/^static const int32 kAddOnMagicNumber = 446681434;$/;"	m	namespace:fst
fst::kAddStateProperties	properties.h	/^const uint64 kAddStateProperties$/;"	m	namespace:fst
fst::kAddSuperFinalProperties	properties.h	/^const uint64 kAddSuperFinalProperties  = kExpanded | kMutable | kError |$/;"	m	namespace:fst
fst::kArcFlags	fst.h	/^static const uint32 kArcFlags = kArcValueFlags | kArcNoCache;$/;"	m	namespace:fst
fst::kArcILabelValue	fst.h	/^static const uint32 kArcILabelValue    = 0x0001;  \/\/ Value() gives valid ilabel$/;"	m	namespace:fst
fst::kArcNextStateValue	fst.h	/^static const uint32 kArcNextStateValue = 0x0008;  \/\/  "       "     " nextstate$/;"	m	namespace:fst
fst::kArcNoCache	fst.h	/^static const uint32 kArcNoCache   = 0x0010;       \/\/ No need to cache arcs$/;"	m	namespace:fst
fst::kArcOLabelValue	fst.h	/^static const uint32 kArcOLabelValue    = 0x0002;  \/\/  "       "     "    olabel$/;"	m	namespace:fst
fst::kArcSortProperties	properties.h	/^const uint64 kArcSortProperties =$/;"	m	namespace:fst
fst::kArcValueFlags	fst.h	/^static const uint32 kArcValueFlags =$/;"	m	namespace:fst
fst::kArcWeightValue	fst.h	/^static const uint32 kArcWeightValue    = 0x0004;  \/\/  "       "     "    weight$/;"	m	namespace:fst
fst::kBinaryProperties	properties.h	/^const uint64 kBinaryProperties =  0x0000000000000007ULL;$/;"	m	namespace:fst
fst::kCoAccessible	properties.h	/^const uint64 kCoAccessible =      0x0000040000000000ULL;$/;"	m	namespace:fst
fst::kCommutative	weight.h	/^const uint64 kCommutative =       0x0000000000000004ULL;$/;"	m	namespace:fst
fst::kCopyProperties	properties.h	/^const uint64 kCopyProperties$/;"	m	namespace:fst
fst::kCyclic	properties.h	/^const uint64 kCyclic =            0x0000000400000000ULL;$/;"	m	namespace:fst
fst::kDeleteArcsProperties	properties.h	/^const uint64 kDeleteArcsProperties$/;"	m	namespace:fst
fst::kDeleteStatesProperties	properties.h	/^const uint64 kDeleteStatesProperties$/;"	m	namespace:fst
fst::kDelta	weight.h	/^const float kDelta =                   1.0F\/1024.0F;$/;"	m	namespace:fst
fst::kDfsBlack	dfs-visit.h	/^const int kDfsBlack = 2;   \/\/ Finished$/;"	m	namespace:fst
fst::kDfsGrey	dfs-visit.h	/^const int kDfsGrey =  1;   \/\/ Discovered & unfinished$/;"	m	namespace:fst
fst::kDfsWhite	dfs-visit.h	/^const int kDfsWhite = 0;   \/\/ Undiscovered$/;"	m	namespace:fst
fst::kEncodeFlags	encode.h	/^static const uint32 kEncodeFlags       = 0x0003;  \/\/ All non-internal flags$/;"	m	namespace:fst
fst::kEncodeHasISymbols	encode.h	/^static const uint32 kEncodeHasISymbols = 0x0004;  \/\/ For internal use$/;"	m	namespace:fst
fst::kEncodeHasOSymbols	encode.h	/^static const uint32 kEncodeHasOSymbols = 0x0008;  \/\/ For internal use$/;"	m	namespace:fst
fst::kEncodeLabels	encode.h	/^static const uint32 kEncodeLabels      = 0x0001;$/;"	m	namespace:fst
fst::kEncodeMagicNumber	encode.h	/^static const int32 kEncodeMagicNumber = 2129983209;$/;"	m	namespace:fst
fst::kEncodeWeights	encode.h	/^static const uint32 kEncodeWeights     = 0x0002;$/;"	m	namespace:fst
fst::kEpsilons	properties.h	/^const uint64 kEpsilons =          0x0000000000400000ULL;$/;"	m	namespace:fst
fst::kError	properties.h	/^const uint64 kError =             0x0000000000000004ULL;$/;"	m	namespace:fst
fst::kExpanded	properties.h	/^const uint64 kExpanded =          0x0000000000000001ULL;$/;"	m	namespace:fst
fst::kExtrinsicProperties	properties.h	/^const uint64 kExtrinsicProperties = kError;$/;"	m	namespace:fst
fst::kFactorArcWeights	factor-weight.h	/^const uint32 kFactorArcWeights   = 0x00000002;$/;"	m	namespace:fst
fst::kFactorFinalWeights	factor-weight.h	/^const uint32 kFactorFinalWeights = 0x00000001;$/;"	m	namespace:fst
fst::kFstProperties	properties.h	/^const uint64 kFstProperties = kBinaryProperties | kTrinaryProperties;$/;"	m	namespace:fst
fst::kIDeterministic	properties.h	/^const uint64 kIDeterministic =    0x0000000000040000ULL;$/;"	m	namespace:fst
fst::kIEpsilons	properties.h	/^const uint64 kIEpsilons =         0x0000000001000000ULL;$/;"	m	namespace:fst
fst::kILabelInvariantProperties	properties.h	/^const uint64 kILabelInvariantProperties =$/;"	m	namespace:fst
fst::kILabelSorted	properties.h	/^const uint64 kILabelSorted =      0x0000000010000000ULL;$/;"	m	namespace:fst
fst::kIdempotent	weight.h	/^const uint64 kIdempotent =             0x0000000000000008ULL;$/;"	m	namespace:fst
fst::kInitialAcyclic	properties.h	/^const uint64 kInitialAcyclic =    0x0000002000000000ULL;$/;"	m	namespace:fst
fst::kInitialCyclic	properties.h	/^const uint64 kInitialCyclic =     0x0000001000000000ULL;$/;"	m	namespace:fst
fst::kInputLookAheadMatcher	lookahead-matcher.h	/^const uint32 kInputLookAheadMatcher =      0x00000001;$/;"	m	namespace:fst
fst::kIntrinsicProperties	properties.h	/^const uint64 kIntrinsicProperties$/;"	m	namespace:fst
fst::kLeftSemiring	weight.h	/^const uint64 kLeftSemiring =           0x0000000000000001ULL;$/;"	m	namespace:fst
fst::kLookAheadEpsilons	lookahead-matcher.h	/^const uint32 kLookAheadEpsilons =          0x00000020;$/;"	m	namespace:fst
fst::kLookAheadFlags	lookahead-matcher.h	/^const uint32 kLookAheadFlags =            0x000000ff;$/;"	m	namespace:fst
fst::kLookAheadKeepRelabelData	lookahead-matcher.h	/^const uint32 kLookAheadKeepRelabelData =  0x00000080;$/;"	m	namespace:fst
fst::kLookAheadNonEpsilonPrefix	lookahead-matcher.h	/^const uint32 kLookAheadNonEpsilonPrefix =  0x00000040;$/;"	m	namespace:fst
fst::kLookAheadNonEpsilons	lookahead-matcher.h	/^const uint32 kLookAheadNonEpsilons =       0x00000010;$/;"	m	namespace:fst
fst::kLookAheadPrefix	lookahead-matcher.h	/^const uint32 kLookAheadPrefix =            0x00000008;$/;"	m	namespace:fst
fst::kLookAheadWeight	lookahead-matcher.h	/^const uint32 kLookAheadWeight =            0x00000004;$/;"	m	namespace:fst
fst::kMatcherFlags	matcher.h	/^const uint32 kMatcherFlags = 0x00000000;$/;"	m	namespace:fst
fst::kMultiEpsList	matcher.h	/^const uint32 kMultiEpsList =  0x00000001;$/;"	m	namespace:fst
fst::kMultiEpsLoop	matcher.h	/^const uint32 kMultiEpsLoop =  0x00000002;$/;"	m	namespace:fst
fst::kMutable	properties.h	/^const uint64 kMutable =           0x0000000000000002ULL;$/;"	m	namespace:fst
fst::kNegTrinaryProperties	properties.h	/^const uint64 kNegTrinaryProperties =$/;"	m	namespace:fst
fst::kNoEpsilons	properties.h	/^const uint64 kNoEpsilons =        0x0000000000800000ULL;$/;"	m	namespace:fst
fst::kNoIEpsilons	properties.h	/^const uint64 kNoIEpsilons =       0x0000000002000000ULL;$/;"	m	namespace:fst
fst::kNoKey	heap.h	/^static const int kNoKey = -1;$/;"	m	namespace:fst
fst::kNoLabel	fst.h	/^const int kNoLabel     =  -1;  \/\/ Not a valid label$/;"	m	namespace:fst
fst::kNoOEpsilons	properties.h	/^const uint64 kNoOEpsilons =       0x0000000008000000ULL;$/;"	m	namespace:fst
fst::kNoStateId	fst.h	/^const int kNoStateId   =  -1;  \/\/ Not a valid state ID$/;"	m	namespace:fst
fst::kNonIDeterministic	properties.h	/^const uint64 kNonIDeterministic = 0x0000000000080000ULL;$/;"	m	namespace:fst
fst::kNonODeterministic	properties.h	/^const uint64 kNonODeterministic = 0x0000000000200000ULL;$/;"	m	namespace:fst
fst::kNotAcceptor	properties.h	/^const uint64 kNotAcceptor =       0x0000000000020000ULL;$/;"	m	namespace:fst
fst::kNotAccessible	properties.h	/^const uint64 kNotAccessible =     0x0000020000000000ULL;$/;"	m	namespace:fst
fst::kNotCoAccessible	properties.h	/^const uint64 kNotCoAccessible =   0x0000080000000000ULL;$/;"	m	namespace:fst
fst::kNotILabelSorted	properties.h	/^const uint64 kNotILabelSorted =   0x0000000020000000ULL;$/;"	m	namespace:fst
fst::kNotOLabelSorted	properties.h	/^const uint64 kNotOLabelSorted =   0x0000000080000000ULL;$/;"	m	namespace:fst
fst::kNotString	properties.h	/^const uint64 kNotString =         0x0000200000000000ULL;$/;"	m	namespace:fst
fst::kNotTopSorted	properties.h	/^const uint64 kNotTopSorted =      0x0000008000000000ULL;$/;"	m	namespace:fst
fst::kNullProperties	properties.h	/^const uint64 kNullProperties$/;"	m	namespace:fst
fst::kODeterministic	properties.h	/^const uint64 kODeterministic =    0x0000000000100000ULL;$/;"	m	namespace:fst
fst::kOEpsilons	properties.h	/^const uint64 kOEpsilons =         0x0000000004000000ULL;$/;"	m	namespace:fst
fst::kOLabelInvariantProperties	properties.h	/^const uint64 kOLabelInvariantProperties =$/;"	m	namespace:fst
fst::kOLabelSorted	properties.h	/^const uint64 kOLabelSorted =      0x0000000040000000ULL;$/;"	m	namespace:fst
fst::kOutputLookAheadMatcher	lookahead-matcher.h	/^const uint32 kOutputLookAheadMatcher =     0x00000002;$/;"	m	namespace:fst
fst::kPath	weight.h	/^const uint64 kPath =                   0x0000000000000010ULL;$/;"	m	namespace:fst
fst::kPosTrinaryProperties	properties.h	/^const uint64 kPosTrinaryProperties =$/;"	m	namespace:fst
fst::kPushLabels	push.h	/^const uint32 kPushLabels =  0x0002;$/;"	m	namespace:fst
fst::kPushRemoveCommonAffix	push.h	/^const uint32 kPushRemoveCommonAffix = 0x0008;$/;"	m	namespace:fst
fst::kPushRemoveTotalWeight	push.h	/^const uint32 kPushRemoveTotalWeight = 0x0004;$/;"	m	namespace:fst
fst::kPushWeights	push.h	/^const uint32 kPushWeights = 0x0001;$/;"	m	namespace:fst
fst::kRightSemiring	weight.h	/^const uint64 kRightSemiring =          0x0000000000000002ULL;$/;"	m	namespace:fst
fst::kRmSuperFinalProperties	properties.h	/^const uint64 kRmSuperFinalProperties  = kExpanded | kMutable | kError |$/;"	m	namespace:fst
fst::kSemiring	weight.h	/^const uint64 kSemiring = kLeftSemiring | kRightSemiring;$/;"	m	namespace:fst
fst::kSetArcProperties	properties.h	/^const uint64 kSetArcProperties = kExpanded | kMutable | kError;$/;"	m	namespace:fst
fst::kSetFinalProperties	properties.h	/^const uint64 kSetFinalProperties$/;"	m	namespace:fst
fst::kSetStartProperties	properties.h	/^const uint64 kSetStartProperties$/;"	m	namespace:fst
fst::kStateSortProperties	properties.h	/^const uint64 kStateSortProperties = kExpanded | kMutable | kError | kAcceptor |$/;"	m	namespace:fst
fst::kString	properties.h	/^const uint64 kString =            0x0000100000000000ULL;$/;"	m	namespace:fst
fst::kStringBad	string-weight.h	/^const int kStringBad = -2;           \/\/ Label for a non-string$/;"	m	namespace:fst
fst::kStringInfinity	string-weight.h	/^const int kStringInfinity = -1;      \/\/ Label for the infinite string$/;"	m	namespace:fst
fst::kStringSeparator	string-weight.h	/^const char kStringSeparator = '_';   \/\/ Label separator in strings$/;"	m	namespace:fst
fst::kTopSorted	properties.h	/^const uint64 kTopSorted =         0x0000004000000000ULL;$/;"	m	namespace:fst
fst::kTrinaryProperties	properties.h	/^const uint64 kTrinaryProperties = 0x00003fffffff0000ULL;$/;"	m	namespace:fst
fst::kUnweighted	properties.h	/^const uint64 kUnweighted =        0x0000000200000000ULL;$/;"	m	namespace:fst
fst::kWeightInvariantProperties	properties.h	/^const uint64 kWeightInvariantProperties =$/;"	m	namespace:fst
fst::kWeighted	properties.h	/^const uint64 kWeighted =          0x0000000100000000ULL;$/;"	m	namespace:fst
fst::olabel_lookahead_flags	matcher-fst.h	/^static const uint32 olabel_lookahead_flags = kOutputLookAheadMatcher |$/;"	m	namespace:fst
fst::operator !=	float-weight.h	/^inline bool operator!=(const FloatWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::operator !=	float-weight.h	/^inline bool operator!=(const FloatWeightTpl<double> &w1,$/;"	f	namespace:fst
fst::operator !=	float-weight.h	/^inline bool operator!=(const FloatWeightTpl<float> &w1,$/;"	f	namespace:fst
fst::operator !=	pair-weight.h	/^inline bool operator!=(const PairWeight<W1, W2> &w1,$/;"	f	namespace:fst
fst::operator !=	sparse-tuple-weight.h	/^inline bool operator!=(const SparseTupleWeight<W, K> &w1,$/;"	f	namespace:fst
fst::operator !=	string-weight.h	/^inline bool operator!=(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
fst::operator !=	tuple-weight.h	/^inline bool operator!=(const TupleWeight<W, n> &w1,$/;"	f	namespace:fst
fst::operator <<	float-weight.h	/^inline ostream &operator<<(ostream &strm, const FloatWeightTpl<T> &w) {$/;"	f	namespace:fst
fst::operator <<	interval-set.h	/^ostream &operator<<(ostream &strm, const IntervalSet<T> &s)  {$/;"	f	namespace:fst
fst::operator <<	pair-weight.h	/^inline ostream &operator<<(ostream &strm, const PairWeight<W1, W2> &w) {$/;"	f	namespace:fst
fst::operator <<	sparse-tuple-weight.h	/^inline ostream &operator<<(ostream &strm, const SparseTupleWeight<W, K> &w) {$/;"	f	namespace:fst
fst::operator <<	string-weight.h	/^inline ostream &operator<<(ostream &strm, const StringWeight<L, S> &w) {$/;"	f	namespace:fst
fst::operator <<	tuple-weight.h	/^inline ostream &operator<<(ostream &strm, const TupleWeight<W, n> &w) {$/;"	f	namespace:fst
fst::operator ==	float-weight.h	/^inline bool operator==(const FloatWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::operator ==	float-weight.h	/^inline bool operator==(const FloatWeightTpl<double> &w1,$/;"	f	namespace:fst
fst::operator ==	float-weight.h	/^inline bool operator==(const FloatWeightTpl<float> &w1,$/;"	f	namespace:fst
fst::operator ==	pair-weight.h	/^inline bool operator==(const PairWeight<W1, W2> &w,$/;"	f	namespace:fst
fst::operator ==	replace.h	/^inline bool operator==(const ReplaceStateTuple<S, P>& x,$/;"	f	namespace:fst
fst::operator ==	signed-log-weight.h	/^inline bool operator==(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
fst::operator ==	sparse-tuple-weight.h	/^inline bool operator==(const SparseTupleWeight<W, K> &w1,$/;"	f	namespace:fst
fst::operator ==	state-table.h	/^inline bool operator==(const ComposeStateTuple<S, F>& x,$/;"	f	namespace:fst
fst::operator ==	string-weight.h	/^inline bool operator==(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
fst::operator ==	tuple-weight.h	/^inline bool operator==(const TupleWeight<W, n> &w1,$/;"	f	namespace:fst
fst::operator >>	float-weight.h	/^inline istream &operator>>(istream &strm, FloatWeightTpl<T> &w) {$/;"	f	namespace:fst
fst::operator >>	pair-weight.h	/^inline istream &operator>>(istream &strm, PairWeight<W1, W2> &w) {$/;"	f	namespace:fst
fst::operator >>	sparse-tuple-weight.h	/^inline istream &operator>>(istream &strm, SparseTupleWeight<W, K> &w) {$/;"	f	namespace:fst
fst::operator >>	string-weight.h	/^inline istream &operator>>(istream &strm, StringWeight<L, S> &w) {$/;"	f	namespace:fst
fst::operator >>	tuple-weight.h	/^inline istream &operator>>(istream &strm, TupleWeight<W, n> &w) {$/;"	f	namespace:fst
fst_	accumulator.h	/^  const Fst<A>* fst_;                    \/\/ Input fst$/;"	m	class:fst::CacheLogAccumulator
fst_	add-on.h	/^  F fst_;$/;"	m	class:fst::AddOnImpl
fst_	arc-map.h	/^  MutableFst<ToArc> *fst_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
fst_	arc-map.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::ArcMapFstImpl
fst_	arcsort.h	/^  const Fst<Arc> &fst_;$/;"	m	class:fst::ArcSortMapper
fst_	cache.h	/^  const F &fst_;$/;"	m	class:fst::CacheStateIterator
fst_	complement.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::ComplementFstImpl
fst_	connect.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::SccVisitor
fst_	determinize.h	/^  const Fst<A> *fst_;            \/\/ Input Fst$/;"	m	class:fst::DeterminizeFstImplBase
fst_	factor-weight.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::FactorWeightFstImpl
fst_	label-reachable.h	/^  VectorFst<Arc> *fst_;$/;"	m	class:fst::LabelReachable
fst_	lookahead-filter.h	/^  const F1 *fst_;$/;"	m	class:fst::LookAheadSelector
fst_	lookahead-filter.h	/^  const F2 *fst_;$/;"	m	class:fst::LookAheadSelector
fst_	lookahead-matcher.h	/^  const FST &fst_;         \/\/ Matcher FST$/;"	m	class:fst::ArcLookAheadMatcher
fst_	matcher.h	/^  const F *fst_;$/;"	m	class:fst::SortedMatcher
fst_	minimize.h	/^  const Fst<A>& fst_;$/;"	m	class:fst::StateComparator
fst_	randgen.h	/^  Fst<A> *fst_;$/;"	m	class:fst::RandGenFstImpl
fst_	randgen.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::ArcSampler
fst_	relabel.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::RelabelFstImpl
fst_	replace.h	/^  const ReplaceFst<A, T> &fst_;           \/\/ Reference to the FST$/;"	m	class:fst::ArcIterator
fst_	replace.h	/^  const ReplaceFst<A, T>& fst_;$/;"	m	class:fst::ReplaceFstMatcher
fst_	rmepsilon.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::RmEpsilonFstImpl
fst_	rmepsilon.h	/^  const Fst<Arc> &fst_;$/;"	m	class:fst::RmEpsilonState
fst_	shortest-distance.h	/^  const Fst<Arc> &fst_;$/;"	m	class:fst::ShortestDistanceState
fst_	state-map.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::ArcSumMapper
fst_	state-map.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::ArcUniqueMapper
fst_	state-map.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::IdentityStateMapper
fst_	state-map.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::StateMapFstImpl
fst_	state-reachable.h	/^  const Fst<A> &fst_;$/;"	m	class:fst::IntervalReachVisitor
fst_	synchronize.h	/^  const Fst<A> *fst_;$/;"	m	class:fst::SynchronizeFstImpl
fst_align	fst.h	/^DECLARE_bool(fst_align);$/;"	v
fst_array_	accumulator.h	/^  vector<const Fst<Arc>*> fst_array_;$/;"	m	class:fst::ReplaceAccumulatorData
fst_array_	replace-util.h	/^  vector<const Fst<Arc> *> fst_array_;            \/\/ Fst per ID$/;"	m	class:fst::ReplaceUtil
fst_array_	replace.h	/^  vector<const Fst<A>*> fst_array_;$/;"	m	class:fst::ReplaceFstImpl
fst_default_cache_gc_limit	cache.h	/^DECLARE_int64(fst_default_cache_gc_limit);$/;"	v
fst_field_separator	string.h	/^DECLARE_string(fst_field_separator);$/;"	v
fst_id	replace.h	/^    Label   fst_id;$/;"	m	struct:fst::ReplaceFstImpl::PrefixTuple
fst_id	replace.h	/^  StateId fst_id;      \/\/ current fst being walked$/;"	m	struct:fst::ReplaceStateTuple
fst_id_	accumulator.h	/^  Label fst_id_;$/;"	m	class:fst::ReplaceAccumulator
fst_state	replace.h	/^  StateId fst_state;   \/\/ current state in fst being walked, not to be$/;"	m	struct:fst::ReplaceStateTuple
fst_tuples_	rational.h	/^  mutable vector<pair<Label, const Fst<A>*> > fst_tuples_;$/;"	m	class:fst::RationalFstImpl
fst_weight_parentheses	pair-weight.h	/^DECLARE_string(fst_weight_parentheses);$/;"	v
fst_weight_separator	pair-weight.h	/^DECLARE_string(fst_weight_separator);$/;"	v
fst_weight_separator	sparse-tuple-weight.h	/^DECLARE_string(fst_weight_separator);$/;"	v
fst_weight_separator	tuple-weight.h	/^DECLARE_string(fst_weight_separator);$/;"	v
fsttype_	fst.h	/^  string fsttype_;                   \/\/ E.g. "vector"$/;"	m	class:fst::FstHeader
gc	cache.h	/^  bool gc;          \/\/ enable GC$/;"	m	struct:fst::CacheOptions
gc_limit	cache.h	/^  size_t gc_limit;  \/\/ # of bytes allowed before GC$/;"	m	struct:fst::CacheOptions
generator1_	random-weight.h	/^  G1 generator1_;$/;"	m	class:fst::LexicographicWeightGenerator
generator1_	random-weight.h	/^  G1 generator1_;$/;"	m	class:fst::ProductWeightGenerator
generator2_	random-weight.h	/^  G2 generator2_;$/;"	m	class:fst::LexicographicWeightGenerator
generator2_	random-weight.h	/^  G2 generator2_;$/;"	m	class:fst::ProductWeightGenerator
generator_	random-weight.h	/^  G generator_;$/;"	m	class:fst::PowerWeightGenerator
generator_	random-weight.h	/^  G generator_;$/;"	m	class:fst::SparsePowerWeightGenerator
h_	bi-table.h	/^  H *h_;         \/\/ Hash function used when hashing entry into hash_set$/;"	m	class:fst::VectorHashBiTable
has_distance	shortest-path.h	/^  bool has_distance;  \/\/ distance vector already contains the$/;"	m	struct:fst::ShortestPathOptions
has_phi_	matcher.h	/^  bool has_phi_;          \/\/ Are there possibly phis at the current state?$/;"	m	class:fst::PhiMatcher
has_rho_	matcher.h	/^  bool has_rho_;          \/\/ Are there possibly rhos at the current state?$/;"	m	class:fst::RhoMatcher
has_sigma_	matcher.h	/^  bool has_sigma_;         \/\/ Are there sigmas at the current state?$/;"	m	class:fst::SigmaMatcher
hash	compat.h	/^template<> struct hash<uint64> {$/;"	s	namespace:std::tr1
hash_equal_	bi-table.h	/^  HashEqual hash_equal_;$/;"	m	class:fst::CompactHashBiTable
hash_equal_	bi-table.h	/^  HashEqual hash_equal_;$/;"	m	class:fst::VectorHashBiTable
hash_func_	bi-table.h	/^  HashFunc hash_func_;$/;"	m	class:fst::CompactHashBiTable
hash_func_	bi-table.h	/^  HashFunc hash_func_;$/;"	m	class:fst::VectorHashBiTable
have_relabel_data_	label-reachable.h	/^  bool have_relabel_data_;            \/\/ Using label2index_?$/;"	m	class:fst::LabelReachableData
have_stats_	replace-util.h	/^  mutable bool have_stats_;                       \/\/ have dependency statistics$/;"	m	class:fst::ReplaceUtil
header	fst.h	/^  const FstHeader *header;      \/\/ Pointer to Fst header. If non-zero, use$/;"	m	struct:fst::FstReadOptions
heap_	queue.h	/^  Heap<S, C, false> heap_;$/;"	m	class:fst::ShortestFirstQueue
height	minimize.h	/^    const vector<StateId>& height() const { return height_; }$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
height_	minimize.h	/^    vector<StateId> height_;$/;"	m	class:fst::AcyclicMinimizer::HeightVisitor
hf	bi-table.h	/^    H hf;$/;"	m	class:fst::CompactHashBiTable::HashFunc
ht_	bi-table.h	/^    const CompactHashBiTable *ht_;$/;"	m	class:fst::CompactHashBiTable::HashEqual
ht_	bi-table.h	/^    const CompactHashBiTable *ht_;$/;"	m	class:fst::CompactHashBiTable::HashFunc
ht_	bi-table.h	/^    const VectorHashBiTable *ht_;$/;"	m	class:fst::VectorHashBiTable::HashEqual
ht_	bi-table.h	/^    const VectorHashBiTable *ht_;$/;"	m	class:fst::VectorHashBiTable::HashFunc
i_	arcsort.h	/^  ssize_t i_;               \/\/ current arc position$/;"	m	class:fst::ArcSortMapper
i_	cache.h	/^  size_t i_;$/;"	m	class:fst::CacheArcIterator
i_	cache.h	/^  size_t i_;$/;"	m	class:fst::CacheMutableArcIterator
i_	const-fst.h	/^  size_t i_;$/;"	m	class:fst::ArcIterator
i_	fst.h	/^  size_t i_;$/;"	m	class:fst::ArcIterator
i_	state-map.h	/^  ssize_t i_;               \/\/ current arc position$/;"	m	class:fst::ArcSumMapper
i_	state-map.h	/^  ssize_t i_;               \/\/ current arc position$/;"	m	class:fst::ArcUniqueMapper
i_	vector-fst.h	/^  size_t i_;$/;"	m	class:fst::ArcIterator
i_	vector-fst.h	/^  size_t i_;$/;"	m	class:fst::MutableArcIterator
id2entry_	bi-table.h	/^  deque<T> id2entry_;$/;"	m	class:fst::ErasableBiTable
id2entry_	bi-table.h	/^  vector<T> id2entry_;  \/\/ Maps state IDs to entry$/;"	m	class:fst::VectorHashBiTable
id2entry_	bi-table.h	/^  vector<T> id2entry_;$/;"	m	class:fst::CompactHashBiTable
id2entry_	bi-table.h	/^  vector<T> id2entry_;$/;"	m	class:fst::HashBiTable
id2entry_	bi-table.h	/^  vector<T> id2entry_;$/;"	m	class:fst::VectorBiTable
idistance_	prune.h	/^  const vector<Weight> &idistance_;$/;"	m	class:fst::PruneCompare
ifst_	randgen.h	/^  const Fst<IArc> *ifst_;$/;"	m	class:fst::RandGenVisitor
ifst_	visit.h	/^  const Fst<Arc> *ifst_;$/;"	m	class:fst::CopyVisitor
ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	class:fst::StringArc
ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::ExpectationArc
ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::GallicArc
ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::LexicographicArc
ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::PowerArc
ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::ProductArc
ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::ReverseArc
ilabel	arc.h	/^  Label ilabel;       \/\/ Transition input label$/;"	m	struct:fst::SparsePowerArc
ilabel	arc.h	/^  Label ilabel;$/;"	m	class:fst::ArcTpl
ilabel	encode.h	/^    Label ilabel;$/;"	m	struct:fst::EncodeTable::Tuple
ilabel	rmepsilon.h	/^    Label ilabel;$/;"	m	struct:fst::RmEpsilonState::Element
ilabel_lookahead_flags	matcher-fst.h	/^static const uint32 ilabel_lookahead_flags = kInputLookAheadMatcher |$/;"	m	namespace:fst
impl_	arc-map.h	/^  const ArcMapFstImpl<A, B, C> *impl_;$/;"	m	class:fst::StateIterator
impl_	cache.h	/^  Impl *impl_;$/;"	m	class:fst::CacheMutableArcIterator
impl_	cache.h	/^  Impl *impl_;$/;"	m	class:fst::CacheStateIterator
impl_	fst.h	/^  I *impl_;$/;"	m	class:fst::ImplToFst
impl_	relabel.h	/^  const RelabelFstImpl<A> *impl_;$/;"	m	class:fst::StateIterator
impl_	replace.h	/^  ReplaceFstImpl<A, T> *impl_;$/;"	m	class:fst::ReplaceFstMatcher
impl_	symbol-table.h	/^  SymbolTableImpl* impl_;$/;"	m	class:fst::SymbolTable
in_dist_	determinize.h	/^  const vector<Weight> *in_dist_;  \/\/ Distance to final NFA states$/;"	m	class:fst::DeterminizeFsaImpl
index_	state-reachable.h	/^  I index_;$/;"	m	class:fst::IntervalReachVisitor
init_	accumulator.h	/^  bool init_;             \/\/ Cumulative weights initialized?$/;"	m	class:fst::FastLogAccumulator
init_	accumulator.h	/^  bool init_;$/;"	m	class:fst::ReplaceAccumulator
init_	sparse-tuple-weight.h	/^  bool init_;  \/\/ in the initialized state?$/;"	m	class:fst::SparseTupleWeightIterator
init_	string-weight.h	/^  bool init_;   \/\/ in the initialized state?$/;"	m	class:fst::StringWeightIterator
input_map_	relabel.h	/^  unordered_map<Label, Label> input_map_;$/;"	m	class:fst::RelabelFstImpl
inref	replace-util.h	/^    map<Label, size_t> inref;$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
int16	types.h	/^typedef int16_t int16;$/;"	t
int32	types.h	/^typedef int32_t int32;$/;"	t
int64	types.h	/^typedef int64_t int64;$/;"	t
int8	types.h	/^typedef int8_t int8;$/;"	t
internal	expanded-fst.h	/^namespace internal {$/;"	n	namespace:fst
internal	fst.h	/^namespace internal {$/;"	n	namespace:fst
internal	mutable-fst.h	/^namespace internal {$/;"	n	namespace:fst
internal	push.h	/^namespace internal {$/;"	n	namespace:fst
intervals_	interval-set.h	/^  vector<Interval> intervals_;$/;"	m	class:fst::IntervalSet
isets_	label-reachable.h	/^  vector<IntervalSet <L> > isets_;    \/\/ Interval sets per state.$/;"	m	class:fst::LabelReachableData
isets_	state-reachable.h	/^  vector< IntervalSet<I> > *isets_;$/;"	m	class:fst::IntervalReachVisitor
isets_	state-reachable.h	/^  vector< IntervalSet<I> > isets_;            \/\/ Interval sets per state$/;"	m	class:fst::StateReachable
istring	synchronize.h	/^    const String *istring;     \/\/ Residual input labels$/;"	m	struct:fst::SynchronizeFstImpl::Element
isymbols	fst.h	/^  const SymbolTable* isymbols;  \/\/ Pointer to input symbols. If non-zero, use$/;"	m	struct:fst::FstReadOptions
isymbols_	arc-map.h	/^  SymbolTable *isymbols_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
isymbols_	encode.h	/^  SymbolTable *isymbols_;       \/\/ Pre-encoded ilabel symbol table$/;"	m	class:fst::EncodeTable
isymbols_	fst.h	/^  SymbolTable *isymbols_;       \/\/ Ilabel symbol table$/;"	m	class:fst::FstImpl
iter_	sparse-tuple-weight.h	/^  typename list<Pair>::const_iterator iter_;$/;"	m	class:fst::SparseTupleWeightIterator
iter_	string-weight.h	/^  typename list<L>::const_iterator iter_;$/;"	m	class:fst::StringWeightIterator
iter_	string-weight.h	/^  typename list<L>::const_reverse_iterator iter_;$/;"	m	class:fst::StringWeightReverseIterator
iterator	sparse-tuple-weight.h	/^  typedef typename list<Pair>::iterator iterator;$/;"	t	class:fst::SparseTupleWeightIterator
kAcceptor	properties.h	/^const uint64 kAcceptor =          0x0000000000010000ULL;$/;"	m	namespace:fst
kAccessible	properties.h	/^const uint64 kAccessible =        0x0000010000000000ULL;$/;"	m	namespace:fst
kAcyclic	properties.h	/^const uint64 kAcyclic =           0x0000000800000000ULL;$/;"	m	namespace:fst
kAddArcProperties	properties.h	/^const uint64 kAddArcProperties = kExpanded | kMutable | kError | kNotAcceptor |$/;"	m	namespace:fst
kAddOnMagicNumber	add-on.h	/^static const int32 kAddOnMagicNumber = 446681434;$/;"	m	namespace:fst
kAddStateProperties	properties.h	/^const uint64 kAddStateProperties$/;"	m	namespace:fst
kAddSuperFinalProperties	properties.h	/^const uint64 kAddSuperFinalProperties  = kExpanded | kMutable | kError |$/;"	m	namespace:fst
kAlignedFileVersion	compact-fst.h	/^  static const int kAlignedFileVersion = 1;$/;"	m	class:fst::CompactFstImpl
kAlignedFileVersion	compact-fst.h	/^const int CompactFstImpl<A, C, U>::kAlignedFileVersion;$/;"	m	class:fst::CompactFstImpl
kAlignedFileVersion	const-fst.h	/^  static const int kAlignedFileVersion = 1;$/;"	m	class:fst::ConstFstImpl
kAlignedFileVersion	const-fst.h	/^const int ConstFstImpl<A, U>::kAlignedFileVersion;$/;"	m	class:fst::ConstFstImpl
kAlphabetSize	random-weight.h	/^  static const int kAlphabetSize = 5;$/;"	m	class:fst::StringWeightGenerator
kAlphabetSize	random-weight.h	/^const int StringWeightGenerator<L, S>::kAlphabetSize;$/;"	m	class:fst::StringWeightGenerator
kArcFlags	fst.h	/^static const uint32 kArcFlags = kArcValueFlags | kArcNoCache;$/;"	m	namespace:fst
kArcILabelValue	fst.h	/^static const uint32 kArcILabelValue    = 0x0001;  \/\/ Value() gives valid ilabel$/;"	m	namespace:fst
kArcNextStateValue	fst.h	/^static const uint32 kArcNextStateValue = 0x0008;  \/\/  "       "     " nextstate$/;"	m	namespace:fst
kArcNoCache	fst.h	/^static const uint32 kArcNoCache   = 0x0010;       \/\/ No need to cache arcs$/;"	m	namespace:fst
kArcOLabelValue	fst.h	/^static const uint32 kArcOLabelValue    = 0x0002;  \/\/  "       "     "    olabel$/;"	m	namespace:fst
kArcSortProperties	properties.h	/^const uint64 kArcSortProperties =$/;"	m	namespace:fst
kArcValueFlags	fst.h	/^static const uint32 kArcValueFlags =$/;"	m	namespace:fst
kArcWeightValue	fst.h	/^static const uint32 kArcWeightValue    = 0x0004;  \/\/  "       "     "    weight$/;"	m	namespace:fst
kBinaryProperties	properties.h	/^const uint64 kBinaryProperties =  0x0000000000000007ULL;$/;"	m	namespace:fst
kCacheArcs	cache.h	/^  static const uint32 kCacheArcs =   0x0002;  \/\/ Arcs have been cached$/;"	m	class:fst::CacheBaseImpl
kCacheArcs	cache.h	/^template <class S, class C> const uint32 CacheBaseImpl<S, C>::kCacheArcs;$/;"	m	class:fst::CacheBaseImpl
kCacheFinal	cache.h	/^  static const uint32 kCacheFinal =  0x0001;  \/\/ Final weight has been cached$/;"	m	class:fst::CacheBaseImpl
kCacheFinal	cache.h	/^template <class S, class C> const uint32 CacheBaseImpl<S, C>::kCacheFinal;$/;"	m	class:fst::CacheBaseImpl
kCacheFlags	cache.h	/^  static const uint32 kCacheFlags = kCacheFinal | kCacheArcs | kCacheRecent$/;"	m	class:fst::CacheBaseImpl
kCacheModified	cache.h	/^  static const uint32 kCacheModified = 0x0008;  \/\/ Mark state as modified$/;"	m	class:fst::CacheBaseImpl
kCacheModified	cache.h	/^template <class S, class C> const uint32 CacheBaseImpl<S, C>::kCacheModified;$/;"	m	class:fst::CacheBaseImpl
kCacheRecent	cache.h	/^  static const uint32 kCacheRecent = 0x0004;  \/\/ Mark as visited since GC$/;"	m	class:fst::CacheBaseImpl
kCacheRecent	cache.h	/^template <class S, class C> const uint32 CacheBaseImpl<S, C>::kCacheRecent;$/;"	m	class:fst::CacheBaseImpl
kCheckSumLength	compat.h	/^  static const int kCheckSumLength = 32;$/;"	m	class:fst::CheckSummer
kCoAccessible	properties.h	/^const uint64 kCoAccessible =      0x0000040000000000ULL;$/;"	m	namespace:fst
kCommutative	weight.h	/^const uint64 kCommutative =       0x0000000000000004ULL;$/;"	m	namespace:fst
kCompareAll	minimize.h	/^  static const uint32 kCompareAll       = 0x00000007;$/;"	m	class:fst::StateComparator
kCompareAll	minimize.h	/^template <class A> const uint32 StateComparator<A>::kCompareAll;$/;"	m	class:fst::StateComparator
kCompareArcs	minimize.h	/^  static const uint32 kCompareArcs      = 0x00000004;$/;"	m	class:fst::StateComparator
kCompareArcs	minimize.h	/^template <class A> const uint32 StateComparator<A>::kCompareArcs;$/;"	m	class:fst::StateComparator
kCompareFinal	minimize.h	/^  static const uint32 kCompareFinal     = 0x00000001;$/;"	m	class:fst::StateComparator
kCompareFinal	minimize.h	/^template <class A> const uint32 StateComparator<A>::kCompareFinal;$/;"	m	class:fst::StateComparator
kCompareOutDegree	minimize.h	/^  static const uint32 kCompareOutDegree = 0x00000002;$/;"	m	class:fst::StateComparator
kCompareOutDegree	minimize.h	/^template <class A> const uint32 StateComparator<A>::kCompareOutDegree;$/;"	m	class:fst::StateComparator
kCopyProperties	properties.h	/^const uint64 kCopyProperties$/;"	m	namespace:fst
kCurrentKey	bi-table.h	/^  static const I kCurrentKey;  \/\/ -2$/;"	m	class:fst::CompactHashBiTable
kCurrentKey	bi-table.h	/^  static const I kCurrentKey;$/;"	m	class:fst::VectorHashBiTable
kCurrentKey	bi-table.h	/^const I CompactHashBiTable<I, T, H>::kCurrentKey = -2;$/;"	m	class:fst::CompactHashBiTable
kCurrentKey	bi-table.h	/^const I VectorHashBiTable<I, T, S, FP, H>::kCurrentKey = -2;$/;"	m	class:fst::VectorHashBiTable
kCyclic	properties.h	/^const uint64 kCyclic =            0x0000000400000000ULL;$/;"	m	namespace:fst
kDeadState	equivalent.h	/^  static const MappedId kDeadState = 0;$/;"	m	struct:fst::EquivalenceUtil
kDeadState	equivalent.h	/^typename EquivalenceUtil<Arc>::MappedId EquivalenceUtil<Arc>::kDeadState;$/;"	m	class:fst::EquivalenceUtil
kDeleteArcsProperties	properties.h	/^const uint64 kDeleteArcsProperties$/;"	m	namespace:fst
kDeleteStatesProperties	properties.h	/^const uint64 kDeleteStatesProperties$/;"	m	namespace:fst
kDelta	weight.h	/^const float kDelta =                   1.0F\/1024.0F;$/;"	m	namespace:fst
kDfsBlack	dfs-visit.h	/^const int kDfsBlack = 2;   \/\/ Finished$/;"	m	namespace:fst
kDfsGrey	dfs-visit.h	/^const int kDfsGrey =  1;   \/\/ Discovered & unfinished$/;"	m	namespace:fst
kDfsWhite	dfs-visit.h	/^const int kDfsWhite = 0;   \/\/ Undiscovered$/;"	m	namespace:fst
kEmptyKey	bi-table.h	/^  static const I kEmptyKey;    \/\/ -1$/;"	m	class:fst::CompactHashBiTable
kEmptyKey	bi-table.h	/^  static const I kEmptyKey;$/;"	m	class:fst::VectorHashBiTable
kEmptyKey	bi-table.h	/^const I CompactHashBiTable<I, T, H>::kEmptyKey = -1;$/;"	m	class:fst::CompactHashBiTable
kEmptyKey	bi-table.h	/^const I VectorHashBiTable<I, T, S, FP, H>::kEmptyKey = -1;$/;"	m	class:fst::VectorHashBiTable
kEncodeFlags	encode.h	/^static const uint32 kEncodeFlags       = 0x0003;  \/\/ All non-internal flags$/;"	m	namespace:fst
kEncodeHasISymbols	encode.h	/^static const uint32 kEncodeHasISymbols = 0x0004;  \/\/ For internal use$/;"	m	namespace:fst
kEncodeHasOSymbols	encode.h	/^static const uint32 kEncodeHasOSymbols = 0x0008;  \/\/ For internal use$/;"	m	namespace:fst
kEncodeLabels	encode.h	/^static const uint32 kEncodeLabels      = 0x0001;$/;"	m	namespace:fst
kEncodeMagicNumber	encode.h	/^static const int32 kEncodeMagicNumber = 2129983209;$/;"	m	namespace:fst
kEncodeWeights	encode.h	/^static const uint32 kEncodeWeights     = 0x0002;$/;"	m	namespace:fst
kEpsilons	properties.h	/^const uint64 kEpsilons =          0x0000000000400000ULL;$/;"	m	namespace:fst
kError	properties.h	/^const uint64 kError =             0x0000000000000004ULL;$/;"	m	namespace:fst
kExpanded	properties.h	/^const uint64 kExpanded =          0x0000000000000001ULL;$/;"	m	namespace:fst
kExtrinsicProperties	properties.h	/^const uint64 kExtrinsicProperties = kError;$/;"	m	namespace:fst
kFactorArcWeights	factor-weight.h	/^const uint32 kFactorArcWeights   = 0x00000002;$/;"	m	namespace:fst
kFactorFinalWeights	factor-weight.h	/^const uint32 kFactorFinalWeights = 0x00000001;$/;"	m	namespace:fst
kFileAlign	compact-fst.h	/^  static const int kFileAlign = 16;$/;"	m	class:fst::CompactFstData
kFileAlign	compact-fst.h	/^const int CompactFstData<E, U>::kFileAlign;$/;"	m	class:fst::CompactFstData
kFileAlign	const-fst.h	/^  static const int kFileAlign = 16;$/;"	m	class:fst::ConstFstImpl
kFileAlign	const-fst.h	/^const int ConstFstImpl<A, U>::kFileAlign;$/;"	m	class:fst::ConstFstImpl
kFileVersion	add-on.h	/^  static const int kFileVersion = 1;$/;"	m	class:fst::AddOnImpl
kFileVersion	add-on.h	/^template <class F, class T> const int AddOnImpl<F, T>::kFileVersion;$/;"	m	class:fst::AddOnImpl
kFileVersion	compact-fst.h	/^  static const int kFileVersion = 2;$/;"	m	class:fst::CompactFstImpl
kFileVersion	compact-fst.h	/^const int CompactFstImpl<A, C, U>::kFileVersion;$/;"	m	class:fst::CompactFstImpl
kFileVersion	const-fst.h	/^  static const int kFileVersion = 2;$/;"	m	class:fst::ConstFstImpl
kFileVersion	const-fst.h	/^const int ConstFstImpl<A, U>::kFileVersion;$/;"	m	class:fst::ConstFstImpl
kFileVersion	edit-fst.h	/^  static const int kFileVersion = 2;$/;"	m	class:fst::EditFstImpl
kFileVersion	vector-fst.h	/^  static const int kFileVersion = 2;$/;"	m	class:fst::VectorFstImpl
kFileVersion	vector-fst.h	/^template <class A> const int VectorFstImpl<A>::kFileVersion;$/;"	m	class:fst::VectorFstImpl
kFstProperties	properties.h	/^const uint64 kFstProperties = kBinaryProperties | kTrinaryProperties;$/;"	m	namespace:fst
kIDeterministic	properties.h	/^const uint64 kIDeterministic =    0x0000000000040000ULL;$/;"	m	namespace:fst
kIEpsilons	properties.h	/^const uint64 kIEpsilons =         0x0000000001000000ULL;$/;"	m	namespace:fst
kILabelInvariantProperties	properties.h	/^const uint64 kILabelInvariantProperties =$/;"	m	namespace:fst
kILabelSorted	properties.h	/^const uint64 kILabelSorted =      0x0000000010000000ULL;$/;"	m	namespace:fst
kIdempotent	weight.h	/^const uint64 kIdempotent =             0x0000000000000008ULL;$/;"	m	namespace:fst
kInitialAcyclic	properties.h	/^const uint64 kInitialAcyclic =    0x0000002000000000ULL;$/;"	m	namespace:fst
kInitialCyclic	properties.h	/^const uint64 kInitialCyclic =     0x0000001000000000ULL;$/;"	m	namespace:fst
kInputLookAheadMatcher	lookahead-matcher.h	/^const uint32 kInputLookAheadMatcher =      0x00000001;$/;"	m	namespace:fst
kIntrinsicProperties	properties.h	/^const uint64 kIntrinsicProperties$/;"	m	namespace:fst
kInvalidId	equivalent.h	/^  static const MappedId kInvalidId = -1;$/;"	m	struct:fst::EquivalenceUtil
kInvalidId	equivalent.h	/^typename EquivalenceUtil<Arc>::MappedId EquivalenceUtil<Arc>::kInvalidId;$/;"	m	class:fst::EquivalenceUtil
kLeftSemiring	weight.h	/^const uint64 kLeftSemiring =           0x0000000000000001ULL;$/;"	m	namespace:fst
kLookAheadEpsilons	lookahead-matcher.h	/^const uint32 kLookAheadEpsilons =          0x00000020;$/;"	m	namespace:fst
kLookAheadFlags	lookahead-matcher.h	/^const uint32 kLookAheadFlags =            0x000000ff;$/;"	m	namespace:fst
kLookAheadKeepRelabelData	lookahead-matcher.h	/^const uint32 kLookAheadKeepRelabelData =  0x00000080;$/;"	m	namespace:fst
kLookAheadNonEpsilonPrefix	lookahead-matcher.h	/^const uint32 kLookAheadNonEpsilonPrefix =  0x00000040;$/;"	m	namespace:fst
kLookAheadNonEpsilons	lookahead-matcher.h	/^const uint32 kLookAheadNonEpsilons =       0x00000010;$/;"	m	namespace:fst
kLookAheadPrefix	lookahead-matcher.h	/^const uint32 kLookAheadPrefix =            0x00000008;$/;"	m	namespace:fst
kLookAheadWeight	lookahead-matcher.h	/^const uint32 kLookAheadWeight =            0x00000004;$/;"	m	namespace:fst
kMatcherFlags	matcher.h	/^const uint32 kMatcherFlags = 0x00000000;$/;"	m	namespace:fst
kMaxStringLength	random-weight.h	/^  static const int kMaxStringLength = 5;$/;"	m	class:fst::StringWeightGenerator
kMaxStringLength	random-weight.h	/^const int StringWeightGenerator<L, S>::kMaxStringLength;$/;"	m	class:fst::StringWeightGenerator
kMinCacheLimit	cache.h	/^  static const size_t kMinCacheLimit = 8096;  \/\/ Minimum (non-zero) cache limit$/;"	m	class:fst::CacheBaseImpl
kMinCacheLimit	cache.h	/^template <class S, class C> const size_t CacheBaseImpl<S, C>::kMinCacheLimit;$/;"	m	class:fst::CacheBaseImpl
kMinFileVersion	add-on.h	/^  static const int kMinFileVersion = 1;$/;"	m	class:fst::AddOnImpl
kMinFileVersion	add-on.h	/^template <class F, class T> const int AddOnImpl<F, T>::kMinFileVersion;$/;"	m	class:fst::AddOnImpl
kMinFileVersion	compact-fst.h	/^  static const int kMinFileVersion = 1;$/;"	m	class:fst::CompactFstImpl
kMinFileVersion	compact-fst.h	/^const int CompactFstImpl<A, C, U>::kMinFileVersion;$/;"	m	class:fst::CompactFstImpl
kMinFileVersion	const-fst.h	/^  static const int kMinFileVersion = 1;$/;"	m	class:fst::ConstFstImpl
kMinFileVersion	const-fst.h	/^const int ConstFstImpl<A, U>::kMinFileVersion;$/;"	m	class:fst::ConstFstImpl
kMinFileVersion	edit-fst.h	/^  static const int kMinFileVersion = 2;$/;"	m	class:fst::EditFstImpl
kMinFileVersion	vector-fst.h	/^  static const int kMinFileVersion = 1;$/;"	m	class:fst::VectorFstImpl
kMinFileVersion	vector-fst.h	/^template <class A> const int VectorFstImpl<A>::kMinFileVersion;$/;"	m	class:fst::VectorFstImpl
kMultiEpsList	matcher.h	/^const uint32 kMultiEpsList =  0x00000001;$/;"	m	namespace:fst
kMultiEpsLoop	matcher.h	/^const uint32 kMultiEpsLoop =  0x00000002;$/;"	m	namespace:fst
kMutable	properties.h	/^const uint64 kMutable =           0x0000000000000002ULL;$/;"	m	namespace:fst
kNegTrinaryProperties	properties.h	/^const uint64 kNegTrinaryProperties =$/;"	m	namespace:fst
kNoEpsilons	properties.h	/^const uint64 kNoEpsilons =        0x0000000000800000ULL;$/;"	m	namespace:fst
kNoIEpsilons	properties.h	/^const uint64 kNoIEpsilons =       0x0000000002000000ULL;$/;"	m	namespace:fst
kNoKey	heap.h	/^static const int kNoKey = -1;$/;"	m	namespace:fst
kNoKey	sparse-tuple-weight.h	/^  const static K kNoKey = -1;$/;"	m	class:fst::SparseTupleWeight
kNoLabel	fst.h	/^const int kNoLabel     =  -1;  \/\/ Not a valid label$/;"	m	namespace:fst
kNoOEpsilons	properties.h	/^const uint64 kNoOEpsilons =       0x0000000008000000ULL;$/;"	m	namespace:fst
kNoStateId	fst.h	/^const int kNoStateId   =  -1;  \/\/ Not a valid state ID$/;"	m	namespace:fst
kNoSymbol	symbol-table.h	/^  static const int64 kNoSymbol = -1;$/;"	m	class:fst::SymbolTable
kNonIDeterministic	properties.h	/^const uint64 kNonIDeterministic = 0x0000000000080000ULL;$/;"	m	namespace:fst
kNonODeterministic	properties.h	/^const uint64 kNonODeterministic = 0x0000000000200000ULL;$/;"	m	namespace:fst
kNotAcceptor	properties.h	/^const uint64 kNotAcceptor =       0x0000000000020000ULL;$/;"	m	namespace:fst
kNotAccessible	properties.h	/^const uint64 kNotAccessible =     0x0000020000000000ULL;$/;"	m	namespace:fst
kNotCoAccessible	properties.h	/^const uint64 kNotCoAccessible =   0x0000080000000000ULL;$/;"	m	namespace:fst
kNotILabelSorted	properties.h	/^const uint64 kNotILabelSorted =   0x0000000020000000ULL;$/;"	m	namespace:fst
kNotOLabelSorted	properties.h	/^const uint64 kNotOLabelSorted =   0x0000000080000000ULL;$/;"	m	namespace:fst
kNotString	properties.h	/^const uint64 kNotString =         0x0000200000000000ULL;$/;"	m	namespace:fst
kNotTopSorted	properties.h	/^const uint64 kNotTopSorted =      0x0000008000000000ULL;$/;"	m	namespace:fst
kNullProperties	properties.h	/^const uint64 kNullProperties$/;"	m	namespace:fst
kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::LexicographicWeightGenerator
kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::LogWeightGenerator_
kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::MinMaxWeightGenerator_
kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::SignedLogWeightGenerator_
kNumRandomWeights	random-weight.h	/^  static const int kNumRandomWeights = 5;$/;"	m	class:fst::TropicalWeightGenerator_
kNumRandomWeights	random-weight.h	/^const int LexicographicWeightGenerator<G1, G2>::kNumRandomWeights;$/;"	m	class:fst::LexicographicWeightGenerator
kNumRandomWeights	random-weight.h	/^template <class T> const int LogWeightGenerator_<T>::kNumRandomWeights;$/;"	m	class:fst::LogWeightGenerator_
kNumRandomWeights	random-weight.h	/^template <class T> const int MinMaxWeightGenerator_<T>::kNumRandomWeights;$/;"	m	class:fst::MinMaxWeightGenerator_
kNumRandomWeights	random-weight.h	/^template <class T> const int SignedLogWeightGenerator_<T>::kNumRandomWeights;$/;"	m	class:fst::SignedLogWeightGenerator_
kNumRandomWeights	random-weight.h	/^template <class T> const int TropicalWeightGenerator_<T>::kNumRandomWeights;$/;"	m	class:fst::TropicalWeightGenerator_
kODeterministic	properties.h	/^const uint64 kODeterministic =    0x0000000000100000ULL;$/;"	m	namespace:fst
kOEpsilons	properties.h	/^const uint64 kOEpsilons =         0x0000000004000000ULL;$/;"	m	namespace:fst
kOLabelInvariantProperties	properties.h	/^const uint64 kOLabelInvariantProperties =$/;"	m	namespace:fst
kOLabelSorted	properties.h	/^const uint64 kOLabelSorted =      0x0000000040000000ULL;$/;"	m	namespace:fst
kOutputLookAheadMatcher	lookahead-matcher.h	/^const uint32 kOutputLookAheadMatcher =     0x00000002;$/;"	m	namespace:fst
kPath	weight.h	/^const uint64 kPath =                   0x0000000000000010ULL;$/;"	m	namespace:fst
kPosTrinaryProperties	properties.h	/^const uint64 kPosTrinaryProperties =$/;"	m	namespace:fst
kPrime	factor-weight.h	/^  static const size_t kPrime = 7853;$/;"	m	class:fst::FactorWeightFstImpl
kPrime	factor-weight.h	/^template <class A, class F> const size_t FactorWeightFstImpl<A, F>::kPrime;$/;"	m	class:fst::FactorWeightFstImpl
kPrime0	replace.h	/^  static const size_t kPrime0;$/;"	m	class:fst::ReplaceFstImpl
kPrime0	replace.h	/^  static const size_t kPrime0;$/;"	m	class:fst::ReplaceHash
kPrime0	replace.h	/^const size_t ReplaceFstImpl<A, T>::kPrime0 = 7853;$/;"	m	class:fst::ReplaceFstImpl
kPrime0	replace.h	/^const size_t ReplaceHash<S, P>::kPrime0 = 7853;$/;"	m	class:fst::ReplaceHash
kPrime0	rmepsilon.h	/^  static const size_t kPrime0 = 7853;$/;"	m	class:fst::RmEpsilonState
kPrime0	rmepsilon.h	/^const size_t RmEpsilonState<Arc, Queue>::kPrime0;$/;"	m	class:fst::RmEpsilonState
kPrime0	state-table.h	/^  static const size_t kPrime0;$/;"	m	class:fst::ComposeHash
kPrime0	state-table.h	/^const size_t ComposeHash<S, F>::kPrime0 = 7853;$/;"	m	class:fst::ComposeHash
kPrime1	replace.h	/^  static const size_t kPrime1;$/;"	m	class:fst::ReplaceHash
kPrime1	replace.h	/^const size_t ReplaceHash<S, P>::kPrime1 = 7867;$/;"	m	class:fst::ReplaceHash
kPrime1	rmepsilon.h	/^  static const size_t kPrime1 = 7867;$/;"	m	class:fst::RmEpsilonState
kPrime1	rmepsilon.h	/^const size_t RmEpsilonState<Arc, Queue>::kPrime1;$/;"	m	class:fst::RmEpsilonState
kPrime1	state-table.h	/^  static const size_t kPrime1;$/;"	m	class:fst::ComposeHash
kPrime1	state-table.h	/^const size_t ComposeHash<S, F>::kPrime1 = 7867;$/;"	m	class:fst::ComposeHash
kPushLabels	push.h	/^const uint32 kPushLabels =  0x0002;$/;"	m	namespace:fst
kPushRemoveCommonAffix	push.h	/^const uint32 kPushRemoveCommonAffix = 0x0008;$/;"	m	namespace:fst
kPushRemoveTotalWeight	push.h	/^const uint32 kPushRemoveTotalWeight = 0x0004;$/;"	m	namespace:fst
kPushWeights	push.h	/^const uint32 kPushWeights = 0x0001;$/;"	m	namespace:fst
kRhoLabel	complement.h	/^  static const Label kRhoLabel = -2;$/;"	m	class:fst::ComplementFst
kRhoLabel	complement.h	/^template <class A> const typename A::Label ComplementFst<A>::kRhoLabel;$/;"	m	class:fst::ComplementFst
kRightSemiring	weight.h	/^const uint64 kRightSemiring =          0x0000000000000002ULL;$/;"	m	namespace:fst
kRmSuperFinalProperties	properties.h	/^const uint64 kRmSuperFinalProperties  = kExpanded | kMutable | kError |$/;"	m	namespace:fst
kSemiring	weight.h	/^const uint64 kSemiring = kLeftSemiring | kRightSemiring;$/;"	m	namespace:fst
kSetArcProperties	properties.h	/^const uint64 kSetArcProperties = kExpanded | kMutable | kError;$/;"	m	namespace:fst
kSetFinalProperties	properties.h	/^const uint64 kSetFinalProperties$/;"	m	namespace:fst
kSetStartProperties	properties.h	/^const uint64 kSetStartProperties$/;"	m	namespace:fst
kStateSortProperties	properties.h	/^const uint64 kStateSortProperties = kExpanded | kMutable | kError | kAcceptor |$/;"	m	namespace:fst
kStaticProperties	compact-fst.h	/^  static const uint64 kStaticProperties = kExpanded;$/;"	m	class:fst::CompactFstImpl
kStaticProperties	compact-fst.h	/^const uint64 CompactFstImpl<A, C, U>::kStaticProperties;$/;"	m	class:fst::CompactFstImpl
kStaticProperties	const-fst.h	/^  static const uint64 kStaticProperties = kExpanded;$/;"	m	class:fst::ConstFstImpl
kStaticProperties	const-fst.h	/^const uint64 ConstFstImpl<A, U>::kStaticProperties;$/;"	m	class:fst::ConstFstImpl
kStaticProperties	edit-fst.h	/^  static const uint64 kStaticProperties = kExpanded | kMutable;$/;"	m	class:fst::EditFstImpl
kStaticProperties	edit-fst.h	/^const uint64 EditFstImpl<A, WrappedFstT, MutableFstT>::kStaticProperties;$/;"	m	class:fst::EditFstImpl
kStaticProperties	vector-fst.h	/^  static const uint64 kStaticProperties = kExpanded | kMutable;$/;"	m	class:fst::VectorFstImpl
kStaticProperties	vector-fst.h	/^template <class A> const uint64 VectorFstImpl<A>::kStaticProperties;$/;"	m	class:fst::VectorFstImpl
kString	properties.h	/^const uint64 kString =            0x0000100000000000ULL;$/;"	m	namespace:fst
kStringBad	string-weight.h	/^const int kStringBad = -2;           \/\/ Label for a non-string$/;"	m	namespace:fst
kStringInfinity	string-weight.h	/^const int kStringInfinity = -1;      \/\/ Label for the infinite string$/;"	m	namespace:fst
kStringSeparator	string-weight.h	/^const char kStringSeparator = '_';   \/\/ Label separator in strings$/;"	m	namespace:fst
kTopSorted	properties.h	/^const uint64 kTopSorted =         0x0000004000000000ULL;$/;"	m	namespace:fst
kTrinaryProperties	properties.h	/^const uint64 kTrinaryProperties = 0x00003fffffff0000ULL;$/;"	m	namespace:fst
kUnweighted	properties.h	/^const uint64 kUnweighted =        0x0000000200000000ULL;$/;"	m	namespace:fst
kWeightInvariantProperties	properties.h	/^const uint64 kWeightInvariantProperties =$/;"	m	namespace:fst
kWeighted	properties.h	/^const uint64 kWeighted =          0x0000000100000000ULL;$/;"	m	namespace:fst
keep_match_	arcfilter.h	/^  bool keep_match_;$/;"	m	class:fst::MultiLabelArcFilter
keep_multi_eps_	compose-filter.h	/^  bool keep_multi_eps_;$/;"	m	class:fst::MultiEpsFilter
keep_relabel_data_	label-reachable.h	/^  bool keep_relabel_data_;            \/\/ Save label2index_ to file?$/;"	m	class:fst::LabelReachableData
key_	heap.h	/^  vector<int> key_;$/;"	m	class:fst::Heap
key_	queue.h	/^  vector<ssize_t> key_;$/;"	m	class:fst::ShortestFirstQueue
key_	symbol-table.h	/^  int64 key_;$/;"	m	class:fst::SymbolTableIterator
key_map_	symbol-table.h	/^  map<int64, const char*> key_map_;$/;"	m	class:fst::SymbolTableImpl
keys_	bi-table.h	/^  KeyHashSet keys_;$/;"	m	class:fst::CompactHashBiTable
keys_	bi-table.h	/^  KeyHashSet keys_;$/;"	m	class:fst::VectorHashBiTable
label2index_	label-reachable.h	/^  unordered_map<L, L> label2index_;        \/\/ Finds index for a label.$/;"	m	class:fst::LabelReachableData
label2state_	label-reachable.h	/^  unordered_map<Label, StateId> label2state_;  \/\/ Finds final state for a label$/;"	m	class:fst::LabelReachable
label_	replace.h	/^  Label label_;                      \/\/ Current label$/;"	m	class:fst::ReplaceFstMatcher
label_common_divisor_	determinize.h	/^  LabelCommonDivisor<L, S> label_common_divisor_;$/;"	m	class:fst::GallicCommonDivisor
label_reachable_	lookahead-matcher.h	/^  LabelReachable<Arc, S> *label_reachable_;  \/\/ Label reachability info$/;"	m	class:fst::LabelLookAheadMatcher
labeled_check_sum_string_	symbol-table.h	/^  mutable string labeled_check_sum_string_;$/;"	m	class:fst::SymbolTableImpl
labels_	arcfilter.h	/^  CompactSet<Label, kNoLabel> labels_;$/;"	m	class:fst::MultiLabelArcFilter
labels_	string.h	/^  vector<Label> labels_;     \/\/ Input FST labels.$/;"	m	class:fst::StringPrinter
length	randgen.h	/^  size_t length;                 \/\/ length of path to this random state$/;"	m	struct:fst::RandState
less_	prune.h	/^  NaturalLess<Weight> less_;$/;"	m	class:fst::PruneCompare
less_	queue.h	/^  L less_;$/;"	m	class:fst::AStarWeightCompare
less_	queue.h	/^  L less_;$/;"	m	class:fst::PruneQueue
less_	queue.h	/^  L less_;$/;"	m	class:fst::StateWeightCompare
less_	queue.h	/^  NaturalLess<W> less_;$/;"	m	class:fst::NaturalAStarQueue
less_	queue.h	/^  NaturalLess<W> less_;$/;"	m	class:fst::NaturalPruneQueue
less_	queue.h	/^  NaturalLess<W> less_;$/;"	m	class:fst::NaturalShortestFirstQueue
less_	shortest-path.h	/^  NaturalLess<Weight> less_;$/;"	m	class:fst::ShortestPathCompare
lfst_	lookahead-matcher.h	/^  const Fst<Arc> *lfst_;                     \/\/ Look-ahead FST$/;"	m	class:fst::LabelLookAheadMatcher
lfst_	lookahead-matcher.h	/^  const Fst<Arc> *lfst_;   \/\/ Look-ahead FST$/;"	m	class:fst::ArcLookAheadMatcher
lmatcher1_	lookahead-filter.h	/^  M *lmatcher1_;$/;"	m	class:fst::LookAheadSelector
lmatcher2_	lookahead-filter.h	/^  M *lmatcher2_;$/;"	m	class:fst::LookAheadSelector
lmatcher_	lookahead-filter.h	/^  M1 *lmatcher_;$/;"	m	class:fst::LookAheadSelector
lmatcher_	lookahead-filter.h	/^  M2 *lmatcher_;$/;"	m	class:fst::LookAheadSelector
lmax_	arc-map.h	/^  Label lmax_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
local_data_	replace.h	/^  mutable ArcIteratorData<Arc> local_data_;  \/\/ Arc iterator data in local fst$/;"	m	class:fst::ArcIterator
lookahead_	lookahead-matcher.h	/^  mutable bool lookahead_;$/;"	m	class:fst::LookAheadMatcher
lookahead_arc_	lookahead-filter.h	/^  mutable bool lookahead_arc_;  \/\/ Look-ahead performed at last FilterArc()?$/;"	m	class:fst::LookAheadComposeFilter
lookahead_type_	lookahead-filter.h	/^  MatchType lookahead_type_;    \/\/ Lookahead match type$/;"	m	class:fst::LookAheadComposeFilter
loop_	matcher.h	/^  Arc loop_;                      \/\/ For non-consuming symbols$/;"	m	class:fst::SortedMatcher
loop_	matcher.h	/^  mutable Arc loop_;             \/\/ For non-consuming symbols$/;"	m	class:fst::MultiEpsMatcher
loop_	replace.h	/^  Arc loop_;$/;"	m	class:fst::ReplaceFstMatcher
lowlink_	connect.h	/^  vector<StateId> *lowlink_;    \/\/ lowlink[s] == dfnumber[s] => SCC root$/;"	m	class:fst::SccVisitor
map_	arc-map.h	/^  Map map_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
mapper_	arc-map.h	/^  C*   mapper_;$/;"	m	class:fst::ArcMapFstImpl
mapper_	state-map.h	/^  C*  mapper_;$/;"	m	class:fst::StateMapFstImpl
match_input_	arcfilter.h	/^  bool match_input_;$/;"	m	class:fst::MultiLabelArcFilter
match_label_	matcher.h	/^  Label match_label_;             \/\/ Current label to be matched$/;"	m	class:fst::SortedMatcher
match_label_	matcher.h	/^  Label match_label_;      \/\/ Label being matched$/;"	m	class:fst::SigmaMatcher
match_set_state_	lookahead-matcher.h	/^  bool match_set_state_;                     \/\/ matcher_.SetState called?$/;"	m	class:fst::LabelLookAheadMatcher
match_type_	compose.h	/^  MatchType match_type_;$/;"	m	class:fst::ComposeFstImpl
match_type_	matcher.h	/^  MatchType match_type_;          \/\/ Type of match to perform$/;"	m	class:fst::SortedMatcher
match_type_	matcher.h	/^  MatchType match_type_;   \/\/ Type of match requested$/;"	m	class:fst::SigmaMatcher
match_type_	matcher.h	/^  MatchType match_type_;  \/\/ Type of match requested$/;"	m	class:fst::PhiMatcher
match_type_	matcher.h	/^  MatchType match_type_;  \/\/ Type of match requested$/;"	m	class:fst::RhoMatcher
match_type_	replace.h	/^  MatchType match_type_;             \/\/ Supplied by caller$/;"	m	class:fst::ReplaceFstMatcher
matcher1	compose.h	/^  M *matcher1;      \/\/ FST1 matcher (see matcher.h)$/;"	m	struct:fst::ComposeFstOptions
matcher1	compose.h	/^  M1 *matcher1;     \/\/ FST1 matcher (see matcher.h)$/;"	m	struct:fst::ComposeFstImplOptions
matcher1_	compose-filter.h	/^  Matcher1 *matcher1_;$/;"	m	class:fst::AltSequenceComposeFilter
matcher1_	compose-filter.h	/^  Matcher1 *matcher1_;$/;"	m	class:fst::MatchComposeFilter
matcher1_	compose-filter.h	/^  Matcher1 *matcher1_;$/;"	m	class:fst::SequenceComposeFilter
matcher1_	compose.h	/^  Matcher1 *matcher1_;$/;"	m	class:fst::ComposeFstImpl
matcher1_	lookahead-filter.h	/^  Matcher1 matcher1_;         \/\/ Multi-epsilon matcher for fst1$/;"	m	class:fst::PushLabelsComposeFilter
matcher2	compose.h	/^  M *matcher2;      \/\/ FST2 matcher$/;"	m	struct:fst::ComposeFstOptions
matcher2	compose.h	/^  M2 *matcher2;     \/\/ FST2 matcher$/;"	m	struct:fst::ComposeFstImplOptions
matcher2_	compose-filter.h	/^  Matcher2 *matcher2_;$/;"	m	class:fst::AltSequenceComposeFilter
matcher2_	compose-filter.h	/^  Matcher2 *matcher2_;$/;"	m	class:fst::MatchComposeFilter
matcher2_	compose-filter.h	/^  Matcher2 *matcher2_;$/;"	m	class:fst::SequenceComposeFilter
matcher2_	compose.h	/^  Matcher2 *matcher2_;$/;"	m	class:fst::ComposeFstImpl
matcher2_	lookahead-filter.h	/^  Matcher2 matcher2_;         \/\/ Multi-epsilon matcher for fst2$/;"	m	class:fst::PushLabelsComposeFilter
matcher_	lookahead-matcher.h	/^  M matcher_;$/;"	m	class:fst::TrivialLookAheadMatcher
matcher_	lookahead-matcher.h	/^  mutable M matcher_;$/;"	m	class:fst::ArcLookAheadMatcher
matcher_	lookahead-matcher.h	/^  mutable M matcher_;$/;"	m	class:fst::LabelLookAheadMatcher
matcher_	matcher-fst.h	/^  M *matcher_;$/;"	m	class:fst::LookAheadMatcher
matcher_	matcher-fst.h	/^  M *matcher_;$/;"	m	class:fst::Matcher
matcher_	matcher.h	/^  M *matcher_;$/;"	m	class:fst::MultiEpsMatcher
matcher_	matcher.h	/^  M *matcher_;$/;"	m	class:fst::PhiMatcher
matcher_	matcher.h	/^  M *matcher_;$/;"	m	class:fst::RhoMatcher
matcher_	matcher.h	/^  M *matcher_;$/;"	m	class:fst::SigmaMatcher
matcher_	replace.h	/^  vector<LocalMatcher*> matcher_;$/;"	m	class:fst::ReplaceFstMatcher
max_height	minimize.h	/^    size_t max_height() const { return max_height_; }$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
max_height_	minimize.h	/^    size_t max_height_;$/;"	m	class:fst::AcyclicMinimizer::HeightVisitor
max_key_	util.h	/^  Key max_key_;$/;"	m	class:fst::CompactSet
max_length	randgen.h	/^  int max_length;            \/\/ Maximum path length$/;"	m	struct:fst::RandGenOptions
max_length_	randgen.h	/^  int max_length_;$/;"	m	class:fst::ArcSampler
maxvisit_	visit.h	/^  StateId maxvisit_;$/;"	m	class:fst::PartialVisitor
min_key_	util.h	/^  Key min_key_;$/;"	m	class:fst::CompactSet
min_unexpanded_state_id_	cache.h	/^  mutable StateId min_unexpanded_state_id_;  \/\/ minimum never-expanded state Id$/;"	m	class:fst::CacheBaseImpl
mode	factor-weight.h	/^  uint32 mode;         \/\/ factor arc weights and\/or final weights$/;"	m	struct:fst::FactorWeightOptions
mode_	factor-weight.h	/^  uint32 mode_;               \/\/ factoring arc and\/or final weights$/;"	m	class:fst::FactorWeightFstImpl
mru_	cache.h	/^  S *mru_;$/;"	m	struct:fst::DefaultCacheStateAllocator
mult1_	state-table.h	/^  ssize_t mult1_;$/;"	m	class:fst::ComposeFingerprint
mult2_	state-table.h	/^  ssize_t mult2_;$/;"	m	class:fst::ComposeFingerprint
multi_eps_iter_	matcher.h	/^  typename CompactSet<Label, kNoLabel>::const_iterator multi_eps_iter_;$/;"	m	class:fst::MultiEpsMatcher
multi_eps_labels_	matcher.h	/^  CompactSet<Label, kNoLabel> multi_eps_labels_;$/;"	m	class:fst::MultiEpsMatcher
mutable_fst_array_	replace-util.h	/^  vector<MutableFst<Arc> *> mutable_fst_array_;   \/\/ MutableFst per ID$/;"	m	class:fst::ReplaceUtil
name_	symbol-table.h	/^  string name_;$/;"	m	class:fst::SymbolTableImpl
narcs	const-fst.h	/^    Unsigned narcs;              \/\/ Number of arcs (per state)$/;"	m	struct:fst::ConstFstImpl::State
narcs	fst.h	/^  size_t narcs;              \/\/ ... and arc count$/;"	m	struct:fst::ArcIteratorData
narcs	replace-util.h	/^    size_t narcs;       \/\/ # of arcs$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
narcs_	compact-fst.h	/^  size_t narcs_;$/;"	m	class:fst::CompactFstData
narcs_	const-fst.h	/^  size_t narcs_;                 \/\/ Number of arcs (per FST)$/;"	m	class:fst::ConstFstImpl
narcs_	const-fst.h	/^  size_t narcs_;$/;"	m	class:fst::ArcIterator
narcs_	matcher.h	/^  size_t narcs_;                  \/\/ Current state arc count$/;"	m	class:fst::SortedMatcher
narcsa_	lookahead-filter.h	/^  ssize_t narcsa_;            \/\/ Number of arcs leaving look-ahead match FST$/;"	m	class:fst::PushLabelsComposeFilter
ncalls_	label-reachable.h	/^  double ncalls_;$/;"	m	class:fst::LabelReachable
ncompacts_	compact-fst.h	/^  size_t ncompacts_;$/;"	m	class:fst::CompactFstData
next	partition.h	/^   Element* next;$/;"	m	struct:fst::Partition::Element
nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	class:fst::StringArc
nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::ExpectationArc
nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::GallicArc
nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::LexicographicArc
nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::PowerArc
nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::ProductArc
nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::ReverseArc
nextstate	arc.h	/^  StateId nextstate;  \/\/ Transition destination state$/;"	m	struct:fst::SparsePowerArc
nextstate	arc.h	/^  StateId nextstate;$/;"	m	class:fst::ArcTpl
nextstate	replace.h	/^    StateId nextstate;$/;"	m	struct:fst::ReplaceFstImpl::PrefixTuple
nextstate	rmepsilon.h	/^    StateId nextstate;$/;"	m	struct:fst::RmEpsilonState::Element
nfinal	replace-util.h	/^    StateId nfinal;     \/\/ # of final states$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
niepsilons	cache.h	/^  size_t niepsilons;         \/\/ # of input epsilons$/;"	m	struct:fst::CacheState
niepsilons	const-fst.h	/^    Unsigned niepsilons;         \/\/ # of input epsilons$/;"	m	struct:fst::ConstFstImpl::State
niepsilons	vector-fst.h	/^  size_t niepsilons;         \/\/ # of input epsilons$/;"	m	struct:fst::VectorState
nintervals_	label-reachable.h	/^  double nintervals_;$/;"	m	class:fst::LabelReachable
nknown_states_	cache.h	/^  StateId nknown_states_;                    \/\/ # of known states$/;"	m	class:fst::CacheBaseImpl
nnonterms	replace-util.h	/^    Label nnonterms;    \/\/ # of non-terminals in Fst$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
noeps1_	compose-filter.h	/^  bool noeps1_, noeps2_;    \/\/ No epsilons leaving s1, s2?$/;"	m	class:fst::MatchComposeFilter
noeps1_	compose-filter.h	/^  bool noeps1_;    \/\/ No epsilons leaving s1_?$/;"	m	class:fst::SequenceComposeFilter
noeps2_	compose-filter.h	/^  bool noeps1_, noeps2_;    \/\/ No epsilons leaving s1, s2?$/;"	m	class:fst::MatchComposeFilter
noeps2_	compose-filter.h	/^  bool noeps2_;    \/\/ No epsilons leaving s2_?$/;"	m	class:fst::AltSequenceComposeFilter
noepsilons	cache.h	/^  size_t noepsilons;         \/\/ # of output epsilons$/;"	m	struct:fst::CacheState
noepsilons	const-fst.h	/^    Unsigned noepsilons;         \/\/ # of output epsilons$/;"	m	struct:fst::ConstFstImpl::State
noepsilons	vector-fst.h	/^  size_t noepsilons;         \/\/ # of output epsilons$/;"	m	struct:fst::VectorState
nonterminal_array_	replace-util.h	/^  vector<Label> nonterminal_array_;               \/\/ Fst ID to non-terminal$/;"	m	class:fst::ReplaceUtil
nonterminal_hash_	replace-util.h	/^  NonTerminalHash nonterminal_hash_;              \/\/ non-terminal to Fst ID$/;"	m	class:fst::ReplaceUtil
nonterminal_hash_	replace.h	/^  NonTerminalHash nonterminal_hash_;$/;"	m	class:fst::ReplaceFstImpl
nonterminal_set_	replace.h	/^  set<Label> nonterminal_set_;$/;"	m	class:fst::ReplaceFstImpl
nonterminals_	rational.h	/^  Label nonterminals_;  \/\/ # of nonterminals used$/;"	m	class:fst::RationalFstImpl
npath	randgen.h	/^  size_t npath;              \/\/ # of paths to generate$/;"	m	struct:fst::RandGenFstOptions
npath	randgen.h	/^  size_t npath;              \/\/ # of paths to generate$/;"	m	struct:fst::RandGenOptions
npath_	randgen.h	/^  size_t npath_;$/;"	m	class:fst::RandGenFstImpl
nref	replace-util.h	/^    size_t nref;        \/\/ # of non-terminal instances referring to this Fst$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
nsamples	randgen.h	/^  size_t nsamples;               \/\/ # of samples to be sampled at this state$/;"	m	struct:fst::RandState
nscc_	connect.h	/^  StateId nscc_;                \/\/ SCC count$/;"	m	class:fst::SccVisitor
nshortest	shortest-path.h	/^  size_t nshortest;   \/\/ return n-shortest paths$/;"	m	struct:fst::ShortestPathOptions
nstates	fst.h	/^  typename A::StateId nstates;  \/\/ O.w. total # of states$/;"	m	struct:fst::StateIteratorData
nstates	replace-util.h	/^    StateId nstates;    \/\/ # of states$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
nstates_	arc-map.h	/^  StateId nstates_;$/;"	m	class:fst::ArcMapFstImpl
nstates_	compact-fst.h	/^  StateId nstates_;$/;"	m	class:fst::StateIterator
nstates_	compact-fst.h	/^  size_t nstates_;$/;"	m	class:fst::CompactFstData
nstates_	connect.h	/^  StateId nstates_;             \/\/ State count$/;"	m	class:fst::CcVisitor
nstates_	connect.h	/^  StateId nstates_;             \/\/ State count$/;"	m	class:fst::SccVisitor
nstates_	const-fst.h	/^  StateId nstates_;              \/\/ Number of states$/;"	m	class:fst::ConstFstImpl
nstates_	const-fst.h	/^  StateId nstates_;$/;"	m	class:fst::StateIterator
nstates_	vector-fst.h	/^  StateId nstates_;$/;"	m	class:fst::StateIterator
nsymbols_	symbol-table.h	/^  size_t nsymbols_;$/;"	m	class:fst::SymbolTableIterator
num_arcs_	compact-fst.h	/^  size_t num_arcs_;$/;"	m	class:fst::ArcIterator
num_arcs_	replace.h	/^  ssize_t num_arcs_;        \/\/ Number of arcs at state_$/;"	m	class:fst::ArcIterator
num_classes	partition.h	/^  const T num_classes() const {$/;"	f	class:fst::Partition
num_new_states_	edit-fst.h	/^  StateId num_new_states_;$/;"	m	class:fst::EditFstData
num_states	minimize.h	/^    const size_t num_states() const { return num_states_; }$/;"	f	class:fst::AcyclicMinimizer::HeightVisitor
num_states_	minimize.h	/^    size_t num_states_;$/;"	m	class:fst::AcyclicMinimizer::HeightVisitor
num_states_	partition.h	/^  int num_states_;$/;"	m	class:fst::Partition
numarcs_	fst.h	/^  int64 numarcs_;                    \/\/ # of arcs$/;"	m	class:fst::FstHeader
numstates_	fst.h	/^  int64 numstates_;                  \/\/ # of states$/;"	m	class:fst::FstHeader
nvisit_	visit.h	/^  StateId nvisit_;$/;"	m	class:fst::PartialVisitor
offset_	accumulator.h	/^  size_t offset_;$/;"	m	class:fst::ReplaceAccumulator
offset_	replace.h	/^  mutable ssize_t offset_;  \/\/ Offset between position in iterator and in arcs_$/;"	m	class:fst::ArcIterator
offset_weight_	accumulator.h	/^  Weight offset_weight_;$/;"	m	class:fst::ReplaceAccumulator
ofst_	randgen.h	/^  MutableFst<OArc> *ofst_;$/;"	m	class:fst::RandGenVisitor
ofst_	visit.h	/^  MutableFst<Arc> *ofst_;$/;"	m	class:fst::CopyVisitor
olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	class:fst::StringArc
olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::ExpectationArc
olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::GallicArc
olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::LexicographicArc
olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::PowerArc
olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::ProductArc
olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::ReverseArc
olabel	arc.h	/^  Label olabel;       \/\/ Transition output label$/;"	m	struct:fst::SparsePowerArc
olabel	arc.h	/^  Label olabel;$/;"	m	class:fst::ArcTpl
olabel	encode.h	/^    Label olabel;$/;"	m	struct:fst::EncodeTable::Tuple
olabel	rmepsilon.h	/^    Label olabel;$/;"	m	struct:fst::RmEpsilonState::Element
olabel_lookahead_flags	matcher-fst.h	/^static const uint32 olabel_lookahead_flags = kOutputLookAheadMatcher |$/;"	m	namespace:fst
onstack_	connect.h	/^  vector<bool> *onstack_;       \/\/ is a state on the SCC stack$/;"	m	class:fst::SccVisitor
operator !=	compose-filter.h	/^  bool operator!=(const IntegerFilterState &f) const {$/;"	f	class:fst::IntegerFilterState
operator !=	compose-filter.h	/^  bool operator!=(const PairFilterState &f) const {$/;"	f	class:fst::PairFilterState
operator !=	compose-filter.h	/^  bool operator!=(const WeightFilterState &f) const {$/;"	f	class:fst::WeightFilterState
operator !=	float-weight.h	/^inline bool operator!=(const FloatWeightTpl<T> &w1,$/;"	f	namespace:fst
operator !=	float-weight.h	/^inline bool operator!=(const FloatWeightTpl<double> &w1,$/;"	f	namespace:fst
operator !=	float-weight.h	/^inline bool operator!=(const FloatWeightTpl<float> &w1,$/;"	f	namespace:fst
operator !=	interval-set.h	/^    bool operator!=(const Interval &i) const {$/;"	f	struct:fst::IntervalSet::Interval
operator !=	interval-set.h	/^  bool operator!=(const IntervalSet<T>& iset) const {$/;"	f	class:fst::IntervalSet
operator !=	pair-weight.h	/^inline bool operator!=(const PairWeight<W1, W2> &w1,$/;"	f	namespace:fst
operator !=	sparse-tuple-weight.h	/^inline bool operator!=(const SparseTupleWeight<W, K> &w1,$/;"	f	namespace:fst
operator !=	string-weight.h	/^inline bool operator!=(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
operator !=	tuple-weight.h	/^inline bool operator!=(const TupleWeight<W, n> &w1,$/;"	f	namespace:fst
operator ()	arc-map.h	/^    size_t operator()(const SW &x) const {$/;"	f	class:fst::GallicToNewSymbolsMapper::StringKey
operator ()	arc-map.h	/^  A operator()(const A &arc) const { return arc; }$/;"	f	struct:fst::IdentityArcMapper
operator ()	arc-map.h	/^  A operator()(const A &arc) const { return arc; }$/;"	f	struct:fst::SuperFinalMapper
operator ()	arc-map.h	/^  A operator()(const A &arc) const {$/;"	f	struct:fst::InvertWeightMapper
operator ()	arc-map.h	/^  A operator()(const A &arc) const {$/;"	f	struct:fst::PlusMapper
operator ()	arc-map.h	/^  A operator()(const A &arc) const {$/;"	f	struct:fst::TimesMapper
operator ()	arc-map.h	/^  A operator()(const FromArc &arc) const {$/;"	f	struct:fst::FromGallicMapper
operator ()	arc-map.h	/^  A operator()(const FromArc &arc) {$/;"	f	struct:fst::GallicToNewSymbolsMapper
operator ()	arc-map.h	/^  B operator()(const A &arc) const {$/;"	f	struct:fst::QuantizeMapper
operator ()	arc-map.h	/^  B operator()(const A &arc) const {$/;"	f	struct:fst::ReverseWeightMapper
operator ()	arc-map.h	/^  B operator()(const A &arc) const {$/;"	f	struct:fst::RmWeightMapper
operator ()	arc-map.h	/^  ToArc operator()(const A &arc) const {$/;"	f	struct:fst::ToGallicMapper
operator ()	arc-map.h	/^  ToArc operator()(const FromArc &arc) const {$/;"	f	class:fst::WeightConvertMapper
operator ()	arcfilter.h	/^  bool operator()(const A &arc) const { return true; }$/;"	f	class:fst::AnyArcFilter
operator ()	arcfilter.h	/^  bool operator()(const A &arc) const {$/;"	f	class:fst::EpsilonArcFilter
operator ()	arcfilter.h	/^  bool operator()(const A &arc) const {$/;"	f	class:fst::InputEpsilonArcFilter
operator ()	arcfilter.h	/^  bool operator()(const A &arc) const {$/;"	f	class:fst::MultiLabelArcFilter
operator ()	arcfilter.h	/^  bool operator()(const A &arc) const {$/;"	f	class:fst::OutputEpsilonArcFilter
operator ()	arcsort.h	/^  bool operator() (A arc1, A arc2) const {$/;"	f	class:fst::ILabelCompare
operator ()	arcsort.h	/^  bool operator() (const A &arc1, const A &arc2) const {$/;"	f	class:fst::OLabelCompare
operator ()	bi-table.h	/^    bool operator()(I k1, I k2) const {$/;"	f	class:fst::CompactHashBiTable::HashEqual
operator ()	bi-table.h	/^    bool operator()(I k1, I k2) const {$/;"	f	class:fst::VectorHashBiTable::HashEqual
operator ()	bi-table.h	/^    size_t operator()(I k) const { return (*(ht_->h_))(ht_->Key2Entry(k)); }$/;"	f	class:fst::VectorHashBiTable::HashFunc
operator ()	bi-table.h	/^    size_t operator()(I k) const { return hf(ht_->Key2T(k)); }$/;"	f	class:fst::CompactHashBiTable::HashFunc
operator ()	compat.h	/^  size_t operator()(uint64 x) const { return x; }$/;"	f	struct:std::tr1::hash
operator ()	determinize.h	/^    bool operator()(Subset* subset1, Subset* subset2) const {$/;"	f	class:fst::DeterminizeFsaImpl::SubsetEqual
operator ()	determinize.h	/^    size_t operator()(const Subset* subset) const {$/;"	f	class:fst::DeterminizeFsaImpl::SubsetKey
operator ()	determinize.h	/^  W operator()(const W &w1, const W &w2) const { return Plus(w1, w2); }$/;"	f	class:fst::DefaultCommonDivisor
operator ()	determinize.h	/^  Weight operator()(const Weight &w1, const Weight &w2) const {$/;"	f	class:fst::GallicCommonDivisor
operator ()	determinize.h	/^  Weight operator()(const Weight &w1, const Weight &w2) const {$/;"	f	class:fst::LabelCommonDivisor
operator ()	encode.h	/^    bool operator()(const Tuple* x, const Tuple* y) const {$/;"	f	class:fst::EncodeTable::TupleEqual
operator ()	encode.h	/^    size_t operator()(const Tuple* x) const {$/;"	f	class:fst::EncodeTable::TupleKey
operator ()	encode.h	/^A EncodeMapper<A>::operator()(const A &arc) {$/;"	f	class:fst::EncodeMapper
operator ()	factor-weight.h	/^    bool operator()(const Element &x, const Element &y) const {$/;"	f	class:fst::FactorWeightFstImpl::ElementEqual
operator ()	factor-weight.h	/^    size_t operator()(const Element &x) const {$/;"	f	class:fst::FactorWeightFstImpl::ElementKey
operator ()	float-weight.h	/^  Log64Weight operator()(LogWeight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
operator ()	float-weight.h	/^  Log64Weight operator()(TropicalWeight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
operator ()	float-weight.h	/^  LogWeight operator()(Log64Weight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
operator ()	float-weight.h	/^  LogWeight operator()(TropicalWeight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
operator ()	float-weight.h	/^  TropicalWeight operator()(Log64Weight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
operator ()	float-weight.h	/^  TropicalWeight operator()(LogWeight w) const { return w.Value(); }$/;"	f	struct:fst::WeightConvert
operator ()	invert.h	/^  A operator()(const A &arc) {$/;"	f	struct:fst::InvertMapper
operator ()	map.h	/^  A operator()(const A &arc) const { return arc; }$/;"	f	struct:fst::IdentityMapper
operator ()	minimize.h	/^    bool operator()(const ArcIter* x, const ArcIter* y) const {$/;"	f	class:fst::CyclicMinimizer::ArcIterCompare
operator ()	minimize.h	/^  bool operator()(const StateId x, const StateId y) const {$/;"	f	class:fst::StateComparator
operator ()	project.h	/^  A operator()(const A &arc) {$/;"	f	class:fst::ProjectMapper
operator ()	prune.h	/^  bool operator()(const StateId x, const StateId y) const {$/;"	f	class:fst::PruneCompare
operator ()	queue.h	/^  S operator()(S s) const { return s; }$/;"	f	struct:fst::TrivialStateEquivClass
operator ()	queue.h	/^  W operator()(S s) const { return W::One(); }$/;"	f	struct:fst::TrivialAStarEstimate
operator ()	queue.h	/^  bool operator()(const S x, const S y) const {$/;"	f	class:fst::AStarWeightCompare
operator ()	queue.h	/^  bool operator()(const S x, const S y) const {$/;"	f	class:fst::StateWeightCompare
operator ()	randgen.h	/^  size_t operator()(const Fst<A> &fst, StateId s) const {$/;"	f	class:fst::LogProbArcSelector
operator ()	randgen.h	/^  size_t operator()(const Fst<A> &fst, StateId s) const {$/;"	f	struct:fst::UniformArcSelector
operator ()	randgen.h	/^  size_t operator()(const Fst<A> &fst, StateId s,$/;"	f	class:fst::FastLogProbArcSelector
operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::LexicographicWeightGenerator
operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::LogWeightGenerator_
operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::MinMaxWeightGenerator_
operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::ProductWeightGenerator
operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::SignedLogWeightGenerator_
operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::StringWeightGenerator
operator ()	random-weight.h	/^  Weight operator() () const {$/;"	f	class:fst::TropicalWeightGenerator_
operator ()	random-weight.h	/^  Weight operator()() const {$/;"	f	class:fst::PowerWeightGenerator
operator ()	random-weight.h	/^  Weight operator()() const {$/;"	f	class:fst::SparsePowerWeightGenerator
operator ()	replace.h	/^    bool operator()(const StackPrefix& x, const StackPrefix& y) const {$/;"	f	class:fst::ReplaceFstImpl::StackPrefixEqual
operator ()	replace.h	/^    size_t operator()(const StackPrefix& x) const {$/;"	f	class:fst::ReplaceFstImpl::StackPrefixKey
operator ()	replace.h	/^  bool operator()(const ReplaceStateTuple<S, P> &tuple) const {$/;"	f	class:fst::ReplaceRootSelector
operator ()	replace.h	/^  size_t operator()(const ReplaceStateTuple<S, P>& t) const {$/;"	f	class:fst::ReplaceHash
operator ()	replace.h	/^  uint64 operator()(const ReplaceStateTuple<S, P> &tuple) const {$/;"	f	class:fst::ReplaceFingerprint
operator ()	replace.h	/^  uint64 operator()(const ReplaceStateTuple<S, P>& tuple) const {$/;"	f	class:fst::ReplaceFstStateFingerprint
operator ()	rmepsilon.h	/^    bool operator()(const Element &e1, const Element &e2) const {$/;"	f	class:fst::RmEpsilonState::ElementEqual
operator ()	rmepsilon.h	/^    size_t operator()(const Element& e) const {$/;"	f	class:fst::RmEpsilonState::ElementKey
operator ()	shortest-path.h	/^  bool operator()(const StateId x, const StateId y) const {$/;"	f	class:fst::ShortestPathCompare
operator ()	signed-log-weight.h	/^  Log64Weight operator()(SignedLog64Weight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  Log64Weight operator()(SignedLogWeight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  LogWeight operator()(SignedLog64Weight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  LogWeight operator()(SignedLogWeight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  SignedLog64Weight operator()(Log64Weight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  SignedLog64Weight operator()(LogWeight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  SignedLog64Weight operator()(SignedLogWeight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  SignedLog64Weight operator()(TropicalWeight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  SignedLogWeight operator()(Log64Weight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  SignedLogWeight operator()(LogWeight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  SignedLogWeight operator()(SignedLog64Weight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  SignedLogWeight operator()(TropicalWeight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  TropicalWeight operator()(SignedLog64Weight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	signed-log-weight.h	/^  TropicalWeight operator()(SignedLogWeight w) const {$/;"	f	struct:fst::WeightConvert
operator ()	state-map.h	/^    bool operator()(const A& x, const A& y) {$/;"	f	struct:fst::ArcSumMapper::Compare
operator ()	state-map.h	/^    bool operator()(const A& x, const A& y) {$/;"	f	struct:fst::ArcSumMapper::Equal
operator ()	state-map.h	/^    bool operator()(const A& x, const A& y) {$/;"	f	struct:fst::ArcUniqueMapper::Compare
operator ()	state-map.h	/^    bool operator()(const A& x, const A& y) {$/;"	f	struct:fst::ArcUniqueMapper::Equal
operator ()	state-table.h	/^  size_t operator()(const ComposeStateTuple<S, F>& t) const {$/;"	f	class:fst::ComposeHash
operator ()	state-table.h	/^  size_t operator()(const StateTuple &tuple) { return tuple.state_id1; }$/;"	f	class:fst::ComposeState1Fingerprint
operator ()	state-table.h	/^  size_t operator()(const StateTuple &tuple) { return tuple.state_id2; }$/;"	f	class:fst::ComposeState2Fingerprint
operator ()	state-table.h	/^  size_t operator()(const StateTuple &tuple) {$/;"	f	class:fst::ComposeFingerprint
operator ()	string.h	/^  bool operator()(const Fst<A> &fst, string *output) {$/;"	f	class:fst::StringPrinter
operator ()	string.h	/^  bool operator()(const string &s, F *fst) const {$/;"	f	class:fst::StringCompiler
operator ()	symbol-table.h	/^    bool operator()(const char *s1, const char *s2) const {$/;"	f	struct:fst::SymbolTableImpl::StrCmp
operator ()	synchronize.h	/^    bool operator()(const Element &x, const Element &y) const {$/;"	f	class:fst::SynchronizeFstImpl::ElementEqual
operator ()	synchronize.h	/^    bool operator()(const String * const &x, const String * const &y) const {$/;"	f	class:fst::SynchronizeFstImpl::StringEqual
operator ()	synchronize.h	/^    size_t operator()(const Element &x) const {$/;"	f	class:fst::SynchronizeFstImpl::ElementKey
operator ()	synchronize.h	/^    size_t operator()(const String * const & x) const {$/;"	f	class:fst::SynchronizeFstImpl::StringKey
operator ()	vector-fst.h	/^LogWeight WeightFromString<LogWeight>::operator()(const string &s) {$/;"	f	class:fst::WeightFromString
operator ()	vector-fst.h	/^TropicalWeight WeightFromString<TropicalWeight>::operator()(const string &s) {$/;"	f	class:fst::WeightFromString
operator ()	vector-fst.h	/^W WeightFromString<W>::operator()(const string &s) {$/;"	f	class:fst::WeightFromString
operator ()	weight.h	/^  W operator()(W w) const { return w; }$/;"	f	struct:fst::WeightConvert
operator ()	weight.h	/^  W2 operator()(W1 w1) const {$/;"	f	struct:fst::WeightConvert
operator ()	weight.h	/^  bool operator()(const W &w1, const W &w2) const {$/;"	f	class:fst::NaturalLess
operator <	interval-set.h	/^    bool operator<(const Interval &i) const {$/;"	f	struct:fst::IntervalSet::Interval
operator <<	float-weight.h	/^inline ostream &operator<<(ostream &strm, const FloatWeightTpl<T> &w) {$/;"	f	namespace:fst
operator <<	interval-set.h	/^ostream &operator<<(ostream &strm, const IntervalSet<T> &s)  {$/;"	f	namespace:fst
operator <<	pair-weight.h	/^inline ostream &operator<<(ostream &strm, const PairWeight<W1, W2> &w) {$/;"	f	namespace:fst
operator <<	sparse-tuple-weight.h	/^inline ostream &operator<<(ostream &strm, const SparseTupleWeight<W, K> &w) {$/;"	f	namespace:fst
operator <<	string-weight.h	/^inline ostream &operator<<(ostream &strm, const StringWeight<L, S> &w) {$/;"	f	namespace:fst
operator <<	tuple-weight.h	/^inline ostream &operator<<(ostream &strm, const TupleWeight<W, n> &w) {$/;"	f	namespace:fst
operator =	edit-fst.h	/^  operator=(const EditFst<A, WrappedFstT, MutableFstT> &fst) {$/;"	f	class:fst::EditFst
operator =	edit-fst.h	/^  virtual EditFst<A, WrappedFstT, MutableFstT> &operator=(const Fst<A> &fst) {$/;"	f	class:fst::EditFst
operator =	expanded-fst.h	/^  ImplToExpandedFst<I, F> &operator=(const Fst<Arc> &fst) {$/;"	f	class:fst::ImplToExpandedFst
operator =	float-weight.h	/^  FloatWeightTpl<T> &operator=(const FloatWeightTpl<T> &w) {$/;"	f	class:fst::FloatWeightTpl
operator =	fst.h	/^  ImplToFst<I, F> &operator=(const Fst<Arc> &fst) {$/;"	f	class:fst::ImplToFst
operator =	mutable-fst.h	/^  ImplToMutableFst<I, F> &operator=(const Fst<Arc> &fst) {$/;"	f	class:fst::ImplToMutableFst
operator =	mutable-fst.h	/^  MutableFst<A> &operator=(const MutableFst<A> &fst) {$/;"	f	class:fst::MutableFst
operator =	pair-weight.h	/^  PairWeight<W1, W2> &operator=(const PairWeight<W1, W2> &w) {$/;"	f	class:fst::PairWeight
operator =	sparse-tuple-weight.h	/^  SparseTupleWeight<W, K> &operator=(const SparseTupleWeight<W, K> &w) {$/;"	f	class:fst::SparseTupleWeight
operator =	symbol-table.h	/^  void operator=(const SymbolTable &st) {$/;"	f	class:fst::SymbolTable
operator =	tuple-weight.h	/^  TupleWeight<W, n> &operator=(const TupleWeight<W, n> &w) {$/;"	f	class:fst::TupleWeight
operator =	vector-fst.h	/^  VectorFst<A> &operator=(const VectorFst<A> &fst) {$/;"	f	class:fst::VectorFst
operator =	vector-fst.h	/^  virtual VectorFst<A> &operator=(const Fst<A> &fst) {$/;"	f	class:fst::VectorFst
operator ==	compose-filter.h	/^  bool operator==(const IntegerFilterState &f) const {$/;"	f	class:fst::IntegerFilterState
operator ==	compose-filter.h	/^  bool operator==(const PairFilterState &f) const {$/;"	f	class:fst::PairFilterState
operator ==	compose-filter.h	/^  bool operator==(const WeightFilterState &f) const {$/;"	f	class:fst::WeightFilterState
operator ==	float-weight.h	/^inline bool operator==(const FloatWeightTpl<T> &w1,$/;"	f	namespace:fst
operator ==	float-weight.h	/^inline bool operator==(const FloatWeightTpl<double> &w1,$/;"	f	namespace:fst
operator ==	float-weight.h	/^inline bool operator==(const FloatWeightTpl<float> &w1,$/;"	f	namespace:fst
operator ==	interval-set.h	/^    bool operator==(const Interval &i) const {$/;"	f	struct:fst::IntervalSet::Interval
operator ==	interval-set.h	/^  bool operator==(const IntervalSet<T>& iset) const {$/;"	f	class:fst::IntervalSet
operator ==	pair-weight.h	/^inline bool operator==(const PairWeight<W1, W2> &w,$/;"	f	namespace:fst
operator ==	replace.h	/^inline bool operator==(const ReplaceStateTuple<S, P>& x,$/;"	f	namespace:fst
operator ==	signed-log-weight.h	/^inline bool operator==(const SignedLogWeightTpl<T> &w1,$/;"	f	namespace:fst
operator ==	sparse-tuple-weight.h	/^inline bool operator==(const SparseTupleWeight<W, K> &w1,$/;"	f	namespace:fst
operator ==	state-table.h	/^inline bool operator==(const ComposeStateTuple<S, F>& x,$/;"	f	namespace:fst
operator ==	string-weight.h	/^inline bool operator==(const StringWeight<L, S> &w1,$/;"	f	namespace:fst
operator ==	tuple-weight.h	/^inline bool operator==(const TupleWeight<W, n> &w1,$/;"	f	namespace:fst
operator >>	float-weight.h	/^inline istream &operator>>(istream &strm, FloatWeightTpl<T> &w) {$/;"	f	namespace:fst
operator >>	pair-weight.h	/^inline istream &operator>>(istream &strm, PairWeight<W1, W2> &w) {$/;"	f	namespace:fst
operator >>	sparse-tuple-weight.h	/^inline istream &operator>>(istream &strm, SparseTupleWeight<W, K> &w) {$/;"	f	namespace:fst
operator >>	string-weight.h	/^inline istream &operator>>(istream &strm, StringWeight<L, S> &w) {$/;"	f	namespace:fst
operator >>	tuple-weight.h	/^inline istream &operator>>(istream &strm, TupleWeight<W, n> &w) {$/;"	f	namespace:fst
order_	queue.h	/^  vector<StateId> order_;$/;"	m	class:fst::TopOrderQueue
order_	topsort.h	/^  vector<StateId> *order_;$/;"	m	class:fst::TopOrderVisitor
ostring	synchronize.h	/^    const String *ostring;     \/\/ Residual output labels$/;"	m	struct:fst::SynchronizeFstImpl::Element
osymbols	fst.h	/^  const SymbolTable* osymbols;  \/\/ Pointer to output symbols. If non-zero, use$/;"	m	struct:fst::FstReadOptions
osymbols_	arc-map.h	/^  const SymbolTable *osymbols_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
osymbols_	encode.h	/^  SymbolTable *osymbols_;       \/\/ Pre-encoded olabel symbol table$/;"	m	class:fst::EncodeTable
osymbols_	fst.h	/^  SymbolTable *osymbols_;       \/\/ Olabel symbol table$/;"	m	class:fst::FstImpl
out_dist_	determinize.h	/^  vector<Weight> *out_dist_;       \/\/ Distance to final DFA states$/;"	m	class:fst::DeterminizeFsaImpl
output_map_	relabel.h	/^  unordered_map<Label, Label> output_map_;$/;"	m	class:fst::RelabelFstImpl
outref	replace-util.h	/^    map<Label, size_t> outref;$/;"	m	struct:fst::ReplaceUtil::ReplaceStats
own_compactor_	compact-fst.h	/^  bool own_compactor_;$/;"	m	class:fst::CompactFstImpl
own_mapper_	arc-map.h	/^  bool own_mapper_;$/;"	m	class:fst::ArcMapFstImpl
own_mapper_	state-map.h	/^  bool own_mapper_;$/;"	m	class:fst::StateMapFstImpl
own_matcher_	matcher.h	/^  bool own_matcher_;             \/\/ Does this class delete the matcher?$/;"	m	class:fst::MultiEpsMatcher
p_	partition.h	/^  const Partition<T>& p_;$/;"	m	class:fst::PartitionIterator
pairs_	shortest-path.h	/^  const vector<Pair> &pairs_;$/;"	m	class:fst::ShortestPathCompare
parent	randgen.h	/^  const RandState<A> *parent;    \/\/ previous random state on this path$/;"	m	struct:fst::RandState
parent_	union-find.h	/^  vector<T> parent_;      \/\/ Parent nodes.$/;"	m	class:fst::UnionFind
partition	minimize.h	/^  const Partition<StateId>& partition() const {$/;"	f	class:fst::CyclicMinimizer
partition	minimize.h	/^  const Partition<StateId>& partition() {$/;"	f	class:fst::AcyclicMinimizer
partition_	minimize.h	/^    const Partition<StateId>& partition_;$/;"	m	class:fst::CyclicMinimizer::ArcIterCompare
partition_	minimize.h	/^  Partition<StateId> partition_;$/;"	m	class:fst::AcyclicMinimizer
partition_	minimize.h	/^  const Partition<typename A::StateId>& partition_;$/;"	m	class:fst::StateComparator
path_	randgen.h	/^  vector<OArc> path_;$/;"	m	class:fst::RandGenVisitor
phi_arc_	matcher.h	/^  mutable Arc phi_arc_;   \/\/ Arc to return$/;"	m	class:fst::PhiMatcher
phi_label_	matcher.h	/^  Label phi_label_;       \/\/ Label that represents the phi transition$/;"	m	class:fst::PhiMatcher
phi_loop_	matcher.h	/^  bool phi_loop_;         \/\/ When true, phi self-loop are allowed and treated$/;"	m	class:fst::PhiMatcher
phi_match_	matcher.h	/^  Label phi_match_;       \/\/ Current label that matches phi loop$/;"	m	class:fst::PhiMatcher
phi_weight_	matcher.h	/^  Weight phi_weight_;     \/\/ Product of the weights of phi transitions taken$/;"	m	class:fst::PhiMatcher
pos	const-fst.h	/^    Unsigned pos;                \/\/ Start of state's arcs in *arcs_$/;"	m	struct:fst::ConstFstImpl::State
pos_	compact-fst.h	/^  size_t pos_;$/;"	m	class:fst::ArcIterator
pos_	complement.h	/^  size_t pos_;$/;"	m	class:fst::ArcIterator
pos_	heap.h	/^  vector<int> pos_;$/;"	m	class:fst::Heap
pos_	replace.h	/^  ssize_t pos_;             \/\/ Current position$/;"	m	class:fst::ArcIterator
pos_	symbol-table.h	/^  ssize_t pos_;$/;"	m	class:fst::SymbolTableIterator
prefix_	replace.h	/^    vector<PrefixTuple> prefix_;$/;"	m	class:fst::ReplaceFstImpl::StackPrefix
prefix_arc_	lookahead-matcher.h	/^  Arc prefix_arc_;                            \/\/ Look-ahead prefix arc$/;"	m	class:fst::LookAheadMatcherBase
prefix_hash_	replace.h	/^  StackPrefixHash prefix_hash_;$/;"	m	class:fst::ReplaceFstImpl
prefix_id	replace.h	/^  PrefixId prefix_id;  \/\/ index in prefix table$/;"	m	struct:fst::ReplaceStateTuple
prev	partition.h	/^   Element* prev;$/;"	m	struct:fst::Partition::Element
project_type_	project.h	/^  ProjectType project_type_;$/;"	m	class:fst::ProjectMapper
properties_	fst.h	/^  mutable uint64 properties_;           \/\/ Property bits$/;"	m	class:fst::FstImpl
properties_	fst.h	/^  uint64 properties_;                \/\/ FST property bits$/;"	m	class:fst::FstHeader
properties_	vector-fst.h	/^  uint64 *properties_;$/;"	m	class:fst::MutableArcIterator
props_	connect.h	/^  uint64 *props_;$/;"	m	class:fst::SccVisitor
queue_	queue.h	/^  Q *queue_;$/;"	m	class:fst::PruneQueue
queue_	queue.h	/^  QueueBase<StateId> *queue_;$/;"	m	class:fst::AutoQueue
queue_	queue.h	/^  vector<Queue*> *queue_;$/;"	m	class:fst::SccQueue
queue_	rmepsilon.h	/^  FifoQueue<StateId> queue_;$/;"	m	class:fst::RmEpsilonFstImpl
queue_type_	queue.h	/^  QueueType queue_type_;$/;"	m	class:fst::QueueBase
queues_	queue.h	/^  vector< QueueBase<StateId>* > queues_;$/;"	m	class:fst::AutoQueue
rank_	union-find.h	/^  vector<int> rank_;      \/\/ Rank of an element = min. depth in tree.$/;"	m	class:fst::UnionFind
rdistance_	shortest-distance.h	/^  vector<Weight> rdistance_;  \/\/ Relaxation distance.$/;"	m	class:fst::ShortestDistanceState
reach_begin_	label-reachable.h	/^  ssize_t reach_begin_;                   \/\/ Iterator pos of first match$/;"	m	class:fst::LabelReachable
reach_end_	label-reachable.h	/^  ssize_t reach_end_;                     \/\/ Iterator pos after last match$/;"	m	class:fst::LabelReachable
reach_input_	label-reachable.h	/^  bool reach_input_;                  \/\/ Input or output labels considered?$/;"	m	class:fst::LabelReachableData
reach_set_state_	lookahead-matcher.h	/^  mutable bool reach_set_state_;             \/\/ reachable_.SetState called?$/;"	m	class:fst::LabelLookAheadMatcher
reach_weight_	label-reachable.h	/^  Weight reach_weight_;                   \/\/ Gives weight sum of arc iterator$/;"	m	class:fst::LabelReachable
reader	register.h	/^  Reader reader;$/;"	m	struct:fst::FstRegisterEntry
recent	accumulator.h	/^    bool recent;              \/\/ Has this state been accessed since last GC?$/;"	m	struct:fst::CacheLogAccumulatorData::CacheState
ref_count	cache.h	/^  mutable int ref_count;$/;"	m	struct:fst::CacheState
ref_count	fst.h	/^  int *ref_count;            \/\/ ... and reference count if non-zero$/;"	m	struct:fst::ArcIteratorData
ref_count_	accumulator.h	/^  RefCounter ref_count_;                  \/\/ Reference count.$/;"	m	class:fst::FastLogAccumulatorData
ref_count_	accumulator.h	/^  RefCounter ref_count_;$/;"	m	class:fst::CacheLogAccumulatorData
ref_count_	accumulator.h	/^  RefCounter ref_count_;$/;"	m	class:fst::ReplaceAccumulatorData
ref_count_	add-on.h	/^  RefCounter ref_count_;$/;"	m	class:fst::AddOnPair
ref_count_	add-on.h	/^  RefCounter ref_count_;$/;"	m	class:fst::NullAddOn
ref_count_	compact-fst.h	/^  RefCounter ref_count_;$/;"	m	class:fst::CompactFstData
ref_count_	edit-fst.h	/^  RefCounter ref_count_;$/;"	m	class:fst::EditFstData
ref_count_	encode.h	/^  RefCounter ref_count_;$/;"	m	class:fst::EncodeTable
ref_count_	fst.h	/^  RefCounter ref_count_;        \/\/ Reference count$/;"	m	class:fst::FstImpl
ref_count_	label-reachable.h	/^  RefCounter ref_count_;              \/\/ Reference count.$/;"	m	class:fst::LabelReachableData
ref_count_	symbol-table.h	/^  mutable RefCounter ref_count_;$/;"	m	class:fst::SymbolTableImpl
register_	flags.h	/^  static FlagRegister<T> *register_;$/;"	m	class:FlagRegister
register_	flags.h	/^FlagRegister<T> *FlagRegister<T>::register_ = 0;$/;"	m	class:FlagRegister
register_	generic-register.h	/^  static RegisterType *register_;$/;"	m	class:fst::GenericRegister
register_	generic-register.h	/^RegisterType *GenericRegister<KeyType, EntryType, RegisterType>::register_ = 0;$/;"	m	class:fst::GenericRegister
register_init_	flags.h	/^  static fst::FstOnceType register_init_;   \/\/ ensures only called once$/;"	m	class:FlagRegister
register_init_	flags.h	/^fst::FstOnceType FlagRegister<T>::register_init_ = fst::FST_ONCE_INIT;$/;"	m	class:FlagRegister
register_init_	generic-register.h	/^                               RegisterType>::register_init_ = FST_ONCE_INIT;$/;"	m	class:fst::GenericRegister
register_init_	generic-register.h	/^  static FstOnceType register_init_;$/;"	m	class:fst::GenericRegister
register_lock_	flags.h	/^  static fst::Mutex* register_lock_;        \/\/ multithreading lock$/;"	m	class:FlagRegister
register_lock_	flags.h	/^fst::Mutex *FlagRegister<T>::register_lock_ = 0;$/;"	m	class:FlagRegister
register_lock_	generic-register.h	/^  static Mutex *register_lock_;$/;"	m	class:fst::GenericRegister
register_lock_	generic-register.h	/^Mutex *GenericRegister<KeyType, EntryType, RegisterType>::register_lock_ = 0;$/;"	m	class:fst::GenericRegister
register_table_	generic-register.h	/^  RegisterMapType register_table_;$/;"	m	class:fst::GenericRegister
relabel_input_	relabel.h	/^  bool relabel_input_;$/;"	m	class:fst::RelabelFstImpl
relabel_output_	relabel.h	/^  bool relabel_output_;$/;"	m	class:fst::RelabelFstImpl
remove_total_weight	randgen.h	/^  bool remove_total_weight;  \/\/ Remove total weight when output is weighted.$/;"	m	struct:fst::RandGenFstOptions
remove_total_weight	randgen.h	/^  bool remove_total_weight;  \/\/ Remove total weight when output is weighted.$/;"	m	struct:fst::RandGenOptions
remove_total_weight_	randgen.h	/^  bool remove_total_weight_;$/;"	m	class:fst::RandGenFstImpl
replace_	rational.h	/^  mutable ReplaceFst<A> *replace_;        \/\/ Underlying ReplaceFst$/;"	m	class:fst::RationalFstImpl
replace_options_	rational.h	/^  ReplaceFstOptions<A> replace_options_;  \/\/ Options for creating 'replace_'$/;"	m	class:fst::RationalFstImpl
rest_	sparse-tuple-weight.h	/^  const list<Pair> & rest_;$/;"	m	class:fst::SparseTupleWeightIterator
rest_	sparse-tuple-weight.h	/^  list<Pair> rest_;$/;"	m	class:fst::SparseTupleWeight
rest_	string-weight.h	/^  const list<L> &rest_;$/;"	m	class:fst::StringWeightIterator
rest_	string-weight.h	/^  const list<L> &rest_;$/;"	m	class:fst::StringWeightReverseIterator
rest_	string-weight.h	/^  list<L> rest_;    \/\/ remaining labels in string$/;"	m	class:fst::StringWeight
retain_	shortest-distance.h	/^  bool retain_;               \/\/ Retain and reuse information across calls$/;"	m	class:fst::ShortestDistanceState
rewrite_both_	matcher.h	/^  bool rewrite_both_;      \/\/ Rewrite both sides when both are 'sigma_label_'$/;"	m	class:fst::SigmaMatcher
rewrite_both_	matcher.h	/^  bool rewrite_both_;     \/\/ Rewrite both sides when both are 'phi_label_'$/;"	m	class:fst::PhiMatcher
rewrite_both_	matcher.h	/^  bool rewrite_both_;     \/\/ Rewrite both sides when both are 'rho_label_'$/;"	m	class:fst::RhoMatcher
rfst_	rational.h	/^  VectorFst<A> rfst_;   \/\/ rational topology machine; uses neg. nonterminals$/;"	m	class:fst::RationalFstImpl
rho_arc_	matcher.h	/^  mutable Arc rho_arc_;   \/\/ Arc to return when rho match$/;"	m	class:fst::RhoMatcher
rho_label_	matcher.h	/^  Label rho_label_;       \/\/ Label that represents the rho transition$/;"	m	class:fst::RhoMatcher
rho_match_	matcher.h	/^  Label rho_match_;       \/\/ Current label that matches rho transition$/;"	m	class:fst::RhoMatcher
rmeps_state_	rmepsilon.h	/^  RmEpsilonState<A, FifoQueue<StateId> > rmeps_state_;$/;"	m	class:fst::RmEpsilonFstImpl
root	replace.h	/^  int64 root;    \/\/ root rule for expansion$/;"	m	struct:fst::ReplaceFstOptions
root_	replace.h	/^  Label root_;$/;"	m	class:fst::ReplaceFstImpl
root_fst_	replace-util.h	/^  Label root_fst_;                                \/\/ root Fst ID$/;"	m	class:fst::ReplaceUtil
root_label_	replace-util.h	/^  Label root_label_;                              \/\/ root non-terminal$/;"	m	class:fst::ReplaceUtil
root_size_	replace.h	/^  StateId root_size_;$/;"	m	class:fst::VectorHashReplaceStateTable
s1_	compose-filter.h	/^  StateId s1_;              \/\/ Current fst1_ state;$/;"	m	class:fst::MatchComposeFilter
s1_	compose-filter.h	/^  StateId s1_;     \/\/ Current fst1_ state;$/;"	m	class:fst::AltSequenceComposeFilter
s1_	compose-filter.h	/^  StateId s1_;     \/\/ Current fst1_ state;$/;"	m	class:fst::SequenceComposeFilter
s2_	compose-filter.h	/^  StateId s2_;              \/\/ Current fst2_ state;$/;"	m	class:fst::MatchComposeFilter
s2_	compose-filter.h	/^  StateId s2_;     \/\/ Current fst2_ state;$/;"	m	class:fst::AltSequenceComposeFilter
s2_	compose-filter.h	/^  StateId s2_;     \/\/ Current fst2_ state;$/;"	m	class:fst::SequenceComposeFilter
s_	accumulator.h	/^  StateId s_;                            \/\/ Current state$/;"	m	class:fst::CacheLogAccumulator
s_	arc-map.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
s_	cache.h	/^  StateId s_;$/;"	m	class:fst::CacheMutableArcIterator
s_	cache.h	/^  StateId s_;$/;"	m	class:fst::CacheStateIterator
s_	compact-fst.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
s_	complement.h	/^  StateId s_;$/;"	m	class:fst::ArcIterator
s_	complement.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
s_	const-fst.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
s_	fst.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
s_	label-reachable.h	/^  StateId s_;                             \/\/ Current state$/;"	m	class:fst::LabelReachable
s_	lookahead-matcher.h	/^  StateId s_;                                \/\/ Matcher state$/;"	m	class:fst::LabelLookAheadMatcher
s_	lookahead-matcher.h	/^  StateId s_;              \/\/ Matcher state$/;"	m	class:fst::ArcLookAheadMatcher
s_	matcher.h	/^  StateId s_;                     \/\/ Current state$/;"	m	class:fst::SortedMatcher
s_	relabel.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
s_	replace.h	/^  StateId s_;                        \/\/ Current state$/;"	m	class:fst::ReplaceFstMatcher
s_	state-reachable.h	/^  StateId s_;                                 \/\/ Current state$/;"	m	class:fst::StateReachable
s_	vector-fst.h	/^  StateId s_;$/;"	m	class:fst::StateIterator
sample_iter_	randgen.h	/^  map<size_t, size_t>::const_iterator sample_iter_;$/;"	m	class:fst::ArcSampler
sample_map_	randgen.h	/^  map<size_t, size_t> sample_map_;$/;"	m	class:fst::ArcSampler
save_relabel_ipairs	lookahead-matcher.h	/^DECLARE_string(save_relabel_ipairs);$/;"	v
save_relabel_opairs	lookahead-matcher.h	/^DECLARE_string(save_relabel_opairs);$/;"	v
scc_	connect.h	/^  vector<StateId> *scc_;        \/\/ State's scc number$/;"	m	class:fst::SccVisitor
scc_	queue.h	/^  const vector<StateId> &scc_;$/;"	m	class:fst::SccQueue
scc_	queue.h	/^  vector<StateId> scc_;$/;"	m	class:fst::AutoQueue
scc_stack_	connect.h	/^  vector<StateId> *scc_stack_;  \/\/ SCC stack (w\/ random access)$/;"	m	class:fst::SccVisitor
sd_state_	rmepsilon.h	/^  ShortestDistanceState<Arc, Queue, EpsilonArcFilter<Arc> > sd_state_;$/;"	m	class:fst::RmEpsilonState
seed_	randgen.h	/^  int seed_;$/;"	m	class:fst::FastLogProbArcSelector
select	randgen.h	/^  size_t select;                 \/\/ previous sample arc selection$/;"	m	struct:fst::RandState
selector_	bi-table.h	/^  S *selector_;  \/\/ Returns true if entry hashed into vector$/;"	m	class:fst::VectorHashBiTable
selector_	lookahead-filter.h	/^  LookAheadSelector<Matcher1, Matcher2, MT> selector_;$/;"	m	class:fst::LookAheadComposeFilter
set_	util.h	/^  set<Key> set_;$/;"	m	class:fst::CompactSet
sigma_arc_	matcher.h	/^  mutable Arc sigma_arc_;  \/\/ Arc to return when sigma match$/;"	m	class:fst::SigmaMatcher
sigma_label_	matcher.h	/^  Label sigma_label_;      \/\/ Label that represents the sigma transition$/;"	m	class:fst::SigmaMatcher
sigma_match_	matcher.h	/^  Label sigma_match_;      \/\/ Current label that matches sigma transition$/;"	m	class:fst::SigmaMatcher
siter_	arc-map.h	/^  StateIterator< Fst<A> > siter_;$/;"	m	class:fst::StateIterator
siter_	complement.h	/^  StateIterator< Fst<A> > siter_;$/;"	m	class:fst::StateIterator
siter_	relabel.h	/^  StateIterator< Fst<A> > siter_;$/;"	m	class:fst::StateIterator
size_	heap.h	/^  int  size_;$/;"	m	class:fst::Heap
source	fst.h	/^  string source;                 \/\/ Where you're writing to$/;"	m	struct:fst::FstWriteOptions
source	fst.h	/^  string source;                \/\/ Where you're reading from$/;"	m	struct:fst::FstReadOptions
source	shortest-distance.h	/^  StateId source;        \/\/ If kNoStateId, use the Fst's initial state$/;"	m	struct:fst::ShortestDistanceOptions
source	symbol-table.h	/^  string source;$/;"	m	struct:fst::SymbolTableReadOptions
source_id_	shortest-distance.h	/^  StateId source_id_;         \/\/ Unique ID characterizing each call to SD$/;"	m	class:fst::ShortestDistanceState
sources_	shortest-distance.h	/^  vector<StateId> sources_;   \/\/ Source ID for ith state in 'distance_',$/;"	m	class:fst::ShortestDistanceState
split_size_	partition.h	/^  vector<T> split_size_;$/;"	m	class:fst::Partition
stackprefix_array_	replace.h	/^  vector<StackPrefix> stackprefix_array_;$/;"	m	class:fst::ReplaceFstImpl
start_	compact-fst.h	/^  ssize_t start_;$/;"	m	class:fst::CompactFstData
start_	connect.h	/^  StateId start_;$/;"	m	class:fst::SccVisitor
start_	const-fst.h	/^  StateId start_;                \/\/ Initial state$/;"	m	class:fst::ConstFstImpl
start_	fst.h	/^  int64 start_;                      \/\/ Start state$/;"	m	class:fst::FstHeader
start_	vector-fst.h	/^  StateId start_;               \/\/ initial state$/;"	m	class:fst::VectorFstBaseImpl
state	factor-weight.h	/^    StateId state;     \/\/ Input state Id$/;"	m	struct:fst::FactorWeightFstImpl::Element
state	synchronize.h	/^    StateId state;     \/\/ Input state Id$/;"	m	struct:fst::SynchronizeFstImpl::Element
state2index_	state-reachable.h	/^  vector<I> *state2index_;$/;"	m	class:fst::IntervalReachVisitor
state2index_	state-reachable.h	/^  vector<I> state2index_;                     \/\/ Finds index for a final state$/;"	m	class:fst::StateReachable
state_	arc-map.h	/^  StateId state_;$/;"	m	struct:fst::GallicToNewSymbolsMapper
state_	cache.h	/^  State *state_;$/;"	m	class:fst::CacheMutableArcIterator
state_	cache.h	/^  const State *state_;$/;"	m	class:fst::CacheArcIterator
state_	compact-fst.h	/^  StateId state_;$/;"	m	class:fst::ArcIterator
state_	compose-filter.h	/^  T state_;$/;"	m	class:fst::IntegerFilterState
state_	matcher.h	/^  StateId state_;         \/\/ State where looking for matches$/;"	m	class:fst::PhiMatcher
state_	queue.h	/^  vector<StateId> state_;$/;"	m	class:fst::TopOrderQueue
state_	replace.h	/^  StateId state_;                         \/\/ State in the FST$/;"	m	class:fst::ArcIterator
state_	vector-fst.h	/^  struct VectorState<A> *state_;$/;"	m	class:fst::MutableArcIterator	typeref:struct:fst::MutableArcIterator::VectorState
state_id	determinize.h	/^    StateId state_id;  \/\/ Input state Id$/;"	m	struct:fst::DeterminizeFsaImpl::Element
state_id	dfs-visit.h	/^  StateId state_id;       \/\/ Fst state ...$/;"	m	struct:fst::DfsState
state_id	randgen.h	/^  StateId state_id;              \/\/ current input FST state$/;"	m	struct:fst::RandState
state_id1	state-table.h	/^  StateId state_id1;         \/\/ State Id on fst1$/;"	m	struct:fst::ComposeStateTuple
state_id2	state-table.h	/^  StateId state_id2;         \/\/ State Id on fst2$/;"	m	struct:fst::ComposeStateTuple
state_queue	shortest-distance.h	/^  Queue *state_queue;    \/\/ Queue discipline used; owned by caller$/;"	m	struct:fst::ShortestDistanceOptions
state_queue_	shortest-distance.h	/^  Queue *state_queue_;$/;"	m	class:fst::ShortestDistanceState
state_table	compose.h	/^  T *state_table;   \/\/ Composition state table (see compose-state-table.h)$/;"	m	struct:fst::ComposeFstImplOptions
state_table	compose.h	/^  T *state_table;   \/\/ Composition state table (see compose-state-table.h)$/;"	m	struct:fst::ComposeFstOptions
state_table	replace.h	/^  T*    state_table;$/;"	m	struct:fst::ReplaceFstOptions
state_table_	accumulator.h	/^  const T * state_table_;$/;"	m	class:fst::ReplaceAccumulatorData
state_table_	compose.h	/^  T *state_table_;$/;"	m	class:fst::ComposeFstImpl
state_table_	randgen.h	/^  vector<RandState<A> *> state_table_;$/;"	m	class:fst::RandGenFstImpl
state_table_	replace.h	/^  StateTable *state_table_;$/;"	m	class:fst::ReplaceFstImpl
state_table_	replace.h	/^  StateTable *state_table_;$/;"	m	class:fst::VectorHashReplaceStateTable
state_threshold	determinize.h	/^  StateId state_threshold;    \/\/ Pruning state threshold.$/;"	m	struct:fst::DeterminizeOptions
state_threshold	prune.h	/^  StateId state_threshold;$/;"	m	class:fst::PruneOptions
state_threshold	rmepsilon.h	/^  StateId state_threshold;   \/\/ Pruning state threshold.$/;"	m	class:fst::RmEpsilonOptions
state_threshold	shortest-path.h	/^  StateId state_threshold;   \/\/ pruning state threshold.$/;"	m	struct:fst::ShortestPathOptions
state_weights_	accumulator.h	/^  double *state_weights_;$/;"	m	class:fst::FastLogAccumulator
states_	compact-fst.h	/^  Unsigned *states_;$/;"	m	class:fst::CompactFstData
states_	const-fst.h	/^  State *states_;                \/\/ States represenation$/;"	m	class:fst::ConstFstImpl
states_	vector-fst.h	/^  vector<State *> states_;      \/\/ States represenation.$/;"	m	class:fst::VectorFstBaseImpl
stats_	replace-util.h	/^  mutable vector<ReplaceStats> stats_;            \/\/ Per Fst statistics$/;"	m	class:fst::ReplaceUtil
std	compat.h	/^namespace std {$/;"	n
std::tr1	compat.h	/^namespace tr1 {$/;"	n	namespace:std
std::tr1::hash	compat.h	/^template<> struct hash<uint64> {$/;"	s	namespace:std::tr1
std::tr1::hash::operator ()	compat.h	/^  size_t operator()(uint64 x) const { return x; }$/;"	f	struct:std::tr1::hash
stream	log.h	/^  std::ostream &stream() { return std::cerr; }$/;"	f	class:LogMessage
string_hash_ranges	symbol-table.h	/^  vector<pair<int64, int64> > string_hash_ranges;$/;"	m	struct:fst::SymbolTableReadOptions
string_set_	synchronize.h	/^  StringSet string_set_;$/;"	m	class:fst::SynchronizeFstImpl
subsequential_label	determinize.h	/^  Label subsequential_label;  \/\/ Label used for residual final output$/;"	m	struct:fst::DeterminizeFstOptions
subsequential_label	determinize.h	/^  Label subsequential_label;  \/\/ Label used for residual final output$/;"	m	struct:fst::DeterminizeOptions
subsequential_label_	determinize.h	/^  Label subsequential_label_;$/;"	m	class:fst::DeterminizeFstImpl
subset_hash_	determinize.h	/^  SubsetHash subset_hash_;$/;"	m	class:fst::DeterminizeFsaImpl
subsets_	determinize.h	/^  vector<Subset *> subsets_;$/;"	m	class:fst::DeterminizeFsaImpl
superfinal_	arc-map.h	/^  StateId superfinal_;$/;"	m	class:fst::ArcMapFstImpl
superfinal_	arc-map.h	/^  bool superfinal_;    \/\/ true if there is a superfinal state and not done$/;"	m	class:fst::StateIterator
superfinal_	randgen.h	/^  StateId superfinal_;$/;"	m	class:fst::RandGenFstImpl
superfinal_	shortest-path.h	/^  StateId superfinal_;$/;"	m	class:fst::ShortestPathCompare
superfinal_label_	arc-map.h	/^  Label superfinal_label_;$/;"	m	struct:fst::FromGallicMapper
symbol_map_	symbol-table.h	/^  map<const char *, int64, StrCmp> symbol_map_;$/;"	m	class:fst::SymbolTableImpl
symbols_	symbol-table.h	/^  vector<const char *> symbols_;$/;"	m	class:fst::SymbolTableImpl
syms_	string.h	/^  const SymbolTable *syms_;  \/\/ Symbol table used when token type is symbol$/;"	m	class:fst::StringCompiler
syms_	string.h	/^  const SymbolTable *syms_;  \/\/ Symbol table used when token type is symbol$/;"	m	class:fst::StringPrinter
t_	add-on.h	/^  T *t_;$/;"	m	class:fst::AddOnImpl
table	encode.h	/^  const EncodeTable<A> &table() const { return *table_; }$/;"	f	class:fst::EncodeMapper
table_	encode.h	/^  EncodeTable<A>* table_;$/;"	m	class:fst::EncodeMapper
table_	symbol-table.h	/^  const SymbolTable& table_;$/;"	m	class:fst::SymbolTableIterator
take_ownership	replace.h	/^  bool  take_ownership;  \/\/ take ownership of input Fst(s)$/;"	m	struct:fst::ReplaceFstOptions
threshold_	queue.h	/^  Weight threshold_;                       \/\/ pruning weight threshold$/;"	m	class:fst::PruneQueue
tmpdir	flags.h	/^DECLARE_string(tmpdir);$/;"	v
to_log_weight_	accumulator.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::CacheLogAccumulator
to_log_weight_	accumulator.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::FastLogAccumulator
to_log_weight_	accumulator.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::LogAccumulator
to_log_weight_	randgen.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::FastLogProbArcSelector
to_log_weight_	randgen.h	/^  WeightConvert<Weight, Log64Weight> to_log_weight_;$/;"	m	class:fst::LogProbArcSelector
to_weight_	accumulator.h	/^  WeightConvert<Log64Weight, Weight> to_weight_;$/;"	m	class:fst::CacheLogAccumulator
to_weight_	accumulator.h	/^  WeightConvert<Log64Weight, Weight> to_weight_;$/;"	m	class:fst::FastLogAccumulator
to_weight_	accumulator.h	/^  WeightConvert<Log64Weight, Weight> to_weight_;$/;"	m	class:fst::LogAccumulator
to_weight_	randgen.h	/^  WeightConvert<Log64Weight, Weight> to_weight_;$/;"	m	class:fst::RandGenFstImpl
token_type_	string.h	/^  TokenType token_type_;     \/\/ Token type: symbol, byte or utf8 encoded$/;"	m	class:fst::StringCompiler
token_type_	string.h	/^  TokenType token_type_;     \/\/ Token type: symbol, byte or utf8 encoded$/;"	m	class:fst::StringPrinter
tr1	compat.h	/^namespace tr1 {$/;"	n	namespace:std
trivial_queue_	queue.h	/^  vector<StateId> trivial_queue_;$/;"	m	class:fst::SccQueue
tuple_	replace.h	/^  mutable typename T::StateTuple tuple_;  \/\/ Tuple corresponding to state_$/;"	m	class:fst::ArcIterator
tuple_	replace.h	/^  mutable typename T::StateTuple tuple_;  \/\/ Tuple corresponding to state_$/;"	m	class:fst::ReplaceFstMatcher
type	closure.h	/^  ClosureType type;$/;"	m	struct:fst::ClosureFstOptions
type	encode.h	/^  const EncodeType type() const { return type_; }$/;"	f	class:fst::EncodeMapper
type_	encode.h	/^  EncodeType type_;$/;"	m	class:fst::EncodeMapper
type_	fst.h	/^  string type_;                 \/\/ Unique name of Fst class$/;"	m	class:fst::FstImpl
type_	lookahead-filter.h	/^  MatchType type_;$/;"	m	class:fst::LookAheadSelector
type_name	flags.h	/^  const char *type_name;$/;"	m	struct:FlagDescription
uint16	types.h	/^typedef uint16_t uint16;$/;"	t
uint32	types.h	/^typedef uint32_t uint32;$/;"	t
uint64	types.h	/^typedef uint64_t uint64;$/;"	t
uint8	types.h	/^typedef uint8_t uint8;$/;"	t
unfactored_	factor-weight.h	/^  vector<StateId> unfactored_;$/;"	m	class:fst::FactorWeightFstImpl
unique	shortest-path.h	/^  bool unique;        \/\/ only return paths with distinct input strings$/;"	m	struct:fst::ShortestPathOptions
unknown_label_	string.h	/^  Label unknown_label_;      \/\/ Label for token missing from symbol table$/;"	m	class:fst::StringCompiler
value	partition.h	/^   T        value;$/;"	m	struct:fst::Partition::Element
value1_	pair-weight.h	/^  W1 value1_;$/;"	m	class:fst::PairWeight
value2_	pair-weight.h	/^  W2 value2_;$/;"	m	class:fst::PairWeight
value_	float-weight.h	/^  T value_;$/;"	m	class:fst::FloatWeightTpl
values_	tuple-weight.h	/^  W values_[n];$/;"	m	class:fst::TupleWeight
version_	fst.h	/^  int32 version_;                    \/\/ Type version #$/;"	m	class:fst::FstHeader
visited_	rmepsilon.h	/^  vector<bool> visited_;          \/\/ '[i] = true' if state 'i' has been visited$/;"	m	class:fst::RmEpsilonState
visited_classes_	partition.h	/^  vector<T> visited_classes_;$/;"	m	class:fst::Partition
visited_states_	rmepsilon.h	/^  slist<StateId> visited_states_; \/\/ List of visited states$/;"	m	class:fst::RmEpsilonState
weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	class:fst::StringArc
weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::ExpectationArc
weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::GallicArc
weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::LexicographicArc
weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::PowerArc
weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::ProductArc
weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::ReverseArc
weight	arc.h	/^  Weight weight;      \/\/ Transition weight$/;"	m	struct:fst::SparsePowerArc
weight	arc.h	/^  Weight weight;$/;"	m	class:fst::ArcTpl
weight	determinize.h	/^    Weight weight;     \/\/ Residual weight$/;"	m	struct:fst::DeterminizeFsaImpl::Element
weight	encode.h	/^    Weight weight;$/;"	m	struct:fst::EncodeTable::Tuple
weight	factor-weight.h	/^    Weight weight;     \/\/ Residual weight$/;"	m	struct:fst::FactorWeightFstImpl::Element
weight_	arc-map.h	/^  Weight weight_;$/;"	m	struct:fst::PlusMapper
weight_	arc-map.h	/^  Weight weight_;$/;"	m	struct:fst::TimesMapper
weight_	compose-filter.h	/^  W weight_;$/;"	m	class:fst::WeightFilterState
weight_	factor-weight.h	/^  GallicWeight<L, W, S> weight_;$/;"	m	class:fst::GallicFactor
weight_	factor-weight.h	/^  StringWeight<L, S> weight_;$/;"	m	class:fst::StringFactor
weight_	lookahead-matcher.h	/^  Weight weight_;                             \/\/ Look-ahead weight$/;"	m	class:fst::LookAheadMatcherBase
weight_common_divisor_	determinize.h	/^  D weight_common_divisor_;$/;"	m	class:fst::GallicCommonDivisor
weight_positions_	accumulator.h	/^  vector<ssize_t> weight_positions_;$/;"	m	class:fst::FastLogAccumulatorData
weight_threshold	determinize.h	/^  Weight weight_threshold;    \/\/ Pruning weight threshold.$/;"	m	struct:fst::DeterminizeOptions
weight_threshold	prune.h	/^  Weight weight_threshold;$/;"	m	class:fst::PruneOptions
weight_threshold	rmepsilon.h	/^  Weight weight_threshold;   \/\/ Pruning weight threshold.$/;"	m	class:fst::RmEpsilonOptions
weight_threshold	shortest-path.h	/^  Weight weight_threshold;   \/\/ pruning weight threshold.$/;"	m	struct:fst::ShortestPathOptions
weighted	randgen.h	/^  bool weighted;             \/\/ Output is tree weighted by path count; o.w.$/;"	m	struct:fst::RandGenOptions
weighted	randgen.h	/^  bool weighted;             \/\/ Output tree weighted by path count; o.w.$/;"	m	struct:fst::RandGenFstOptions
weighted_	randgen.h	/^  bool weighted_;$/;"	m	class:fst::RandGenFstImpl
weights	accumulator.h	/^    vector<double>* weights;  \/\/ Accumulated weights for this state.$/;"	m	struct:fst::CacheLogAccumulatorData::CacheState
weights_	accumulator.h	/^  vector<double> *weights_;              \/\/ Accumulated weights for cur. state$/;"	m	class:fst::CacheLogAccumulator
weights_	accumulator.h	/^  vector<double> weights_;$/;"	m	class:fst::FastLogAccumulatorData
weights_	queue.h	/^  const vector<Weight>& weights_;$/;"	m	class:fst::AStarWeightCompare
weights_	queue.h	/^  const vector<Weight>& weights_;$/;"	m	class:fst::StateWeightCompare
wrapped_	edit-fst.h	/^  const WrappedFstT *wrapped_;$/;"	m	class:fst::EditFstImpl
write_header	fst.h	/^  bool write_header;             \/\/ Write the header?$/;"	m	struct:fst::FstWriteOptions
write_isymbols	fst.h	/^  bool write_isymbols;           \/\/ Write input symbols?$/;"	m	struct:fst::FstWriteOptions
write_osymbols	fst.h	/^  bool write_osymbols;           \/\/ Write output symbols?$/;"	m	struct:fst::FstWriteOptions
~AddOnImpl	add-on.h	/^  ~AddOnImpl() {$/;"	f	class:fst::AddOnImpl
~AddOnPair	add-on.h	/^  ~AddOnPair() {$/;"	f	class:fst::AddOnPair
~AltSequenceComposeFilter	compose-filter.h	/^  ~AltSequenceComposeFilter() {$/;"	f	class:fst::AltSequenceComposeFilter
~ArcIterator	compact-fst.h	/^  ~ArcIterator() {}$/;"	f	class:fst::ArcIterator
~ArcIterator	complement.h	/^  virtual ~ArcIterator() { delete aiter_; }$/;"	f	class:fst::ArcIterator
~ArcIterator	fst.h	/^  ~ArcIterator() {$/;"	f	class:fst::ArcIterator
~ArcIterator	replace.h	/^  ~ArcIterator() {$/;"	f	class:fst::ArcIterator
~ArcIteratorBase	fst.h	/^  virtual ~ArcIteratorBase() {}$/;"	f	class:fst::ArcIteratorBase
~ArcMapFstImpl	arc-map.h	/^  ~ArcMapFstImpl() {$/;"	f	class:fst::ArcMapFstImpl
~ArcSampler	randgen.h	/^  ~ArcSampler() {$/;"	f	class:fst::ArcSampler
~AutoQueue	queue.h	/^  ~AutoQueue() {$/;"	f	class:fst::AutoQueue
~CacheArcIterator	cache.h	/^  ~CacheArcIterator() { --state_->ref_count;  }$/;"	f	class:fst::CacheArcIterator
~CacheBaseImpl	cache.h	/^  ~CacheBaseImpl() {$/;"	f	class:fst::CacheBaseImpl
~CacheLogAccumulator	accumulator.h	/^  ~CacheLogAccumulator() {$/;"	f	class:fst::CacheLogAccumulator
~CacheLogAccumulatorData	accumulator.h	/^  ~CacheLogAccumulatorData() {$/;"	f	class:fst::CacheLogAccumulatorData
~CacheMutableArcIterator	cache.h	/^  ~CacheMutableArcIterator() {$/;"	f	class:fst::CacheMutableArcIterator
~CcVisitor	connect.h	/^  ~CcVisitor() {$/;"	f	class:fst::CcVisitor
~CompactFstData	compact-fst.h	/^  ~CompactFstData() {$/;"	f	class:fst::CompactFstData
~CompactFstImpl	compact-fst.h	/^  ~CompactFstImpl(){$/;"	f	class:fst::CompactFstImpl
~ComplementFstImpl	complement.h	/^  ~ComplementFstImpl() { delete fst_; }$/;"	f	class:fst::ComplementFstImpl
~ComposeFstImpl	compose.h	/^  ~ComposeFstImpl() {$/;"	f	class:fst::ComposeFstImpl
~ComposeFstImplBase	compose.h	/^  virtual ~ComposeFstImplBase() {}$/;"	f	class:fst::ComposeFstImplBase
~ConstFstImpl	const-fst.h	/^  ~ConstFstImpl() {$/;"	f	class:fst::ConstFstImpl
~CyclicMinimizer	minimize.h	/^  ~CyclicMinimizer() {$/;"	f	class:fst::CyclicMinimizer
~DefaultCacheStateAllocator	cache.h	/^  ~DefaultCacheStateAllocator() {$/;"	f	struct:fst::DefaultCacheStateAllocator
~DeterminizeFsaImpl	determinize.h	/^  virtual ~DeterminizeFsaImpl() {$/;"	f	class:fst::DeterminizeFsaImpl
~DeterminizeFstImpl	determinize.h	/^  ~DeterminizeFstImpl() { delete from_fst_; }$/;"	f	class:fst::DeterminizeFstImpl
~DeterminizeFstImplBase	determinize.h	/^  virtual ~DeterminizeFstImplBase() { delete fst_; }$/;"	f	class:fst::DeterminizeFstImplBase
~EditFst	edit-fst.h	/^  virtual ~EditFst() {}$/;"	f	class:fst::EditFst
~EditFstData	edit-fst.h	/^  ~EditFstData() {$/;"	f	class:fst::EditFstData
~EditFstImpl	edit-fst.h	/^  ~EditFstImpl() {$/;"	f	class:fst::EditFstImpl
~EncodeMapper	encode.h	/^  ~EncodeMapper() {$/;"	f	class:fst::EncodeMapper
~EncodeTable	encode.h	/^  ~EncodeTable() {$/;"	f	class:fst::EncodeTable
~FactorWeightFstImpl	factor-weight.h	/^  ~FactorWeightFstImpl() {$/;"	f	class:fst::FactorWeightFstImpl
~FastLogAccumulator	accumulator.h	/^  ~FastLogAccumulator() {$/;"	f	class:fst::FastLogAccumulator
~Fst	fst.h	/^  virtual ~Fst() {}$/;"	f	class:fst::Fst
~FstImpl	fst.h	/^  virtual ~FstImpl() {$/;"	f	class:fst::FstImpl
~GenericRegister	generic-register.h	/^  virtual ~GenericRegister() { }$/;"	f	class:fst::GenericRegister
~Heap	heap.h	/^  ~Heap() { }$/;"	f	class:fst::Heap
~IdentityStateMapper	state-map.h	/^  ~IdentityStateMapper() { delete aiter_; }$/;"	f	class:fst::IdentityStateMapper
~ImplToFst	fst.h	/^  virtual ~ImplToFst() { if (!impl_->DecrRefCount()) delete impl_;  }$/;"	f	class:fst::ImplToFst
~LabelLookAheadMatcher	lookahead-matcher.h	/^  ~LabelLookAheadMatcher() {$/;"	f	class:fst::LabelLookAheadMatcher
~LabelReachable	label-reachable.h	/^  ~LabelReachable() {$/;"	f	class:fst::LabelReachable
~LabelReachableData	label-reachable.h	/^  ~LabelReachableData() {}$/;"	f	class:fst::LabelReachableData
~LogMessage	log.h	/^  ~LogMessage() {$/;"	f	class:LogMessage
~LookAheadMatcher	lookahead-matcher.h	/^  ~LookAheadMatcher() { delete base_; }$/;"	f	class:fst::LookAheadMatcher
~LookAheadMatcher	matcher-fst.h	/^  ~LookAheadMatcher() { delete matcher_; }$/;"	f	class:fst::LookAheadMatcher
~LookAheadMatcherBase	lookahead-matcher.h	/^  virtual ~LookAheadMatcherBase() {}$/;"	f	class:fst::LookAheadMatcherBase
~LookAheadSelector	lookahead-filter.h	/^  ~LookAheadSelector() {$/;"	f	class:fst::LookAheadSelector
~MatchComposeFilter	compose-filter.h	/^  ~MatchComposeFilter() {$/;"	f	class:fst::MatchComposeFilter
~Matcher	matcher-fst.h	/^  ~Matcher() { delete matcher_; }$/;"	f	class:fst::Matcher
~Matcher	matcher.h	/^  ~Matcher() { delete base_; }$/;"	f	class:fst::Matcher
~MatcherBase	matcher.h	/^  virtual ~MatcherBase() {}$/;"	f	class:fst::MatcherBase
~MultiEpsMatcher	matcher.h	/^  ~MultiEpsMatcher() {$/;"	f	class:fst::MultiEpsMatcher
~MutableArcIterator	mutable-fst.h	/^  ~MutableArcIterator() { delete data_.base; }$/;"	f	class:fst::MutableArcIterator
~Partition	partition.h	/^  ~Partition() {$/;"	f	class:fst::Partition
~PhiMatcher	matcher.h	/^  virtual ~PhiMatcher() {$/;"	f	class:fst::PhiMatcher
~PruneQueue	queue.h	/^  ~PruneQueue() { delete queue_; }$/;"	f	class:fst::PruneQueue
~QueueBase	queue.h	/^  virtual ~QueueBase() {}$/;"	f	class:fst::QueueBase
~RandGenFstImpl	randgen.h	/^  ~RandGenFstImpl() {$/;"	f	class:fst::RandGenFstImpl
~RationalFstImpl	rational.h	/^  virtual ~RationalFstImpl() {$/;"	f	class:fst::RationalFstImpl
~RelabelFstImpl	relabel.h	/^  ~RelabelFstImpl() { delete fst_; }$/;"	f	class:fst::RelabelFstImpl
~ReplaceAccumulator	accumulator.h	/^  ~ReplaceAccumulator() {$/;"	f	class:fst::ReplaceAccumulator
~ReplaceAccumulatorData	accumulator.h	/^  ~ReplaceAccumulatorData() {$/;"	f	class:fst::ReplaceAccumulatorData
~ReplaceFstImpl	replace.h	/^  ~ReplaceFstImpl() {$/;"	f	class:fst::ReplaceFstImpl
~ReplaceFstMatcher	replace.h	/^  virtual ~ReplaceFstMatcher() {$/;"	f	class:fst::ReplaceFstMatcher
~ReplaceUtil	replace-util.h	/^  ~ReplaceUtil() {$/;"	f	class:fst::ReplaceUtil
~RhoMatcher	matcher.h	/^  virtual ~RhoMatcher() {$/;"	f	class:fst::RhoMatcher
~RmEpsilonFstImpl	rmepsilon.h	/^  ~RmEpsilonFstImpl() {$/;"	f	class:fst::RmEpsilonFstImpl
~SequenceComposeFilter	compose-filter.h	/^  ~SequenceComposeFilter() {$/;"	f	class:fst::SequenceComposeFilter
~ShortestDistanceState	shortest-distance.h	/^  ~ShortestDistanceState() {}$/;"	f	class:fst::ShortestDistanceState
~SigmaMatcher	matcher.h	/^  virtual ~SigmaMatcher() {$/;"	f	class:fst::SigmaMatcher
~SortedMatcher	matcher.h	/^  virtual ~SortedMatcher() {$/;"	f	class:fst::SortedMatcher
~StateIterator	fst.h	/^  ~StateIterator() { if (data_.base) delete data_.base; }$/;"	f	class:fst::StateIterator
~StateIteratorBase	fst.h	/^  virtual ~StateIteratorBase() {}$/;"	f	class:fst::StateIteratorBase
~StateMapFstImpl	state-map.h	/^  ~StateMapFstImpl() {$/;"	f	class:fst::StateMapFstImpl
~SymbolTable	symbol-table.h	/^  virtual ~SymbolTable() {$/;"	f	class:fst::SymbolTable
~SymbolTableImpl	symbol-table.h	/^  ~SymbolTableImpl() {$/;"	f	class:fst::SymbolTableImpl
~SymbolTableIterator	symbol-table.h	/^  ~SymbolTableIterator() { }$/;"	f	class:fst::SymbolTableIterator
~SynchronizeFstImpl	synchronize.h	/^  ~SynchronizeFstImpl() {$/;"	f	class:fst::SynchronizeFstImpl
~VectorBiTable	bi-table.h	/^  ~VectorBiTable() { delete fp_; }$/;"	f	class:fst::VectorBiTable
~VectorFstBaseImpl	vector-fst.h	/^  ~VectorFstBaseImpl() {$/;"	f	class:fst::VectorFstBaseImpl
~VectorHashBiTable	bi-table.h	/^  ~VectorHashBiTable() {$/;"	f	class:fst::VectorHashBiTable
~VectorHashReplaceStateTable	replace.h	/^  ~VectorHashReplaceStateTable() {$/;"	f	class:fst::VectorHashReplaceStateTable
